/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../packages/php-cgi-wasm lazy recursive":
/*!**************************************************************!*\
  !*** ../packages/php-cgi-wasm/ lazy strict namespace object ***!
  \**************************************************************/
/***/ ((module) => {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(() => {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = () => ([]);
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = "../packages/php-cgi-wasm lazy recursive";
module.exports = webpackEmptyAsyncContext;

/***/ }),

/***/ "../packages/php-cgi-wasm/php-cgi-worker.mjs.wasm":
/*!********************************************************!*\
  !*** ../packages/php-cgi-wasm/php-cgi-worker.mjs.wasm ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "8ded6ed7443506246706.wasm";

/***/ }),

/***/ "../../../software/pglite/packages/pglite/dist/postgres.data":
/*!*******************************************************************!*\
  !*** ../../../software/pglite/packages/pglite/dist/postgres.data ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "bc46a5d5c440de38d4a5.data";

/***/ }),

/***/ "../../../software/pglite/packages/pglite/dist/postgres.wasm":
/*!*******************************************************************!*\
  !*** ../../../software/pglite/packages/pglite/dist/postgres.wasm ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "fcb7a7ac4b20758c5ba8.wasm";

/***/ }),

/***/ "../packages/php-cgi-wasm/PhpCgiBase.mjs":
/*!***********************************************!*\
  !*** ../packages/php-cgi-wasm/PhpCgiBase.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PhpCgiBase: () => (/* binding */ PhpCgiBase)
/* harmony export */ });
/* harmony import */ var _config_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.mjs */ "../packages/php-cgi-wasm/config.mjs");
/* harmony import */ var _parseResponse_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parseResponse.mjs */ "../packages/php-cgi-wasm/parseResponse.mjs");
/* harmony import */ var _breakoutRequest_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./breakoutRequest.mjs */ "../packages/php-cgi-wasm/breakoutRequest.mjs");
/* harmony import */ var _fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fsOps.mjs */ "../packages/php-cgi-wasm/fsOps.mjs");
/* harmony import */ var _resolveDependencies_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resolveDependencies.mjs */ "../packages/php-cgi-wasm/resolveDependencies.mjs");







/**
 * An object representing a dynamically loaded data file.
 * @typedef {string|object} FileDef
 * @property {string} url
 * @property {string} path
 * @property {string} parent
 */

/**
 * A string or object representing a dynamically loaded shared library.
 * @typedef {string|object} LibDef
 * @property {string} name
 * @property {string} url
 * @property {boolean} ini
 * @property {function():libDef[]} getLibs
 * @property {function():fileDef[]} getFiles
 */

const STR = 'string';
const NUM = 'number';
const putEnv = (php, key, value) => php.ccall('wasm_sapi_cgi_putenv', 'number', ['string', 'string'], [key, value]);
const requestTimes = new WeakMap();
class PhpCgiBase {
  docroot = null;
  prefix = '/php-wasm';
  exclude = [];
  rewrite = path => path;
  cookies = null;
  types = {};
  onRequest = () => {};
  notFound = () => {};
  sharedLibs = [];
  files = [];
  phpArgs = {};
  maxRequestAge = 0;
  staticCacheTime = 60_000;
  dynamicCacheTime = 0;
  vHosts = [];
  php = null;
  input = [];
  output = [];
  error = [];
  count = 0;
  queue = [];

  /**
   * Creates a new PHP instance (async)
   * @param {*} PHP
   * @param {string} options.prefix The URL path prefix to look for when routing to PHP.
   * @param {string} options.docroot The internal directory to use as the public document root.
   * @param {string[]} options.exclude Array of URL prefixes to exclude from routing to PHP.
   * @param {Array.<{pathPrefix: string, directory: string, entrypoint: string}>} options.vHosts A list of prefixes, directories and entrypoints to serve multiple PHP applications by URL prefix.
   * @param {string} options.entrypoint Path to PHP file under docroot to serve as an entrypoint
   * @param {function(string):string} options.rewrite Function to rewrite URLs
   * @param {object<string, string>} options.types Mapping of file extensions to mime types to populate the `Content-type` header.
   * @param {function()} options.onRequest Function to be executed on each request.
   * @param {function(Request):Response|string} options.notFound Function to handle 404s.
   * @param {LibDef[]} options.sharedLibs Dynamically load shared libraries with LibDefs
   * @param {FileDef[]} options.files Dynamically load files with FileDefs
   * @param {boolean} options.autoTransaction Automatically handle FS transactions on each request
   * @param {number} options.maxRequestAge Oldest request to process (ms)
   * @param {number} options.staticCacheTime Static cache time (ms)
   * @param {number} options.dynamicCacheTime Dynamic cache time (ms)
   * @param {object<string, string}>} options.env Mapping of environment variable names to values to set inside the server.
   */
  constructor(PHP, {
    docroot,
    prefix,
    exclude,
    rewrite,
    entrypoint,
    cookies,
    types,
    onRequest,
    notFound,
    sharedLibs,
    actions,
    files,
    ...args
  } = {}) {
    this.PHP = PHP;
    this.docroot = docroot || this.docroot;
    this.prefix = prefix || this.prefix;
    this.exclude = exclude || this.exclude;
    this.rewrite = rewrite || this.rewrite;
    this.entrypoint = entrypoint || this.entrypoint;
    this.cookies = cookies || new Map();
    this.types = types || this.types;
    this.onRequest = onRequest || this.onRequest;
    this.notFound = notFound || this.notFound;
    this.sharedLibs = sharedLibs || this.sharedLibs;
    this.files = files || this.files;
    this.extraActions = actions || {};
    this.phpArgs = args;
    this.autoTransaction = 'autoTransaction' in args ? args.autoTransaction : true;
    this.transactionStarted = false;
    this.maxRequestAge = args.maxRequestAge || this.maxRequestAge;
    this.staticCacheTime = args.staticCacheTime || this.staticCacheTime;
    this.dynamicCacheTime = args.dynamicCacheTime || this.dynamicCacheTime;
    this.vHosts = args.vHosts || [];
    this.env = {};
    Object.assign(this.env, args.env || {});
    this.refresh();
  }
  handleInstallEvent(event) {
    return event.waitUntil(self.skipWaiting());
  }
  handleActivateEvent(event) {
    return event.waitUntil(self.clients.claim());
  }
  async handleMessageEvent(event) {
    const {
      data,
      source
    } = event;
    const {
      action,
      token,
      params = []
    } = data;
    const actions = ['analyzePath', 'readdir', 'readFile', 'stat', 'mkdir', 'rmdir', 'writeFile', 'rename', 'unlink', 'putEnv', 'refresh', 'getSettings', 'setSettings', 'getEnvs', 'setEnvs', 'storeInit'];
    if (actions.includes(action)) {
      let result, error;
      try {
        result = await this[action](...params);
      } catch (_error) {
        error = JSON.parse(JSON.stringify(_error));
        console.warn(_error);
      } finally {
        source.postMessage({
          re: token,
          result,
          error
        });
      }
    }
    if (action in this.extraActions) {
      let result, error;
      try {
        result = await this.extraActions[action](this, ...params);
      } catch (_error) {
        error = JSON.parse(JSON.stringify(_error));
        console.warn(_error);
      } finally {
        source.postMessage({
          re: token,
          result,
          error
        });
      }
    }
  }
  handleFetchEvent(event) {
    const url = new URL(event.request.url);
    const prefix = this.prefix;
    const {
      files,
      urlLibs
    } = (0,_resolveDependencies_mjs__WEBPACK_IMPORTED_MODULE_4__.resolveDependencies)(this.sharedLibs, this);
    let isWhitelisted = false;
    let isBlacklisted = false;
    if (globalThis.location) {
      const staticUrls = [self.location.pathname, ...files.map(file => file.url), ...Object.values(urlLibs)].map(url => new URL(url, self.location.origin)).filter(url => url.origin === self.location.origin).map(url => url.pathname);
      isWhitelisted = url.pathname.substr(0, prefix.length) === prefix && url.hostname === self.location.hostname;
      isBlacklisted = url.pathname.match(/\.wasm$/i) || staticUrls.includes(url.pathname) || this.exclude.findIndex(exclude => url.pathname.substr(0, exclude.length) === exclude) > -1 || false;
    } else {
      isWhitelisted = url.pathname.substr(0, prefix.length) === prefix;
      isBlacklisted = url.pathname.match(/\.wasm$/i) || this.exclude.findIndex(exclude => url.pathname.substr(0, exclude.length) === exclude) > -1 || false;
    }
    if (isWhitelisted && !isBlacklisted) {
      requestTimes.set(event.request, Date.now());
      const response = this.request(event.request);
      return event.respondWith(response);
    } else {
      return fetch(event.request);
    }
  }
  async _enqueue(callback, params = []) {
    let accept, reject;
    const coordinator = new Promise((a, r) => [accept, reject] = [a, r]);
    this.queue.push([callback, params, accept, reject]);
    if (!this.queue.length) {
      return;
    }
    while (this.queue.length) {
      const [callback, params, accept, reject] = this.queue.shift();
      await callback(...params).then(accept).catch(reject);
    }
    return coordinator;
  }
  refresh() {
    const {
      files,
      libs,
      urlLibs
    } = (0,_resolveDependencies_mjs__WEBPACK_IMPORTED_MODULE_4__.resolveDependencies)(this.sharedLibs, this);
    const userLocateFile = this.phpArgs.locateFile || (() => undefined);
    const locateFile = (path, directory) => {
      let located = userLocateFile(path, directory);
      if (located !== undefined) {
        return located;
      }
      if (urlLibs[path]) {
        return String(urlLibs[path]);
      }
      console.log((path, directory));
    };
    const phpArgs = {
      persist: [{
        mountPath: '/persist'
      }, {
        mountPath: '/config'
      }],
      ...this.phpArgs,
      stdin: () => this.input ? String(this.input.shift()).charCodeAt(0) : null,
      stdout: x => this.output.push(x),
      stderr: x => this.error.push(x),
      locateFile
    };
    this.binary = new this.PHP(phpArgs).then(async php => {
      await php.ccall('pib_storage_init', NUM, [], [], {
        async: true
      });
      if (!php.FS.analyzePath('/preload').exists) {
        php.FS.mkdir('/preload');
      }
      await this.files.concat(files).forEach(fileDef => php.FS.createPreloadedFile(fileDef.parent, fileDef.name, userLocateFile(fileDef.url) ?? fileDef.url, true, false));
      const iniLines = libs.map(lib => {
        if (typeof lib === 'string' || lib instanceof URL) {
          return `extension=${lib}`;
        } else if (typeof lib === 'object' && lib.ini) {
          return `extension=${String(lib.url).split('/').pop()}`;
        }
      });
      this.phpArgs.ini && iniLines.push(this.phpArgs.ini.replace(/\n\s+/g, '\n'));
      php.FS.writeFile('/php.ini', iniLines.join("\n") + "\n", {
        encoding: 'utf8'
      });
      await php.ccall('wasm_sapi_cgi_init', 'number', [], [], {
        async: true
      });
      await this.loadInit(php);
      return php;
    });
  }
  async _beforeRequest() {}
  async _afterRequest() {}
  async request(request) {
    const {
      url,
      method = 'GET',
      get,
      post,
      contentType
    } = await (0,_breakoutRequest_mjs__WEBPACK_IMPORTED_MODULE_2__.breakoutRequest)(request);
    if (globalThis.caches) {
      const cache = await caches.open('static-v1');
      const cached = await cache.match(url);

      // this.maxRequestAge

      if (cached) {
        const cacheTime = Number(cached.headers.get('x-php-wasm-cache-time'));
        if (this.staticCacheTime > 0 && this.staticCacheTime > Date.now() - cacheTime) {
          this.onRequest(request, cached);
          return cached;
        }
      }
    }
    const php = await this.binary;
    await this._beforeRequest();
    let docroot = this.docroot;
    let vHostEntrypoint,
      vHostPrefix = this.prefix;
    for (const {
      pathPrefix,
      directory,
      entrypoint
    } of this.vHosts) {
      if (pathPrefix === url.pathname.substr(0, pathPrefix.length)) {
        docroot = directory;
        vHostEntrypoint = entrypoint;
        vHostPrefix = pathPrefix;
        break;
      }
    }
    const rewrite = this.rewrite(url.pathname);
    let scriptName, path;
    if (typeof rewrite === 'object') {
      scriptName = rewrite.scriptName;
      path = docroot + rewrite.path;
    } else {
      path = docroot + '/' + rewrite.substr((vHostPrefix || this.prefix).length);
      scriptName = path;
    }
    if (vHostEntrypoint) {
      scriptName = vHostPrefix + '/' + vHostEntrypoint;
    }
    let originalPath = url.pathname;
    const extension = path.split('.').pop();
    if (extension !== 'php' && extension !== 'phar') {
      const aboutPath = php.FS.analyzePath(path);

      // Return static file
      if (aboutPath.exists && php.FS.isFile(aboutPath.object.mode)) {
        const response = new Response(php.FS.readFile(path, {
          encoding: 'binary',
          url
        }), {});
        response.headers.append('x-php-wasm-cache-time', new Date().getTime());
        if (extension in this.types) {
          response.headers.append('Content-type', this.types[extension]);
        }
        if (globalThis.caches) {
          const cache = await caches.open('static-v1');
          cache.put(url, response.clone());
        }
        this.onRequest(request, response);
        return response;
      } else if (aboutPath.exists && php.FS.isDir(aboutPath.object.mode) && '/' !== originalPath[-1 + originalPath.length]) {
        originalPath += '/';
      }

      // Rewrite to index
      path = docroot + '/index.php';
    }
    if (this.maxRequestAge > 0 && Date.now() - requestTimes.get(request) > this.maxRequestAge) {
      const response = new Response('408: Request Timed Out.', {
        status: 408
      });
      this.onRequest(request, response);
      return response;
    }
    const aboutPath = php.FS.analyzePath(path);
    if (!aboutPath.exists) {
      const rawResponse = this.notFound ? this.notFound(request) : '404 - Not Found.';
      if (rawResponse) {
        return rawResponse instanceof Response ? rawResponse : new Response(rawResponse, {
          status: 404
        });
      }
    }
    this.input = ['POST', 'PUT', 'PATCH'].includes(method) ? post.split('') : [];
    this.output = [];
    this.error = [];
    const selfUrl = new URL(globalThis.location || request.url);
    putEnv(php, 'PHP_VERSION', _config_mjs__WEBPACK_IMPORTED_MODULE_0__.phpVersion);
    putEnv(php, 'PHP_INI_SCAN_DIR', `/config:/preload:${docroot}`);
    putEnv(php, 'PHPRC', '/php.ini');
    for (const [name, value] of Object.entries(this.env)) {
      putEnv(php, name, value);
    }
    const protocol = selfUrl.protocol.substr(0, selfUrl.protocol.length - 1);
    putEnv(php, 'SERVER_SOFTWARE', globalThis.navigator ? globalThis.navigator.userAgent : globalThis.process ? 'Node ' + globalThis.process.version : 'Javascript - Unknown');
    putEnv(php, 'REQUEST_METHOD', method);
    putEnv(php, 'REMOTE_ADDR', '127.0.0.1');
    putEnv(php, 'HTTP_HOST', selfUrl.host);
    putEnv(php, 'REQUEST_SCHEME', protocol);
    putEnv(php, 'HTTPS', protocol === 'https' ? 'on' : 'off');
    putEnv(php, 'DOCUMENT_ROOT', docroot);
    putEnv(php, 'REQUEST_URI', originalPath);
    putEnv(php, 'SCRIPT_NAME', scriptName);
    putEnv(php, 'SCRIPT_FILENAME', path);
    putEnv(php, 'PATH_TRANSLATED', path);
    putEnv(php, 'QUERY_STRING', get);
    putEnv(php, 'HTTP_COOKIE', [...this.cookies.entries()].map(e => `${e[0]}=${e[1]}`).join(';'));
    putEnv(php, 'REDIRECT_STATUS', '200');
    putEnv(php, 'CONTENT_TYPE', contentType);
    putEnv(php, 'CONTENT_LENGTH', String(this.input.length));
    try {
      const exitCode = await navigator.locks.request('php-wasm-fs-lock', async () => {
        return php.ccall('main', 'number', [], [], {
          async: true
        });
      });
      if (exitCode === 0) {
        this._afterRequest();
      } else {
        console.warn(new TextDecoder().decode(new Uint8Array(this.output).buffer));
        console.error(new TextDecoder().decode(new Uint8Array(this.error).buffer));
        await this.refresh();
      }
    } catch (error) {
      console.error(error);
      this.refresh();
      const response = new Response(`500: Internal Server Error.\n` + `=`.repeat(80) + `\n\n` + `Stacktrace:\n${error.stack}\n` + `=`.repeat(80) + `\n\n` + `STDERR:\n${new TextDecoder().decode(new Uint8Array(this.error).buffer)}\n` + `=`.repeat(80) + `\n\n` + `STDOUT:\n${new TextDecoder().decode(new Uint8Array(this.output).buffer)}\n` + `=`.repeat(80) + `\n\n`, {
        status: 500
      });
      this.onRequest(request, response);
      return response;
    }
    ++this.count;
    const parsedResponse = (0,_parseResponse_mjs__WEBPACK_IMPORTED_MODULE_1__.parseResponse)(this.output);
    let status = 200;
    for (const [name, value] of Object.entries(parsedResponse.headers)) {
      if (name === 'Status') {
        status = value.substr(0, 3);
      }
    }
    if (parsedResponse.headers['Set-Cookie']) {
      const raw = parsedResponse.headers['Set-Cookie'];
      const semi = raw.indexOf(';');
      const equal = raw.indexOf('=');
      const key = raw.substr(0, equal);
      const value = raw.substr(1 + equal, -1 + semi - equal);
      this.cookies.set(key, value);
    }
    const headers = {
      ...parsedResponse.headers
    };

    // delete headers['Set-Cookie'];

    if (extension in this.types) {
      // headers["Content-type"] = this.types[extension];
    } else {
      headers["Content-type"] = headers["Content-type"] ?? 'text/html; charset=utf-8';
    }
    if (parsedResponse.headers.Location) {
      headers.Location = parsedResponse.headers.Location;
    }
    const response = new Response(parsedResponse.body || '', {
      headers,
      status,
      url
    });
    this.onRequest(request, response);
    return response;
  }
  analyzePath(path) {
    return this._enqueue(_fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.analyzePath, [this.binary, path]);
  }
  readdir(path) {
    return this._enqueue(_fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.readdir, [this.binary, path]);
  }
  readFile(path, options) {
    return this._enqueue(_fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.readFile, [this.binary, path, options]);
  }
  stat(path) {
    return this._enqueue(_fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.stat, [this.binary, path]);
  }
  mkdir(path) {
    return this._enqueue(_fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.mkdir, [this.binary, path]);
  }
  rmdir(path) {
    return this._enqueue(_fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.rmdir, [this.binary, path]);
  }
  rename(path, newPath) {
    return this._enqueue(_fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.rename, [this.binary, path, newPath]);
  }
  writeFile(path, data, options) {
    return this._enqueue(_fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.writeFile, [this.binary, path, data, options]);
  }
  unlink(path) {
    return this._enqueue(_fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.unlink, [this.binary, path]);
  }
  async putEnv(name, value) {
    return (await this.binary).ccall('wasm_sapi_cgi_putenv', 'number', ['string', 'string'], [name, value]);
  }
  async getSettings() {
    return {
      docroot: this.docroot,
      maxRequestAge: this.maxRequestAge,
      staticCacheTime: this.staticCacheTime,
      dynamicCacheTime: this.dynamicCacheTime,
      vHosts: this.vHosts
    };
  }
  async setSettings({
    docroot,
    maxRequestAge,
    staticCacheTime,
    dynamicCacheTime,
    vHosts
  }) {
    this.docroot = docroot ?? this.docroot;
    this.maxRequestAge = maxRequestAge ?? this.maxRequestAge;
    this.staticCacheTime = staticCacheTime ?? this.staticCacheTime;
    this.dynamicCacheTime = dynamicCacheTime ?? this.dynamicCacheTime;
    this.vHosts = vHosts ?? this.vHosts;
  }
  async getEnvs() {
    return {
      ...this.env
    };
  }
  async setEnvs(env) {
    for (const key of Object.keys(this.env)) {
      this.env[key] = undefined;
    }
    Object.assign(this.env, env);
  }
  async storeInit() {
    const settings = await this.getSettings();
    const env = await this.getEnvs();
    await this.writeFile('/config/init.json', JSON.stringify({
      settings,
      env
    }, null, 4), {
      encoding: 'utf8'
    });
  }
  async loadInit(binary) {
    const initPath = '/config/init.json';
    const check = await _fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.analyzePath(binary, initPath);
    if (!check.exists) {
      return;
    }
    const initJson = await _fsOps_mjs__WEBPACK_IMPORTED_MODULE_3__.fsOps.readFile(binary, initPath, {
      encoding: 'utf8'
    });
    const init = JSON.parse(initJson || '{}');
    const {
      settings,
      env
    } = init;
    this.setSettings(settings);
    this.setEnvs(env);
  }
}
PhpCgiBase.phpVersion = _config_mjs__WEBPACK_IMPORTED_MODULE_0__.phpVersion;
PhpCgiBase.phpVersionFull = _config_mjs__WEBPACK_IMPORTED_MODULE_0__.phpVersionFull;

/***/ }),

/***/ "../packages/php-cgi-wasm/PhpCgiWebBase.mjs":
/*!**************************************************!*\
  !*** ../packages/php-cgi-wasm/PhpCgiWebBase.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PhpCgiWebBase: () => (/* binding */ PhpCgiWebBase)
/* harmony export */ });
/* harmony import */ var _PhpCgiBase_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PhpCgiBase.mjs */ "../packages/php-cgi-wasm/PhpCgiBase.mjs");
/* harmony import */ var _webTransactions_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webTransactions.mjs */ "../packages/php-cgi-wasm/webTransactions.mjs");
/* harmony import */ var _resolveDependencies_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resolveDependencies.mjs */ "../packages/php-cgi-wasm/resolveDependencies.mjs");



const STR = 'string';
const NUM = 'number';
class PhpCgiWebBase extends _PhpCgiBase_mjs__WEBPACK_IMPORTED_MODULE_0__.PhpCgiBase {
  startTransaction() {
    return (0,_webTransactions_mjs__WEBPACK_IMPORTED_MODULE_1__.startTransaction)(this);
  }
  commitTransaction() {
    return (0,_webTransactions_mjs__WEBPACK_IMPORTED_MODULE_1__.commitTransaction)(this);
  }
  async _beforeRequest() {
    if (!this.initialized) {
      const php = await this.binary;
      await this.loadInit(php);
      await navigator.locks.request('php-wasm-fs-lock', async () => {
        await new Promise((accept, reject) => php.FS.syncfs(true, err => {
          if (err) reject(err);else accept();
        }));
      });
    }
    this.initialized = true;
  }
  async _afterRequest() {
    const php = await this.binary;
    if (this.phpArgs.staticFS) {
      return;
    }
    await navigator.locks.request('php-wasm-fs-lock', async () => {
      await new Promise((accept, reject) => php.FS.syncfs(false, err => {
        if (err) reject(err);else accept();
      }));
    });
  }
  refresh() {
    const {
      files,
      libs,
      urlLibs
    } = (0,_resolveDependencies_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveDependencies)(this.sharedLibs, this);
    const userLocateFile = this.phpArgs.locateFile || (() => undefined);
    const locateFile = path => {
      let located = userLocateFile(path);
      if (located !== undefined) {
        return located;
      }
      if (urlLibs[path]) {
        return urlLibs[path];
      }
    };
    const phpArgs = {
      persist: [{
        mountPath: '/persist'
      }, {
        mountPath: '/config'
      }],
      ...this.phpArgs,
      stdin: () => this.input ? String(this.input.shift()).charCodeAt(0) : null,
      stdout: x => this.output.push(x),
      stderr: x => this.error.push(x),
      locateFile
    };
    this.binary = navigator.locks.request('php-wasm-fs-lock', async () => {
      const php = await new this.PHP(phpArgs);
      await php.ccall('pib_storage_init', NUM, [], [], {
        async: true
      });
      if (!php.FS.analyzePath('/preload').exists) {
        php.FS.mkdir('/preload');
      }
      await this.files.concat(files).forEach(fileDef => php.FS.createPreloadedFile(fileDef.parent, fileDef.name, fileDef.url, true, false));
      const iniLines = libs.map(lib => {
        if (typeof lib === 'string' || lib instanceof URL) {
          return `extension=${lib}`;
        } else if (typeof lib === 'object' && lib.ini) {
          return `extension=${String(lib.url).split('/').pop()}`;
        }
      });
      this.phpArgs.ini && iniLines.push(this.phpArgs.ini.replace(/\n\s+/g, '\n'));
      php.FS.writeFile('/php.ini', iniLines.join("\n") + "\n", {
        encoding: 'utf8'
      });
      await new Promise((accept, reject) => {
        php.FS.syncfs(true, error => {
          if (error) reject(error);else accept();
        });
      });
      await php.ccall('wasm_sapi_cgi_init', 'number', [], [], {
        async: true
      });
      await this.loadInit(php);
      return php;
    });
  }
  async _enqueue(callback, params = []) {
    let accept, reject;
    const coordinator = new Promise((a, r) => [accept, reject] = [a, r]);
    this.queue.push([callback, params, accept, reject]);
    navigator.locks.request('php-wasm-fs-lock', async () => {
      if (!this.queue.length) {
        return;
      }
      await (this.autoTransaction ? this.startTransaction() : Promise.resolve());
      do {
        const [callback, params, accept, reject] = this.queue.shift();
        await callback(...params).then(accept).catch(reject);
        let lockChecks = 5;
        while (!this.queue.length && lockChecks--) {
          await new Promise(a => setTimeout(a, 5));
        }
      } while (this.queue.length);
      await (this.autoTransaction ? this.commitTransaction() : Promise.resolve());
    });
    return coordinator;
  }
}

/***/ }),

/***/ "../packages/php-cgi-wasm/PhpCgiWorker.mjs":
/*!*************************************************!*\
  !*** ../packages/php-cgi-wasm/PhpCgiWorker.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PhpCgiWorker: () => (/* binding */ PhpCgiWorker)
/* harmony export */ });
/* harmony import */ var _PhpCgiWebBase_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PhpCgiWebBase.mjs */ "../packages/php-cgi-wasm/PhpCgiWebBase.mjs");
/* harmony import */ var _php_cgi_worker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./php-cgi-worker.mjs */ "../packages/php-cgi-wasm/php-cgi-worker.mjs");


class PhpCgiWorker extends _PhpCgiWebBase_mjs__WEBPACK_IMPORTED_MODULE_0__.PhpCgiWebBase {
  constructor({
    docroot,
    prefix,
    rewrite,
    cookies,
    types,
    onRequest,
    notFound,
    ...args
  } = {}) {
    super(_php_cgi_worker_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], {
      docroot,
      prefix,
      rewrite,
      cookies,
      types,
      onRequest,
      notFound,
      ...args
    });
  }
}

/***/ }),

/***/ "../packages/php-cgi-wasm/breakoutRequest.mjs":
/*!****************************************************!*\
  !*** ../packages/php-cgi-wasm/breakoutRequest.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   breakoutRequest: () => (/* binding */ breakoutRequest)
/* harmony export */ });
const breakoutRequest = request => {
  let getPost = Promise.resolve('');
  if (request.body) {
    getPost = new Promise(accept => {
      const reader = request.body.getReader();
      const postBody = [];
      const processBody = ({
        done,
        value
      }) => {
        if (value) {
          postBody.push([...value].map(x => String.fromCharCode(x)).join(''));
        }
        if (!done) {
          return reader.read().then(processBody);
        }
        accept(postBody.join(''));
      };
      return reader.read().then(processBody);
    });
  } else if (request.arrayBuffer) {
    getPost = request.arrayBuffer().then(buffer => [...new Uint8Array(buffer)].map(x => String.fromCharCode(x)).join(''));
  } else if (request.on) {
    getPost = new Promise(accept => {
      let body = [];
      request.on('data', chunk => body.push(chunk));
      request.on('end', () => accept([...new Uint8Array(Buffer.concat(body))].map(x => String.fromCharCode(x)).join('')));
    });
  }
  const url = new URL(request.url);
  return getPost.then(post => ({
    url,
    method: request.method,
    get: url.search ? url.search.substr(1) : '',
    post: request.method === 'POST' ? post : null,
    contentType: request.method === 'POST' ? request.headers && request.headers.get('Content-Type') || 'application/x-www-form-urlencoded' : null
  }));
};

/***/ }),

/***/ "../packages/php-cgi-wasm/config.mjs":
/*!*******************************************!*\
  !*** ../packages/php-cgi-wasm/config.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   phpVersion: () => (/* binding */ phpVersion),
/* harmony export */   phpVersionFull: () => (/* binding */ phpVersionFull)
/* harmony export */ });
const phpVersion = "8.3";
const phpVersionFull = "8.3.7";

/***/ }),

/***/ "../packages/php-cgi-wasm/fsOps.mjs":
/*!******************************************!*\
  !*** ../packages/php-cgi-wasm/fsOps.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fsOps: () => (/* binding */ fsOps)
/* harmony export */ });
class fsOps {
  static async analyzePath(binary, path) {
    const result = (await binary).FS.analyzePath(path);
    if (!result.object) {
      return {
        exists: false
      };
    }
    const object = {
      exists: true,
      id: result.object.id,
      mode: result.object.mode,
      mount: {
        mountpoint: result.object.mount.mountpoint,
        mounts: result.object.mount.mounts.map(m => m.mountpoint)
      },
      isDevice: result.object.isDevice,
      isFolder: result.object.isFolder,
      read: result.object.read,
      write: result.object.write
    };
    return {
      ...result,
      object,
      parentObject: undefined
    };
  }
  static async readdir(binary, path) {
    return (await binary).FS.readdir(path);
  }
  static async readFile(binary, path, options) {
    return (await binary).FS.readFile(path, options);
  }
  static async stat(binary, path) {
    return (await binary).FS.stat(path);
  }
  static async mkdir(binary, path) {
    const php = await binary;
    const _result = php.FS.mkdir(path);
    return {
      id: _result.id,
      mode: _result.mode,
      mount: {
        mountpoint: _result.mount.mountpoint,
        mounts: _result.mount.mounts.map(m => m.mountpoint)
      },
      isDevice: _result.isDevice,
      isFolder: _result.isFolder,
      read: _result.read,
      write: _result.write
    };
  }
  static async rmdir(binary, path) {
    return (await binary).FS.rmdir(path);
  }
  static async rename(binary, path, newPath) {
    return (await binary).FS.rename(path, newPath);
  }
  static async writeFile(binary, path, data, options) {
    return (await binary).FS.writeFile(path, data, options);
  }
  static async unlink(binary, path) {
    return (await binary).FS.unlink(path);
  }
}

/***/ }),

/***/ "../packages/php-cgi-wasm/parseResponse.mjs":
/*!**************************************************!*\
  !*** ../packages/php-cgi-wasm/parseResponse.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseResponse: () => (/* binding */ parseResponse)
/* harmony export */ });
const parseResponse = response => {
  const headers = {};
  const line = [];
  const decoder = new TextDecoder();
  let i = 0;
  for (; i < response.length; i++) {
    if (response[i] === 0xD && response[i + 1] === 0xA)
      // We're at a CRLF
      {
        if (line.length) {
          const header = decoder.decode(new Uint8Array(line).buffer);
          const colon = header.indexOf(':');
          if (colon < 0) {
            headers[header] = true;
          } else {
            headers[header.substring(0, colon)] = header.substring(colon + 2);
          }
          line.length = 0;
          i++;
          continue;
        } else {
          i++;
          break;
        }
      }
    line.push(response[i]);
  }
  return {
    headers,
    body: new Uint8Array(response.slice(1 + i)).buffer
  };
};

/***/ }),

/***/ "../packages/php-cgi-wasm/php-cgi-worker.mjs":
/*!***************************************************!*\
  !*** ../packages/php-cgi-wasm/php-cgi-worker.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var PHP=(()=>{const importMeta=({});var _scriptName=importMeta.url;return function(moduleArg={}){var moduleRtn;// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(moduleArg) => Promise<Module>
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module=moduleArg;// Set up the promise that indicates the Module is initialized
var readyPromiseResolve,readyPromiseReject;var readyPromise=new Promise((resolve,reject)=>{readyPromiseResolve=resolve;readyPromiseReject=reject;});// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).
var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=true;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// include: /src/.cache/pre.js
Module.preRun=Module.preRun||[];if(typeof Module.preRun=="function")Module.preRun=[Module.preRun];Module.preRun.push(()=>Object.assign(ENV,Module.ENV||{}));Module.preRun=Module.preRun||[];if(typeof Module.preRun=="function")Module.preRun=[Module.preRun];Module.preRun.push(()=>ENV.ICU_DATA=ENV.ICU_DATA||"/preload");// end include: /src/.cache/pre.js
// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow;};// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory="";function locateFile(path,defaultPath=null){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)??defaultPath??scriptDirectory+path;}return defaultPath??scriptDirectory+path;}// Hooks that are implemented differently in different runtime environments.
var readAsync,readBinary;// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){// Check worker, not web, since window could be polyfilled
scriptDirectory=self.location.href;}else if(typeof document!="undefined"&&document.currentScript){// web
scriptDirectory=document.currentScript.src;}// When MODULARIZE, this JS may be executed later, after document.currentScript
// is gone, so we saved it, and we use it here instead of any other info.
if(_scriptName){scriptDirectory=_scriptName;}// blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
// otherwise, slice off the final part of the url to find the script directory.
// if scriptDirectory does not contain a slash, lastIndexOf will return -1,
// and scriptDirectory will correctly be replaced with an empty string.
// If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
// they are removed because they could contain a slash.
if(scriptDirectory.startsWith("blob:")){scriptDirectory="";}else{scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1);}{// include: web_or_worker_shell_read.js
if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest();xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(/** @type{!ArrayBuffer} */xhr.response);};}readAsync=url=>fetch(url,{credentials:"same-origin"}).then(response=>{if(response.ok){return response.arrayBuffer();}return Promise.reject(new Error(response.status+" : "+response.url));});}}else// end include: web_or_worker_shell_read.js
{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.error.bind(console);// Merge back in the overrides
Object.assign(Module,moduleOverrides);// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used.
moduleOverrides=null;// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.
if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// end include: shell.js
// include: preamble.js
// === Preamble library stuff ===
// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html
var dynamicLibraries=Module["dynamicLibraries"]||[];var wasmBinary=Module["wasmBinary"];// include: base64Utils.js
// Converts a string of base64 into a byte array (Uint8Array).
function intArrayFromBase64(s){var decoded=atob(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i);}return bytes;}// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename){if(!isDataURI(filename)){return;}return intArrayFromBase64(filename.slice(dataURIPrefix.length));}// end include: base64Utils.js
// Wasm globals
var wasmMemory;//========================================
// Runtime essentials
//========================================
// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT=false;// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we
// don't define it at all in release modes.  This matches the behaviour of
// MINIMAL_RUNTIME.
// TODO(sbc): Make this the default even without STRICT enabled.
/** @type {function(*, string=)} */function assert(condition,text){if(!condition){// This build was created without ASSERTIONS defined.  `assert()` should not
// ever be called in this configuration but in case there are callers in
// the wild leave this simple abort() implementation here for now.
abort(text);}}// Memory management
var HEAP,/** @type {!Int8Array} */HEAP8,/** @type {!Uint8Array} */HEAPU8,/** @type {!Int16Array} */HEAP16,/** @type {!Uint16Array} */HEAPU16,/** @type {!Int32Array} */HEAP32,/** @type {!Uint32Array} */HEAPU32,/** @type {!Float32Array} */HEAPF32,/** @type {!Float64Array} */HEAPF64;// include: runtime_shared.js
function updateMemoryViews(){var b=wasmMemory.buffer;Module["HEAP8"]=HEAP8=new Int8Array(b);Module["HEAP16"]=HEAP16=new Int16Array(b);Module["HEAPU8"]=HEAPU8=new Uint8Array(b);Module["HEAPU16"]=HEAPU16=new Uint16Array(b);Module["HEAP32"]=HEAP32=new Int32Array(b);Module["HEAPU32"]=HEAPU32=new Uint32Array(b);Module["HEAPF32"]=HEAPF32=new Float32Array(b);Module["HEAPF64"]=HEAPF64=new Float64Array(b);}// end include: runtime_shared.js
// In non-standalone/normal mode, we create the memory here.
// include: runtime_init_memory.js
// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"];}else{var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||134217728;wasmMemory=new WebAssembly.Memory({"initial":INITIAL_MEMORY/65536,// In theory we should not need to emit the maximum if we want "unlimited"
// or 4GB of memory, but VMs error on that atm, see
// https://github.com/emscripten-core/emscripten/issues/14130
// And in the pthreads case we definitely need to emit a maximum. So
// always emit one.
"maximum":65536});}updateMemoryViews();// end include: runtime_init_memory.js
// include: runtime_stack_check.js
// end include: runtime_stack_check.js
var __ATPRERUN__=[];// functions called before the runtime is initialized
var __ATINIT__=[];// functions called during startup
var __ATMAIN__=[];// functions called when main() is to be run
var __ATEXIT__=[];// functions called during shutdown
var __ATPOSTRUN__=[];// functions called after the main() is called
var __RELOC_FUNCS__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__RELOC_FUNCS__);if(!Module["noFSInit"]&&!FS.initialized)FS.init();FS.ignorePermissions=false;TTY.init();SOCKFS.root=FS.mount(SOCKFS,{},null);PIPEFS.root=FS.mount(PIPEFS,{},null);callRuntimeCallbacks(__ATINIT__);}function preMain(){callRuntimeCallbacks(__ATMAIN__);}function exitRuntime(){___funcs_on_exit();// Native atexit() functions
callRuntimeCallbacks(__ATEXIT__);FS.quit();TTY.shutdown();IDBFS.quit();runtimeExited=true;}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnInit(cb){__ATINIT__.unshift(cb);}function addOnPreMain(cb){__ATMAIN__.unshift(cb);}function addOnExit(cb){__ATEXIT__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}// include: runtime_math.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;// overridden to take different actions when all run dependencies are fulfilled
function getUniqueRunDependency(id){return id;}function addRunDependency(id){runDependencies++;Module["monitorRunDependencies"]?.(runDependencies);}function removeRunDependency(id){runDependencies--;Module["monitorRunDependencies"]?.(runDependencies);if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null;}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}/** @param {string|number=} what */function abort(what){Module["onAbort"]?.(what);what="Aborted("+what+")";// TODO(sbc): Should we remove printing and leave it up to whoever
// catches the exception?
err(what);ABORT=true;what+=". Build with -sASSERTIONS for more info.";// Use a wasm runtime error, because a JS error might be seen as a foreign
// exception, which means we'd run destructors on it. We need the error to
// simply make the program stop.
// FIXME This approach does not work in Wasm EH because it currently does not assume
// all RuntimeErrors are from traps; it decides whether a RuntimeError is from
// a trap or not based on a hidden field within the object. So at the moment
// we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
// allows this in the wasm spec.
// Suppress closure compiler warning here. Closure compiler's builtin extern
// definition for WebAssembly.RuntimeError claims it takes no arguments even
// though it can.
// TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
/** @suppress {checkTypes} */var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);// Throw the error whether or not MODULARIZE is set because abort is used
// in code paths apart from instantiation where an exception is expected
// to be thrown when abort is called.
throw e;}// include: memoryprofiler.js
// end include: memoryprofiler.js
// include: URIUtils.js
// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix="data:application/octet-stream;base64,";/**
 * Indicates whether filename is a base64 data URI.
 * @noinline
 */var isDataURI=filename=>filename.startsWith(dataURIPrefix);/**
 * Indicates whether filename is delivered via file protocol (as opposed to http/https)
 * @noinline
 */var isFileURI=filename=>filename.startsWith("file://");// end include: URIUtils.js
// include: runtime_exceptions.js
// end include: runtime_exceptions.js
function findWasmBinary(){if(Module["locateFile"]){var f="php-cgi-worker.mjs.wasm";if(!isDataURI(f)){return locateFile(f,new URL(/* asset import */ __webpack_require__(/*! php-cgi-worker.mjs.wasm */ "../packages/php-cgi-wasm/php-cgi-worker.mjs.wasm"), __webpack_require__.b).href);}return f;}// Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.
return new URL(/* asset import */ __webpack_require__(/*! php-cgi-worker.mjs.wasm */ "../packages/php-cgi-wasm/php-cgi-worker.mjs.wasm"), __webpack_require__.b).href;}var wasmBinaryFile;function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary);}if(readBinary){return readBinary(file);}throw"both async and sync fetching of the wasm failed";}function getBinaryPromise(binaryFile){// If we don't have the binary yet, try to load it asynchronously.
// Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
// See https://github.com/github/fetch/pull/92#issuecomment-140665932
// Cordova or Electron apps are typically loaded from a file:// url.
// So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"){return fetch(binaryFile,{credentials:"same-origin"}).then(response=>{if(!response["ok"]){throw`failed to load wasm binary file at '${binaryFile}'`;}return response["arrayBuffer"]();}).catch(()=>getBinarySync(binaryFile));}// Fetch the binary using readAsync
return readAsync(binaryFile).then(response=>new Uint8Array(/** @type{!ArrayBuffer} */response),// Fall back to getBinarySync if readAsync fails
()=>getBinarySync(binaryFile));}// Otherwise, getBinarySync should be able to get it synchronously
return Promise.resolve().then(()=>getBinarySync(binaryFile));}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then(binary=>WebAssembly.instantiate(binary,imports)).then(receiver,reason=>{err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason);});}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(binaryFile)&&typeof fetch=="function"){return fetch(binaryFile,{credentials:"same-origin"}).then(response=>{// Suppress closure warning here since the upstream definition for
// instantiateStreaming only allows Promise<Repsponse> rather than
// an actual Response.
// TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
/** @suppress {checkTypes} */var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,function(reason){// We expect the most common failure cause to be a bad MIME type for the binary,
// in which case falling back to ArrayBuffer instantiation should work.
err(`wasm streaming compile failed: ${reason}`);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(binaryFile,imports,callback);});});}return instantiateArrayBuffer(binaryFile,imports,callback);}function getWasmImports(){// prepare imports
return{"env":wasmImports,"wasi_snapshot_preview1":wasmImports,"GOT.mem":new Proxy(wasmImports,GOTHandler),"GOT.func":new Proxy(wasmImports,GOTHandler)};}// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm(){var info=getWasmImports();// Load the wasm module and create an instance of using native support in the JS engine.
// handle a generated wasm instance, receiving its exports and
// performing other necessary setup
/** @param {WebAssembly.Module=} module*/function receiveInstance(instance,module){wasmExports=instance.exports;wasmExports=relocateExports(wasmExports,1024);wasmExports=Asyncify.instrumentWasmExports(wasmExports);var metadata=getDylinkMetadata(module);if(metadata.neededDynlibs){dynamicLibraries=metadata.neededDynlibs.concat(dynamicLibraries);}mergeLibSymbols(wasmExports,"main");LDSO.init();loadDylibs();wasmExports=applySignatureConversions(wasmExports);addOnInit(wasmExports["__wasm_call_ctors"]);__RELOC_FUNCS__.push(wasmExports["__wasm_apply_data_relocs"]);removeRunDependency("wasm-instantiate");return wasmExports;}// wait for the pthread pool (if any)
addRunDependency("wasm-instantiate");// Prefer streaming instantiation if available.
function receiveInstantiationResult(result){// 'result' is a ResultObject object which has both the module and instance.
// receiveInstance() will swap in the exports (to Module.asm) so they can be called
receiveInstance(result["instance"],result["module"]);}// User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
// to manually instantiate the Wasm module themselves. This allows pages to
// run the instantiation parallel to any other async startup actions they are
// performing.
// Also pthreads and wasm workers initialize the wasm instance through this
// path.
if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance);}catch(e){err(`Module.instantiateWasm callback failed with error: ${e}`);// If instantiation fails, reject the module ready promise.
readyPromiseReject(e);}}wasmBinaryFile??=findWasmBinary();// If instantiation fails, reject the module ready promise.
instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult).catch(readyPromiseReject);return{};}// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;var tempI64;// include: runtime_debug.js
// end include: runtime_debug.js
// With MAIN_MODULE + ASYNCIFY the normal method of placing stub functions in
// wasmImports for as-yet-undefined symbols doesn't work since ASYNCIFY then
// wraps these stub functions and we can't then replace them directly.  Instead
// the stub functions call into `asyncifyStubs` which gets populated by the
// dynamic linker as symbols are loaded.
var asyncifyStubs={};// === Body ===
var ASM_CONSTS={1527919:$0=>{const statement=Module.targets.get($0);Module.PdoParams.delete(statement);},1528001:$0=>{const results=Module.targets.get($0);if(results){return results.length;}return 0;},1528094:$0=>{const results=Module.targets.get($0);if(results.length){return Object.keys(results[0]).length;}return 0;},1528210:($0,$1)=>{const targetId=$0;const target=Module.targets.get(targetId);const current=$1;if(current>=target.length){return null;}return Module.jsToZval(target[current]);},1528387:($0,$1)=>{const results=Module.targets.get($0);if(results.length){const jsRet=Object.keys(results[0])[$1];const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;}return 0;},1528625:($0,$1,$2)=>{const results=Module.targets.get($0);const current=-1+$1;const colno=$2;if(current>=results.length){return null;}const result=results[current];const key=Object.keys(result)[$2];const zval=Module.jsToZval(result[key]);return zval;},1528885:($0,$1,$2)=>{const stmtTgtId=$0;const paramPtr=$1;const paramPos=$2;const statement=Module.targets.get(stmtTgtId);const paramVal=Module.zvalToJS(paramPtr);if(!Module.PdoParams.has(statement)){Module.PdoParams.set(statement,[]);}const paramList=Module.PdoParams.get(statement);paramList[paramPos]=paramVal;},1529207:($0,$1,$2)=>{console.log("GET ATTR",$0,$1,$2);},1529248:($0,$1,$2)=>{console.log("COL META",$0,$1,$2);},1529289:($0,$1,$2)=>{console.log("CLOSE",$0,$1,$2);},1529327:($0,$1,$2,$3)=>{const db=Module.zvalToJS($0);const query=UTF8ToString($1);const supports_placeholders=$2;const ret=$3;const prepared=(...params)=>db.query(query,params);prepared.query=query;const zval=Module.jsToZval(prepared);return zval;},1529579:()=>1,1529593:($0,$1,$2)=>{console.log("SET ATTR",$0,$1,$2);return true;},1529647:($0,$1,$2)=>{console.log("GET ATTR",$0,$1,$2);return 1;},1529698:$0=>{console.log("SHUTDOWN",$0);},1529731:($0,$1)=>{console.log("GET GC",$0,$1);},1529766:$0=>{if(Module.persist){const persist=Array.isArray(Module.persist)?Module.persist:[Module.persist];const useNodeRawFS=$0;persist.forEach(p=>{const mountPath=p.mountPath||"/persist";const localPath=p.localPath||"./persist";FS.mkdir(mountPath);if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){FS.mount(IDBFS,{autoPersist:false},mountPath);}else if(ENVIRONMENT_IS_NODE){if(!useNodeRawFS){const fs=(globalThis.__non_webpack_require__||require)("fs");if(!fs.existsSync(localPath)){fs.mkdirSync(localPath,{recursive:true});}FS.mount(NODEFS,{root:localPath},mountPath);}}});}},1530390:($0,$1)=>{const target=Module.targets.get($0);const property=UTF8ToString($1);if(!(property in target)){const jsRet="UN";const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;}if(target[property]===null){const jsRet="NU";const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;}const result=target[property];if(!result||!["function","object"].includes(typeof result)){const jsRet="OK"+String(result);const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;}const jsRet="XX";const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;},1531200:($0,$1,$2)=>{const target=Module.targets.get($0);const property=UTF8ToString($1);const result=target[property];const zvalPtr=$2;if(result&&["function","object"].includes(typeof result)){let index=Module.targets.getId(result);if(!Module.targets.has(result)){index=Module.targets.add(result);Module.zvalMap.set(result,zvalPtr);}return index;}return 0;},1531570:$0=>{"function"===typeof Module.targets.get($0);},1531622:($0,$1,$2,$3,$4)=>{(()=>{const target=Module.targets.get($0);const property=UTF8ToString($1);const funcPtr=$2;const zvalPtr=$3;const paramCount=$4;target[property]=Module.callableToJs(funcPtr,null);})();},1531831:($0,$1,$2)=>{(()=>{const target=Module.targets.get($0);const property=UTF8ToString($1);const zvalPtr=$2;if(!Module.targets.has(target[property])){target[property]=Module.marshalObject(zvalPtr);}})();},1532038:($0,$1)=>{(()=>{const target=Module.targets.get($0);const property=UTF8ToString($1);delete target[property];})();},1532154:($0,$1)=>{(()=>{const target=Module.targets.get($0);const property=UTF8ToString($1);target[property]=null;})();},1532270:($0,$1)=>{(()=>{const target=Module.targets.get($0);const property=UTF8ToString($1);target[property]=false;})();},1532387:($0,$1)=>{(()=>{const target=Module.targets.get($0);const property=UTF8ToString($1);target[property]=true;})();},1532503:($0,$1,$2)=>{(()=>{const target=Module.targets.get($0);const property=UTF8ToString($1);target[property]=$2;})();},1532617:($0,$1,$2)=>{(()=>{const target=Module.targets.get($0);const property=UTF8ToString($1);target[property]=$2;})();},1532731:($0,$1,$2)=>{(()=>{const target=Module.targets.get($0);const property=UTF8ToString($1);const newValue=UTF8ToString($2);target[property]=newValue;})();},1532886:($0,$1)=>{let target=Module.targets.get($0);const property=$1;if(target instanceof ArrayBuffer){if(!Module.bufferMaps.has(target)){Module.bufferMaps.set(target,new Uint8Array(target));}target=Module.bufferMaps.get(target);}if(!(property in target)){const jsRet="UN";const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;}if(target[property]===null){const jsRet="NU";const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;}const result=target[property];if(!result||!["function","object"].includes(typeof result)){const jsRet="OK"+String(result);const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;}const jsRet="XX";const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;},1533852:($0,$1,$2)=>{const target=Module.targets.get($0);const property=UTF8ToString($1);const result=target[property];const zvalPtr=$2;if(result&&["function","object"].includes(typeof result)){let index=Module.targets.getId(result);if(!Module.targets.has(result)){index=Module.targets.add(result);Module.zvalMap.set(result,zvalPtr);}return index;}return 0;},1534222:$0=>{"function"===typeof Module.targets.get($0);},1534274:($0,$1,$2,$3)=>{(()=>{const target=Module.targets.get($0);const property=$1;const funcPtr=$2;const zvalPtr=$3;target[property]=Module.callableToJs(funcPtr);})();},1534440:($0,$1,$2)=>{(()=>{const target=Module.targets.get($0);const property=$1;const zvalPtr=$2;if(!Module.targets.has(target[property])){target[property]=Module.marshalObject(zvalPtr);}})();},1534633:($0,$1)=>{(()=>{const target=Module.targets.get($0);const property=$1;delete target[property];})();},1534735:($0,$1)=>{(()=>{const target=Module.targets.get($0);const property=$1;target[property]=null;})();},1534837:($0,$1)=>{(()=>{const target=Module.targets.get($0);const property=$1;target[property]=false;})();},1534940:($0,$1)=>{(()=>{const target=Module.targets.get($0);const property=$1;target[property]=true;})();},1535042:($0,$1,$2)=>{(()=>{const target=Module.targets.get($0);const property=$1;target[property]=$2;})();},1535142:($0,$1,$2)=>{(()=>{const target=Module.targets.get($0);const property=$1;target[property]=$2;})();},1535242:($0,$1,$2)=>{(()=>{const target=Module.targets.get($0);const property=$1;const newValue=UTF8ToString($2);target[property]=newValue;})();},1535383:($0,$1,$2)=>{console.log("HASD",$0);const target=Module.targets.get($0);const property=$1;const check_empty=$2;if(Array.isArray(target)){return typeof target[property]!=="undefined";}if(target instanceof ArrayBuffer){if(!Module.bufferMaps.has(target)){Module.bufferMaps.set(target,new Uint8Array(target));}const targetBytes=Module.bufferMaps.get(target);return targetBytes[property]!=="undefined";}if(!check_empty){return property in target;}else{return!!target[property];}},1535887:($0,$1)=>{(()=>{const target=Module.targets.get($0);const property=UTF8ToString($1);delete target[property];})();},1536003:($0,$1)=>{(()=>{const target=Module.targets.get($0);const property=$1;delete target[property];})();},1536105:$0=>{const target=Module.targets.get($0);let json;if(typeof target==="function"){json=JSON.stringify({});}else{try{json=JSON.stringify({...target});}catch{json=JSON.stringify({});}}const jsRet=String(json);const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;},1536457:($0,$1)=>{const target=Module.targets.get($0);const property=UTF8ToString($1);return property in target;},1536562:$0=>{const target=Module.targets.get($0);const name=target.constructor&&target.constructor.name||"Object";const len=lengthBytesUTF8(name)+1;const namePtr=_malloc(name);stringToUTF8(name,namePtr,len);return namePtr;},1536799:($0,$1,$2,$3,$4)=>{const target=Module.targets.get($0);const method_name=UTF8ToString($1);const argv=$2;const argc=$3;const size=$4;const args=[];for(let i=0;i<argc;i++){args.push(Module.zvalToJS(argv+i*size));}const jsRet=target[method_name](...args);const retZval=Module.jsToZval(jsRet);return retZval;},1537127:($0,$1,$2,$3)=>{const target=Module.targets.get($0);const argv=$1;const argc=$2;const size=$3;const args=[];for(let i=0;i<argc;i++){args.push(Module.zvalToJS(argv+i*size));}const jsRet=target(...args);return Module.jsToZval(jsRet);},1537379:($0,$1)=>{const target=Module.targets.get($0);const property_name=UTF8ToString($1);target[property_name]=newValueJson;const jsRet=target[property_name];return Module.jsToZval(jsRet);},1537568:$0=>{const jsRet=String(eval(UTF8ToString($0)));const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;},1537736:($0,$1)=>{const funcName=UTF8ToString($0);const argJson=UTF8ToString($1);const func=globalThis[funcName];const args=JSON.parse(argJson||"[]")||[];const jsRet=String(func(...args));const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;},1538047:($0,$1)=>{const timeout=Number(UTF8ToString($0));const funcPtr=$1;setTimeout(()=>{Module.ccall("vrzno_exec_callback","number",["number","number","number"],[funcPtr,null,0]);Module.ccall("vrzno_del_callback","number",["number"],[funcPtr]);},timeout);},1538319:$0=>Module.jsToZval(Module[UTF8ToString($0)]),1538373:($0,$1,$2,$3)=>{const _class=Module.targets.get($0);const argv=$1;const argc=$2;const size=$3;const args=[];for(let i=0;i<argc;i++){args.push(Module.zvalToJS(argv+i*size));}const _object=new _class(...args);return Module.jsToZval(_object);},1538633:$0=>{const name=UTF8ToString($0);return Module.jsToZval(__webpack_require__("../packages/php-cgi-wasm lazy recursive")(name));},1538706:()=>{Module.zvalMap=new WeakMap();Module.isTarget=Symbol("IS_TARGET");const FinReg=globalThis.FinalizationRegistry||class{register(){}unregister(){}};const wRef=globalThis.WeakRef||class{constructor(val){this.val=val;}deref(){return this.val;}};Module.fRegistry=Module.fRegistry||new FinReg(zvalPtr=>{Module.ccall("vrzno_expose_dec_refcount","number",["number"],[zvalPtr]);});Module.bufferMaps=new WeakMap();Module.WeakerMap=Module.WeakerMap||class WeakerMap{constructor(entries){this.registry=new FinReg(held=>this.delete(held));this.map=new Map();entries&&entries.forEach(([key,value])=>this.set(key,value));}get size(){return this.map.size;}clear(){this.map.clear();}delete(key){this.map.delete(key);}[Symbol.iterator](){const mapIterator=this.map[Symbol.iterator]();return{next:()=>{do{const entry=mapIterator.next();if(entry.done){return{done:true};}const[key,ref]=entry.value;const value=ref.deref();if(!value){this.map.delete(key);continue;}return{done:false,value:[key,value]};}while(true);}};}entries(){return{[Symbol.iterator]:()=>this[Symbol.iterator]()};}forEach(callback){for(const[k,v]of this){callback(v,k,this);}}get(key){if(!this.has(key)){return;}return this.map.get(key).deref();}has(key){if(!this.map.has(key)){return false;}const result=this.map.get(key).deref();if(!result){this.map.delete(key);}return result;}keys(){return[...this].map(v=>v[0]);}set(key,value){if(typeof value!=="function"&&typeof value!=="object"){throw new Error("WeakerMap values must be objects.");}if(this.map.has(key)){this.registry.unregister(this.get(key));}this.registry.register(value,key,value);return this.map.set(key,new wRef(value));}values(){return[...this].map(v=>v[1]);}};Module.marshalObject=zvalPtr=>{const nativeTarget=Module.ccall("vrzno_expose_zval_is_target","number",["number"],[zvalPtr]);if(nativeTarget&&Module.targets.hasId(nativeTarget)){return Module.targets.get(nativeTarget);}const proxy=new Proxy({},{ownKeys:target=>{console.log("ownKeys",{target});const keysLoc=Module.ccall("vrzno_expose_object_keys","number",["number"],[zvalPtr]);const keyJson=UTF8ToString(keysLoc);const keys=JSON.parse(keyJson);keys.push(...Reflect.ownKeys(target));return keys;},has:(target,prop)=>{console.log("has",{target,prop});switch(typeof prop){case"number":return!!Module.ccall("vrzno_expose_dimension_pointer","number",["number","number"],[zvalPtr,prop]);case"string":const len=lengthBytesUTF8(prop)+1;const namePtr=_malloc(len);stringToUTF8(prop,namePtr,len);return!!Module.ccall("vrzno_expose_property_pointer","number",["number","number"],[zvalPtr,namePtr]);default:return false;}},get:(target,prop)=>{console.log("get",{target,prop});let retPtr;console.log({target,prop});switch(typeof prop){case"number":retPtr=Module.ccall("vrzno_expose_dimension_pointer","number",["number","number"],[zvalPtr,prop]);case"string":const len=lengthBytesUTF8(prop)+1;const namePtr=_malloc(len);stringToUTF8(prop,namePtr,len);retPtr=Module.ccall("vrzno_expose_property_pointer","number",["number","number"],[zvalPtr,namePtr]);default:return false;}const proxy=Module.zvalToJS(retPtr);if(proxy&&["function","object"].includes(typeof proxy)){Module.zvalMap.set(proxy,retPtr);}_free(namePtr);return proxy??Reflect.get(target,prop);},getOwnPropertyDescriptor:(target,prop)=>{console.log("getOwnPropertyDescriptor",{target,prop});let retPtr;switch(typeof prop){case"number":retPtr=Module.ccall("vrzno_expose_dimension_pointer","number",["number","number"],[zvalPtr,prop]);case"string":const len=lengthBytesUTF8(prop)+1;const namePtr=_malloc(len);stringToUTF8(prop,namePtr,len);retPtr=Module.ccall("vrzno_expose_property_pointer","number",["number","number"],[zvalPtr,namePtr]);default:return false;}const proxy=Module.zvalToJS(retPtr);if(proxy&&["function","object"].includes(typeof proxy)){Module.zvalMap.set(proxy,retPtr);}_free(namePtr);return{configurable:true,enumerable:true,value:target[prop]};}});Module.zvalMap.set(proxy,zvalPtr);Module.targets.add(proxy);Module.ccall("vrzno_expose_inc_refcount","number",["number"],[zvalPtr]);Module.fRegistry.register(proxy,zvalPtr,proxy);return proxy;};Module.callableToJs=Module.callableToJs||(funcPtr=>{const wrapped=(...args)=>{let paramPtrs=[],paramsPtr=null;if(args.length){paramsPtr=Module.ccall("vrzno_expose_create_params","number",["number","number"],[args.length]);paramPtrs=args.map(a=>Module.jsToZval(a));paramPtrs.forEach((paramPtr,i)=>{Module.ccall("vrzno_expose_set_param","number",["number","number","number"],[paramsPtr,i,paramPtr]);});}const zvalPtr=Module.ccall("vrzno_exec_callback","number",["number","number","number"],[funcPtr,paramsPtr,args.length]);if(args.length){paramPtrs.forEach((p,i)=>{});Module.ccall("vrzno_expose_efree","number",["number","number"],[paramsPtr,false]);}if(zvalPtr){return Module.zvalToJS(zvalPtr);}};Module.callables.set(funcPtr,wrapped);return wrapped;});Module.zvalToJS=Module.zvalToJS||(zvalPtr=>{const IS_UNDEF=0;const IS_NULL=1;const IS_FALSE=2;const IS_TRUE=3;const IS_LONG=4;const IS_DOUBLE=5;const IS_STRING=6;const IS_ARRAY=7;const IS_OBJECT=8;zvalPtr=Module.ccall("vrzno_expose_zval_deref","number",["number"],[zvalPtr]);const type=Module.ccall("vrzno_expose_type","number",["number"],[zvalPtr]);const callable=Module.ccall("vrzno_expose_callable","number",["number"],[zvalPtr]);let valPtr;if(callable&&type!==IS_STRING){const wrapped=Module.callableToJs(callable);if(!Module.targets.has(wrapped)){Module.targets.add(wrapped);Module.zvalMap.set(wrapped,zvalPtr);Module.ccall("vrzno_expose_inc_refcount","number",["number"],[zvalPtr]);Module.fRegistry.register(wrapped,zvalPtr,wrapped);}return wrapped;}switch(type){case IS_UNDEF:return undefined;break;case IS_NULL:return null;break;case IS_TRUE:return true;break;case IS_FALSE:return false;break;case IS_LONG:return Module.ccall("vrzno_expose_long","number",["number"],[zvalPtr]);break;case IS_DOUBLE:valPtr=Module.ccall("vrzno_expose_double","number",["number"],[zvalPtr]);if(!valPtr){return null;}return getValue(valPtr,"double");break;case IS_STRING:valPtr=Module.ccall("vrzno_expose_string","number",["number"],[zvalPtr]);if(!valPtr){return null;}return UTF8ToString(valPtr);break;case IS_ARRAY:case IS_OBJECT:const proxy=Module.marshalObject(zvalPtr);if(Module.targets.hasId(zvalPtr)){}return proxy;break;default:return null;break;}});Module.jsToZval=Module.jsToZval||(value=>{if(value&&["function","object"].includes(typeof value)){if(Module.zvalMap.has(value)){return Module.zvalMap.get(value);}}let zvalPtr;if(typeof value==="undefined"){zvalPtr=Module.ccall("vrzno_expose_create_undef","number",[],[]);}else if(value===null){zvalPtr=Module.ccall("vrzno_expose_create_null","number",[],[]);}else if([true,false].includes(value)){zvalPtr=Module.ccall("vrzno_expose_create_bool","number",["number"],[value]);}else if(value&&["function","object"].includes(typeof value)){let index,existed;if(!Module.targets.has(value)){index=Module.targets.add(value);existed=false;}else{index=Module.targets.getId(value);existed=true;}zvalPtr=Module.ccall("vrzno_expose_create_object_for_target","number",["number","number"],[index,typeof value==="function"]);Module.zvalMap.set(value,zvalPtr);if(!existed){Module.ccall("vrzno_expose_inc_refcount","number",["number"],[zvalPtr]);Module.fRegistry.register(value,zvalPtr,value);}}else if(typeof value==="number"){if(Number.isInteger(value)){zvalPtr=Module.ccall("vrzno_expose_create_long","number",["number"],[value]);}else if(Number.isFinite(value)){zvalPtr=Module.ccall("vrzno_expose_create_double","number",["number"],[value]);}}else if(typeof value==="string"){const len=lengthBytesUTF8(value)+1;const strLoc=_malloc(len);stringToUTF8(value,strLoc,len);zvalPtr=Module.ccall("vrzno_expose_create_string","number",["number"],[strLoc]);_free(strLoc);}return zvalPtr;});Module.UniqueIndex=Module.UniqueIndex||class UniqueIndex{constructor(){this.byObject=new WeakMap();this.byInteger=new Module.WeakerMap();this.tacked=new Map();this.id=0;Object.defineProperty(this,"add",{configurable:false,writable:false,value:callback=>{if(this.byObject.has(callback)){const id=this.byObject.get(callback);return id;}const newid=++this.id;this.byObject.set(callback,newid);this.byInteger.set(newid,callback);return newid;}});Object.defineProperty(this,"has",{configurable:false,writable:false,value:obj=>{if(this.byObject.has(obj)){return this.byObject.get(obj);}}});Object.defineProperty(this,"hasId",{configurable:false,writable:false,value:address=>{if(this.byInteger.has(address)){return this.byInteger.get(address);}}});Object.defineProperty(this,"get",{configurable:false,writable:false,value:address=>{if(this.byInteger.has(address)){return this.byInteger.get(address);}}});Object.defineProperty(this,"getId",{configurable:false,writable:false,value:obj=>{if(this.byObject.has(obj)){return this.byObject.get(obj);}}});Object.defineProperty(this,"remove",{configurable:false,writable:false,value:address=>{const obj=this.byInteger.get(address);if(obj){this.byObject.delete(obj);this.byInteger.delete(address);}}});Object.defineProperty(this,"tack",{configurable:false,writable:false,value:target=>{if(!this.tacked.has(target)){this.tacked.set(target,1);}else{this.tacked.set(target,1+this.tacked.get(target));}}});Object.defineProperty(this,"untack",{configurable:false,writable:false,value:target=>{if(!this.tacked.has(target)){return;}this.tacked.set(target,-1+this.tacked.get(target));if(this.tacked.get(target)<=0){return this.tacked.delete(target);}}});}};Module.callables=Module.callables||new Module.WeakerMap();Module.targets=Module.targets||new Module.UniqueIndex();Module.PdoParams=new WeakMap();Module.PdoD1Driver=Module.PdoD1Driver||class PdoD1Driver{prepare(db,query){console.log("prepare",{db,query});return db.prepare(query);}doer(db,query){console.log("doer",{db,query});}};Module.pdoDriver=Module.pdoDriver||new Module.PdoD1Driver();},1549732:$0=>{const results=Module.targets.get($0);if(results){return results.length;}return 0;},1549825:$0=>{const results=Module.targets.get($0);if(results.length){return Object.keys(results[0]).length;}return 0;},1549941:($0,$1)=>{const targetId=$0;const target=Module.targets.get(targetId);const current=$1;if(current>=target.length){return null;}return Module.jsToZval(target[current]);},1550118:($0,$1)=>{const results=Module.targets.get($0);if(results.length){const jsRet=Object.keys(results[0])[$1];const len=lengthBytesUTF8(jsRet)+1;const strLoc=_malloc(len);stringToUTF8(jsRet,strLoc,len);return strLoc;}return 0;},1550356:($0,$1,$2)=>{const results=Module.targets.get($0);const current=-1+$1;const colno=$2;if(current>=results.length){return null;}const result=results[current];const key=Object.keys(result)[$2];const zval=Module.jsToZval(result[key]);return zval;},1550616:($0,$1)=>{const statement=Module.targets.get($0);const paramVal=Module.zvalToJS($1);if(!Module.PdoParams.has(statement)){Module.PdoParams.set(statement,[]);}const paramList=Module.PdoParams.get(statement);paramList.push(paramVal);},1550855:($0,$1,$2)=>{console.log("GET ATTR",$0,$1,$2);},1550896:($0,$1,$2)=>{console.log("COL META",$0,$1,$2);},1550937:($0,$1,$2)=>{console.log("CLOSE",$0,$1,$2);},1550975:$0=>{console.log("CLOSE",$0);},1551005:($0,$1)=>{const target=Module.targets.get($0);const query=UTF8ToString($1);if(Module.pdoDriver&&Module.pdoDriver.prepare){const prepared=Module.pdoDriver.prepare(target,query);const zval=Module.jsToZval(prepared);return zval;}return null;},1551257:($0,$1)=>{console.log("DO",$0,UTF8ToString($1));const target=Module.targets.get($0);const query=UTF8ToString($1);if(Module.pdoDriver&&Module.pdoDriver.doer){return Module.pdoDriver.doer(target,query);}return 1;},1551478:$0=>{console.log("BEGIN TXN",$0);return true;},1551525:$0=>{console.log("COMMIT TXN",$0);return true;},1551573:$0=>{console.log("ROLLBACK TXN",$0);return true;},1551623:($0,$1,$2)=>{console.log("SET ATTR",$0,$1,$2);return true;},1551677:($0,$1)=>{console.log("LAST INSERT ID",$0,UTF8ToString($1));return 0;},1551744:($0,$1,$2)=>{console.log("FETCH ERROR FUNC",$0,$1,$2);},1551793:($0,$1,$2)=>{console.log("GET ATTR",$0,$1,$2);return 0;},1551844:$0=>{console.log("SHUTDOWN",$0);},1551877:($0,$1)=>{console.log("GET GC",$0,$1);},1551912:()=>Module.targets.add(globalThis),1551955:($0,$1)=>{let target=Module.targets.get($0);const property=$1;if(target instanceof ArrayBuffer){if(!Module.bufferMaps.has(target)){Module.bufferMaps.set(target,new Uint8Array(target));}target=Module.bufferMaps.get(target);}if(Array.isArray(target)||ArrayBuffer.isView(target)){if(property>=0&&property<target.length){return 1;}}return 0;},1552318:($0,$1)=>{let target=Module.targets.get($0);const property=$1;if(target instanceof ArrayBuffer){if(!Module.bufferMaps.has(target)){Module.bufferMaps.set(target,new Uint8Array(target));}target=Module.bufferMaps.get(target);}return Module.jsToZval(target[property]);},1552594:$0=>{if(!$0){AL.alcErr=40964;return 1;}},1552642:$0=>{if(!AL.currentCtx){err("alGetProcAddress() called without a valid context");return 1;}if(!$0){AL.currentCtx.err=40963;return 1;}}};function __asyncjs__pdo_pglite_real_stmt_execute(targetId,error){return Asyncify.handleAsync(async()=>{const statement=Module.targets.get(targetId);if(!Module.PdoParams.has(statement)){Module.PdoParams.set(statement,[]);}const params=Module.PdoParams.get(statement);try{const result=await statement(...params);const rows=result.rows??[];const _fields=result.fields??[];const fields=new Map();_fields.forEach(field=>{fields.set(field.name,field);});const utf8decoder=new TextDecoder();const mapped=rows.map(row=>{const _row={};for(const[key,val]of Object.entries(row)){if(fields.has(key)&&fields.get(key).dataTypeID===17){_row[key]=utf8decoder.decode(val);continue;}_row[key]=val;}return _row;});return Module.jsToZval(mapped);}catch(exception){const message=String(exception.message);const len=lengthBytesUTF8(message)+1;const strLoc=_malloc(len);console.error(message,statement.query,exception);stringToUTF8(message,strLoc,len);setValue(error,strLoc,"*");return 0;}});}__asyncjs__pdo_pglite_real_stmt_execute.sig="iii";function __asyncjs__pdo_pglite_real_handle_begin(handle){return Asyncify.handleAsync(async()=>{const db=Module.targets.get(handle);await db.query("BEGIN");});}__asyncjs__pdo_pglite_real_handle_begin.sig="ii";function __asyncjs__pdo_pglite_real_handle_commit(handle){return Asyncify.handleAsync(async()=>{const db=Module.targets.get(handle);await db.query("COMMIT");});}__asyncjs__pdo_pglite_real_handle_commit.sig="ii";function __asyncjs__pdo_pglite_real_handle_rollback(handle){return Asyncify.handleAsync(async()=>{const db=Module.targets.get(handle);await db.query("ROLLBACK");});}__asyncjs__pdo_pglite_real_handle_rollback.sig="ii";function __asyncjs__pdo_pglite_real_last_insert_id(handle,namePtr){return Asyncify.handleAsync(async()=>{const db=Module.targets.get(handle);if(namePtr){const name=UTF8ToString(namePtr);console.log("LAST INSERT ID",$0,name);const result=await db.query("SELECT CURRVAL($1)",name);console.log(result);}else{console.log("LAST INSERT ID",$0);const result=await db.query("SELECT CURRVAL($1)",name);console.log(result);}return 0;});}__asyncjs__pdo_pglite_real_last_insert_id.sig="iii";function __asyncjs__pdo_pglite_real_db_handle_factory(connectionStringPrt){return Asyncify.handleAsync(async()=>{if(!Module.PGlite){throw new Error("The PGlite class must be provided as a constructor arg to PHP to use PGlite.");}const connectionString=UTF8ToString(connectionStringPrt);const pglite=new Module.PGlite("idb://"+connectionString);return Module.jsToZval(pglite);});}__asyncjs__pdo_pglite_real_db_handle_factory.sig="ii";function __asyncjs__vrzno_await_internal(targetId){return Asyncify.handleAsync(async()=>{const target=Module.targets.get(targetId);const result=await target;return Module.jsToZval(result);});}__asyncjs__vrzno_await_internal.sig="ii";function __asyncjs__pdo_vrzno_real_stmt_execute(targetId){return Asyncify.handleAsync(async()=>{const statement=Module.targets.get(targetId);if(!Module.PdoParams.has(statement)){Module.PdoParams.set(statement,[]);}const paramList=Module.PdoParams.get(statement);const bound=paramList.length?statement.bind(...paramList):statement;const result=await bound.run();Module.PdoParams.delete(statement);if(!result.success){return false;}return Module.jsToZval(result.results);});}__asyncjs__pdo_vrzno_real_stmt_execute.sig="ii";// end include: preamble.js
/** @constructor */function ExitStatus(status){this.name="ExitStatus";this.message=`Program terminated with exit(${status})`;this.status=status;}var GOT={};var currentModuleWeakSymbols=new Set([]);var GOTHandler={get(obj,symName){var rtn=GOT[symName];if(!rtn){rtn=GOT[symName]=new WebAssembly.Global({"value":"i32","mutable":true});}if(!currentModuleWeakSymbols.has(symName)){// Any non-weak reference to a symbol marks it as `required`, which
// enabled `reportUndefinedSymbols` to report undefeind symbol errors
// correctly.
rtn.required=true;}return rtn;}};var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){// Pass the module as the first argument.
callbacks.shift()(Module);}};var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder():undefined;/**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number} idx
     * @param {number=} maxBytesToRead
     * @return {string}
     */var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{idx>>>=0;var endIdx=idx+maxBytesToRead;var endPtr=idx;// TextDecoder needs to know the byte length in advance, it doesn't stop on
// null terminator by itself.  Also, use the length info to avoid running tiny
// strings through TextDecoder, since .subarray() allocates garbage.
// (As a tiny code save trick, compare endPtr against endIdx using a negation,
// so that undefined means Infinity)
while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr));}var str="";// If building with TextDecoder, we have already computed the string length
// above, so test loop end condition against that
while(idx<endPtr){// For UTF8 byte structure, see:
// http://en.wikipedia.org/wiki/UTF-8#Description
// https://www.ietf.org/rfc/rfc2279.txt
// https://tools.ietf.org/html/rfc3629
var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue;}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue;}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}return str;};var getDylinkMetadata=binary=>{var offset=0;var end=0;function getU8(){return binary[offset++];}function getLEB(){var ret=0;var mul=1;while(1){var byte=binary[offset++];ret+=(byte&127)*mul;mul*=128;if(!(byte&128))break;}return ret;}function getString(){var len=getLEB();offset+=len;return UTF8ArrayToString(binary,offset-len,len);}/** @param {string=} message */function failIf(condition,message){if(condition)throw new Error(message);}var name="dylink.0";if(binary instanceof WebAssembly.Module){var dylinkSection=WebAssembly.Module.customSections(binary,name);if(dylinkSection.length===0){name="dylink";dylinkSection=WebAssembly.Module.customSections(binary,name);}failIf(dylinkSection.length===0,"need dylink section");binary=new Uint8Array(dylinkSection[0]);end=binary.length;}else{var int32View=new Uint32Array(new Uint8Array(binary.subarray(0,24)).buffer);var magicNumberFound=int32View[0]==1836278016;failIf(!magicNumberFound,"need to see wasm magic number");// \0asm
// we should see the dylink custom section right after the magic number and wasm version
failIf(binary[8]!==0,"need the dylink section to be first");offset=9;var section_size=getLEB();//section size
end=offset+section_size;name=getString();}var customSection={neededDynlibs:[],tlsExports:new Set(),weakImports:new Set()};if(name=="dylink"){customSection.memorySize=getLEB();customSection.memoryAlign=getLEB();customSection.tableSize=getLEB();customSection.tableAlign=getLEB();// shared libraries this module needs. We need to load them first, so that
// current module could resolve its imports. (see tools/shared.py
// WebAssembly.make_shared_library() for "dylink" section extension format)
var neededDynlibsCount=getLEB();for(var i=0;i<neededDynlibsCount;++i){var libname=getString();customSection.neededDynlibs.push(libname);}}else{failIf(name!=="dylink.0");var WASM_DYLINK_MEM_INFO=1;var WASM_DYLINK_NEEDED=2;var WASM_DYLINK_EXPORT_INFO=3;var WASM_DYLINK_IMPORT_INFO=4;var WASM_SYMBOL_TLS=256;var WASM_SYMBOL_BINDING_MASK=3;var WASM_SYMBOL_BINDING_WEAK=1;while(offset<end){var subsectionType=getU8();var subsectionSize=getLEB();if(subsectionType===WASM_DYLINK_MEM_INFO){customSection.memorySize=getLEB();customSection.memoryAlign=getLEB();customSection.tableSize=getLEB();customSection.tableAlign=getLEB();}else if(subsectionType===WASM_DYLINK_NEEDED){var neededDynlibsCount=getLEB();for(var i=0;i<neededDynlibsCount;++i){libname=getString();customSection.neededDynlibs.push(libname);}}else if(subsectionType===WASM_DYLINK_EXPORT_INFO){var count=getLEB();while(count--){var symname=getString();var flags=getLEB();if(flags&WASM_SYMBOL_TLS){customSection.tlsExports.add(symname);}}}else if(subsectionType===WASM_DYLINK_IMPORT_INFO){var count=getLEB();while(count--){var modname=getString();var symname=getString();var flags=getLEB();if((flags&WASM_SYMBOL_BINDING_MASK)==WASM_SYMBOL_BINDING_WEAK){customSection.weakImports.add(symname);}}}else{// unknown subsection
offset+=subsectionSize;}}}return customSection;};/**
     * @param {number} ptr
     * @param {string} type
     */function getValue(ptr,type="i8"){if(type.endsWith("*"))type="*";switch(type){case"i1":return HEAP8[ptr>>>0];case"i8":return HEAP8[ptr>>>0];case"i16":return HEAP16[ptr>>>1>>>0];case"i32":return HEAP32[ptr>>>2>>>0];case"i64":abort("to do getValue(i64) use WASM_BIGINT");case"float":return HEAPF32[ptr>>>2>>>0];case"double":return HEAPF64[ptr>>>3>>>0];case"*":return HEAPU32[ptr>>>2>>>0];default:abort(`invalid type for getValue: ${type}`);}}var newDSO=(name,handle,syms)=>{var dso={refcount:Infinity,name,exports:syms,global:true};LDSO.loadedLibsByName[name]=dso;if(handle!=undefined){LDSO.loadedLibsByHandle[handle]=dso;}return dso;};var LDSO={loadedLibsByName:{},loadedLibsByHandle:{},init(){newDSO("__main__",0,wasmImports);}};var ___heap_base=35252320;var alignMemory=(size,alignment)=>Math.ceil(size/alignment)*alignment;var getMemory=size=>{// After the runtime is initialized, we must only use sbrk() normally.
if(runtimeInitialized){// Currently we don't support freeing of static data when modules are
// unloaded via dlclose.  This function is tagged as `noleakcheck` to
// avoid having this reported as leak.
return _calloc(size,1);}var ret=___heap_base;// Keep __heap_base stack aligned.
var end=ret+alignMemory(size,16);___heap_base=end;GOT["__heap_base"].value=end;return ret;};var isInternalSym=symName=>["__cpp_exception","__c_longjmp","__wasm_apply_data_relocs","__dso_handle","__tls_size","__tls_align","__set_stack_limits","_emscripten_tls_init","__wasm_init_tls","__wasm_call_ctors","__start_em_asm","__stop_em_asm","__start_em_js","__stop_em_js"].includes(symName)||symName.startsWith("__em_js__");var uleb128Encode=(n,target)=>{if(n<128){target.push(n);}else{target.push(n%128|128,n>>7);}};var sigToWasmTypes=sig=>{var typeNames={"i":"i32","j":"i64","f":"f32","d":"f64","e":"externref","p":"i32"};var type={parameters:[],results:sig[0]=="v"?[]:[typeNames[sig[0]]]};for(var i=1;i<sig.length;++i){type.parameters.push(typeNames[sig[i]]);}return type;};var generateFuncType=(sig,target)=>{var sigRet=sig.slice(0,1);var sigParam=sig.slice(1);var typeCodes={"i":127,// i32
"p":127,// i32
"j":126,// i64
"f":125,// f32
"d":124,// f64
"e":111};// Parameters, length + signatures
target.push(96);/* form: func */uleb128Encode(sigParam.length,target);for(var i=0;i<sigParam.length;++i){target.push(typeCodes[sigParam[i]]);}// Return values, length + signatures
// With no multi-return in MVP, either 0 (void) or 1 (anything else)
if(sigRet=="v"){target.push(0);}else{target.push(1,typeCodes[sigRet]);}};var convertJsFunctionToWasm=(func,sig)=>{// If the type reflection proposal is available, use the new
// "WebAssembly.Function" constructor.
// Otherwise, construct a minimal wasm module importing the JS function and
// re-exporting it.
if(typeof WebAssembly.Function=="function"){return new WebAssembly.Function(sigToWasmTypes(sig),func);}// The module is static, with the exception of the type section, which is
// generated based on the signature passed in.
var typeSectionBody=[1];// count: 1
generateFuncType(sig,typeSectionBody);// Rest of the module is static
var bytes=[0,97,115,109,// magic ("\0asm")
1,0,0,0,// version: 1
1];// Write the overall length of the type section followed by the body
uleb128Encode(typeSectionBody.length,bytes);bytes.push(...typeSectionBody);// The rest of the module is static
bytes.push(2,7,// import section
// (import "e" "f" (func 0 (type 0)))
1,1,101,1,102,0,0,7,5,// export section
// (export "f" (func 0 (type 0)))
1,1,102,0,0);// We can compile this wasm module synchronously because it is very small.
// This accepts an import (at "e.f"), that it reroutes to an export (at "f")
var module=new WebAssembly.Module(new Uint8Array(bytes));var instance=new WebAssembly.Instance(module,{"e":{"f":func}});var wrappedFunc=instance.exports["f"];return wrappedFunc;};var wasmTableMirror=[];/** @type {WebAssembly.Table} */var wasmTable=new WebAssembly.Table({"initial":5085,"element":"anyfunc"});var getWasmTableEntry=funcPtr=>{var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr);}return func;};var updateTableMap=(offset,count)=>{if(functionsInTableMap){for(var i=offset;i<offset+count;i++){var item=getWasmTableEntry(i);// Ignore null values.
if(item){functionsInTableMap.set(item,i);}}}};var functionsInTableMap;var getFunctionAddress=func=>{// First, create the map if this is the first use.
if(!functionsInTableMap){functionsInTableMap=new WeakMap();updateTableMap(0,wasmTable.length);}return functionsInTableMap.get(func)||0;};var freeTableIndexes=[];var getEmptyTableSlot=()=>{// Reuse a free index if there is one, otherwise grow.
if(freeTableIndexes.length){return freeTableIndexes.pop();}// Grow the table
try{wasmTable.grow(1);}catch(err){if(!(err instanceof RangeError)){throw err;}throw"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";}return wasmTable.length-1;};var setWasmTableEntry=(idx,func)=>{wasmTable.set(idx,func);// With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overridden to return wrapped
// functions so we need to call it here to retrieve the potential wrapper correctly
// instead of just storing 'func' directly into wasmTableMirror
wasmTableMirror[idx]=wasmTable.get(idx);};/** @param {string=} sig */var addFunction=(func,sig)=>{// Check if the function is already in the table, to ensure each function
// gets a unique index.
var rtn=getFunctionAddress(func);if(rtn){return rtn;}// It's not in the table, add it now.
var ret=getEmptyTableSlot();// Set the new value.
try{// Attempting to call this with JS function will cause of table.set() to fail
setWasmTableEntry(ret,func);}catch(err){if(!(err instanceof TypeError)){throw err;}var wrapped=convertJsFunctionToWasm(func,sig);setWasmTableEntry(ret,wrapped);}functionsInTableMap.set(func,ret);return ret;};var updateGOT=(exports,replace)=>{for(var symName in exports){if(isInternalSym(symName)){continue;}var value=exports[symName];if(symName.startsWith("orig$")){symName=symName.split("$")[1];replace=true;}GOT[symName]||=new WebAssembly.Global({"value":"i32","mutable":true});if(replace||GOT[symName].value==0){if(typeof value=="function"){GOT[symName].value=addFunction(value);}else if(typeof value=="number"){GOT[symName].value=value;}else{err(`unhandled export type for '${symName}': ${typeof value}`);}}}};/** @param {boolean=} replace */var relocateExports=(exports,memoryBase,replace)=>{var relocated={};for(var e in exports){var value=exports[e];if(typeof value=="object"){// a breaking change in the wasm spec, globals are now objects
// https://github.com/WebAssembly/mutable-global/issues/1
value=value.value;}if(typeof value=="number"){value+=memoryBase;}relocated[e]=value;}updateGOT(relocated,replace);return relocated;};var isSymbolDefined=symName=>{// Ignore 'stub' symbols that are auto-generated as part of the original
// `wasmImports` used to instantiate the main module.
var existing=wasmImports[symName];if(!existing||existing.stub){return false;}// Even if a symbol exists in wasmImports, and is not itself a stub, it
// could be an ASYNCIFY wrapper function that wraps a stub function.
if(symName in asyncifyStubs&&!asyncifyStubs[symName]){return false;}return true;};/** @suppress {duplicate } */var setTempRet0=val=>__emscripten_tempret_set(val);var _setTempRet0=setTempRet0;Module["_setTempRet0"]=_setTempRet0;var createDyncallWrapper=sig=>{var sections=[];var prelude=[0,97,115,109,// magic ("\0asm")
1,0,0,0];// version: 1
sections.push(prelude);var wrappersig=[// if return type is j, we will put the upper 32 bits into tempRet0.
sig[0].replace("j","i"),"i",// The first argument is the function pointer to call
// in the rest of the argument list, one 64 bit integer is legalized into
// two 32 bit integers.
sig.slice(1).replace(/j/g,"ii")].join("");var typeSectionBody=[3];// number of types = 3
generateFuncType(wrappersig,typeSectionBody);// The signature of the wrapper we are generating
generateFuncType(sig,typeSectionBody);// the signature of the function pointer we will call
generateFuncType("vi",typeSectionBody);// the signature of setTempRet0
var typeSection=[1];/* Type section code */uleb128Encode(typeSectionBody.length,typeSection);// length of section in bytes
typeSection.push(...typeSectionBody);sections.push(typeSection);var importSection=[2,// import section code
15,// length of section in bytes
2,// number of imports = 2
// Import the wasmTable, which we will call "t"
1,101,// name "e"
1,116,// name "t"
1,112,// importing a table
0,// with no max # of elements
0,// and min of 0 elements
// Import the setTempRet0 function, which we will call "r"
1,101,// name "e"
1,114,// name "r"
0,// importing a function
2];// type 2
sections.push(importSection);var functionSection=[3,// function section code
2,// length of section in bytes
1,// number of functions = 1
0];// type 0 = wrappersig
sections.push(functionSection);var exportSection=[7,// export section code
5,// length of section in bytes
1,// One export
1,102,// name "f"
0,// type: function
1];// function index 1 = the wrapper function (index 0 is setTempRet0)
sections.push(exportSection);var convert_code=[];if(sig[0]==="j"){// Add a single extra i64 local. In order to legalize the return value we
// need a local to store it in. Local variables are run length encoded.
convert_code=[1,// One run
1,// of length 1
126];}else// of i64
{convert_code.push(0);}// no local variables (except the arguments)
function localGet(j){convert_code.push(32);// local.get
uleb128Encode(j,convert_code);}var j=1;for(var i=1;i<sig.length;i++){if(sig[i]=="j"){localGet(j+1);convert_code.push(173,// i64.extend_i32_unsigned
66,32,// i64.const 32
134);// i64.shl,
localGet(j);convert_code.push(172,// i64.extend_i32_signed
132);// i64.or
j+=2;}else{localGet(j);j++;}}convert_code.push(32,0,// local.get 0 (put function pointer on stack)
17,1,0);// call_indirect type 1 = wrapped_sig, table 0 = only table
if(sig[0]==="j"){// tee into j (after the argument handling loop, j is one past the
// argument list so it points to the i64 local we added)
convert_code.push(34);uleb128Encode(j,convert_code);convert_code.push(66,32,// i64.const 32
136,// i64.shr_u
167,// i32.wrap_i64
16,0);// Call function 0
localGet(j);convert_code.push(167);}// i32.wrap_i64
convert_code.push(11);// end
var codeBody=[1];// one code
uleb128Encode(convert_code.length,codeBody);codeBody.push(...convert_code);var codeSection=[10];/* Code section code */uleb128Encode(codeBody.length,codeSection);codeSection.push(...codeBody);sections.push(codeSection);var bytes=new Uint8Array([].concat.apply([],sections));// We can compile this wasm module synchronously because it is small.
var module=new WebAssembly.Module(bytes);var instance=new WebAssembly.Instance(module,{"e":{"t":wasmTable,"r":setTempRet0}});var wrappedFunc=instance.exports["f"];return wrappedFunc;};var dynCallLegacy=(sig,ptr,args)=>{sig=sig.replace(/p/g,"i");if(!("dynCall_"+sig in Module)){Module["dynCall_"+sig]=createDyncallWrapper(sig);}var f=Module["dynCall_"+sig];return f(ptr,...args);};var dynCall=(sig,ptr,args=[])=>{var rtn=dynCallLegacy(sig,ptr,args);return sig[0]=="p"?rtn>>>0:rtn;};var stackSave=()=>_emscripten_stack_get_current();var stackRestore=val=>__emscripten_stack_restore(val);var createInvokeFunction=sig=>(ptr,...args)=>{var sp=stackSave();try{return dynCall(sig,ptr,args);}catch(e){stackRestore(sp);// Create a try-catch guard that rethrows the Emscripten EH exception.
// Exceptions thrown from C++ will be a pointer (number) and longjmp
// will throw the number Infinity. Use the compact and fast "e !== e+0"
// test to check if e was not a Number.
if(e!==e+0)throw e;_setThrew(1,0);}};var resolveGlobalSymbol=(symName,direct=false)=>{var sym;// First look for the orig$ symbol which is the symbol without i64
// legalization performed.
if(direct&&"orig$"+symName in wasmImports){symName="orig$"+symName;}if(isSymbolDefined(symName)){sym=wasmImports[symName];}else// Asm.js-style exception handling: invoke wrapper generation
if(symName.startsWith("invoke_")){// Create (and cache) new invoke_ functions on demand.
sym=wasmImports[symName]=createInvokeFunction(symName.split("_")[1]);}return{sym,name:symName};};/**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index (i.e. maxBytesToRead will not
     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
     *   JS JIT optimizations off, so it is worth to consider consistently using one
     * @return {string}
     */var UTF8ToString=(ptr,maxBytesToRead)=>{ptr>>>=0;return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):"";};/**
      * @param {string=} libName
      * @param {Object=} localScope
      * @param {number=} handle
      */var loadWebAssemblyModule=(binary,flags,libName,localScope,handle)=>{var metadata=getDylinkMetadata(binary);currentModuleWeakSymbols=metadata.weakImports;// loadModule loads the wasm module after all its dependencies have been loaded.
// can be called both sync/async.
function loadModule(){// The first thread to load a given module needs to allocate the static
// table and memory regions.  Later threads re-use the same table region
// and can ignore the memory region (since memory is shared between
// threads already).
// If `handle` is specified than it is assumed that the calling thread has
// exclusive access to it for the duration of this function.  See the
// locking in `dynlink.c`.
var firstLoad=!handle||!HEAP8[handle+8>>>0];if(firstLoad){// alignments are powers of 2
var memAlign=Math.pow(2,metadata.memoryAlign);// prepare memory
var memoryBase=metadata.memorySize?alignMemory(getMemory(metadata.memorySize+memAlign),memAlign):0;// TODO: add to cleanups
var tableBase=metadata.tableSize?wasmTable.length:0;if(handle){HEAP8[handle+8>>>0]=1;HEAPU32[handle+12>>>2>>>0]=memoryBase;HEAP32[handle+16>>>2>>>0]=metadata.memorySize;HEAPU32[handle+20>>>2>>>0]=tableBase;HEAP32[handle+24>>>2>>>0]=metadata.tableSize;}}else{memoryBase=HEAPU32[handle+12>>>2>>>0];tableBase=HEAPU32[handle+20>>>2>>>0];}var tableGrowthNeeded=tableBase+metadata.tableSize-wasmTable.length;if(tableGrowthNeeded>0){wasmTable.grow(tableGrowthNeeded);}// This is the export map that we ultimately return.  We declare it here
// so it can be used within resolveSymbol.  We resolve symbols against
// this local symbol map in the case there they are not present on the
// global Module object.  We need this fallback because Modules sometime
// need to import their own symbols
var moduleExports;function resolveSymbol(sym){var resolved=resolveGlobalSymbol(sym).sym;if(!resolved&&localScope){resolved=localScope[sym];}if(!resolved){resolved=moduleExports[sym];}return resolved;}// TODO kill ↓↓↓ (except "symbols local to this module", it will likely be
// not needed if we require that if A wants symbols from B it has to link
// to B explicitly: similarly to -Wl,--no-undefined)
// wasm dynamic libraries are pure wasm, so they cannot assist in
// their own loading. When side module A wants to import something
// provided by a side module B that is loaded later, we need to
// add a layer of indirection, but worse, we can't even tell what
// to add the indirection for, without inspecting what A's imports
// are. To do that here, we use a JS proxy (another option would
// be to inspect the binary directly).
var proxyHandler={get(stubs,prop){// symbols that should be local to this module
switch(prop){case"__memory_base":return memoryBase;case"__table_base":return tableBase;}if(prop in wasmImports&&!wasmImports[prop].stub){// No stub needed, symbol already exists in symbol table
return wasmImports[prop];}// Return a stub function that will resolve the symbol
// when first called.
if(!(prop in stubs)){var resolved;stubs[prop]=(...args)=>{resolved||=resolveSymbol(prop);return resolved(...args);};}return stubs[prop];}};var proxy=new Proxy({},proxyHandler);var info={"GOT.mem":new Proxy({},GOTHandler),"GOT.func":new Proxy({},GOTHandler),"env":proxy,"wasi_snapshot_preview1":proxy};function postInstantiation(module,instance){// add new entries to functionsInTableMap
updateTableMap(tableBase,metadata.tableSize);moduleExports=relocateExports(instance.exports,memoryBase);moduleExports=Asyncify.instrumentWasmExports(moduleExports);if(!flags.allowUndefined){reportUndefinedSymbols();}function addEmAsm(addr,body){var args=[];var arity=0;for(;arity<16;arity++){if(body.indexOf("$"+arity)!=-1){args.push("$"+arity);}else{break;}}args=args.join(",");var func=`(${args}) => { ${body} };`;ASM_CONSTS[start]=eval(func);}// Add any EM_ASM function that exist in the side module
if("__start_em_asm"in moduleExports){var start=moduleExports["__start_em_asm"];var stop=moduleExports["__stop_em_asm"];while(start<stop){var jsString=UTF8ToString(start);addEmAsm(start,jsString);start=HEAPU8.indexOf(0,start)+1;}}function addEmJs(name,cSig,body){// The signature here is a C signature (e.g. "(int foo, char* bar)").
// See `create_em_js` in emcc.py` for the build-time version of this
// code.
var jsArgs=[];cSig=cSig.slice(1,-1);if(cSig!="void"){cSig=cSig.split(",");for(var i in cSig){var jsArg=cSig[i].split(" ").pop();jsArgs.push(jsArg.replace("*",""));}}var func=`(${jsArgs}) => ${body};`;moduleExports[name]=eval(func);}for(var name in moduleExports){if(name.startsWith("__em_js__")){var start=moduleExports[name];var jsString=UTF8ToString(start);// EM_JS strings are stored in the data section in the form
// SIG<::>BODY.
var parts=jsString.split("<::>");addEmJs(name.replace("__em_js__",""),parts[0],parts[1]);delete moduleExports[name];}}// initialize the module
var applyRelocs=moduleExports["__wasm_apply_data_relocs"];if(applyRelocs){if(runtimeInitialized){applyRelocs();}else{__RELOC_FUNCS__.push(applyRelocs);}}var init=moduleExports["__wasm_call_ctors"];if(init){if(runtimeInitialized){init();}else{// we aren't ready to run compiled code yet
__ATINIT__.push(init);}}return moduleExports;}if(flags.loadAsync){if(binary instanceof WebAssembly.Module){var instance=new WebAssembly.Instance(binary,info);return Promise.resolve(postInstantiation(binary,instance));}return WebAssembly.instantiate(binary,info).then(result=>postInstantiation(result.module,result.instance));}var module=binary instanceof WebAssembly.Module?binary:new WebAssembly.Module(binary);var instance=new WebAssembly.Instance(module,info);return postInstantiation(module,instance);}// now load needed libraries and the module itself.
if(flags.loadAsync){return metadata.neededDynlibs.reduce((chain,dynNeeded)=>chain.then(()=>loadDynamicLibrary(dynNeeded,flags,localScope)),Promise.resolve()).then(loadModule);}metadata.neededDynlibs.forEach(needed=>loadDynamicLibrary(needed,flags,localScope));return loadModule();};var mergeLibSymbols=(exports,libName)=>{// add symbols into global namespace TODO: weak linking etc.
for(var[sym,exp]of Object.entries(exports)){// When RTLD_GLOBAL is enabled, the symbols defined by this shared object
// will be made available for symbol resolution of subsequently loaded
// shared objects.
// We should copy the symbols (which include methods and variables) from
// SIDE_MODULE to MAIN_MODULE.
const setImport=target=>{if(target in asyncifyStubs){asyncifyStubs[target]=exp;}if(!isSymbolDefined(target)){wasmImports[target]=exp;}};setImport(sym);if(sym.startsWith("dynCall_")&&!Module.hasOwnProperty(sym)){Module[sym]=exp;}}};/** @param {boolean=} noRunDep */var asyncLoad=(url,onload,onerror,noRunDep)=>{var dep=!noRunDep?getUniqueRunDependency(`al ${url}`):"";readAsync(url).then(arrayBuffer=>{onload(new Uint8Array(arrayBuffer));if(dep)removeRunDependency(dep);},err=>{if(onerror){onerror();}else{throw`Loading data file "${url}" failed.`;}});if(dep)addRunDependency(dep);};var preloadPlugins=Module["preloadPlugins"]||[];var registerWasmPlugin=()=>{// Use string keys here to avoid minification since the plugin consumer
// also uses string keys.
var wasmPlugin={"promiseChainEnd":Promise.resolve(),"canHandle":name=>!Module["noWasmDecoding"]&&name.endsWith(".so"),"handle":(byteArray,name,onload,onerror)=>{// loadWebAssemblyModule can not load modules out-of-order, so rather
// than just running the promises in parallel, this makes a chain of
// promises to run in series.
wasmPlugin["promiseChainEnd"]=wasmPlugin["promiseChainEnd"].then(()=>loadWebAssemblyModule(byteArray,{loadAsync:true,nodelete:true},name,{})).then(exports=>{preloadedWasm[name]=exports;onload(byteArray);},error=>{err(`failed to instantiate wasm: ${name}: ${error}`);onerror();});}};preloadPlugins.push(wasmPlugin);};var preloadedWasm={};/**
       * @param {number=} handle
       * @param {Object=} localScope
       */function loadDynamicLibrary(libName,flags={global:true,nodelete:true},localScope,handle){// when loadDynamicLibrary did not have flags, libraries were loaded
// globally & permanently
var dso=LDSO.loadedLibsByName[libName];if(dso){// the library is being loaded or has been loaded already.
if(!flags.global){if(localScope){Object.assign(localScope,dso.exports);}}else if(!dso.global){// The library was previously loaded only locally but not
// we have a request with global=true.
dso.global=true;mergeLibSymbols(dso.exports,libName);}// same for "nodelete"
if(flags.nodelete&&dso.refcount!==Infinity){dso.refcount=Infinity;}dso.refcount++;if(handle){LDSO.loadedLibsByHandle[handle]=dso;}return flags.loadAsync?Promise.resolve(true):true;}// allocate new DSO
dso=newDSO(libName,handle,"loading");dso.refcount=flags.nodelete?Infinity:1;dso.global=flags.global;// libName -> libData
function loadLibData(){// for wasm, we can use fetch for async, but for fs mode we can only imitate it
if(handle){var data=HEAPU32[handle+28>>>2>>>0];var dataSize=HEAPU32[handle+32>>>2>>>0];if(data&&dataSize){var libData=HEAP8.slice(data,data+dataSize);return flags.loadAsync?Promise.resolve(libData):libData;}}var libFile=locateFile(libName);if(flags.loadAsync){return new Promise((resolve,reject)=>asyncLoad(libFile,resolve,reject));}// load the binary synchronously
if(!readBinary){throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);}return readBinary(libFile);}// libName -> exports
function getExports(){// lookup preloaded cache first
var preloaded=preloadedWasm[libName];if(preloaded){return flags.loadAsync?Promise.resolve(preloaded):preloaded;}// module not preloaded - load lib data and create new module from it
if(flags.loadAsync){return loadLibData().then(libData=>loadWebAssemblyModule(libData,flags,libName,localScope,handle));}return loadWebAssemblyModule(loadLibData(),flags,libName,localScope,handle);}// module for lib is loaded - update the dso & global namespace
function moduleLoaded(exports){if(dso.global){mergeLibSymbols(exports,libName);}else if(localScope){Object.assign(localScope,exports);}dso.exports=exports;}if(flags.loadAsync){return getExports().then(exports=>{moduleLoaded(exports);return true;});}moduleLoaded(getExports());return true;}var reportUndefinedSymbols=()=>{for(var[symName,entry]of Object.entries(GOT)){if(entry.value==0){var value=resolveGlobalSymbol(symName,true).sym;if(!value&&!entry.required){// Ignore undefined symbols that are imported as weak.
continue;}if(typeof value=="function"){/** @suppress {checkTypes} */entry.value=addFunction(value,value.sig);}else if(typeof value=="number"){entry.value=value;}else{throw new Error(`bad export type for '${symName}': ${typeof value}`);}}}};var loadDylibs=()=>{if(!dynamicLibraries.length){reportUndefinedSymbols();return;}// Load binaries asynchronously
addRunDependency("loadDylibs");dynamicLibraries.reduce((chain,lib)=>chain.then(()=>loadDynamicLibrary(lib,{loadAsync:true,global:true,nodelete:true,allowUndefined:true})),Promise.resolve()).then(()=>{// we got them all, wonderful
reportUndefinedSymbols();removeRunDependency("loadDylibs");});};var noExitRuntime=Module["noExitRuntime"]||false;/**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */function setValue(ptr,value,type="i8"){if(type.endsWith("*"))type="*";switch(type){case"i1":HEAP8[ptr>>>0]=value;break;case"i8":HEAP8[ptr>>>0]=value;break;case"i16":HEAP16[ptr>>>1>>>0]=value;break;case"i32":HEAP32[ptr>>>2>>>0]=value;break;case"i64":abort("to do setValue(i64) use WASM_BIGINT");case"float":HEAPF32[ptr>>>2>>>0]=value;break;case"double":HEAPF64[ptr>>>3>>>0]=value;break;case"*":HEAPU32[ptr>>>2>>>0]=value;break;default:abort(`invalid type for setValue: ${type}`);}}function _UTF8ToHtml(...args){return asyncifyStubs["UTF8ToHtml"](...args);}_UTF8ToHtml.stub=true;asyncifyStubs["UTF8ToHtml"]=undefined;function _UTF8Toisolat1(...args){return asyncifyStubs["UTF8Toisolat1"](...args);}_UTF8Toisolat1.stub=true;asyncifyStubs["UTF8Toisolat1"]=undefined;var convertI32PairToI53Checked=(lo,hi)=>hi+2097152>>>0<4194305-!!lo?(lo>>>0)+hi*4294967296:NaN;function ___assert_fail(condition,filename,line,func){condition>>>=0;filename>>>=0;func>>>=0;abort(`Assertion failed: ${UTF8ToString(condition)}, at: `+[filename?UTF8ToString(filename):"unknown filename",line,func?UTF8ToString(func):"unknown function"]);}___assert_fail.sig="vppip";var ___asyncify_data=new WebAssembly.Global({"value":"i32","mutable":true},0);var ___asyncify_state=new WebAssembly.Global({"value":"i32","mutable":true},0);var ___call_sighandler=function(fp,sig){fp>>>=0;return(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */sig);};___call_sighandler.sig="vpi";var ___memory_base=new WebAssembly.Global({"value":"i32","mutable":false},1024);var ___stack_high=35252320;var ___stack_low=1697888;var ___stack_pointer=new WebAssembly.Global({"value":"i32","mutable":true},35252320);var PATH={isAbs:path=>path.charAt(0)==="/",splitPath:filename=>{var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1);},normalizeArray:(parts,allowAboveRoot)=>{// if the path tries to go above the root, `up` ends up > 0
var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1);}else if(last===".."){parts.splice(i,1);up++;}else if(up){parts.splice(i,1);up--;}}// if the path is allowed to go above the root, restore leading ..s
if(allowAboveRoot){for(;up;up--){parts.unshift("..");}}return parts;},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.substr(-1)==="/";// Normalize the path
path=PATH.normalizeArray(path.split("/").filter(p=>!!p),!isAbsolute).join("/");if(!path&&!isAbsolute){path=".";}if(path&&trailingSlash){path+="/";}return(isAbsolute?"/":"")+path;},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){// No dirname whatsoever
return".";}if(dir){// It has a dirname, strip trailing slash
dir=dir.substr(0,dir.length-1);}return root+dir;},basename:path=>{// EMSCRIPTEN return '/'' for '/', not an empty string
if(path==="/")return"/";path=PATH.normalize(path);path=path.replace(/\/$/,"");var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1);},join:(...paths)=>PATH.normalize(paths.join("/")),join2:(l,r)=>PATH.normalize(l+"/"+r)};var initRandomFill=()=>{if(typeof crypto=="object"&&typeof crypto["getRandomValues"]=="function"){// for modern web browsers
return view=>crypto.getRandomValues(view);}else// we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
abort("initRandomDevice");};var randomFill=view=>(randomFill=initRandomFill())(view);var PATH_FS={resolve:(...args)=>{var resolvedPath="",resolvedAbsolute=false;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?args[i]:FS.cwd();// Skip empty and invalid entries
if(typeof path!="string"){throw new TypeError("Arguments to path.resolve must be strings");}else if(!path){return"";}// an invalid portion invalidates the whole thing
resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=PATH.isAbs(path);}// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)
resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter(p=>!!p),!resolvedAbsolute).join("/");return(resolvedAbsolute?"/":"")+resolvedPath||".";},relative:(from,to)=>{from=PATH_FS.resolve(from).substr(1);to=PATH_FS.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break;}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break;}if(start>end)return[];return arr.slice(start,end-start+1);}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break;}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..");}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/");}};var FS_stdin_getChar_buffer=[];var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){// Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
// unit, not a Unicode code point of the character! So decode
// UTF16->UTF32->UTF8.
// See http://unicode.org/faq/utf_bom.html#utf16-3
var c=str.charCodeAt(i);// possibly a lead surrogate
if(c<=127){len++;}else if(c<=2047){len+=2;}else if(c>=55296&&c<=57343){len+=4;++i;}else{len+=3;}}return len;};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{outIdx>>>=0;// Parameter maxBytesToWrite is not optional. Negative values, 0, null,
// undefined and false each don't write out any bytes.
if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;// -1 for string null terminator.
for(var i=0;i<str.length;++i){// Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
// unit, not a Unicode code point of the character! So decode
// UTF16->UTF32->UTF8.
// See http://unicode.org/faq/utf_bom.html#utf16-3
// For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
// and https://www.ietf.org/rfc/rfc2279.txt
// and https://tools.ietf.org/html/rfc3629
var u=str.charCodeAt(i);// possibly a lead surrogate
if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++>>>0]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++>>>0]=192|u>>6;heap[outIdx++>>>0]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++>>>0]=224|u>>12;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63;}else{if(outIdx+3>=endIdx)break;heap[outIdx++>>>0]=240|u>>18;heap[outIdx++>>>0]=128|u>>12&63;heap[outIdx++>>>0]=128|u>>6&63;heap[outIdx++>>>0]=128|u&63;}}// Null-terminate the pointer to the buffer.
heap[outIdx>>>0]=0;return outIdx-startIdx;};/** @type {function(string, boolean=, number=)} */function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array;}var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var result=null;{}if(!result){return null;}FS_stdin_getChar_buffer=intArrayFromString(result,true);}return FS_stdin_getChar_buffer.shift();};var TTY={ttys:[],init(){},// https://github.com/emscripten-core/emscripten/pull/1555
// if (ENVIRONMENT_IS_NODE) {
//   // currently, FS.init does not distinguish if process.stdin is a file or TTY
//   // device, it always assumes it's a TTY device. because of this, we're forcing
//   // process.stdin to UTF8 encoding to at least make stdin reading compatible
//   // with text files until FS.init can be refactored.
//   process.stdin.setEncoding('utf8');
// }
shutdown(){},// https://github.com/emscripten-core/emscripten/pull/1555
// if (ENVIRONMENT_IS_NODE) {
//   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
//   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
//   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
//   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
//   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
//   process.stdin.pause();
// }
register(dev,ops){TTY.ttys[dev]={input:[],output:[],ops};FS.registerDevice(dev,TTY.stream_ops);},stream_ops:{open(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43);}stream.tty=tty;stream.seekable=false;},close(stream){// flush any pending line data
stream.tty.ops.fsync(stream.tty);},fsync(stream){stream.tty.ops.fsync(stream.tty);},read(stream,buffer,offset,length,pos){/* ignored */if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60);}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty);}catch(e){throw new FS.ErrnoError(29);}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6);}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead;},write(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60);}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i]);}}catch(e){throw new FS.ErrnoError(29);}if(length){stream.node.timestamp=Date.now();}return i;}},default_tty_ops:{get_char(tty){return FS_stdin_getChar();},put_char(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[];}else{if(val!=0)tty.output.push(val);}},// val == 0 would cut text output off in the middle.
fsync(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[];}},ioctl_tcgets(tty){// typical setting
return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};},ioctl_tcsets(tty,optional_actions,data){// currently just ignore
return 0;},ioctl_tiocgwinsz(tty){return[24,80];}},default_tty1_ops:{put_char(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[];}else{if(val!=0)tty.output.push(val);}},fsync(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[];}}}};var zeroMemory=(address,size)=>{HEAPU8.fill(0,address,address+size);return address;};var mmapAlloc=size=>{size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(!ptr)return 0;return zeroMemory(ptr,size);};var MEMFS={ops_table:null,mount(mount){return MEMFS.createNode(null,"/",16384|511,/* 0777 */0);},createNode(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){// no supported
throw new FS.ErrnoError(63);}MEMFS.ops_table||={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={};}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;// The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
// When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
// for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
// penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
node.contents=null;}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream;}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream;}node.timestamp=Date.now();// add the new node to the parent
if(parent){parent.contents[name]=node;parent.timestamp=node.timestamp;}return node;},getFileDataAsTypedArray(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);// Make sure to not return excess unused bytes.
return new Uint8Array(node.contents);},expandFileStorage(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;// No need to expand, the storage was already large enough.
// Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
// For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
// avoid overshooting the allocation cap by a very large margin.
var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);// At minimum allocate 256b for each file when expanding.
var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);// Allocate new storage.
if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);},// Copy old data over to the new storage.
resizeFileStorage(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;// Fully decommit when requesting a resize to zero.
node.usedBytes=0;}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);// Allocate new storage.
if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)));}// Copy old data over to the new storage.
node.usedBytes=newSize;}},node_ops:{getattr(node){var attr={};// device numbers reuse inode numbers.
attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096;}else if(FS.isFile(node.mode)){attr.size=node.usedBytes;}else if(FS.isLink(node.mode)){attr.size=node.link.length;}else{attr.size=0;}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);// NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
//       but this is not required by the standard.
attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr;},setattr(node,attr){if(attr.mode!==undefined){node.mode=attr.mode;}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp;}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size);}},lookup(parent,name){throw FS.genericErrors[44];},mknod(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev);},rename(old_node,new_dir,new_name){// if we're overwriting a directory at new_name, make sure it's empty.
if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(55);}}}// do the internal rewiring
delete old_node.parent.contents[old_node.name];old_node.parent.timestamp=Date.now();old_node.name=new_name;new_dir.contents[new_name]=old_node;new_dir.timestamp=old_node.parent.timestamp;},unlink(parent,name){delete parent.contents[name];parent.timestamp=Date.now();},rmdir(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55);}delete parent.contents[name];parent.timestamp=Date.now();},readdir(node){var entries=[".",".."];for(var key of Object.keys(node.contents)){entries.push(key);}return entries;},symlink(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|/* 0777 */40960,0);node.link=oldpath;return node;},readlink(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28);}return node.link;}},stream_ops:{read(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){// non-trivial, and typed array
buffer.set(contents.subarray(position,position+size),offset);}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i];}return size;},write(stream,buffer,offset,length,position,canOwn){// If the buffer is located in main memory (HEAP), and if
// memory can grow, we can't hold on to references of the
// memory buffer, as they may get invalidated. That means we
// need to do copy its contents.
if(buffer.buffer===HEAP8.buffer){canOwn=false;}if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){// This write is from a typed array to a typed array?
if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length;}else if(node.usedBytes===0&&position===0){// If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length;}else if(position+length<=node.usedBytes){// Writing to an already allocated and used subrange of the file?
node.contents.set(buffer.subarray(offset,offset+length),position);return length;}}// Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){// Use typed array write which is available.
node.contents.set(buffer.subarray(offset,offset+length),position);}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i];}}node.usedBytes=Math.max(node.usedBytes,position+length);return length;},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position;}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes;}}if(position<0){throw new FS.ErrnoError(28);}return position;},allocate(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length);},mmap(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43);}var ptr;var allocated;var contents=stream.node.contents;// Only make a new copy when MAP_PRIVATE is specified.
if(!(flags&2)&&contents&&contents.buffer===HEAP8.buffer){// We can't emulate MAP_SHARED when the file is not backed by the
// buffer we're mapping to (e.g. the HEAP buffer).
allocated=false;ptr=contents.byteOffset;}else{allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48);}if(contents){// Try to avoid unnecessary slices.
if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length);}else{contents=Array.prototype.slice.call(contents,position,position+length);}}HEAP8.set(contents,ptr>>>0);}}return{ptr,allocated};},msync(stream,buffer,offset,length,mmapFlags){MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);// should we check if bytesWritten and length are the same?
return 0;}}};var FS_createDataFile=(parent,name,fileData,canRead,canWrite,canOwn)=>{FS.createDataFile(parent,name,fileData,canRead,canWrite,canOwn);};var FS_handledByPreloadPlugin=(byteArray,fullname,finish,onerror)=>{// Ensure plugins are ready.
if(typeof Browser!="undefined")Browser.init();var handled=false;preloadPlugins.forEach(plugin=>{if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,onerror);handled=true;}});return handled;};var FS_createPreloadedFile=(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{// TODO we should allow people to just pass in a complete filename instead
// of parent and name being that we just join them anyways
var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(`cp ${fullname}`);// might have several active requests for the same fullname
function processData(byteArray){function finish(byteArray){preFinish?.();if(!dontCreateFile){FS_createDataFile(parent,name,byteArray,canRead,canWrite,canOwn);}onload?.();removeRunDependency(dep);}if(FS_handledByPreloadPlugin(byteArray,fullname,finish,()=>{onerror?.();removeRunDependency(dep);})){return;}finish(byteArray);}addRunDependency(dep);if(typeof url=="string"){asyncLoad(url,processData,onerror);}else{processData(url);}};var FS_modeStringToFlags=str=>{var flagModes={"r":0,"r+":2,"w":512|64|1,"w+":512|64|2,"a":1024|64|1,"a+":1024|64|2};var flags=flagModes[str];if(typeof flags=="undefined"){throw new Error(`Unknown file open mode: ${str}`);}return flags;};var FS_getMode=(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode;};var IDBFS={dbs:{},indexedDB:()=>{if(typeof indexedDB!="undefined")return indexedDB;var ret=null;if(typeof window=="object")ret=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB;return ret;},DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",queuePersist:mount=>{function onPersistComplete(){if(mount.idbPersistState==="again")startPersist();else// If a new sync request has appeared in between, kick off a new sync
mount.idbPersistState=0;}// Otherwise reset sync state back to idle to wait for a new sync later
function startPersist(){mount.idbPersistState="idb";// Mark that we are currently running a sync operation
IDBFS.syncfs(mount,/*populate:*/false,onPersistComplete);}if(!mount.idbPersistState){// Programs typically write/copy/move multiple files in the in-memory
// filesystem within a single app frame, so when a filesystem sync
// command is triggered, do not start it immediately, but only after
// the current frame is finished. This way all the modified files
// inside the main loop tick will be batched up to the same sync.
mount.idbPersistState=setTimeout(startPersist,0);}else if(mount.idbPersistState==="idb"){// There is an active IndexedDB sync operation in-flight, but we now
// have accumulated more files to sync. We should therefore queue up
// a new sync after the current one finishes so that all writes
// will be properly persisted.
mount.idbPersistState="again";}},mount:mount=>{// reuse core MEMFS functionality
var mnt=MEMFS.mount(mount);// If the automatic IDBFS persistence option has been selected, then automatically persist
// all modifications to the filesystem as they occur.
if(mount?.opts?.autoPersist){mnt.idbPersistState=0;// IndexedDB sync starts in idle state
var memfs_node_ops=mnt.node_ops;mnt.node_ops=Object.assign({},mnt.node_ops);// Clone node_ops to inject write tracking
mnt.node_ops.mknod=(parent,name,mode,dev)=>{var node=memfs_node_ops.mknod(parent,name,mode,dev);// Propagate injected node_ops to the newly created child node
node.node_ops=mnt.node_ops;// Remember for each IDBFS node which IDBFS mount point they came from so we know which mount to persist on modification.
node.idbfs_mount=mnt.mount;// Remember original MEMFS stream_ops for this node
node.memfs_stream_ops=node.stream_ops;// Clone stream_ops to inject write tracking
node.stream_ops=Object.assign({},node.stream_ops);// Track all file writes
node.stream_ops.write=(stream,buffer,offset,length,position,canOwn)=>{// This file has been modified, we must persist IndexedDB when this file closes
stream.node.isModified=true;return node.memfs_stream_ops.write(stream,buffer,offset,length,position,canOwn);};// Persist IndexedDB on file close
node.stream_ops.close=stream=>{var n=stream.node;if(n.isModified){IDBFS.queuePersist(n.idbfs_mount);n.isModified=false;}if(n.memfs_stream_ops.close)return n.memfs_stream_ops.close(stream);};return node;};// Also kick off persisting the filesystem on other operations that modify the filesystem.
mnt.node_ops.mkdir=(...args)=>(IDBFS.queuePersist(mnt.mount),memfs_node_ops.mkdir(...args));mnt.node_ops.rmdir=(...args)=>(IDBFS.queuePersist(mnt.mount),memfs_node_ops.rmdir(...args));mnt.node_ops.symlink=(...args)=>(IDBFS.queuePersist(mnt.mount),memfs_node_ops.symlink(...args));mnt.node_ops.unlink=(...args)=>(IDBFS.queuePersist(mnt.mount),memfs_node_ops.unlink(...args));mnt.node_ops.rename=(...args)=>(IDBFS.queuePersist(mnt.mount),memfs_node_ops.rename(...args));}return mnt;},syncfs:(mount,populate,callback)=>{IDBFS.getLocalSet(mount,(err,local)=>{if(err)return callback(err);IDBFS.getRemoteSet(mount,(err,remote)=>{if(err)return callback(err);var src=populate?remote:local;var dst=populate?local:remote;IDBFS.reconcile(src,dst,callback);});});},quit:()=>{Object.values(IDBFS.dbs).forEach(value=>value.close());IDBFS.dbs={};},getDB:(name,callback)=>{// check the cache first
var db=IDBFS.dbs[name];if(db){return callback(null,db);}var req;try{req=IDBFS.indexedDB().open(name,IDBFS.DB_VERSION);}catch(e){return callback(e);}if(!req){return callback("Unable to connect to IndexedDB");}req.onupgradeneeded=e=>{var db=/** @type {IDBDatabase} */e.target.result;var transaction=e.target.transaction;var fileStore;if(db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)){fileStore=transaction.objectStore(IDBFS.DB_STORE_NAME);}else{fileStore=db.createObjectStore(IDBFS.DB_STORE_NAME);}if(!fileStore.indexNames.contains("timestamp")){fileStore.createIndex("timestamp","timestamp",{unique:false});}};req.onsuccess=()=>{db=/** @type {IDBDatabase} */req.result;// add to the cache
IDBFS.dbs[name]=db;callback(null,db);};req.onerror=e=>{callback(e.target.error);e.preventDefault();};},getLocalSet:(mount,callback)=>{var entries={};function isRealDir(p){return p!=="."&&p!=="..";}function toAbsolute(root){return p=>PATH.join2(root,p);}var check=FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));while(check.length){var path=check.pop();var stat;try{stat=FS.stat(path);}catch(e){return callback(e);}if(FS.isDir(stat.mode)){check.push(...FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));}entries[path]={"timestamp":stat.mtime};}return callback(null,{type:"local",entries});},getRemoteSet:(mount,callback)=>{var entries={};IDBFS.getDB(mount.mountpoint,(err,db)=>{if(err)return callback(err);try{var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readonly");transaction.onerror=e=>{callback(e.target.error);e.preventDefault();};var store=transaction.objectStore(IDBFS.DB_STORE_NAME);var index=store.index("timestamp");index.openKeyCursor().onsuccess=event=>{var cursor=event.target.result;if(!cursor){return callback(null,{type:"remote",db,entries});}entries[cursor.primaryKey]={"timestamp":cursor.key};cursor.continue();};}catch(e){return callback(e);}});},loadLocalEntry:(path,callback)=>{var stat,node;try{var lookup=FS.lookupPath(path);node=lookup.node;stat=FS.stat(path);}catch(e){return callback(e);}if(FS.isDir(stat.mode)){return callback(null,{"timestamp":stat.mtime,"mode":stat.mode});}else if(FS.isFile(stat.mode)){// Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.
// Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.
node.contents=MEMFS.getFileDataAsTypedArray(node);return callback(null,{"timestamp":stat.mtime,"mode":stat.mode,"contents":node.contents});}else{return callback(new Error("node type not supported"));}},storeLocalEntry:(path,entry,callback)=>{try{if(FS.isDir(entry["mode"])){FS.mkdirTree(path,entry["mode"]);}else if(FS.isFile(entry["mode"])){FS.writeFile(path,entry["contents"],{canOwn:true});}else{return callback(new Error("node type not supported"));}FS.chmod(path,entry["mode"]);FS.utime(path,entry["timestamp"],entry["timestamp"]);}catch(e){return callback(e);}callback(null);},removeLocalEntry:(path,callback)=>{try{var stat=FS.stat(path);if(FS.isDir(stat.mode)){FS.rmdir(path);}else if(FS.isFile(stat.mode)){FS.unlink(path);}}catch(e){return callback(e);}callback(null);},loadRemoteEntry:(store,path,callback)=>{var req=store.get(path);req.onsuccess=event=>callback(null,event.target.result);req.onerror=e=>{callback(e.target.error);e.preventDefault();};},storeRemoteEntry:(store,path,entry,callback)=>{try{var req=store.put(entry,path);}catch(e){callback(e);return;}req.onsuccess=event=>callback();req.onerror=e=>{callback(e.target.error);e.preventDefault();};},removeRemoteEntry:(store,path,callback)=>{var req=store.delete(path);req.onsuccess=event=>callback();req.onerror=e=>{callback(e.target.error);e.preventDefault();};},reconcile:(src,dst,callback)=>{var total=0;var create=[];Object.keys(src.entries).forEach(key=>{var e=src.entries[key];var e2=dst.entries[key];if(!e2||e["timestamp"].getTime()!=e2["timestamp"].getTime()){create.push(key);total++;}});var remove=[];Object.keys(dst.entries).forEach(key=>{if(!src.entries[key]){remove.push(key);total++;}});if(!total){return callback(null);}var errored=false;var db=src.type==="remote"?src.db:dst.db;var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readwrite");var store=transaction.objectStore(IDBFS.DB_STORE_NAME);function done(err){if(err&&!errored){errored=true;return callback(err);}}// transaction may abort if (for example) there is a QuotaExceededError
transaction.onerror=transaction.onabort=e=>{done(e.target.error);e.preventDefault();};transaction.oncomplete=e=>{if(!errored){callback(null);}};// sort paths in ascending order so directory entries are created
// before the files inside them
create.sort().forEach(path=>{if(dst.type==="local"){IDBFS.loadRemoteEntry(store,path,(err,entry)=>{if(err)return done(err);IDBFS.storeLocalEntry(path,entry,done);});}else{IDBFS.loadLocalEntry(path,(err,entry)=>{if(err)return done(err);IDBFS.storeRemoteEntry(store,path,entry,done);});}});// sort paths in descending order so files are deleted before their
// parent directories
remove.sort().reverse().forEach(path=>{if(dst.type==="local"){IDBFS.removeLocalEntry(path,done);}else{IDBFS.removeRemoteEntry(store,path,done);}});}};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:class{// We set the `name` property to be able to identify `FS.ErrnoError`
// - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
// - when using PROXYFS, an error can come from an underlying FS
// as different FS objects have their own FS.ErrnoError each,
// the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
// we'll use the reliable test `err.name == "ErrnoError"` instead
constructor(errno){// TODO(sbc): Use the inline member declaration syntax once we
// support it in acorn and closure.
this.name="ErrnoError";this.errno=errno;}},genericErrors:{},filesystems:null,syncFSRequests:0,readFiles:{},FSStream:class{constructor(){// TODO(https://github.com/emscripten-core/emscripten/issues/21414):
// Use inline field declarations.
this.shared={};}get object(){return this.node;}set object(val){this.node=val;}get isRead(){return(this.flags&2097155)!==1;}get isWrite(){return(this.flags&2097155)!==0;}get isAppend(){return this.flags&1024;}get flags(){return this.shared.flags;}set flags(val){this.shared.flags=val;}get position(){return this.shared.position;}set position(val){this.shared.position=val;}},FSNode:class{constructor(parent,name,mode,rdev){if(!parent){parent=this;}// root node sets parent to itself
this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev;this.readMode=292|73;this.writeMode=146;}get read(){return(this.mode&this.readMode)===this.readMode;}set read(val){val?this.mode|=this.readMode:this.mode&=~this.readMode;}get write(){return(this.mode&this.writeMode)===this.writeMode;}set write(val){val?this.mode|=this.writeMode:this.mode&=~this.writeMode;}get isFolder(){return FS.isDir(this.mode);}get isDevice(){return FS.isChrdev(this.mode);}},lookupPath(path,opts={}){path=PATH_FS.resolve(path);if(!path)return{path:"",node:null};var defaults={follow_mount:true,recurse_count:0};opts=Object.assign(defaults,opts);if(opts.recurse_count>8){// max recursive lookup of 8
throw new FS.ErrnoError(32);}// split the absolute path
var parts=path.split("/").filter(p=>!!p);// start at the root
var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){// stop resolving
break;}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);// jump to the mount's root node if this is a mountpoint
if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root;}}// by default, lookupPath will not follow a symlink if it is the final path component.
// setting opts.follow = true will override this behavior.
if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH_FS.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count+1});current=lookup.node;if(count++>40){// limit max consecutive symlinks to 40 (SYMLOOP_MAX).
throw new FS.ErrnoError(32);}}}}return{path:current_path,node:current};},getPath(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?`${mount}/${path}`:mount+path;}path=path?`${node.name}/${path}`:node.name;node=node.parent;}},hashName(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0;}return(parentid+hash>>>0)%FS.nameTable.length;},hashAddNode(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node;},hashRemoveNode(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next;}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break;}current=current.name_next;}}},lookupNode(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode);}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node;}}// if we failed to find it in the cache, call into the VFS
return FS.lookup(parent,name);},createNode(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node;},destroyNode(node){FS.hashRemoveNode(node);},isRoot(node){return node===node.parent;},isMountpoint(node){return!!node.mounted;},isFile(mode){return(mode&61440)===32768;},isDir(mode){return(mode&61440)===16384;},isLink(mode){return(mode&61440)===40960;},isChrdev(mode){return(mode&61440)===8192;},isBlkdev(mode){return(mode&61440)===24576;},isFIFO(mode){return(mode&61440)===4096;},isSocket(mode){return(mode&49152)===49152;},flagsToPermissionString(flag){var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w";}return perms;},nodePermissions(node,perms){if(FS.ignorePermissions){return 0;}// return 0 if any user, group or owner bits are set.
if(perms.includes("r")&&!(node.mode&292)){return 2;}else if(perms.includes("w")&&!(node.mode&146)){return 2;}else if(perms.includes("x")&&!(node.mode&73)){return 2;}return 0;},mayLookup(dir){if(!FS.isDir(dir.mode))return 54;var errCode=FS.nodePermissions(dir,"x");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0;},mayCreate(dir,name){try{var node=FS.lookupNode(dir,name);return 20;}catch(e){}return FS.nodePermissions(dir,"wx");},mayDelete(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name);}catch(e){return e.errno;}var errCode=FS.nodePermissions(dir,"wx");if(errCode){return errCode;}if(isdir){if(!FS.isDir(node.mode)){return 54;}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10;}}else{if(FS.isDir(node.mode)){return 31;}}return 0;},mayOpen(node,flags){if(!node){return 44;}if(FS.isLink(node.mode)){return 32;}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||// opening for write
flags&512){// TODO: check for O_SEARCH? (== search for dir only)
return 31;}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags));},MAX_OPEN_FDS:4096,nextfd(){for(var fd=0;fd<=FS.MAX_OPEN_FDS;fd++){if(!FS.streams[fd]){return fd;}}throw new FS.ErrnoError(33);},getStreamChecked(fd){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8);}return stream;},getStream:fd=>FS.streams[fd],createStream(stream,fd=-1){// clone it, so we can return an instance of FSStream
stream=Object.assign(new FS.FSStream(),stream);if(fd==-1){fd=FS.nextfd();}stream.fd=fd;FS.streams[fd]=stream;return stream;},closeStream(fd){FS.streams[fd]=null;},dupStream(origStream,fd=-1){var stream=FS.createStream(origStream,fd);stream.stream_ops?.dup?.(stream);return stream;},chrdev_stream_ops:{open(stream){var device=FS.getDevice(stream.node.rdev);// override node's stream ops with the device's
stream.stream_ops=device.stream_ops;// forward the open call
stream.stream_ops.open?.(stream);},llseek(){throw new FS.ErrnoError(70);}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice(dev,ops){FS.devices[dev]={stream_ops:ops};},getDevice:dev=>FS.devices[dev],getMounts(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push(...m.mounts);}return mounts;},syncfs(populate,callback){if(typeof populate=="function"){callback=populate;populate=false;}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode);}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode);}return;}if(++completed>=mounts.length){doCallback(null);}}// sync all mounts
mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null);}mount.type.syncfs(mount,populate,done);});},mount(type,opts,mountpoint){var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10);}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;// use the absolute path
node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10);}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54);}}var mount={type,opts,mountpoint,mounts:[]};// create a root node for the fs
var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot;}else if(node){// set as a mountpoint
node.mounted=mount;// add the new mount to the current mount's children
if(node.mount){node.mount.mounts.push(mount);}}return mountRoot;},unmount(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28);}// destroy the nodes for this mount, and all its child mounts
var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current);}current=next;}});// no longer a mountpoint
node.mounted=null;// remove this mount from the child mounts
var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1);},lookup(parent,name){return parent.node_ops.lookup(parent,name);},mknod(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(28);}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode);}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63);}return parent.node_ops.mknod(parent,name,mode,dev);},create(path,mode){mode=mode!==undefined?mode:438;/* 0666 */mode&=4095;mode|=32768;return FS.mknod(path,mode,0);},mkdir(path,mode){mode=mode!==undefined?mode:511;/* 0777 */mode&=511|512;mode|=16384;return FS.mknod(path,mode,0);},mkdirTree(path,mode){var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode);}catch(e){if(e.errno!=20)throw e;}}},mkdev(path,mode,dev){if(typeof dev=="undefined"){dev=mode;mode=438;}/* 0666 */mode|=8192;return FS.mknod(path,mode,dev);},symlink(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44);}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44);}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode);}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63);}return parent.node_ops.symlink(parent,newname,oldpath);},rename(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);// parents must exist
var lookup,old_dir,new_dir;// let the errors from non existent directories percolate up
lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);// need to be part of the same mount
if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75);}// source must exist
var old_node=FS.lookupNode(old_dir,old_name);// old path should not be an ancestor of the new path
var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(28);}// new path should not be an ancestor of the old path
relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(55);}// see if the new path already exists
var new_node;try{new_node=FS.lookupNode(new_dir,new_name);}catch(e){}// early out if nothing needs to change
if(old_node===new_node){return;}// we'll need to delete the old entry
var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode);}// need delete permissions if we'll be overwriting.
// need create permissions if new doesn't already exist.
errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode);}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63);}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10);}// if we are going to change the parent, check write permissions
if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,"w");if(errCode){throw new FS.ErrnoError(errCode);}}// remove the node from the lookup hash
FS.hashRemoveNode(old_node);// do the underlying fs rename
try{old_dir.node_ops.rename(old_node,new_dir,new_name);// update old node (we do this here to avoid each backend 
// needing to)
old_node.parent=new_dir;}catch(e){throw e;}finally{// add the node back to the hash (in case node_ops.rename
// changed its name)
FS.hashAddNode(old_node);}},rmdir(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode);}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63);}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10);}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);},readdir(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(54);}return node.node_ops.readdir(node);},unlink(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44);}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){// According to POSIX, we should map EISDIR to EPERM, but
// we instead do what Linux does (and we must, as we use
// the musl linux libc).
throw new FS.ErrnoError(errCode);}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63);}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10);}parent.node_ops.unlink(parent,name);FS.destroyNode(node);},readlink(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44);}if(!link.node_ops.readlink){throw new FS.ErrnoError(28);}return PATH_FS.resolve(FS.getPath(link.parent),link.node_ops.readlink(link));},stat(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(44);}if(!node.node_ops.getattr){throw new FS.ErrnoError(63);}return node.node_ops.getattr(node);},lstat(path){return FS.stat(path,true);},chmod(path,mode,dontFollow){var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else{node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63);}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()});},lchmod(path,mode){FS.chmod(path,mode,true);},fchmod(fd,mode){var stream=FS.getStreamChecked(fd);FS.chmod(stream.node,mode);},chown(path,uid,gid,dontFollow){var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node;}else{node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63);}node.node_ops.setattr(node,{timestamp:Date.now()});},// we ignore the uid / gid for now
lchown(path,uid,gid){FS.chown(path,uid,gid,true);},fchown(fd,uid,gid){var stream=FS.getStreamChecked(fd);FS.chown(stream.node,uid,gid);},truncate(path,len){if(len<0){throw new FS.ErrnoError(28);}var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;}else{node=path;}if(!node.node_ops.setattr){throw new FS.ErrnoError(63);}if(FS.isDir(node.mode)){throw new FS.ErrnoError(31);}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28);}var errCode=FS.nodePermissions(node,"w");if(errCode){throw new FS.ErrnoError(errCode);}node.node_ops.setattr(node,{size:len,timestamp:Date.now()});},ftruncate(fd,len){var stream=FS.getStreamChecked(fd);if((stream.flags&2097155)===0){throw new FS.ErrnoError(28);}FS.truncate(stream.node,len);},utime(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)});},open(path,flags,mode){if(path===""){throw new FS.ErrnoError(44);}flags=typeof flags=="string"?FS_modeStringToFlags(flags):flags;if(flags&64){mode=typeof mode=="undefined"?438:/* 0666 */mode;mode=mode&4095|32768;}else{mode=0;}var node;if(typeof path=="object"){node=path;}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node;}catch(e){}}// perhaps we need to create the node
var created=false;if(flags&64){if(node){// if O_CREAT and O_EXCL are set, error out if the node already exists
if(flags&128){throw new FS.ErrnoError(20);}}else{// node doesn't exist, try to create it
node=FS.mknod(path,mode,0);created=true;}}if(!node){throw new FS.ErrnoError(44);}// can't truncate a device
if(FS.isChrdev(node.mode)){flags&=~512;}// if asked only for a directory, then this must be one
if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54);}// check permissions, if this is not a file we just created now (it is ok to
// create and write to a file with read-only permissions; it is read-only
// for later use)
if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode);}}// do truncation if necessary
if(flags&512&&!created){FS.truncate(node,0);}// we've already handled these, don't pass down to the underlying vfs
flags&=~(128|512|131072);// register the stream with the filesystem
var stream=FS.createStream({node,path:FS.getPath(node),// we want the absolute path to the node
flags,seekable:true,position:0,stream_ops:node.stream_ops,// used by the file family libc calls (fopen, fwrite, ferror, etc.)
ungotten:[],error:false});// call the new stream's open function
if(stream.stream_ops.open){stream.stream_ops.open(stream);}if(Module["logReadFiles"]&&!(flags&1)){if(!(path in FS.readFiles)){FS.readFiles[path]=1;}}return stream;},close(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8);}if(stream.getdents)stream.getdents=null;// free readdir state
try{if(stream.stream_ops.close){stream.stream_ops.close(stream);}}catch(e){throw e;}finally{FS.closeStream(stream.fd);}stream.fd=null;},isClosed(stream){return stream.fd===null;},llseek(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8);}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70);}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28);}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position;},read(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28);}if(FS.isClosed(stream)){throw new FS.ErrnoError(8);}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8);}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31);}if(!stream.stream_ops.read){throw new FS.ErrnoError(28);}var seeking=typeof position!="undefined";if(!seeking){position=stream.position;}else if(!stream.seekable){throw new FS.ErrnoError(70);}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead;},write(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28);}if(FS.isClosed(stream)){throw new FS.ErrnoError(8);}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8);}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31);}if(!stream.stream_ops.write){throw new FS.ErrnoError(28);}if(stream.seekable&&stream.flags&1024){// seek to the end before writing in append mode
FS.llseek(stream,0,2);}var seeking=typeof position!="undefined";if(!seeking){position=stream.position;}else if(!stream.seekable){throw new FS.ErrnoError(70);}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten;},allocate(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(8);}if(offset<0||length<=0){throw new FS.ErrnoError(28);}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8);}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43);}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138);}stream.stream_ops.allocate(stream,offset,length);},mmap(stream,length,position,prot,flags){// User requests writing to file (prot & PROT_WRITE != 0).
// Checking if we have permissions to write to the file unless
// MAP_PRIVATE flag is set. According to POSIX spec it is possible
// to write to file opened in read-only mode with MAP_PRIVATE flag,
// as all modifications will be visible only in the memory of
// the current process.
if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2);}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2);}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43);}if(!length){throw new FS.ErrnoError(28);}return stream.stream_ops.mmap(stream,length,position,prot,flags);},msync(stream,buffer,offset,length,mmapFlags){if(!stream.stream_ops.msync){return 0;}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags);},ioctl(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59);}return stream.stream_ops.ioctl(stream,cmd,arg);},readFile(path,opts={}){opts.flags=opts.flags||0;opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error(`Invalid encoding type "${opts.encoding}"`);}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0);}else if(opts.encoding==="binary"){ret=buf;}FS.close(stream);return ret;},writeFile(path,data,opts={}){opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data=="string"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn);}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn);}else{throw new Error("Unsupported data type");}FS.close(stream);},cwd:()=>FS.currentPath,chdir(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44);}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54);}var errCode=FS.nodePermissions(lookup.node,"x");if(errCode){throw new FS.ErrnoError(errCode);}FS.currentPath=lookup.path;},createDefaultDirectories(){FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user");},createDefaultDevices(){// create /dev
FS.mkdir("/dev");// setup /dev/null
FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length});FS.mkdev("/dev/null",FS.makedev(1,3));// setup /dev/tty and /dev/tty1
// stderr needs to print output using err() rather than out()
// so we register a second tty just for it.
TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));// setup /dev/[u]random
// use a buffer to avoid overhead of individual crypto calls per byte
var randomBuffer=new Uint8Array(1024),randomLeft=0;var randomByte=()=>{if(randomLeft===0){randomLeft=randomFill(randomBuffer).byteLength;}return randomBuffer[--randomLeft];};FS.createDevice("/dev","random",randomByte);FS.createDevice("/dev","urandom",randomByte);// we're not going to emulate the actual shm device,
// just create the tmp dirs that reside in it commonly
FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp");},createSpecialDirectories(){// create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
// name of the stream for fd 6 (see test_unistd_ttyname)
FS.mkdir("/proc");var proc_self=FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount(){var node=FS.createNode(proc_self,"fd",16384|511,/* 0777 */73);node.node_ops={lookup(parent,name){var fd=+name;var stream=FS.getStreamChecked(fd);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:()=>stream.path}};ret.parent=ret;// make it look like a simple root node
return ret;}};return node;}},{},"/proc/self/fd");},createStandardStreams(input,output,error){// TODO deprecate the old functionality of a single
// input / output callback and that utilizes FS.createDevice
// and instead require a unique set of stream ops
// by default, we symlink the standard streams to the
// default tty devices. however, if the standard streams
// have been overwritten we create a unique device for
// them instead.
if(input){FS.createDevice("/dev","stdin",input);}else{FS.symlink("/dev/tty","/dev/stdin");}if(output){FS.createDevice("/dev","stdout",null,output);}else{FS.symlink("/dev/tty","/dev/stdout");}if(error){FS.createDevice("/dev","stderr",null,error);}else{FS.symlink("/dev/tty1","/dev/stderr");}// open default streams for the stdin, stdout and stderr devices
var stdin=FS.open("/dev/stdin",0);var stdout=FS.open("/dev/stdout",1);var stderr=FS.open("/dev/stderr",1);},staticInit(){// Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
[44].forEach(code=>{FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>";});FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS,"IDBFS":IDBFS};},init(input,output,error){FS.initialized=true;// Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
input??=Module["stdin"];output??=Module["stdout"];error??=Module["stderr"];FS.createStandardStreams(input,output,error);},quit(){FS.initialized=false;// force-flush all streams, so we get musl std streams printed out
_fflush(0);// close all of our streams
for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue;}FS.close(stream);}},findObject(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null;}return ret.object;},analyzePath(path,dontResolveLastLink){// operate from within the context of the symlink's target
try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path;}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/";}catch(e){ret.error=e.errno;}return ret;},createPath(parent,path,canRead,canWrite){parent=typeof parent=="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current);}catch(e){}// ignore EEXIST
parent=current;}return current;},createFile(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent=="string"?parent:FS.getPath(parent),name);var mode=FS_getMode(canRead,canWrite);return FS.create(path,mode);},createDataFile(parent,name,data,canRead,canWrite,canOwn){var path=name;if(parent){parent=typeof parent=="string"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent;}var mode=FS_getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data=="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr;}// make sure we can write to the file
FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode);}},createDevice(parent,name,input,output){var path=PATH.join2(typeof parent=="string"?parent:FS.getPath(parent),name);var mode=FS_getMode(!!input,!!output);FS.createDevice.major??=64;var dev=FS.makedev(FS.createDevice.major++,0);// Create a fake device that a set of stream ops to emulate
// the old behavior.
FS.registerDevice(dev,{open(stream){stream.seekable=false;},close(stream){// flush any pending line data
if(output?.buffer?.length){output(10);}},read(stream,buffer,offset,length,pos){/* ignored */var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input();}catch(e){throw new FS.ErrnoError(29);}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6);}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result;}if(bytesRead){stream.node.timestamp=Date.now();}return bytesRead;},write(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i]);}catch(e){throw new FS.ErrnoError(29);}}if(length){stream.node.timestamp=Date.now();}return i;}});return FS.mkdev(path,mode,dev);},forceLoadFile(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");}else{// Command-line.
try{obj.contents=readBinary(obj.url);obj.usedBytes=obj.contents.length;}catch(e){throw new FS.ErrnoError(29);}}},createLazyFile(parent,name,url,canRead,canWrite){// Lazy chunked Uint8Array (implements get and length from Uint8Array).
// Actual getting is abstracted away for eventual reuse.
class LazyUint8Array{constructor(){this.lengthKnown=false;this.chunks=[];}// Loaded chunks. Index is the chunk number
get(idx){if(idx>this.length-1||idx<0){return undefined;}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset];}setDataGetter(getter){this.getter=getter;}cacheLength(){// Find length
var xhr=new XMLHttpRequest();xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;// Chunk size in bytes
if(!hasByteServing)chunkSize=datalength;// Function to get a range from the remote URL.
var doXHR=(from,to)=>{if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");// TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
var xhr=new XMLHttpRequest();xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);// Some hints to the browser that we want binary data.
xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined");}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(/** @type{Array<number>} */xhr.response||[]);}return intArrayFromString(xhr.responseText||"",true);};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;// including this byte
end=Math.min(end,datalength-1);// if datalength-1 is selected, this is the last block
if(typeof lazyArray.chunks[chunkNum]=="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end);}if(typeof lazyArray.chunks[chunkNum]=="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum];});if(usesGzip||!datalength){// if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
chunkSize=datalength=1;// this will force getter(0)/doXHR do download the whole file
datalength=this.getter(0).length;chunkSize=datalength;out("LazyFiles on gzip forces download of the whole file when length is accessed");}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true;}get length(){if(!this.lengthKnown){this.cacheLength();}return this._length;}get chunkSize(){if(!this.lengthKnown){this.cacheLength();}return this._chunkSize;}}if(typeof XMLHttpRequest!="undefined"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array();var properties={isDevice:false,contents:lazyArray};}else{var properties={isDevice:false,url};}var node=FS.createFile(parent,name,properties,canRead,canWrite);// This is a total hack, but I want to get this lazy file code out of the
// core of MEMFS. If we want to keep this lazy file concept I feel it should
// be its own thin LAZYFS proxying calls to MEMFS.
if(properties.contents){node.contents=properties.contents;}else if(properties.url){node.contents=null;node.url=properties.url;}// Add a function that defers querying the file size until it is asked the first time.
Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length;}}});// override each stream op with one that tries to force load the lazy file first
var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=(...args)=>{FS.forceLoadFile(node);return fn(...args);};});function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){// normal array
for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i];}}else{for(var i=0;i<size;i++){// LazyUint8Array from sync binary XHR
buffer[offset+i]=contents.get(position+i);}}return size;}// use a custom read function
stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position);};// use a custom mmap function
stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48);}writeChunks(stream,HEAP8,ptr,length,position);return{ptr,allocated:true};};node.stream_ops=stream_ops;return node;}};var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path;}// relative path
var dir;if(dirfd===-100){dir=FS.cwd();}else{var dirstream=SYSCALLS.getStreamFromFD(dirfd);dir=dirstream.path;}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44);}return dir;}return PATH.join2(dir,path);},doStat(func,path,buf){var stat=func(path);HEAP32[buf>>>2>>>0]=stat.dev;HEAP32[buf+4>>>2>>>0]=stat.mode;HEAPU32[buf+8>>>2>>>0]=stat.nlink;HEAP32[buf+12>>>2>>>0]=stat.uid;HEAP32[buf+16>>>2>>>0]=stat.gid;HEAP32[buf+20>>>2>>>0]=stat.rdev;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+24>>>2>>>0]=tempI64[0],HEAP32[buf+28>>>2>>>0]=tempI64[1];HEAP32[buf+32>>>2>>>0]=4096;HEAP32[buf+36>>>2>>>0]=stat.blocks;var atime=stat.atime.getTime();var mtime=stat.mtime.getTime();var ctime=stat.ctime.getTime();tempI64=[Math.floor(atime/1e3)>>>0,(tempDouble=Math.floor(atime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>>2>>>0]=tempI64[0],HEAP32[buf+44>>>2>>>0]=tempI64[1];HEAPU32[buf+48>>>2>>>0]=atime%1e3*1e3*1e3;tempI64=[Math.floor(mtime/1e3)>>>0,(tempDouble=Math.floor(mtime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+56>>>2>>>0]=tempI64[0],HEAP32[buf+60>>>2>>>0]=tempI64[1];HEAPU32[buf+64>>>2>>>0]=mtime%1e3*1e3*1e3;tempI64=[Math.floor(ctime/1e3)>>>0,(tempDouble=Math.floor(ctime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+72>>>2>>>0]=tempI64[0],HEAP32[buf+76>>>2>>>0]=tempI64[1];HEAPU32[buf+80>>>2>>>0]=ctime%1e3*1e3*1e3;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+88>>>2>>>0]=tempI64[0],HEAP32[buf+92>>>2>>>0]=tempI64[1];return 0;},doMsync(addr,stream,len,flags,offset){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43);}if(flags&2){// MAP_PRIVATE calls need not to be synced back to underlying fs
return 0;}var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags);},getStreamFromFD(fd){var stream=FS.getStreamChecked(fd);return stream;},varargs:undefined,getStr(ptr){var ret=UTF8ToString(ptr);return ret;}};function ___syscall__newselect(nfds,readfds,writefds,exceptfds,timeout){readfds>>>=0;writefds>>>=0;exceptfds>>>=0;timeout>>>=0;try{// readfds are supported,
// writefds checks socket open status
// exceptfds are supported, although on web, such exceptional conditions never arise in web sockets
//                          and so the exceptfds list will always return empty.
// timeout is supported, although on SOCKFS and PIPEFS these are ignored and always treated as 0 - fully async
var total=0;var srcReadLow=readfds?HEAP32[readfds>>>2>>>0]:0,srcReadHigh=readfds?HEAP32[readfds+4>>>2>>>0]:0;var srcWriteLow=writefds?HEAP32[writefds>>>2>>>0]:0,srcWriteHigh=writefds?HEAP32[writefds+4>>>2>>>0]:0;var srcExceptLow=exceptfds?HEAP32[exceptfds>>>2>>>0]:0,srcExceptHigh=exceptfds?HEAP32[exceptfds+4>>>2>>>0]:0;var dstReadLow=0,dstReadHigh=0;var dstWriteLow=0,dstWriteHigh=0;var dstExceptLow=0,dstExceptHigh=0;var allLow=(readfds?HEAP32[readfds>>>2>>>0]:0)|(writefds?HEAP32[writefds>>>2>>>0]:0)|(exceptfds?HEAP32[exceptfds>>>2>>>0]:0);var allHigh=(readfds?HEAP32[readfds+4>>>2>>>0]:0)|(writefds?HEAP32[writefds+4>>>2>>>0]:0)|(exceptfds?HEAP32[exceptfds+4>>>2>>>0]:0);var check=function(fd,low,high,val){return fd<32?low&val:high&val;};for(var fd=0;fd<nfds;fd++){var mask=1<<fd%32;if(!check(fd,allLow,allHigh,mask)){continue;}// index isn't in the set
var stream=SYSCALLS.getStreamFromFD(fd);var flags=SYSCALLS.DEFAULT_POLLMASK;if(stream.stream_ops.poll){var timeoutInMillis=-1;if(timeout){// select(2) is declared to accept "struct timeval { time_t tv_sec; suseconds_t tv_usec; }".
// However, musl passes the two values to the syscall as an array of long values.
// Note that sizeof(time_t) != sizeof(long) in wasm32. The former is 8, while the latter is 4.
// This means using "C_STRUCTS.timeval.tv_usec" leads to a wrong offset.
// So, instead, we use POINTER_SIZE.
var tv_sec=readfds?HEAP32[timeout>>>2>>>0]:0,tv_usec=readfds?HEAP32[timeout+4>>>2>>>0]:0;timeoutInMillis=(tv_sec+tv_usec/1e6)*1e3;}flags=stream.stream_ops.poll(stream,timeoutInMillis);}if(flags&1&&check(fd,srcReadLow,srcReadHigh,mask)){fd<32?dstReadLow=dstReadLow|mask:dstReadHigh=dstReadHigh|mask;total++;}if(flags&4&&check(fd,srcWriteLow,srcWriteHigh,mask)){fd<32?dstWriteLow=dstWriteLow|mask:dstWriteHigh=dstWriteHigh|mask;total++;}if(flags&2&&check(fd,srcExceptLow,srcExceptHigh,mask)){fd<32?dstExceptLow=dstExceptLow|mask:dstExceptHigh=dstExceptHigh|mask;total++;}}if(readfds){HEAP32[readfds>>>2>>>0]=dstReadLow;HEAP32[readfds+4>>>2>>>0]=dstReadHigh;}if(writefds){HEAP32[writefds>>>2>>>0]=dstWriteLow;HEAP32[writefds+4>>>2>>>0]=dstWriteHigh;}if(exceptfds){HEAP32[exceptfds>>>2>>>0]=dstExceptLow;HEAP32[exceptfds+4>>>2>>>0]=dstExceptHigh;}return total;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall__newselect.sig="iipppp";var SOCKFS={mount(mount){// If Module['websocket'] has already been defined (e.g. for configuring
// the subprotocol/url) use that, if not initialise it to a new object.
Module["websocket"]=Module["websocket"]&&"object"===typeof Module["websocket"]?Module["websocket"]:{};// Add the Event registration mechanism to the exported websocket configuration
// object so we can register network callbacks from native JavaScript too.
// For more documentation see system/include/emscripten/emscripten.h
Module["websocket"]._callbacks={};Module["websocket"]["on"]=/** @this{Object} */function(event,callback){if("function"===typeof callback){this._callbacks[event]=callback;}return this;};Module["websocket"].emit=/** @this{Object} */function(event,param){if("function"===typeof this._callbacks[event]){this._callbacks[event].call(this,param);}};// If debug is enabled register simple default logging callbacks for each Event.
return FS.createNode(null,"/",16384|511,/* 0777 */0);},createSocket(family,type,protocol){type&=~526336;// Some applications may pass it; it makes no sense for a single process.
var streaming=type==1;if(streaming&&protocol&&protocol!=6){throw new FS.ErrnoError(66);}// create our internal socket structure
var sock={family,type,protocol,server:null,error:null,// Used in getsockopt for SOL_SOCKET/SO_ERROR test
peers:{},pending:[],recv_queue:[],sock_ops:SOCKFS.websocket_sock_ops};// create the filesystem node to store the socket structure
var name=SOCKFS.nextname();var node=FS.createNode(SOCKFS.root,name,49152,0);node.sock=sock;// and the wrapping stream that enables library functions such
// as read and write to indirectly interact with the socket
var stream=FS.createStream({path:name,node,flags:2,seekable:false,stream_ops:SOCKFS.stream_ops});// map the new stream to the socket structure (sockets have a 1:1
// relationship with a stream)
sock.stream=stream;return sock;},getSocket(fd){var stream=FS.getStream(fd);if(!stream||!FS.isSocket(stream.node.mode)){return null;}return stream.node.sock;},stream_ops:{poll(stream){var sock=stream.node.sock;return sock.sock_ops.poll(sock);},ioctl(stream,request,varargs){var sock=stream.node.sock;return sock.sock_ops.ioctl(sock,request,varargs);},read(stream,buffer,offset,length,position){/* ignored */var sock=stream.node.sock;var msg=sock.sock_ops.recvmsg(sock,length);if(!msg){// socket is closed
return 0;}buffer.set(msg.buffer,offset);return msg.buffer.length;},write(stream,buffer,offset,length,position){/* ignored */var sock=stream.node.sock;return sock.sock_ops.sendmsg(sock,buffer,offset,length);},close(stream){var sock=stream.node.sock;sock.sock_ops.close(sock);}},nextname(){if(!SOCKFS.nextname.current){SOCKFS.nextname.current=0;}return"socket["+SOCKFS.nextname.current++ +"]";},websocket_sock_ops:{createPeer(sock,addr,port){var ws;if(typeof addr=="object"){ws=addr;addr=null;port=null;}if(ws){// for sockets that've already connected (e.g. we're the server)
// we can inspect the _socket property for the address
if(ws._socket){addr=ws._socket.remoteAddress;port=ws._socket.remotePort;}else// if we're just now initializing a connection to the remote,
// inspect the url property
{var result=/ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);if(!result){throw new Error("WebSocket URL must be in the format ws(s)://address:port");}addr=result[1];port=parseInt(result[2],10);}}else{// create the actual websocket object and connect
try{// runtimeConfig gets set to true if WebSocket runtime configuration is available.
var runtimeConfig=Module["websocket"]&&"object"===typeof Module["websocket"];// The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
// comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
var url="ws:#".replace("#","//");if(runtimeConfig){if("string"===typeof Module["websocket"]["url"]){url=Module["websocket"]["url"];}}if(url==="ws://"||url==="wss://"){// Is the supplied URL config just a prefix, if so complete it.
var parts=addr.split("/");url=url+parts[0]+":"+port+"/"+parts.slice(1).join("/");}// Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
var subProtocols="binary";// The default value is 'binary'
if(runtimeConfig){if("string"===typeof Module["websocket"]["subprotocol"]){subProtocols=Module["websocket"]["subprotocol"];}}// The default WebSocket options
var opts=undefined;if(subProtocols!=="null"){// The regex trims the string (removes spaces at the beginning and end, then splits the string by
// <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
subProtocols=subProtocols.replace(/^ +| +$/g,"").split(/ *, */);opts=subProtocols;}// some webservers (azure) does not support subprotocol header
if(runtimeConfig&&null===Module["websocket"]["subprotocol"]){subProtocols="null";opts=undefined;}// If node we use the ws library.
var WebSocketConstructor;{WebSocketConstructor=WebSocket;}ws=new WebSocketConstructor(url,opts);ws.binaryType="arraybuffer";}catch(e){throw new FS.ErrnoError(23);}}var peer={addr,port,socket:ws,dgram_send_queue:[]};SOCKFS.websocket_sock_ops.addPeer(sock,peer);SOCKFS.websocket_sock_ops.handlePeerEvents(sock,peer);// if this is a bound dgram socket, send the port number first to allow
// us to override the ephemeral port reported to us by remotePort on the
// remote end.
if(sock.type===2&&typeof sock.sport!="undefined"){peer.dgram_send_queue.push(new Uint8Array([255,255,255,255,"p".charCodeAt(0),"o".charCodeAt(0),"r".charCodeAt(0),"t".charCodeAt(0),(sock.sport&65280)>>8,sock.sport&255]));}return peer;},getPeer(sock,addr,port){return sock.peers[addr+":"+port];},addPeer(sock,peer){sock.peers[peer.addr+":"+peer.port]=peer;},removePeer(sock,peer){delete sock.peers[peer.addr+":"+peer.port];},handlePeerEvents(sock,peer){var first=true;var handleOpen=function(){Module["websocket"].emit("open",sock.stream.fd);try{var queued=peer.dgram_send_queue.shift();while(queued){peer.socket.send(queued);queued=peer.dgram_send_queue.shift();}}catch(e){// not much we can do here in the way of proper error handling as we've already
// lied and said this data was sent. shut it down.
peer.socket.close();}};function handleMessage(data){if(typeof data=="string"){var encoder=new TextEncoder();// should be utf-8
data=encoder.encode(data);}else// make a typed array from the string
{assert(data.byteLength!==undefined);// must receive an ArrayBuffer
if(data.byteLength==0){// An empty ArrayBuffer will emit a pseudo disconnect event
// as recv/recvmsg will return zero which indicates that a socket
// has performed a shutdown although the connection has not been disconnected yet.
return;}data=new Uint8Array(data);}// if this is the port message, override the peer's port with it
var wasfirst=first;first=false;if(wasfirst&&data.length===10&&data[0]===255&&data[1]===255&&data[2]===255&&data[3]===255&&data[4]==="p".charCodeAt(0)&&data[5]==="o".charCodeAt(0)&&data[6]==="r".charCodeAt(0)&&data[7]==="t".charCodeAt(0)){// update the peer's port and it's key in the peer map
var newport=data[8]<<8|data[9];SOCKFS.websocket_sock_ops.removePeer(sock,peer);peer.port=newport;SOCKFS.websocket_sock_ops.addPeer(sock,peer);return;}sock.recv_queue.push({addr:peer.addr,port:peer.port,data});Module["websocket"].emit("message",sock.stream.fd);}if(ENVIRONMENT_IS_NODE){peer.socket.on("open",handleOpen);peer.socket.on("message",function(data,isBinary){if(!isBinary){return;}handleMessage(new Uint8Array(data).buffer);});// copy from node Buffer -> ArrayBuffer
peer.socket.on("close",function(){Module["websocket"].emit("close",sock.stream.fd);});peer.socket.on("error",function(error){// Although the ws library may pass errors that may be more descriptive than
// ECONNREFUSED they are not necessarily the expected error code e.g.
// ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
// is still probably the most useful thing to do.
sock.error=14;// Used in getsockopt for SOL_SOCKET/SO_ERROR test.
Module["websocket"].emit("error",[sock.stream.fd,sock.error,"ECONNREFUSED: Connection refused"]);});}else{peer.socket.onopen=handleOpen;peer.socket.onclose=function(){Module["websocket"].emit("close",sock.stream.fd);};peer.socket.onmessage=function peer_socket_onmessage(event){handleMessage(event.data);};peer.socket.onerror=function(error){// The WebSocket spec only allows a 'simple event' to be thrown on error,
// so we only really know as much as ECONNREFUSED.
sock.error=14;// Used in getsockopt for SOL_SOCKET/SO_ERROR test.
Module["websocket"].emit("error",[sock.stream.fd,sock.error,"ECONNREFUSED: Connection refused"]);};}},poll(sock){if(sock.type===1&&sock.server){// listen sockets should only say they're available for reading
// if there are pending clients.
return sock.pending.length?64|1:0;}var mask=0;var dest=sock.type===1?// we only care about the socket state for connection-based sockets
SOCKFS.websocket_sock_ops.getPeer(sock,sock.daddr,sock.dport):null;if(sock.recv_queue.length||!dest||// connection-less sockets are always ready to read
dest&&dest.socket.readyState===dest.socket.CLOSING||dest&&dest.socket.readyState===dest.socket.CLOSED){// let recv return 0 once closed
mask|=64|1;}if(!dest||// connection-less sockets are always ready to write
dest&&dest.socket.readyState===dest.socket.OPEN){mask|=4;}if(dest&&dest.socket.readyState===dest.socket.CLOSING||dest&&dest.socket.readyState===dest.socket.CLOSED){mask|=16;}return mask;},ioctl(sock,request,arg){switch(request){case 21531:var bytes=0;if(sock.recv_queue.length){bytes=sock.recv_queue[0].data.length;}HEAP32[arg>>>2>>>0]=bytes;return 0;default:return 28;}},close(sock){// if we've spawned a listen server, close it
if(sock.server){try{sock.server.close();}catch(e){}sock.server=null;}// close any peer connections
var peers=Object.keys(sock.peers);for(var i=0;i<peers.length;i++){var peer=sock.peers[peers[i]];try{peer.socket.close();}catch(e){}SOCKFS.websocket_sock_ops.removePeer(sock,peer);}return 0;},bind(sock,addr,port){if(typeof sock.saddr!="undefined"||typeof sock.sport!="undefined"){throw new FS.ErrnoError(28);}// already bound
sock.saddr=addr;sock.sport=port;// in order to emulate dgram sockets, we need to launch a listen server when
// binding on a connection-less socket
// note: this is only required on the server side
if(sock.type===2){// close the existing server if it exists
if(sock.server){sock.server.close();sock.server=null;}// swallow error operation not supported error that occurs when binding in the
// browser where this isn't supported
try{sock.sock_ops.listen(sock,0);}catch(e){if(!(e.name==="ErrnoError"))throw e;if(e.errno!==138)throw e;}}},connect(sock,addr,port){if(sock.server){throw new FS.ErrnoError(138);}// TODO autobind
// if (!sock.addr && sock.type == 2) {
// }
// early out if we're already connected / in the middle of connecting
if(typeof sock.daddr!="undefined"&&typeof sock.dport!="undefined"){var dest=SOCKFS.websocket_sock_ops.getPeer(sock,sock.daddr,sock.dport);if(dest){if(dest.socket.readyState===dest.socket.CONNECTING){throw new FS.ErrnoError(7);}else{throw new FS.ErrnoError(30);}}}// add the socket to our peer list and set our
// destination address / port to match
var peer=SOCKFS.websocket_sock_ops.createPeer(sock,addr,port);sock.daddr=peer.addr;sock.dport=peer.port;// always "fail" in non-blocking mode
throw new FS.ErrnoError(26);},listen(sock,backlog){if(!ENVIRONMENT_IS_NODE){throw new FS.ErrnoError(138);}},accept(listensock){if(!listensock.server||!listensock.pending.length){throw new FS.ErrnoError(28);}var newsock=listensock.pending.shift();newsock.stream.flags=listensock.stream.flags;return newsock;},getname(sock,peer){var addr,port;if(peer){if(sock.daddr===undefined||sock.dport===undefined){throw new FS.ErrnoError(53);}addr=sock.daddr;port=sock.dport;}else{// TODO saddr and sport will be set for bind()'d UDP sockets, but what
// should we be returning for TCP sockets that've been connect()'d?
addr=sock.saddr||0;port=sock.sport||0;}return{addr,port};},sendmsg(sock,buffer,offset,length,addr,port){if(sock.type===2){// connection-less sockets will honor the message address,
// and otherwise fall back to the bound destination address
if(addr===undefined||port===undefined){addr=sock.daddr;port=sock.dport;}// if there was no address to fall back to, error out
if(addr===undefined||port===undefined){throw new FS.ErrnoError(17);}}else{// connection-based sockets will only use the bound
addr=sock.daddr;port=sock.dport;}// find the peer for the destination address
var dest=SOCKFS.websocket_sock_ops.getPeer(sock,addr,port);// early out if not connected with a connection-based socket
if(sock.type===1){if(!dest||dest.socket.readyState===dest.socket.CLOSING||dest.socket.readyState===dest.socket.CLOSED){throw new FS.ErrnoError(53);}else if(dest.socket.readyState===dest.socket.CONNECTING){throw new FS.ErrnoError(6);}}// create a copy of the incoming data to send, as the WebSocket API
// doesn't work entirely with an ArrayBufferView, it'll just send
// the entire underlying buffer
if(ArrayBuffer.isView(buffer)){offset+=buffer.byteOffset;buffer=buffer.buffer;}var data;data=buffer.slice(offset,offset+length);// if we're emulating a connection-less dgram socket and don't have
// a cached connection, queue the buffer to send upon connect and
// lie, saying the data was sent now.
if(sock.type===2){if(!dest||dest.socket.readyState!==dest.socket.OPEN){// if we're not connected, open a new connection
if(!dest||dest.socket.readyState===dest.socket.CLOSING||dest.socket.readyState===dest.socket.CLOSED){dest=SOCKFS.websocket_sock_ops.createPeer(sock,addr,port);}dest.dgram_send_queue.push(data);return length;}}try{// send the actual data
dest.socket.send(data);return length;}catch(e){throw new FS.ErrnoError(28);}},recvmsg(sock,length){// http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
if(sock.type===1&&sock.server){// tcp servers should not be recv()'ing on the listen socket
throw new FS.ErrnoError(53);}var queued=sock.recv_queue.shift();if(!queued){if(sock.type===1){var dest=SOCKFS.websocket_sock_ops.getPeer(sock,sock.daddr,sock.dport);if(!dest){// if we have a destination address but are not connected, error out
throw new FS.ErrnoError(53);}if(dest.socket.readyState===dest.socket.CLOSING||dest.socket.readyState===dest.socket.CLOSED){// return null if the socket has closed
return null;}// else, our socket is in a valid state but truly has nothing available
throw new FS.ErrnoError(6);}throw new FS.ErrnoError(6);}// queued.data will be an ArrayBuffer if it's unadulterated, but if it's
// requeued TCP data it'll be an ArrayBufferView
var queuedLength=queued.data.byteLength||queued.data.length;var queuedOffset=queued.data.byteOffset||0;var queuedBuffer=queued.data.buffer||queued.data;var bytesRead=Math.min(length,queuedLength);var res={buffer:new Uint8Array(queuedBuffer,queuedOffset,bytesRead),addr:queued.addr,port:queued.port};// push back any unread data for TCP connections
if(sock.type===1&&bytesRead<queuedLength){var bytesRemaining=queuedLength-bytesRead;queued.data=new Uint8Array(queuedBuffer,queuedOffset+bytesRead,bytesRemaining);sock.recv_queue.unshift(queued);}return res;}}};var getSocketFromFD=fd=>{var socket=SOCKFS.getSocket(fd);if(!socket)throw new FS.ErrnoError(8);return socket;};var Sockets={BUFFER_SIZE:10240,MAX_BUFFER_SIZE:10485760,nextFd:1,fds:{},nextport:1,maxport:65535,peer:null,connections:{},portmap:{},localAddr:4261412874,addrPool:[33554442,50331658,67108874,83886090,100663306,117440522,134217738,150994954,167772170,184549386,201326602,218103818,234881034]};var inetPton4=str=>{var b=str.split(".");for(var i=0;i<4;i++){var tmp=Number(b[i]);if(isNaN(tmp))return null;b[i]=tmp;}return(b[0]|b[1]<<8|b[2]<<16|b[3]<<24)>>>0;};/** @suppress {checkTypes} */var jstoi_q=str=>parseInt(str);var inetPton6=str=>{var words;var w,offset,z,i;/* http://home.deds.nl/~aeron/regex/ */var valid6regx=/^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;var parts=[];if(!valid6regx.test(str)){return null;}if(str==="::"){return[0,0,0,0,0,0,0,0];}// Z placeholder to keep track of zeros when splitting the string on ":"
if(str.startsWith("::")){str=str.replace("::","Z:");}else// leading zeros case
{str=str.replace("::",":Z:");}if(str.indexOf(".")>0){// parse IPv4 embedded stress
str=str.replace(new RegExp("[.]","g"),":");words=str.split(":");words[words.length-4]=jstoi_q(words[words.length-4])+jstoi_q(words[words.length-3])*256;words[words.length-3]=jstoi_q(words[words.length-2])+jstoi_q(words[words.length-1])*256;words=words.slice(0,words.length-2);}else{words=str.split(":");}offset=0;z=0;for(w=0;w<words.length;w++){if(typeof words[w]=="string"){if(words[w]==="Z"){// compressed zeros - write appropriate number of zero words
for(z=0;z<8-words.length+1;z++){parts[w+z]=0;}offset=z-1;}else{// parse hex to field to 16-bit value and write it in network byte-order
parts[w+offset]=_htons(parseInt(words[w],16));}}else{// parsed IPv4 words
parts[w+offset]=words[w];}}return[parts[1]<<16|parts[0],parts[3]<<16|parts[2],parts[5]<<16|parts[4],parts[7]<<16|parts[6]];};/** @param {number=} addrlen */var writeSockaddr=(sa,family,addr,port,addrlen)=>{switch(family){case 2:addr=inetPton4(addr);zeroMemory(sa,16);if(addrlen){HEAP32[addrlen>>>2>>>0]=16;}HEAP16[sa>>>1>>>0]=family;HEAP32[sa+4>>>2>>>0]=addr;HEAP16[sa+2>>>1>>>0]=_htons(port);break;case 10:addr=inetPton6(addr);zeroMemory(sa,28);if(addrlen){HEAP32[addrlen>>>2>>>0]=28;}HEAP32[sa>>>2>>>0]=family;HEAP32[sa+8>>>2>>>0]=addr[0];HEAP32[sa+12>>>2>>>0]=addr[1];HEAP32[sa+16>>>2>>>0]=addr[2];HEAP32[sa+20>>>2>>>0]=addr[3];HEAP16[sa+2>>>1>>>0]=_htons(port);break;default:return 5;}return 0;};var DNS={address_map:{id:1,addrs:{},names:{}},lookup_name(name){// If the name is already a valid ipv4 / ipv6 address, don't generate a fake one.
var res=inetPton4(name);if(res!==null){return name;}res=inetPton6(name);if(res!==null){return name;}// See if this name is already mapped.
var addr;if(DNS.address_map.addrs[name]){addr=DNS.address_map.addrs[name];}else{var id=DNS.address_map.id++;assert(id<65535,"exceeded max address mappings of 65535");addr="172.29."+(id&255)+"."+(id&65280);DNS.address_map.names[addr]=name;DNS.address_map.addrs[name]=addr;}return addr;},lookup_addr(addr){if(DNS.address_map.names[addr]){return DNS.address_map.names[addr];}return null;}};function ___syscall_accept4(fd,addr,addrlen,flags,d1,d2){addr>>>=0;addrlen>>>=0;try{var sock=getSocketFromFD(fd);var newsock=sock.sock_ops.accept(sock);if(addr){var errno=writeSockaddr(addr,newsock.family,DNS.lookup_name(newsock.daddr),newsock.dport,addrlen);}return newsock.stream.fd;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_accept4.sig="iippiii";var inetNtop4=addr=>(addr&255)+"."+(addr>>8&255)+"."+(addr>>16&255)+"."+(addr>>24&255);var inetNtop6=ints=>{//  ref:  http://www.ietf.org/rfc/rfc2373.txt - section 2.5.4
//  Format for IPv4 compatible and mapped  128-bit IPv6 Addresses
//  128-bits are split into eight 16-bit words
//  stored in network byte order (big-endian)
//  |                80 bits               | 16 |      32 bits        |
//  +-----------------------------------------------------------------+
//  |               10 bytes               |  2 |      4 bytes        |
//  +--------------------------------------+--------------------------+
//  +               5 words                |  1 |      2 words        |
//  +--------------------------------------+--------------------------+
//  |0000..............................0000|0000|    IPv4 ADDRESS     | (compatible)
//  +--------------------------------------+----+---------------------+
//  |0000..............................0000|FFFF|    IPv4 ADDRESS     | (mapped)
//  +--------------------------------------+----+---------------------+
var str="";var word=0;var longest=0;var lastzero=0;var zstart=0;var len=0;var i=0;var parts=[ints[0]&65535,ints[0]>>16,ints[1]&65535,ints[1]>>16,ints[2]&65535,ints[2]>>16,ints[3]&65535,ints[3]>>16];// Handle IPv4-compatible, IPv4-mapped, loopback and any/unspecified addresses
var hasipv4=true;var v4part="";// check if the 10 high-order bytes are all zeros (first 5 words)
for(i=0;i<5;i++){if(parts[i]!==0){hasipv4=false;break;}}if(hasipv4){// low-order 32-bits store an IPv4 address (bytes 13 to 16) (last 2 words)
v4part=inetNtop4(parts[6]|parts[7]<<16);// IPv4-mapped IPv6 address if 16-bit value (bytes 11 and 12) == 0xFFFF (6th word)
if(parts[5]===-1){str="::ffff:";str+=v4part;return str;}// IPv4-compatible IPv6 address if 16-bit value (bytes 11 and 12) == 0x0000 (6th word)
if(parts[5]===0){str="::";//special case IPv6 addresses
if(v4part==="0.0.0.0")v4part="";// any/unspecified address
if(v4part==="0.0.0.1")v4part="1";// loopback address
str+=v4part;return str;}}// Handle all other IPv6 addresses
// first run to find the longest contiguous zero words
for(word=0;word<8;word++){if(parts[word]===0){if(word-lastzero>1){len=0;}lastzero=word;len++;}if(len>longest){longest=len;zstart=word-longest+1;}}for(word=0;word<8;word++){if(longest>1){// compress contiguous zeros - to produce "::"
if(parts[word]===0&&word>=zstart&&word<zstart+longest){if(word===zstart){str+=":";if(zstart===0)str+=":";}//leading zeros case
continue;}}// converts 16-bit words from big-endian to little-endian before converting to hex string
str+=Number(_ntohs(parts[word]&65535)).toString(16);str+=word<7?":":"";}return str;};var readSockaddr=(sa,salen)=>{// family / port offsets are common to both sockaddr_in and sockaddr_in6
var family=HEAP16[sa>>>1>>>0];var port=_ntohs(HEAPU16[sa+2>>>1>>>0]);var addr;switch(family){case 2:if(salen!==16){return{errno:28};}addr=HEAP32[sa+4>>>2>>>0];addr=inetNtop4(addr);break;case 10:if(salen!==28){return{errno:28};}addr=[HEAP32[sa+8>>>2>>>0],HEAP32[sa+12>>>2>>>0],HEAP32[sa+16>>>2>>>0],HEAP32[sa+20>>>2>>>0]];addr=inetNtop6(addr);break;default:return{errno:5};}return{family,addr,port};};/** @param {boolean=} allowNull */var getSocketAddress=(addrp,addrlen,allowNull)=>{if(allowNull&&addrp===0)return null;var info=readSockaddr(addrp,addrlen);if(info.errno)throw new FS.ErrnoError(info.errno);info.addr=DNS.lookup_addr(info.addr)||info.addr;return info;};function ___syscall_bind(fd,addr,addrlen,d1,d2,d3){addr>>>=0;addrlen>>>=0;try{var sock=getSocketFromFD(fd);var info=getSocketAddress(addr,addrlen);sock.sock_ops.bind(sock,info.addr,info.port);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_bind.sig="iippiii";function ___syscall_chdir(path){path>>>=0;try{path=SYSCALLS.getStr(path);FS.chdir(path);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_chdir.sig="ip";function ___syscall_chmod(path,mode){path>>>=0;try{path=SYSCALLS.getStr(path);FS.chmod(path,mode);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_chmod.sig="ipi";function ___syscall_connect(fd,addr,addrlen,d1,d2,d3){addr>>>=0;addrlen>>>=0;try{var sock=getSocketFromFD(fd);var info=getSocketAddress(addr,addrlen);sock.sock_ops.connect(sock,info.addr,info.port);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_connect.sig="iippiii";function ___syscall_dup(fd){try{var old=SYSCALLS.getStreamFromFD(fd);return FS.dupStream(old).fd;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_dup.sig="ii";function ___syscall_dup3(fd,newfd,flags){try{var old=SYSCALLS.getStreamFromFD(fd);if(old.fd===newfd)return-28;// Check newfd is within range of valid open file descriptors.
if(newfd<0||newfd>=FS.MAX_OPEN_FDS)return-8;var existing=FS.getStream(newfd);if(existing)FS.close(existing);return FS.dupStream(old,newfd).fd;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_dup3.sig="iiii";function ___syscall_faccessat(dirfd,path,amode,flags){path>>>=0;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(amode&~7){// need a valid mode
return-28;}var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node){return-44;}var perms="";if(amode&4)perms+="r";if(amode&2)perms+="w";if(amode&1)perms+="x";if(perms&&/* otherwise, they've just passed F_OK */FS.nodePermissions(node,perms)){return-2;}return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_faccessat.sig="iipii";var ___syscall_fadvise64=(fd,offset,len,advice)=>0;// your advice is important to us (but we can't use it)
___syscall_fadvise64.sig="iiiiiii";function ___syscall_fallocate(fd,mode,offset_low,offset_high,len_low,len_high){var offset=convertI32PairToI53Checked(offset_low,offset_high);var len=convertI32PairToI53Checked(len_low,len_high);try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.allocate(stream,offset,len);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_fallocate.sig="iiiiiii";function ___syscall_fchdir(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.chdir(stream.path);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_fchdir.sig="ii";function ___syscall_fchmod(fd,mode){try{FS.fchmod(fd,mode);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_fchmod.sig="iii";function ___syscall_fchmodat2(dirfd,path,mode,flags){path>>>=0;try{var nofollow=flags&256;path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);FS.chmod(path,mode,nofollow);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_fchmodat2.sig="iipii";function ___syscall_fchown32(fd,owner,group){try{FS.fchown(fd,owner,group);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_fchown32.sig="iiii";function ___syscall_fchownat(dirfd,path,owner,group,flags){path>>>=0;try{path=SYSCALLS.getStr(path);var nofollow=flags&256;flags=flags&~256;path=SYSCALLS.calculateAt(dirfd,path);(nofollow?FS.lchown:FS.chown)(path,owner,group);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_fchownat.sig="iipiii";/** @suppress {duplicate } */function syscallGetVarargI(){// the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.
var ret=HEAP32[+SYSCALLS.varargs>>>2>>>0];SYSCALLS.varargs+=4;return ret;}var syscallGetVarargP=syscallGetVarargI;function ___syscall_fcntl64(fd,cmd,varargs){varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=syscallGetVarargI();if(arg<0){return-28;}while(FS.streams[arg]){arg++;}var newStream;newStream=FS.dupStream(stream,arg);return newStream.fd;}case 1:case 2:return 0;// FD_CLOEXEC makes no sense for a single process.
case 3:return stream.flags;case 4:{var arg=syscallGetVarargI();stream.flags|=arg;return 0;}case 12:{var arg=syscallGetVarargP();var offset=0;// We're always unlocked.
HEAP16[arg+offset>>>1>>>0]=2;return 0;}case 13:case 14:return 0;}// Pretend that the locking is successful.
return-28;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_fcntl64.sig="iiip";function ___syscall_fdatasync(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);return 0;}// we can't do anything synchronously; the in-memory FS is already synced to
catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_fdatasync.sig="ii";function ___syscall_fstat64(fd,buf){buf>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);return SYSCALLS.doStat(FS.stat,stream.path,buf);}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_fstat64.sig="iip";function ___syscall_statfs64(path,size,buf){path>>>=0;size>>>=0;buf>>>=0;try{path=SYSCALLS.getStr(path);// NOTE: None of the constants here are true. We're just returning safe and
//       sane values.
HEAP32[buf+4>>>2>>>0]=4096;HEAP32[buf+40>>>2>>>0]=4096;HEAP32[buf+8>>>2>>>0]=1e6;HEAP32[buf+12>>>2>>>0]=5e5;HEAP32[buf+16>>>2>>>0]=5e5;HEAP32[buf+20>>>2>>>0]=FS.nextInode;HEAP32[buf+24>>>2>>>0]=1e6;HEAP32[buf+28>>>2>>>0]=42;HEAP32[buf+44>>>2>>>0]=2;// ST_NOSUID
HEAP32[buf+36>>>2>>>0]=255;return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_statfs64.sig="ippp";function ___syscall_fstatfs64(fd,size,buf){size>>>=0;buf>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);return ___syscall_statfs64(0,size,buf);}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_fstatfs64.sig="iipp";function ___syscall_ftruncate64(fd,length_low,length_high){var length=convertI32PairToI53Checked(length_low,length_high);try{if(isNaN(length))return 61;FS.ftruncate(fd,length);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_ftruncate64.sig="iiii";var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);function ___syscall_getcwd(buf,size){buf>>>=0;size>>>=0;try{if(size===0)return-28;var cwd=FS.cwd();var cwdLengthInBytes=lengthBytesUTF8(cwd)+1;if(size<cwdLengthInBytes)return-68;stringToUTF8(cwd,buf,size);return cwdLengthInBytes;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_getcwd.sig="ipp";function ___syscall_getdents64(fd,dirp,count){dirp>>>=0;count>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);stream.getdents||=FS.readdir(stream.path);var struct_size=280;var pos=0;var off=FS.llseek(stream,0,1);var idx=Math.floor(off/struct_size);while(idx<stream.getdents.length&&pos+struct_size<=count){var id;var type;var name=stream.getdents[idx];if(name==="."){id=stream.node.id;type=4;}else// DT_DIR
if(name===".."){var lookup=FS.lookupPath(stream.path,{parent:true});id=lookup.node.id;type=4;}else// DT_DIR
{var child=FS.lookupNode(stream.node,name);id=child.id;type=FS.isChrdev(child.mode)?2:// DT_CHR, character device.
FS.isDir(child.mode)?4:// DT_DIR, directory.
FS.isLink(child.mode)?10:// DT_LNK, symbolic link.
8;}// DT_REG, regular file.
tempI64=[id>>>0,(tempDouble=id,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[dirp+pos>>>2>>>0]=tempI64[0],HEAP32[dirp+pos+4>>>2>>>0]=tempI64[1];tempI64=[(idx+1)*struct_size>>>0,(tempDouble=(idx+1)*struct_size,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[dirp+pos+8>>>2>>>0]=tempI64[0],HEAP32[dirp+pos+12>>>2>>>0]=tempI64[1];HEAP16[dirp+pos+16>>>1>>>0]=280;HEAP8[dirp+pos+18>>>0]=type;stringToUTF8(name,dirp+pos+19,256);pos+=struct_size;idx+=1;}FS.llseek(stream,idx*struct_size,0);return pos;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_getdents64.sig="iipp";function ___syscall_getpeername(fd,addr,addrlen,d1,d2,d3){addr>>>=0;addrlen>>>=0;try{var sock=getSocketFromFD(fd);if(!sock.daddr){return-53;}// The socket is not connected.
var errno=writeSockaddr(addr,sock.family,DNS.lookup_name(sock.daddr),sock.dport,addrlen);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_getpeername.sig="iippiii";function ___syscall_getsockname(fd,addr,addrlen,d1,d2,d3){addr>>>=0;addrlen>>>=0;try{var sock=getSocketFromFD(fd);// TODO: sock.saddr should never be undefined, see TODO in websocket_sock_ops.getname
var errno=writeSockaddr(addr,sock.family,DNS.lookup_name(sock.saddr||"0.0.0.0"),sock.sport,addrlen);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_getsockname.sig="iippiii";function ___syscall_getsockopt(fd,level,optname,optval,optlen,d1){optval>>>=0;optlen>>>=0;try{var sock=getSocketFromFD(fd);// Minimal getsockopt aimed at resolving https://github.com/emscripten-core/emscripten/issues/2211
// so only supports SOL_SOCKET with SO_ERROR.
if(level===1){if(optname===4){HEAP32[optval>>>2>>>0]=sock.error;HEAP32[optlen>>>2>>>0]=4;sock.error=null;// Clear the error (The SO_ERROR option obtains and then clears this field).
return 0;}}return-50;}// The option is unknown at the level indicated.
catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_getsockopt.sig="iiiippi";function ___syscall_ioctl(fd,op,varargs){varargs>>>=0;SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:{if(!stream.tty)return-59;return 0;}case 21505:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcgets){var termios=stream.tty.ops.ioctl_tcgets(stream);var argp=syscallGetVarargP();HEAP32[argp>>>2>>>0]=termios.c_iflag||0;HEAP32[argp+4>>>2>>>0]=termios.c_oflag||0;HEAP32[argp+8>>>2>>>0]=termios.c_cflag||0;HEAP32[argp+12>>>2>>>0]=termios.c_lflag||0;for(var i=0;i<32;i++){HEAP8[argp+i+17>>>0]=termios.c_cc[i]||0;}return 0;}return 0;}case 21510:case 21511:case 21512:{if(!stream.tty)return-59;return 0;}// no-op, not actually adjusting terminal settings
case 21506:case 21507:case 21508:{if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tcsets){var argp=syscallGetVarargP();var c_iflag=HEAP32[argp>>>2>>>0];var c_oflag=HEAP32[argp+4>>>2>>>0];var c_cflag=HEAP32[argp+8>>>2>>>0];var c_lflag=HEAP32[argp+12>>>2>>>0];var c_cc=[];for(var i=0;i<32;i++){c_cc.push(HEAP8[argp+i+17>>>0]);}return stream.tty.ops.ioctl_tcsets(stream.tty,op,{c_iflag,c_oflag,c_cflag,c_lflag,c_cc});}return 0;}// no-op, not actually adjusting terminal settings
case 21519:{if(!stream.tty)return-59;var argp=syscallGetVarargP();HEAP32[argp>>>2>>>0]=0;return 0;}case 21520:{if(!stream.tty)return-59;return-28;}// not supported
case 21531:{var argp=syscallGetVarargP();return FS.ioctl(stream,op,argp);}case 21523:{// TODO: in theory we should write to the winsize struct that gets
// passed in, but for now musl doesn't read anything on it
if(!stream.tty)return-59;if(stream.tty.ops.ioctl_tiocgwinsz){var winsize=stream.tty.ops.ioctl_tiocgwinsz(stream.tty);var argp=syscallGetVarargP();HEAP16[argp>>>1>>>0]=winsize[0];HEAP16[argp+2>>>1>>>0]=winsize[1];}return 0;}case 21524:{// TODO: technically, this ioctl call should change the window size.
// but, since emscripten doesn't have any concept of a terminal window
// yet, we'll just silently throw it away as we do TIOCGWINSZ
if(!stream.tty)return-59;return 0;}case 21515:{if(!stream.tty)return-59;return 0;}default:return-28;}}// not supported
catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_ioctl.sig="iiip";function ___syscall_listen(fd,backlog){try{var sock=getSocketFromFD(fd);sock.sock_ops.listen(sock,backlog);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_listen.sig="iiiiiii";function ___syscall_lstat64(path,buf){path>>>=0;buf>>>=0;try{path=SYSCALLS.getStr(path);return SYSCALLS.doStat(FS.lstat,path,buf);}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_lstat64.sig="ipp";function ___syscall_mkdirat(dirfd,path,mode){path>>>=0;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);// remove a trailing slash, if one - /a/b/ has basename of '', but
// we want to create b in the context of this function
path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_mkdirat.sig="iipi";function ___syscall_mknodat(dirfd,path,mode,dev){path>>>=0;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);// we don't want this in the JS API as it uses mknod to create all nodes.
switch(mode&61440){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-28;}FS.mknod(path,mode,dev);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_mknodat.sig="iipii";function ___syscall_newfstatat(dirfd,path,buf,flags){path>>>=0;buf>>>=0;try{path=SYSCALLS.getStr(path);var nofollow=flags&256;var allowEmpty=flags&4096;flags=flags&~6400;path=SYSCALLS.calculateAt(dirfd,path,allowEmpty);return SYSCALLS.doStat(nofollow?FS.lstat:FS.stat,path,buf);}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_newfstatat.sig="iippi";function ___syscall_openat(dirfd,path,flags,varargs){path>>>=0;varargs>>>=0;SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?syscallGetVarargI():0;return FS.open(path,flags,mode).fd;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_openat.sig="iipip";var PIPEFS={BUCKET_BUFFER_SIZE:8192,mount(mount){// Do not pollute the real root directory or its child nodes with pipes
// Looks like it is OK to create another pseudo-root node not linked to the FS.root hierarchy this way
return FS.createNode(null,"/",16384|511,/* 0777 */0);},createPipe(){var pipe={buckets:[],// refcnt 2 because pipe has a read end and a write end. We need to be
// able to read from the read end after write end is closed.
refcnt:2};pipe.buckets.push({buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:0,roffset:0});var rName=PIPEFS.nextname();var wName=PIPEFS.nextname();var rNode=FS.createNode(PIPEFS.root,rName,4096,0);var wNode=FS.createNode(PIPEFS.root,wName,4096,0);rNode.pipe=pipe;wNode.pipe=pipe;var readableStream=FS.createStream({path:rName,node:rNode,flags:0,seekable:false,stream_ops:PIPEFS.stream_ops});rNode.stream=readableStream;var writableStream=FS.createStream({path:wName,node:wNode,flags:1,seekable:false,stream_ops:PIPEFS.stream_ops});wNode.stream=writableStream;return{readable_fd:readableStream.fd,writable_fd:writableStream.fd};},stream_ops:{poll(stream){var pipe=stream.node.pipe;if((stream.flags&2097155)===1){return 256|4;}if(pipe.buckets.length>0){for(var i=0;i<pipe.buckets.length;i++){var bucket=pipe.buckets[i];if(bucket.offset-bucket.roffset>0){return 64|1;}}}return 0;},ioctl(stream,request,varargs){return 28;},fsync(stream){return 28;},read(stream,buffer,offset,length,position){/* ignored */var pipe=stream.node.pipe;var currentLength=0;for(var i=0;i<pipe.buckets.length;i++){var bucket=pipe.buckets[i];currentLength+=bucket.offset-bucket.roffset;}var data=buffer.subarray(offset,offset+length);if(length<=0){return 0;}if(currentLength==0){// Behave as if the read end is always non-blocking
throw new FS.ErrnoError(6);}var toRead=Math.min(currentLength,length);var totalRead=toRead;var toRemove=0;for(var i=0;i<pipe.buckets.length;i++){var currBucket=pipe.buckets[i];var bucketSize=currBucket.offset-currBucket.roffset;if(toRead<=bucketSize){var tmpSlice=currBucket.buffer.subarray(currBucket.roffset,currBucket.offset);if(toRead<bucketSize){tmpSlice=tmpSlice.subarray(0,toRead);currBucket.roffset+=toRead;}else{toRemove++;}data.set(tmpSlice);break;}else{var tmpSlice=currBucket.buffer.subarray(currBucket.roffset,currBucket.offset);data.set(tmpSlice);data=data.subarray(tmpSlice.byteLength);toRead-=tmpSlice.byteLength;toRemove++;}}if(toRemove&&toRemove==pipe.buckets.length){// Do not generate excessive garbage in use cases such as
// write several bytes, read everything, write several bytes, read everything...
toRemove--;pipe.buckets[toRemove].offset=0;pipe.buckets[toRemove].roffset=0;}pipe.buckets.splice(0,toRemove);return totalRead;},write(stream,buffer,offset,length,position){/* ignored */var pipe=stream.node.pipe;var data=buffer.subarray(offset,offset+length);var dataLen=data.byteLength;if(dataLen<=0){return 0;}var currBucket=null;if(pipe.buckets.length==0){currBucket={buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:0,roffset:0};pipe.buckets.push(currBucket);}else{currBucket=pipe.buckets[pipe.buckets.length-1];}assert(currBucket.offset<=PIPEFS.BUCKET_BUFFER_SIZE);var freeBytesInCurrBuffer=PIPEFS.BUCKET_BUFFER_SIZE-currBucket.offset;if(freeBytesInCurrBuffer>=dataLen){currBucket.buffer.set(data,currBucket.offset);currBucket.offset+=dataLen;return dataLen;}else if(freeBytesInCurrBuffer>0){currBucket.buffer.set(data.subarray(0,freeBytesInCurrBuffer),currBucket.offset);currBucket.offset+=freeBytesInCurrBuffer;data=data.subarray(freeBytesInCurrBuffer,data.byteLength);}var numBuckets=data.byteLength/PIPEFS.BUCKET_BUFFER_SIZE|0;var remElements=data.byteLength%PIPEFS.BUCKET_BUFFER_SIZE;for(var i=0;i<numBuckets;i++){var newBucket={buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:PIPEFS.BUCKET_BUFFER_SIZE,roffset:0};pipe.buckets.push(newBucket);newBucket.buffer.set(data.subarray(0,PIPEFS.BUCKET_BUFFER_SIZE));data=data.subarray(PIPEFS.BUCKET_BUFFER_SIZE,data.byteLength);}if(remElements>0){var newBucket={buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:data.byteLength,roffset:0};pipe.buckets.push(newBucket);newBucket.buffer.set(data);}return dataLen;},close(stream){var pipe=stream.node.pipe;pipe.refcnt--;if(pipe.refcnt===0){pipe.buckets=null;}}},nextname(){if(!PIPEFS.nextname.current){PIPEFS.nextname.current=0;}return"pipe["+PIPEFS.nextname.current++ +"]";}};function ___syscall_pipe(fdPtr){fdPtr>>>=0;try{if(fdPtr==0){throw new FS.ErrnoError(21);}var res=PIPEFS.createPipe();HEAP32[fdPtr>>>2>>>0]=res.readable_fd;HEAP32[fdPtr+4>>>2>>>0]=res.writable_fd;return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_pipe.sig="ip";function ___syscall_poll(fds,nfds,timeout){fds>>>=0;try{var nonzero=0;for(var i=0;i<nfds;i++){var pollfd=fds+8*i;var fd=HEAP32[pollfd>>>2>>>0];var events=HEAP16[pollfd+4>>>1>>>0];var mask=32;var stream=FS.getStream(fd);if(stream){mask=SYSCALLS.DEFAULT_POLLMASK;if(stream.stream_ops.poll){mask=stream.stream_ops.poll(stream,-1);}}mask&=events|8|16;if(mask)nonzero++;HEAP16[pollfd+6>>>1>>>0]=mask;}return nonzero;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_poll.sig="ipii";function ___syscall_readlinkat(dirfd,path,buf,bufsize){path>>>=0;buf>>>=0;bufsize>>>=0;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(bufsize<=0)return-28;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len>>>0];stringToUTF8(ret,buf,bufsize+1);// readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
// stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
HEAP8[buf+len>>>0]=endChar;return len;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_readlinkat.sig="iippp";function ___syscall_recvfrom(fd,buf,len,flags,addr,addrlen){buf>>>=0;len>>>=0;addr>>>=0;addrlen>>>=0;try{var sock=getSocketFromFD(fd);var msg=sock.sock_ops.recvmsg(sock,len);if(!msg)return 0;// socket is closed
if(addr){var errno=writeSockaddr(addr,sock.family,DNS.lookup_name(msg.addr),msg.port,addrlen);}HEAPU8.set(msg.buffer,buf>>>0);return msg.buffer.byteLength;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_recvfrom.sig="iippipp";function ___syscall_recvmsg(fd,message,flags,d1,d2,d3){message>>>=0;try{var sock=getSocketFromFD(fd);var iov=HEAPU32[message+8>>>2>>>0];var num=HEAP32[message+12>>>2>>>0];// get the total amount of data we can read across all arrays
var total=0;for(var i=0;i<num;i++){total+=HEAP32[iov+(8*i+4)>>>2>>>0];}// try to read total data
var msg=sock.sock_ops.recvmsg(sock,total);if(!msg)return 0;// socket is closed
// TODO honor flags:
// MSG_OOB
// Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific.
// MSG_PEEK
// Peeks at the incoming message.
// MSG_WAITALL
// Requests that the function block until the full amount of data requested can be returned. The function may return a smaller amount of data if a signal is caught, if the connection is terminated, if MSG_PEEK was specified, or if an error is pending for the socket.
// write the source address out
var name=HEAPU32[message>>>2>>>0];if(name){var errno=writeSockaddr(name,sock.family,DNS.lookup_name(msg.addr),msg.port);}// write the buffer out to the scatter-gather arrays
var bytesRead=0;var bytesRemaining=msg.buffer.byteLength;for(var i=0;bytesRemaining>0&&i<num;i++){var iovbase=HEAPU32[iov+(8*i+0)>>>2>>>0];var iovlen=HEAP32[iov+(8*i+4)>>>2>>>0];if(!iovlen){continue;}var length=Math.min(iovlen,bytesRemaining);var buf=msg.buffer.subarray(bytesRead,bytesRead+length);HEAPU8.set(buf,iovbase+bytesRead>>>0);bytesRead+=length;bytesRemaining-=length;}// TODO set msghdr.msg_flags
// MSG_EOR
// End of record was received (if supported by the protocol).
// MSG_OOB
// Out-of-band data was received.
// MSG_TRUNC
// Normal data was truncated.
// MSG_CTRUNC
return bytesRead;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_recvmsg.sig="iipiiii";function ___syscall_renameat(olddirfd,oldpath,newdirfd,newpath){oldpath>>>=0;newpath>>>=0;try{oldpath=SYSCALLS.getStr(oldpath);newpath=SYSCALLS.getStr(newpath);oldpath=SYSCALLS.calculateAt(olddirfd,oldpath);newpath=SYSCALLS.calculateAt(newdirfd,newpath);FS.rename(oldpath,newpath);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_renameat.sig="iipip";function ___syscall_rmdir(path){path>>>=0;try{path=SYSCALLS.getStr(path);FS.rmdir(path);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_rmdir.sig="ip";function ___syscall_sendmsg(fd,message,flags,d1,d2,d3){message>>>=0;d1>>>=0;d2>>>=0;try{var sock=getSocketFromFD(fd);var iov=HEAPU32[message+8>>>2>>>0];var num=HEAP32[message+12>>>2>>>0];// read the address and port to send to
var addr,port;var name=HEAPU32[message>>>2>>>0];var namelen=HEAP32[message+4>>>2>>>0];if(name){var info=readSockaddr(name,namelen);if(info.errno)return-info.errno;port=info.port;addr=DNS.lookup_addr(info.addr)||info.addr;}// concatenate scatter-gather arrays into one message buffer
var total=0;for(var i=0;i<num;i++){total+=HEAP32[iov+(8*i+4)>>>2>>>0];}var view=new Uint8Array(total);var offset=0;for(var i=0;i<num;i++){var iovbase=HEAPU32[iov+(8*i+0)>>>2>>>0];var iovlen=HEAP32[iov+(8*i+4)>>>2>>>0];for(var j=0;j<iovlen;j++){view[offset++]=HEAP8[iovbase+j>>>0];}}// write the buffer
return sock.sock_ops.sendmsg(sock,view,0,total,addr,port);}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_sendmsg.sig="iipippi";function ___syscall_sendto(fd,message,length,flags,addr,addr_len){message>>>=0;length>>>=0;addr>>>=0;addr_len>>>=0;try{var sock=getSocketFromFD(fd);var dest=getSocketAddress(addr,addr_len,true);if(!dest){// send, no address provided
return FS.write(sock.stream,HEAP8,message,length);}// sendto an address
return sock.sock_ops.sendmsg(sock,HEAP8,message,length,dest.addr,dest.port);}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_sendto.sig="iippipp";function ___syscall_socket(domain,type,protocol){try{var sock=SOCKFS.createSocket(domain,type,protocol);return sock.stream.fd;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_socket.sig="iiiiiii";function ___syscall_stat64(path,buf){path>>>=0;buf>>>=0;try{path=SYSCALLS.getStr(path);return SYSCALLS.doStat(FS.stat,path,buf);}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_stat64.sig="ipp";function ___syscall_symlink(target,linkpath){target>>>=0;linkpath>>>=0;try{target=SYSCALLS.getStr(target);linkpath=SYSCALLS.getStr(linkpath);FS.symlink(target,linkpath);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_symlink.sig="ipp";function ___syscall_symlinkat(target,newdirfd,linkpath){target>>>=0;linkpath>>>=0;try{linkpath=SYSCALLS.calculateAt(newdirfd,linkpath);FS.symlink(target,linkpath);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_symlinkat.sig="ipip";function ___syscall_truncate64(path,length_low,length_high){path>>>=0;var length=convertI32PairToI53Checked(length_low,length_high);try{if(isNaN(length))return 61;path=SYSCALLS.getStr(path);FS.truncate(path,length);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_truncate64.sig="ipii";function ___syscall_unlinkat(dirfd,path,flags){path>>>=0;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(flags===0){FS.unlink(path);}else if(flags===512){FS.rmdir(path);}else{abort("Invalid flags passed to unlinkat");}return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_unlinkat.sig="iipi";var readI53FromI64=ptr=>HEAPU32[ptr>>>2>>>0]+HEAP32[ptr+4>>>2>>>0]*4294967296;function ___syscall_utimensat(dirfd,path,times,flags){path>>>=0;times>>>=0;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path,true);var now=Date.now(),atime,mtime;if(!times){atime=now;mtime=now;}else{var seconds=readI53FromI64(times);var nanoseconds=HEAP32[times+8>>>2>>>0];if(nanoseconds==1073741823){atime=now;}else if(nanoseconds==1073741822){atime=-1;}else{atime=seconds*1e3+nanoseconds/(1e3*1e3);}times+=16;seconds=readI53FromI64(times);nanoseconds=HEAP32[times+8>>>2>>>0];if(nanoseconds==1073741823){mtime=now;}else if(nanoseconds==1073741822){mtime=-1;}else{mtime=seconds*1e3+nanoseconds/(1e3*1e3);}}// -1 here means UTIME_OMIT was passed.  FS.utime tables the max of these
// two values and sets the timestamp to that single value.  If both were
// set to UTIME_OMIT then we can skip the call completely.
if(mtime!=-1||atime!=-1){FS.utime(path,atime,mtime);}return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}___syscall_utimensat.sig="iippi";var ___table_base=new WebAssembly.Global({"value":"i32","mutable":false},1);function ___xmlOutputBufferCreateFilename(...args){return asyncifyStubs["__xmlOutputBufferCreateFilename"](...args);}___xmlOutputBufferCreateFilename.stub=true;asyncifyStubs["__xmlOutputBufferCreateFilename"]=undefined;function ___xmlParserInputBufferCreateFilename(...args){return asyncifyStubs["__xmlParserInputBufferCreateFilename"](...args);}___xmlParserInputBufferCreateFilename.stub=true;asyncifyStubs["__xmlParserInputBufferCreateFilename"]=undefined;function ___xmlRegisterCallbacks(...args){return asyncifyStubs["__xmlRegisterCallbacks"](...args);}___xmlRegisterCallbacks.stub=true;asyncifyStubs["__xmlRegisterCallbacks"]=undefined;var __abort_js=()=>{abort("");};__abort_js.sig="v";var ENV={};var stackAlloc=sz=>__emscripten_stack_alloc(sz);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret;};var dlSetError=msg=>{var sp=stackSave();var cmsg=stringToUTF8OnStack(msg);___dl_seterr(cmsg,0);stackRestore(sp);};var dlopenInternal=(handle,jsflags)=>{// void *dlopen(const char *file, int mode);
// http://pubs.opengroup.org/onlinepubs/009695399/functions/dlopen.html
var filename=UTF8ToString(handle+36);var flags=HEAP32[handle+4>>>2>>>0];filename=PATH.normalize(filename);var searchpaths=[];var global=Boolean(flags&256);var localScope=global?null:{};// We don't care about RTLD_NOW and RTLD_LAZY.
var combinedFlags={global,nodelete:Boolean(flags&4096),loadAsync:jsflags.loadAsync};if(jsflags.loadAsync){return loadDynamicLibrary(filename,combinedFlags,localScope,handle);}try{return loadDynamicLibrary(filename,combinedFlags,localScope,handle);}catch(e){dlSetError(`Could not load dynamic lib: ${filename}\n${e}`);return 0;}};var __dlopen_js=function(handle){handle>>>=0;return Asyncify.handleSleep(wakeUp=>{dlopenInternal(handle,{loadAsync:true}).then(wakeUp).catch(()=>wakeUp(0));});};__dlopen_js.sig="pp";__dlopen_js.isAsync=true;function __dlsym_js(handle,symbol,symbolIndex){handle>>>=0;symbol>>>=0;symbolIndex>>>=0;// void *dlsym(void *restrict handle, const char *restrict name);
// http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html
symbol=UTF8ToString(symbol);var result;var newSymIndex;var lib=LDSO.loadedLibsByHandle[handle];if(!lib.exports.hasOwnProperty(symbol)||lib.exports[symbol].stub){dlSetError(`Tried to lookup unknown symbol "${symbol}" in dynamic lib: ${lib.name}`);return 0;}newSymIndex=Object.keys(lib.exports).indexOf(symbol);var origSym="orig$"+symbol;result=lib.exports[origSym];if(result){newSymIndex=Object.keys(lib.exports).indexOf(origSym);}else result=lib.exports[symbol];if(typeof result=="function"){// Asyncify wraps exports, and we need to look through those wrappers.
if("orig"in result){result=result.orig;}var addr=getFunctionAddress(result);if(addr){result=addr;}else{// Insert the function into the wasm table.  If its a direct wasm
// function the second argument will not be needed.  If its a JS
// function we rely on the `sig` attribute being set based on the
// `<func>__sig` specified in library JS file.
result=addFunction(result,result.sig);HEAPU32[symbolIndex>>>2>>>0]=newSymIndex;}}return result;}__dlsym_js.sig="pppp";var handleException=e=>{// Certain exception types we do not treat as errors since they are used for
// internal control flow.
// 1. ExitStatus, which is thrown by exit()
// 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
//    that wish to return to JS event loop.
if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS;}quit_(1,e);};var runtimeKeepaliveCounter=0;var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){Module["onExit"]?.(code);ABORT=true;}quit_(code,new ExitStatus(code));};_proc_exit.sig="vi";/** @suppress {duplicate } *//** @param {boolean|number=} implicit */var exitJS=(status,implicit)=>{EXITSTATUS=status;if(!keepRuntimeAlive()){exitRuntime();}_proc_exit(status);};var _exit=exitJS;_exit.sig="vi";var maybeExit=()=>{if(runtimeExited){return;}if(!keepRuntimeAlive()){try{_exit(EXITSTATUS);}catch(e){handleException(e);}}};var callUserCallback=func=>{if(runtimeExited||ABORT){return;}try{func();maybeExit();}catch(e){handleException(e);}};var runtimeKeepalivePush=()=>{runtimeKeepaliveCounter+=1;};runtimeKeepalivePush.sig="v";var runtimeKeepalivePop=()=>{runtimeKeepaliveCounter-=1;};runtimeKeepalivePop.sig="v";function __emscripten_dlopen_js(handle,onsuccess,onerror,user_data){handle>>>=0;onsuccess>>>=0;onerror>>>=0;user_data>>>=0;/** @param {Object=} e */function errorCallback(e){var filename=UTF8ToString(handle+36);dlSetError(`'Could not load dynamic lib: ${filename}\n${e}`);runtimeKeepalivePop();callUserCallback(()=>((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */handle,user_data));}function successCallback(){runtimeKeepalivePop();callUserCallback(()=>((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */handle,user_data));}runtimeKeepalivePush();var promise=dlopenInternal(handle,{loadAsync:true});if(promise){promise.then(successCallback,errorCallback);}else{errorCallback();}}__emscripten_dlopen_js.sig="vpppp";var nowIsMonotonic=1;var __emscripten_get_now_is_monotonic=()=>nowIsMonotonic;__emscripten_get_now_is_monotonic.sig="i";var getExecutableName=()=>thisProgram||"./this.program";function __emscripten_get_progname(str,len){str>>>=0;stringToUTF8(getExecutableName(),str,len);}__emscripten_get_progname.sig="vpi";function __emscripten_lookup_name(name){name>>>=0;// uint32_t _emscripten_lookup_name(const char *name);
var nameString=UTF8ToString(name);return inetPton4(DNS.lookup_name(nameString));}__emscripten_lookup_name.sig="ip";function __emscripten_memcpy_js(dest,src,num){dest>>>=0;src>>>=0;num>>>=0;return HEAPU8.copyWithin(dest>>>0,src>>>0,src+num>>>0);}__emscripten_memcpy_js.sig="vppp";var __emscripten_runtime_keepalive_clear=()=>{noExitRuntime=false;runtimeKeepaliveCounter=0;};__emscripten_runtime_keepalive_clear.sig="v";function __emscripten_system(command){command>>>=0;// int system(const char *command);
// http://pubs.opengroup.org/onlinepubs/000095399/functions/system.html
// Can't call external programs.
if(!command)return 0;// no shell available
return-52;}__emscripten_system.sig="ip";var __emscripten_throw_longjmp=()=>{throw Infinity;};__emscripten_throw_longjmp.sig="v";function __gmtime_js(time_low,time_high,tmPtr){var time=convertI32PairToI53Checked(time_low,time_high);tmPtr>>>=0;var date=new Date(time*1e3);HEAP32[tmPtr>>>2>>>0]=date.getUTCSeconds();HEAP32[tmPtr+4>>>2>>>0]=date.getUTCMinutes();HEAP32[tmPtr+8>>>2>>>0]=date.getUTCHours();HEAP32[tmPtr+12>>>2>>>0]=date.getUTCDate();HEAP32[tmPtr+16>>>2>>>0]=date.getUTCMonth();HEAP32[tmPtr+20>>>2>>>0]=date.getUTCFullYear()-1900;HEAP32[tmPtr+24>>>2>>>0]=date.getUTCDay();var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>>2>>>0]=yday;}__gmtime_js.sig="viip";var isLeapYear=year=>year%4===0&&(year%100!==0||year%400===0);var MONTH_DAYS_LEAP_CUMULATIVE=[0,31,60,91,121,152,182,213,244,274,305,335];var MONTH_DAYS_REGULAR_CUMULATIVE=[0,31,59,90,120,151,181,212,243,273,304,334];var ydayFromDate=date=>{var leap=isLeapYear(date.getFullYear());var monthDaysCumulative=leap?MONTH_DAYS_LEAP_CUMULATIVE:MONTH_DAYS_REGULAR_CUMULATIVE;var yday=monthDaysCumulative[date.getMonth()]+date.getDate()-1;// -1 since it's days since Jan 1
return yday;};function __localtime_js(time_low,time_high,tmPtr){var time=convertI32PairToI53Checked(time_low,time_high);tmPtr>>>=0;var date=new Date(time*1e3);HEAP32[tmPtr>>>2>>>0]=date.getSeconds();HEAP32[tmPtr+4>>>2>>>0]=date.getMinutes();HEAP32[tmPtr+8>>>2>>>0]=date.getHours();HEAP32[tmPtr+12>>>2>>>0]=date.getDate();HEAP32[tmPtr+16>>>2>>>0]=date.getMonth();HEAP32[tmPtr+20>>>2>>>0]=date.getFullYear()-1900;HEAP32[tmPtr+24>>>2>>>0]=date.getDay();var yday=ydayFromDate(date)|0;HEAP32[tmPtr+28>>>2>>>0]=yday;HEAP32[tmPtr+36>>>2>>>0]=-(date.getTimezoneOffset()*60);// Attention: DST is in December in South, and some regions don't have DST at all.
var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>>2>>>0]=dst;}__localtime_js.sig="viip";var __mktime_js=function(tmPtr){tmPtr>>>=0;var ret=(()=>{var date=new Date(HEAP32[tmPtr+20>>>2>>>0]+1900,HEAP32[tmPtr+16>>>2>>>0],HEAP32[tmPtr+12>>>2>>>0],HEAP32[tmPtr+8>>>2>>>0],HEAP32[tmPtr+4>>>2>>>0],HEAP32[tmPtr>>>2>>>0],0);// There's an ambiguous hour when the time goes back; the tm_isdst field is
// used to disambiguate it.  Date() basically guesses, so we fix it up if it
// guessed wrong, or fill in tm_isdst with the guess if it's -1.
var dst=HEAP32[tmPtr+32>>>2>>>0];var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);// DST is in December in South
if(dst<0){// Attention: some regions don't have DST at all.
HEAP32[tmPtr+32>>>2>>>0]=Number(summerOffset!=winterOffset&&dstOffset==guessedOffset);}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;// Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.
date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4);}HEAP32[tmPtr+24>>>2>>>0]=date.getDay();var yday=ydayFromDate(date)|0;HEAP32[tmPtr+28>>>2>>>0]=yday;// To match expected behavior, update fields from date
HEAP32[tmPtr>>>2>>>0]=date.getSeconds();HEAP32[tmPtr+4>>>2>>>0]=date.getMinutes();HEAP32[tmPtr+8>>>2>>>0]=date.getHours();HEAP32[tmPtr+12>>>2>>>0]=date.getDate();HEAP32[tmPtr+16>>>2>>>0]=date.getMonth();HEAP32[tmPtr+20>>>2>>>0]=date.getYear();var timeMs=date.getTime();if(isNaN(timeMs)){return-1;}// Return time in microseconds
return timeMs/1e3;})();return setTempRet0((tempDouble=ret,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)),ret>>>0;};__mktime_js.sig="ip";function __mmap_js(len,prot,flags,fd,offset_low,offset_high,allocated,addr){len>>>=0;var offset=convertI32PairToI53Checked(offset_low,offset_high);allocated>>>=0;addr>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);var res=FS.mmap(stream,len,offset,prot,flags);var ptr=res.ptr;HEAP32[allocated>>>2>>>0]=res.allocated;HEAPU32[addr>>>2>>>0]=ptr;return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}__mmap_js.sig="ipiiiiipp";function __msync_js(addr,len,prot,flags,fd,offset_low,offset_high){addr>>>=0;len>>>=0;var offset=convertI32PairToI53Checked(offset_low,offset_high);try{if(isNaN(offset))return 61;SYSCALLS.doMsync(addr,SYSCALLS.getStreamFromFD(fd),len,flags,offset);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}__msync_js.sig="ippiiiii";function __munmap_js(addr,len,prot,flags,fd,offset_low,offset_high){addr>>>=0;len>>>=0;var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset);}}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}__munmap_js.sig="ippiiiii";var timers={};var _emscripten_get_now=()=>performance.now();_emscripten_get_now.sig="d";var __setitimer_js=(which,timeout_ms)=>{// First, clear any existing timer.
if(timers[which]){clearTimeout(timers[which].id);delete timers[which];}// A timeout of zero simply cancels the current timeout so we have nothing
// more to do.
if(!timeout_ms)return 0;var id=setTimeout(()=>{delete timers[which];callUserCallback(()=>__emscripten_timeout(which,_emscripten_get_now()));},timeout_ms);timers[which]={id,timeout_ms};return 0;};__setitimer_js.sig="iid";var __timegm_js=function(tmPtr){tmPtr>>>=0;var ret=(()=>{var time=Date.UTC(HEAP32[tmPtr+20>>>2>>>0]+1900,HEAP32[tmPtr+16>>>2>>>0],HEAP32[tmPtr+12>>>2>>>0],HEAP32[tmPtr+8>>>2>>>0],HEAP32[tmPtr+4>>>2>>>0],HEAP32[tmPtr>>>2>>>0],0);var date=new Date(time);HEAP32[tmPtr+24>>>2>>>0]=date.getUTCDay();var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>>2>>>0]=yday;return date.getTime()/1e3;})();return setTempRet0((tempDouble=ret,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)),ret>>>0;};__timegm_js.sig="ip";var __tzset_js=function(timezone,daylight,std_name,dst_name){timezone>>>=0;daylight>>>=0;std_name>>>=0;dst_name>>>=0;// TODO: Use (malleable) environment variables instead of system settings.
var currentYear=new Date().getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();// Local standard timezone offset. Local standard time is not adjusted for
// daylight savings.  This code uses the fact that getTimezoneOffset returns
// a greater value during Standard Time versus Daylight Saving Time (DST).
// Thus it determines the expected output during Standard Time, and it
// compares whether the output of the given date the same (Standard) or less
// (DST).
var stdTimezoneOffset=Math.max(winterOffset,summerOffset);// timezone is specified as seconds west of UTC ("The external variable
// `timezone` shall be set to the difference, in seconds, between
// Coordinated Universal Time (UTC) and local standard time."), the same
// as returned by stdTimezoneOffset.
// See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
HEAPU32[timezone>>>2>>>0]=stdTimezoneOffset*60;HEAP32[daylight>>>2>>>0]=Number(winterOffset!=summerOffset);var extractZone=timezoneOffset=>{// Why inverse sign?
// Read here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset
var sign=timezoneOffset>=0?"-":"+";var absOffset=Math.abs(timezoneOffset);var hours=String(Math.floor(absOffset/60)).padStart(2,"0");var minutes=String(absOffset%60).padStart(2,"0");return`UTC${sign}${hours}${minutes}`;};var winterName=extractZone(winterOffset);var summerName=extractZone(summerOffset);if(summerOffset<winterOffset){// Northern hemisphere
stringToUTF8(winterName,std_name,17);stringToUTF8(summerName,dst_name,17);}else{stringToUTF8(winterName,dst_name,17);stringToUTF8(summerName,std_name,17);}};__tzset_js.sig="vpppp";var _emscripten_set_main_loop_timing=(mode,value)=>{Browser.mainLoop.timingMode=mode;Browser.mainLoop.timingValue=value;if(!Browser.mainLoop.func){return 1;}// Return non-zero on failure, can't set timing mode when there is no main loop.
if(!Browser.mainLoop.running){runtimeKeepalivePush();Browser.mainLoop.running=true;}if(mode==0){Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_setTimeout(){var timeUntilNextTick=Math.max(0,Browser.mainLoop.tickStartTime+value-_emscripten_get_now())|0;setTimeout(Browser.mainLoop.runner,timeUntilNextTick);};// doing this each time means that on exception, we stop
Browser.mainLoop.method="timeout";}else if(mode==1){Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_rAF(){Browser.requestAnimationFrame(Browser.mainLoop.runner);};Browser.mainLoop.method="rAF";}else if(mode==2){if(typeof Browser.setImmediate=="undefined"){if(typeof setImmediate=="undefined"){// Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
var setImmediates=[];var emscriptenMainLoopMessageId="setimmediate";/** @param {Event} event */var Browser_setImmediate_messageHandler=event=>{// When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
// so check for both cases.
if(event.data===emscriptenMainLoopMessageId||event.data.target===emscriptenMainLoopMessageId){event.stopPropagation();setImmediates.shift()();}};addEventListener("message",Browser_setImmediate_messageHandler,true);Browser.setImmediate=/** @type{function(function(): ?, ...?): number} */func=>{setImmediates.push(func);if(ENVIRONMENT_IS_WORKER){Module["setImmediates"]??=[];Module["setImmediates"].push(func);postMessage({target:emscriptenMainLoopMessageId});}else// In --proxy-to-worker, route the message via proxyClient.js
postMessage(emscriptenMainLoopMessageId,"*");};}else{Browser.setImmediate=setImmediate;}}Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_setImmediate(){Browser.setImmediate(Browser.mainLoop.runner);};Browser.mainLoop.method="immediate";}return 0;};_emscripten_set_main_loop_timing.sig="iii";/**
     * @param {number=} arg
     * @param {boolean=} noSetTiming
     */var setMainLoop=(browserIterationFunc,fps,simulateInfiniteLoop,arg,noSetTiming)=>{Browser.mainLoop.func=browserIterationFunc;Browser.mainLoop.arg=arg;var thisMainLoopId=Browser.mainLoop.currentlyRunningMainloop;function checkIsRunning(){if(thisMainLoopId<Browser.mainLoop.currentlyRunningMainloop){runtimeKeepalivePop();maybeExit();return false;}return true;}// We create the loop runner here but it is not actually running until
// _emscripten_set_main_loop_timing is called (which might happen a
// later time).  This member signifies that the current runner has not
// yet been started so that we can call runtimeKeepalivePush when it
// gets it timing set for the first time.
Browser.mainLoop.running=false;Browser.mainLoop.runner=function Browser_mainLoop_runner(){if(ABORT)return;if(Browser.mainLoop.queue.length>0){var start=Date.now();var blocker=Browser.mainLoop.queue.shift();blocker.func(blocker.arg);if(Browser.mainLoop.remainingBlockers){var remaining=Browser.mainLoop.remainingBlockers;var next=remaining%1==0?remaining-1:Math.floor(remaining);if(blocker.counted){Browser.mainLoop.remainingBlockers=next;}else{// not counted, but move the progress along a tiny bit
next=next+.5;// do not steal all the next one's progress
Browser.mainLoop.remainingBlockers=(8*remaining+next)/9;}}Browser.mainLoop.updateStatus();// catches pause/resume main loop from blocker execution
if(!checkIsRunning())return;setTimeout(Browser.mainLoop.runner,0);return;}// catch pauses from non-main loop sources
if(!checkIsRunning())return;// Implement very basic swap interval control
Browser.mainLoop.currentFrameNumber=Browser.mainLoop.currentFrameNumber+1|0;if(Browser.mainLoop.timingMode==1&&Browser.mainLoop.timingValue>1&&Browser.mainLoop.currentFrameNumber%Browser.mainLoop.timingValue!=0){// Not the scheduled time to render this frame - skip.
Browser.mainLoop.scheduler();return;}else if(Browser.mainLoop.timingMode==0){Browser.mainLoop.tickStartTime=_emscripten_get_now();}// Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
// VBO double-buffering and reduce GPU stalls.
Browser.mainLoop.runIter(browserIterationFunc);// catch pauses from the main loop itself
if(!checkIsRunning())return;// Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
// to queue the newest produced audio samples.
// TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
//       do not need to be hardcoded into this function, but can be more generic.
if(typeof SDL=="object")SDL.audio?.queueNewAudioData?.();Browser.mainLoop.scheduler();};if(!noSetTiming){if(fps&&fps>0){_emscripten_set_main_loop_timing(0,1e3/fps);}else{// Do rAF by rendering each frame (no decimating)
_emscripten_set_main_loop_timing(1,1);}Browser.mainLoop.scheduler();}if(simulateInfiniteLoop){throw"unwind";}};/** @param {number=} timeout */var safeSetTimeout=(func,timeout)=>{runtimeKeepalivePush();return setTimeout(()=>{runtimeKeepalivePop();callUserCallback(func);},timeout);};var warnOnce=text=>{warnOnce.shown||={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text);}};var Browser={mainLoop:{running:false,scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause(){Browser.mainLoop.scheduler=null;// Incrementing this signals the previous main loop that it's now become old, and it must return.
Browser.mainLoop.currentlyRunningMainloop++;},resume(){Browser.mainLoop.currentlyRunningMainloop++;var timingMode=Browser.mainLoop.timingMode;var timingValue=Browser.mainLoop.timingValue;var func=Browser.mainLoop.func;Browser.mainLoop.func=null;// do not set timing and call scheduler, we will do it on the next lines
setMainLoop(func,0,false,Browser.mainLoop.arg,true);_emscripten_set_main_loop_timing(timingMode,timingValue);Browser.mainLoop.scheduler();},updateStatus(){if(Module["setStatus"]){var message=Module["statusMessage"]||"Please wait...";var remaining=Browser.mainLoop.remainingBlockers;var expected=Browser.mainLoop.expectedBlockers;if(remaining){if(remaining<expected){Module["setStatus"](`{message} ({expected - remaining}/{expected})`);}else{Module["setStatus"](message);}}else{Module["setStatus"]("");}}},runIter(func){if(ABORT)return;if(Module["preMainLoop"]){var preRet=Module["preMainLoop"]();if(preRet===false){return;}}callUserCallback(func);Module["postMainLoop"]?.();}},useWebGL:false,isFullscreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init(){if(Browser.initted)return;Browser.initted=true;// Support for plugins that can process preloaded files. You can add more of these to
// your app by creating and appending to preloadPlugins.
// Each plugin is asked if it can handle a file based on the file's name. If it can,
// it is given the file's raw data. When it is done, it calls a callback with the file's
// (possibly modified) data. For example, a plugin might decompress a file, or it
// might create some side data structure for use later (like an Image element, etc.).
var imagePlugin={};imagePlugin["canHandle"]=function imagePlugin_canHandle(name){return!Module["noImageDecoding"]&&/\.(jpg|jpeg|png|bmp|webp)$/i.test(name);};imagePlugin["handle"]=function imagePlugin_handle(byteArray,name,onload,onerror){var b=new Blob([byteArray],{type:Browser.getMimetype(name)});if(b.size!==byteArray.length){// Safari bug #118630
// Safari's Blob can only take an ArrayBuffer
b=new Blob([new Uint8Array(byteArray).buffer],{type:Browser.getMimetype(name)});}var url=URL.createObjectURL(b);var img=new Image();img.onload=()=>{var canvas=/** @type {!HTMLCanvasElement} */document.createElement("canvas");canvas.width=img.width;canvas.height=img.height;var ctx=canvas.getContext("2d");ctx.drawImage(img,0,0);preloadedImages[name]=canvas;URL.revokeObjectURL(url);onload?.(byteArray);};img.onerror=event=>{err(`Image ${url} could not be decoded`);onerror?.();};img.src=url;};preloadPlugins.push(imagePlugin);var audioPlugin={};audioPlugin["canHandle"]=function audioPlugin_canHandle(name){return!Module["noAudioDecoding"]&&name.substr(-4)in{".ogg":1,".wav":1,".mp3":1};};audioPlugin["handle"]=function audioPlugin_handle(byteArray,name,onload,onerror){var done=false;function finish(audio){if(done)return;done=true;preloadedAudios[name]=audio;onload?.(byteArray);}function fail(){if(done)return;done=true;preloadedAudios[name]=new Audio();// empty shim
onerror?.();}var b=new Blob([byteArray],{type:Browser.getMimetype(name)});var url=URL.createObjectURL(b);// XXX we never revoke this!
var audio=new Audio();audio.addEventListener("canplaythrough",()=>finish(audio),false);// use addEventListener due to chromium bug 124926
audio.onerror=function audio_onerror(event){if(done)return;err(`warning: browser could not fully decode audio ${name}, trying slower base64 approach`);function encode64(data){var BASE="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var PAD="=";var ret="";var leftchar=0;var leftbits=0;for(var i=0;i<data.length;i++){leftchar=leftchar<<8|data[i];leftbits+=8;while(leftbits>=6){var curr=leftchar>>leftbits-6&63;leftbits-=6;ret+=BASE[curr];}}if(leftbits==2){ret+=BASE[(leftchar&3)<<4];ret+=PAD+PAD;}else if(leftbits==4){ret+=BASE[(leftchar&15)<<2];ret+=PAD;}return ret;}audio.src="data:audio/x-"+name.substr(-3)+";base64,"+encode64(byteArray);finish(audio);};// we don't wait for confirmation this worked - but it's worth trying
audio.src=url;// workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
safeSetTimeout(()=>{finish(audio);},// try to use it even though it is not necessarily ready to play
1e4);};preloadPlugins.push(audioPlugin);// Canvas event setup
function pointerLockChange(){Browser.pointerLock=document["pointerLockElement"]===Module["canvas"]||document["mozPointerLockElement"]===Module["canvas"]||document["webkitPointerLockElement"]===Module["canvas"]||document["msPointerLockElement"]===Module["canvas"];}var canvas=Module["canvas"];if(canvas){// forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
// Module['forcedAspectRatio'] = 4 / 3;
canvas.requestPointerLock=canvas["requestPointerLock"]||canvas["mozRequestPointerLock"]||canvas["webkitRequestPointerLock"]||canvas["msRequestPointerLock"]||(()=>{});canvas.exitPointerLock=document["exitPointerLock"]||document["mozExitPointerLock"]||document["webkitExitPointerLock"]||document["msExitPointerLock"]||(()=>{});// no-op if function does not exist
canvas.exitPointerLock=canvas.exitPointerLock.bind(document);document.addEventListener("pointerlockchange",pointerLockChange,false);document.addEventListener("mozpointerlockchange",pointerLockChange,false);document.addEventListener("webkitpointerlockchange",pointerLockChange,false);document.addEventListener("mspointerlockchange",pointerLockChange,false);if(Module["elementPointerLock"]){canvas.addEventListener("click",ev=>{if(!Browser.pointerLock&&Module["canvas"].requestPointerLock){Module["canvas"].requestPointerLock();ev.preventDefault();}},false);}}},createContext(/** @type {HTMLCanvasElement} */canvas,useWebGL,setInModule,webGLContextAttributes){if(useWebGL&&Module.ctx&&canvas==Module.canvas)return Module.ctx;// no need to recreate GL context if it's already been created for this canvas.
var ctx;var contextHandle;if(useWebGL){// For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
var contextAttributes={antialias:false,alpha:false,majorVersion:1};if(webGLContextAttributes){for(var attribute in webGLContextAttributes){contextAttributes[attribute]=webGLContextAttributes[attribute];}}// This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
// actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
// Browser.createContext() should not even be emitted.
if(typeof GL!="undefined"){contextHandle=GL.createContext(canvas,contextAttributes);if(contextHandle){ctx=GL.getContext(contextHandle).GLctx;}}}else{ctx=canvas.getContext("2d");}if(!ctx)return null;if(setInModule){Module.ctx=ctx;if(useWebGL)GL.makeContextCurrent(contextHandle);Browser.useWebGL=useWebGL;Browser.moduleContextCreatedCallbacks.forEach(callback=>callback());Browser.init();}return ctx;},fullscreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullscreen(lockPointer,resizeCanvas){Browser.lockPointer=lockPointer;Browser.resizeCanvas=resizeCanvas;if(typeof Browser.lockPointer=="undefined")Browser.lockPointer=true;if(typeof Browser.resizeCanvas=="undefined")Browser.resizeCanvas=false;var canvas=Module["canvas"];function fullscreenChange(){Browser.isFullscreen=false;var canvasContainer=canvas.parentNode;if((document["fullscreenElement"]||document["mozFullScreenElement"]||document["msFullscreenElement"]||document["webkitFullscreenElement"]||document["webkitCurrentFullScreenElement"])===canvasContainer){canvas.exitFullscreen=Browser.exitFullscreen;if(Browser.lockPointer)canvas.requestPointerLock();Browser.isFullscreen=true;if(Browser.resizeCanvas){Browser.setFullscreenCanvasSize();}else{Browser.updateCanvasDimensions(canvas);}}else{// remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
canvasContainer.parentNode.insertBefore(canvas,canvasContainer);canvasContainer.parentNode.removeChild(canvasContainer);if(Browser.resizeCanvas){Browser.setWindowedCanvasSize();}else{Browser.updateCanvasDimensions(canvas);}}Module["onFullScreen"]?.(Browser.isFullscreen);Module["onFullscreen"]?.(Browser.isFullscreen);}if(!Browser.fullscreenHandlersInstalled){Browser.fullscreenHandlersInstalled=true;document.addEventListener("fullscreenchange",fullscreenChange,false);document.addEventListener("mozfullscreenchange",fullscreenChange,false);document.addEventListener("webkitfullscreenchange",fullscreenChange,false);document.addEventListener("MSFullscreenChange",fullscreenChange,false);}// create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
var canvasContainer=document.createElement("div");canvas.parentNode.insertBefore(canvasContainer,canvas);canvasContainer.appendChild(canvas);// use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
canvasContainer.requestFullscreen=canvasContainer["requestFullscreen"]||canvasContainer["mozRequestFullScreen"]||canvasContainer["msRequestFullscreen"]||(canvasContainer["webkitRequestFullscreen"]?()=>canvasContainer["webkitRequestFullscreen"](Element["ALLOW_KEYBOARD_INPUT"]):null)||(canvasContainer["webkitRequestFullScreen"]?()=>canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"]):null);canvasContainer.requestFullscreen();},exitFullscreen(){// This is workaround for chrome. Trying to exit from fullscreen
// not in fullscreen state will cause "TypeError: Document not active"
// in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
if(!Browser.isFullscreen){return false;}var CFS=document["exitFullscreen"]||document["cancelFullScreen"]||document["mozCancelFullScreen"]||document["msExitFullscreen"]||document["webkitCancelFullScreen"]||(()=>{});CFS.apply(document,[]);return true;},nextRAF:0,fakeRequestAnimationFrame(func){// try to keep 60fps between calls to here
var now=Date.now();if(Browser.nextRAF===0){Browser.nextRAF=now+1e3/60;}else{while(now+2>=Browser.nextRAF){// fudge a little, to avoid timer jitter causing us to do lots of delay:0
Browser.nextRAF+=1e3/60;}}var delay=Math.max(Browser.nextRAF-now,0);setTimeout(func,delay);},requestAnimationFrame(func){if(typeof requestAnimationFrame=="function"){requestAnimationFrame(func);return;}var RAF=Browser.fakeRequestAnimationFrame;RAF(func);},safeSetTimeout(func,timeout){// Legacy function, this is used by the SDL2 port so we need to keep it
// around at least until that is updated.
// See https://github.com/libsdl-org/SDL/pull/6304
return safeSetTimeout(func,timeout);},safeRequestAnimationFrame(func){runtimeKeepalivePush();return Browser.requestAnimationFrame(()=>{runtimeKeepalivePop();callUserCallback(func);});},getMimetype(name){return{"jpg":"image/jpeg","jpeg":"image/jpeg","png":"image/png","bmp":"image/bmp","ogg":"audio/ogg","wav":"audio/wav","mp3":"audio/mpeg"}[name.substr(name.lastIndexOf(".")+1)];},getUserMedia(func){window.getUserMedia||=navigator["getUserMedia"]||navigator["mozGetUserMedia"];window.getUserMedia(func);},getMovementX(event){return event["movementX"]||event["mozMovementX"]||event["webkitMovementX"]||0;},getMovementY(event){return event["movementY"]||event["mozMovementY"]||event["webkitMovementY"]||0;},getMouseWheelDelta(event){var delta=0;switch(event.type){case"DOMMouseScroll":// 3 lines make up a step
delta=event.detail/3;break;case"mousewheel":// 120 units make up a step
delta=event.wheelDelta/120;break;case"wheel":delta=event.deltaY;switch(event.deltaMode){case 0:// DOM_DELTA_PIXEL: 100 pixels make up a step
delta/=100;break;case 1:// DOM_DELTA_LINE: 3 lines make up a step
delta/=3;break;case 2:// DOM_DELTA_PAGE: A page makes up 80 steps
delta*=80;break;default:throw"unrecognized mouse wheel delta mode: "+event.deltaMode;}break;default:throw"unrecognized mouse wheel event: "+event.type;}return delta;},mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseCoords(pageX,pageY){// Calculate the movement based on the changes
// in the coordinates.
var rect=Module["canvas"].getBoundingClientRect();var cw=Module["canvas"].width;var ch=Module["canvas"].height;// Neither .scrollX or .pageXOffset are defined in a spec, but
// we prefer .scrollX because it is currently in a spec draft.
// (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
var scrollX=typeof window.scrollX!="undefined"?window.scrollX:window.pageXOffset;var scrollY=typeof window.scrollY!="undefined"?window.scrollY:window.pageYOffset;var adjustedX=pageX-(scrollX+rect.left);var adjustedY=pageY-(scrollY+rect.top);// the canvas might be CSS-scaled compared to its backbuffer;
// SDL-using content will want mouse coordinates in terms
// of backbuffer units.
adjustedX=adjustedX*(cw/rect.width);adjustedY=adjustedY*(ch/rect.height);return{x:adjustedX,y:adjustedY};},setMouseCoords(pageX,pageY){const{x,y}=Browser.calculateMouseCoords(pageX,pageY);Browser.mouseMovementX=x-Browser.mouseX;Browser.mouseMovementY=y-Browser.mouseY;Browser.mouseX=x;Browser.mouseY=y;},calculateMouseEvent(event){// event should be mousemove, mousedown or mouseup
if(Browser.pointerLock){// When the pointer is locked, calculate the coordinates
// based on the movement of the mouse.
// Workaround for Firefox bug 764498
if(event.type!="mousemove"&&"mozMovementX"in event){Browser.mouseMovementX=Browser.mouseMovementY=0;}else{Browser.mouseMovementX=Browser.getMovementX(event);Browser.mouseMovementY=Browser.getMovementY(event);}// add the mouse delta to the current absolute mouse position
Browser.mouseX+=Browser.mouseMovementX;Browser.mouseY+=Browser.mouseMovementY;}else{if(event.type==="touchstart"||event.type==="touchend"||event.type==="touchmove"){var touch=event.touch;if(touch===undefined){return;}// the "touch" property is only defined in SDL
var coords=Browser.calculateMouseCoords(touch.pageX,touch.pageY);if(event.type==="touchstart"){Browser.lastTouches[touch.identifier]=coords;Browser.touches[touch.identifier]=coords;}else if(event.type==="touchend"||event.type==="touchmove"){var last=Browser.touches[touch.identifier];last||=coords;Browser.lastTouches[touch.identifier]=last;Browser.touches[touch.identifier]=coords;}return;}Browser.setMouseCoords(event.pageX,event.pageY);}},resizeListeners:[],updateResizeListeners(){var canvas=Module["canvas"];Browser.resizeListeners.forEach(listener=>listener(canvas.width,canvas.height));},setCanvasSize(width,height,noUpdates){var canvas=Module["canvas"];Browser.updateCanvasDimensions(canvas,width,height);if(!noUpdates)Browser.updateResizeListeners();},windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize(){// check if SDL is available
if(typeof SDL!="undefined"){var flags=HEAPU32[SDL.screen>>>2>>>0];flags=flags|8388608;// set SDL_FULLSCREEN flag
HEAP32[SDL.screen>>>2>>>0]=flags;}Browser.updateCanvasDimensions(Module["canvas"]);Browser.updateResizeListeners();},setWindowedCanvasSize(){// check if SDL is available
if(typeof SDL!="undefined"){var flags=HEAPU32[SDL.screen>>>2>>>0];flags=flags&~8388608;// clear SDL_FULLSCREEN flag
HEAP32[SDL.screen>>>2>>>0]=flags;}Browser.updateCanvasDimensions(Module["canvas"]);Browser.updateResizeListeners();},updateCanvasDimensions(canvas,wNative,hNative){if(wNative&&hNative){canvas.widthNative=wNative;canvas.heightNative=hNative;}else{wNative=canvas.widthNative;hNative=canvas.heightNative;}var w=wNative;var h=hNative;if(Module["forcedAspectRatio"]&&Module["forcedAspectRatio"]>0){if(w/h<Module["forcedAspectRatio"]){w=Math.round(h*Module["forcedAspectRatio"]);}else{h=Math.round(w/Module["forcedAspectRatio"]);}}if((document["fullscreenElement"]||document["mozFullScreenElement"]||document["msFullscreenElement"]||document["webkitFullscreenElement"]||document["webkitCurrentFullScreenElement"])===canvas.parentNode&&typeof screen!="undefined"){var factor=Math.min(screen.width/w,screen.height/h);w=Math.round(w*factor);h=Math.round(h*factor);}if(Browser.resizeCanvas){if(canvas.width!=w)canvas.width=w;if(canvas.height!=h)canvas.height=h;if(typeof canvas.style!="undefined"){canvas.style.removeProperty("width");canvas.style.removeProperty("height");}}else{if(canvas.width!=wNative)canvas.width=wNative;if(canvas.height!=hNative)canvas.height=hNative;if(typeof canvas.style!="undefined"){if(w!=wNative||h!=hNative){canvas.style.setProperty("width",w+"px","important");canvas.style.setProperty("height",h+"px","important");}else{canvas.style.removeProperty("width");canvas.style.removeProperty("height");}}}}};var AL={QUEUE_INTERVAL:25,QUEUE_LOOKAHEAD:.1,DEVICE_NAME:"Emscripten OpenAL",CAPTURE_DEVICE_NAME:"Emscripten OpenAL capture",ALC_EXTENSIONS:{ALC_SOFT_pause_device:true,ALC_SOFT_HRTF:true},AL_EXTENSIONS:{AL_EXT_float32:true,AL_SOFT_loop_points:true,AL_SOFT_source_length:true,AL_EXT_source_distance_model:true,AL_SOFT_source_spatialize:true},_alcErr:0,alcErr:0,deviceRefCounts:{},alcStringCache:{},paused:false,stringCache:{},contexts:{},currentCtx:null,buffers:{0:{id:0,refCount:0,audioBuf:null,frequency:0,bytesPerSample:2,channels:1,length:0}},paramArray:[],_nextId:1,newId:()=>AL.freeIds.length>0?AL.freeIds.pop():AL._nextId++,freeIds:[],scheduleContextAudio:ctx=>{// If we are animating using the requestAnimationFrame method, then the main loop does not run when in the background.
// To give a perfect glitch-free audio stop when switching from foreground to background, we need to avoid updating
// audio altogether when in the background, so detect that case and kill audio buffer streaming if so.
if(Browser.mainLoop.timingMode===1&&document["visibilityState"]!="visible"){return;}for(var i in ctx.sources){AL.scheduleSourceAudio(ctx.sources[i]);}},scheduleSourceAudio:(src,lookahead)=>{// See comment on scheduleContextAudio above.
if(Browser.mainLoop.timingMode===1&&document["visibilityState"]!="visible"){return;}if(src.state!==4114){return;}var currentTime=AL.updateSourceTime(src);var startTime=src.bufStartTime;var startOffset=src.bufOffset;var bufCursor=src.bufsProcessed;// Advance past any audio that is already scheduled
for(var i=0;i<src.audioQueue.length;i++){var audioSrc=src.audioQueue[i];startTime=audioSrc._startTime+audioSrc._duration;startOffset=0;bufCursor+=audioSrc._skipCount+1;}if(!lookahead){lookahead=AL.QUEUE_LOOKAHEAD;}var lookaheadTime=currentTime+lookahead;var skipCount=0;while(startTime<lookaheadTime){if(bufCursor>=src.bufQueue.length){if(src.looping){bufCursor%=src.bufQueue.length;}else{break;}}var buf=src.bufQueue[bufCursor%src.bufQueue.length];// If the buffer contains no data, skip it
if(buf.length===0){skipCount++;// If we've gone through the whole queue and everything is 0 length, just give up
if(skipCount===src.bufQueue.length){break;}}else{var audioSrc=src.context.audioCtx.createBufferSource();audioSrc.buffer=buf.audioBuf;audioSrc.playbackRate.value=src.playbackRate;if(buf.audioBuf._loopStart||buf.audioBuf._loopEnd){audioSrc.loopStart=buf.audioBuf._loopStart;audioSrc.loopEnd=buf.audioBuf._loopEnd;}var duration=0;// If the source is a looping static buffer, use native looping for gapless playback
if(src.type===4136&&src.looping){duration=Number.POSITIVE_INFINITY;audioSrc.loop=true;if(buf.audioBuf._loopStart){audioSrc.loopStart=buf.audioBuf._loopStart;}if(buf.audioBuf._loopEnd){audioSrc.loopEnd=buf.audioBuf._loopEnd;}}else{duration=(buf.audioBuf.duration-startOffset)/src.playbackRate;}audioSrc._startOffset=startOffset;audioSrc._duration=duration;audioSrc._skipCount=skipCount;skipCount=0;audioSrc.connect(src.gain);if(typeof audioSrc.start!="undefined"){// Sample the current time as late as possible to mitigate drift
startTime=Math.max(startTime,src.context.audioCtx.currentTime);audioSrc.start(startTime,startOffset);}else if(typeof audioSrc.noteOn!="undefined"){startTime=Math.max(startTime,src.context.audioCtx.currentTime);audioSrc.noteOn(startTime);}audioSrc._startTime=startTime;src.audioQueue.push(audioSrc);startTime+=duration;}startOffset=0;bufCursor++;}},updateSourceTime:src=>{var currentTime=src.context.audioCtx.currentTime;if(src.state!==4114){return currentTime;}// if the start time is unset, determine it based on the current offset.
// This will be the case when a source is resumed after being paused, and
// allows us to pretend that the source actually started playing some time
// in the past such that it would just now have reached the stored offset.
if(!isFinite(src.bufStartTime)){src.bufStartTime=currentTime-src.bufOffset/src.playbackRate;src.bufOffset=0;}var nextStartTime=0;while(src.audioQueue.length){var audioSrc=src.audioQueue[0];src.bufsProcessed+=audioSrc._skipCount;nextStartTime=audioSrc._startTime+audioSrc._duration;// n.b. audioSrc._duration already factors in playbackRate, so no divide by src.playbackRate on it.
if(currentTime<nextStartTime){break;}src.audioQueue.shift();src.bufStartTime=nextStartTime;src.bufOffset=0;src.bufsProcessed++;}if(src.bufsProcessed>=src.bufQueue.length&&!src.looping){// The source has played its entire queue and is non-looping, so just mark it as stopped.
AL.setSourceState(src,4116);}else if(src.type===4136&&src.looping){// If the source is a looping static buffer, determine the buffer offset based on the loop points
var buf=src.bufQueue[0];if(buf.length===0){src.bufOffset=0;}else{var delta=(currentTime-src.bufStartTime)*src.playbackRate;var loopStart=buf.audioBuf._loopStart||0;var loopEnd=buf.audioBuf._loopEnd||buf.audioBuf.duration;if(loopEnd<=loopStart){loopEnd=buf.audioBuf.duration;}if(delta<loopEnd){src.bufOffset=delta;}else{src.bufOffset=loopStart+(delta-loopStart)%(loopEnd-loopStart);}}}else if(src.audioQueue[0]){// The source is still actively playing, so we just need to calculate where we are in the current buffer
// so it can be remembered if the source gets paused.
src.bufOffset=(currentTime-src.audioQueue[0]._startTime)*src.playbackRate;}else{// The source hasn't finished yet, but there is no scheduled audio left for it. This can be because
// the source has just been started/resumed, or due to an underrun caused by a long blocking operation.
// We need to determine what state we would be in by this point in time so that when we next schedule
// audio playback, it will be just as if no underrun occurred.
if(src.type!==4136&&src.looping){// if the source is a looping buffer queue, let's first calculate the queue duration, so we can
// quickly fast forward past any full loops of the queue and only worry about the remainder.
var srcDuration=AL.sourceDuration(src)/src.playbackRate;if(srcDuration>0){src.bufStartTime+=Math.floor((currentTime-src.bufStartTime)/srcDuration)*srcDuration;}}// Since we've already skipped any full-queue loops if there were any, we just need to find
// out where in the queue the remaining time puts us, which won't require stepping through the
// entire queue more than once.
for(var i=0;i<src.bufQueue.length;i++){if(src.bufsProcessed>=src.bufQueue.length){if(src.looping){src.bufsProcessed%=src.bufQueue.length;}else{AL.setSourceState(src,4116);break;}}var buf=src.bufQueue[src.bufsProcessed];if(buf.length>0){nextStartTime=src.bufStartTime+buf.audioBuf.duration/src.playbackRate;if(currentTime<nextStartTime){src.bufOffset=(currentTime-src.bufStartTime)*src.playbackRate;break;}src.bufStartTime=nextStartTime;}src.bufOffset=0;src.bufsProcessed++;}}return currentTime;},cancelPendingSourceAudio:src=>{AL.updateSourceTime(src);for(var i=1;i<src.audioQueue.length;i++){var audioSrc=src.audioQueue[i];audioSrc.stop();}if(src.audioQueue.length>1){src.audioQueue.length=1;}},stopSourceAudio:src=>{for(var i=0;i<src.audioQueue.length;i++){src.audioQueue[i].stop();}src.audioQueue.length=0;},setSourceState:(src,state)=>{if(state===4114){if(src.state===4114||src.state==4116){src.bufsProcessed=0;src.bufOffset=0;}else{}AL.stopSourceAudio(src);src.state=4114;src.bufStartTime=Number.NEGATIVE_INFINITY;AL.scheduleSourceAudio(src);}else if(state===4115){if(src.state===4114){// Store off the current offset to restore with on resume.
AL.updateSourceTime(src);AL.stopSourceAudio(src);src.state=4115;}}else if(state===4116){if(src.state!==4113){src.state=4116;src.bufsProcessed=src.bufQueue.length;src.bufStartTime=Number.NEGATIVE_INFINITY;src.bufOffset=0;AL.stopSourceAudio(src);}}else if(state===4113){if(src.state!==4113){src.state=4113;src.bufsProcessed=0;src.bufStartTime=Number.NEGATIVE_INFINITY;src.bufOffset=0;AL.stopSourceAudio(src);}}},initSourcePanner:src=>{if(src.type===4144)/* AL_UNDETERMINED */{return;}// Find the first non-zero buffer in the queue to determine the proper format
var templateBuf=AL.buffers[0];for(var i=0;i<src.bufQueue.length;i++){if(src.bufQueue[i].id!==0){templateBuf=src.bufQueue[i];break;}}// Create a panner if AL_SOURCE_SPATIALIZE_SOFT is set to true, or alternatively if it's set to auto and the source is mono
if(src.spatialize===1||src.spatialize===2&&/* AL_AUTO_SOFT */templateBuf.channels===1){if(src.panner){return;}src.panner=src.context.audioCtx.createPanner();AL.updateSourceGlobal(src);AL.updateSourceSpace(src);src.panner.connect(src.context.gain);src.gain.disconnect();src.gain.connect(src.panner);}else{if(!src.panner){return;}src.panner.disconnect();src.gain.disconnect();src.gain.connect(src.context.gain);src.panner=null;}},updateContextGlobal:ctx=>{for(var i in ctx.sources){AL.updateSourceGlobal(ctx.sources[i]);}},updateSourceGlobal:src=>{var panner=src.panner;if(!panner){return;}panner.refDistance=src.refDistance;panner.maxDistance=src.maxDistance;panner.rolloffFactor=src.rolloffFactor;panner.panningModel=src.context.hrtf?"HRTF":"equalpower";// Use the source's distance model if AL_SOURCE_DISTANCE_MODEL is enabled
var distanceModel=src.context.sourceDistanceModel?src.distanceModel:src.context.distanceModel;switch(distanceModel){case 0:panner.distanceModel="inverse";panner.refDistance=340282e33;/* FLT_MAX */break;case 53249:/* AL_INVERSE_DISTANCE */case 53250:/* AL_INVERSE_DISTANCE_CLAMPED */panner.distanceModel="inverse";break;case 53251:/* AL_LINEAR_DISTANCE */case 53252:/* AL_LINEAR_DISTANCE_CLAMPED */panner.distanceModel="linear";break;case 53253:/* AL_EXPONENT_DISTANCE */case 53254:/* AL_EXPONENT_DISTANCE_CLAMPED */panner.distanceModel="exponential";break;}},updateListenerSpace:ctx=>{var listener=ctx.audioCtx.listener;if(listener.positionX){listener.positionX.value=ctx.listener.position[0];listener.positionY.value=ctx.listener.position[1];listener.positionZ.value=ctx.listener.position[2];}else{listener.setPosition(ctx.listener.position[0],ctx.listener.position[1],ctx.listener.position[2]);}if(listener.forwardX){listener.forwardX.value=ctx.listener.direction[0];listener.forwardY.value=ctx.listener.direction[1];listener.forwardZ.value=ctx.listener.direction[2];listener.upX.value=ctx.listener.up[0];listener.upY.value=ctx.listener.up[1];listener.upZ.value=ctx.listener.up[2];}else{listener.setOrientation(ctx.listener.direction[0],ctx.listener.direction[1],ctx.listener.direction[2],ctx.listener.up[0],ctx.listener.up[1],ctx.listener.up[2]);}// Update sources that are relative to the listener
for(var i in ctx.sources){AL.updateSourceSpace(ctx.sources[i]);}},updateSourceSpace:src=>{if(!src.panner){return;}var panner=src.panner;var posX=src.position[0];var posY=src.position[1];var posZ=src.position[2];var dirX=src.direction[0];var dirY=src.direction[1];var dirZ=src.direction[2];var listener=src.context.listener;var lPosX=listener.position[0];var lPosY=listener.position[1];var lPosZ=listener.position[2];// WebAudio does spatialization in world-space coordinates, meaning both the buffer sources and
// the listener position are in the same absolute coordinate system relative to a fixed origin.
// By default, OpenAL works this way as well, but it also provides a "listener relative" mode, where
// a buffer source's coordinate are interpreted not in absolute world space, but as being relative
// to the listener object itself, so as the listener moves the source appears to move with it
// with no update required. Since web audio does not support this mode, we must transform the source
// coordinates from listener-relative space to absolute world space.
// We do this via affine transformation matrices applied to the source position and source direction.
// A change-of-basis converts from listener-space displacements to world-space displacements,
// which must be done for both the source position and direction. Lastly, the source position must be
// added to the listener position to get the final source position, since the source position represents
// a displacement from the listener.
if(src.relative){// Negate the listener direction since forward is -Z.
var lBackX=-listener.direction[0];var lBackY=-listener.direction[1];var lBackZ=-listener.direction[2];var lUpX=listener.up[0];var lUpY=listener.up[1];var lUpZ=listener.up[2];var inverseMagnitude=(x,y,z)=>{var length=Math.sqrt(x*x+y*y+z*z);if(length<Number.EPSILON){return 0;}return 1/length;};// Normalize the Back vector
var invMag=inverseMagnitude(lBackX,lBackY,lBackZ);lBackX*=invMag;lBackY*=invMag;lBackZ*=invMag;// ...and the Up vector
invMag=inverseMagnitude(lUpX,lUpY,lUpZ);lUpX*=invMag;lUpY*=invMag;lUpZ*=invMag;// Calculate the Right vector as the cross product of the Up and Back vectors
var lRightX=lUpY*lBackZ-lUpZ*lBackY;var lRightY=lUpZ*lBackX-lUpX*lBackZ;var lRightZ=lUpX*lBackY-lUpY*lBackX;// Back and Up might not be exactly perpendicular, so the cross product also needs normalization
invMag=inverseMagnitude(lRightX,lRightY,lRightZ);lRightX*=invMag;lRightY*=invMag;lRightZ*=invMag;// Recompute Up from the now orthonormal Right and Back vectors so we have a fully orthonormal basis
lUpX=lBackY*lRightZ-lBackZ*lRightY;lUpY=lBackZ*lRightX-lBackX*lRightZ;lUpZ=lBackX*lRightY-lBackY*lRightX;var oldX=dirX;var oldY=dirY;var oldZ=dirZ;// Use our 3 vectors to apply a change-of-basis matrix to the source direction
dirX=oldX*lRightX+oldY*lUpX+oldZ*lBackX;dirY=oldX*lRightY+oldY*lUpY+oldZ*lBackY;dirZ=oldX*lRightZ+oldY*lUpZ+oldZ*lBackZ;oldX=posX;oldY=posY;oldZ=posZ;// ...and to the source position
posX=oldX*lRightX+oldY*lUpX+oldZ*lBackX;posY=oldX*lRightY+oldY*lUpY+oldZ*lBackY;posZ=oldX*lRightZ+oldY*lUpZ+oldZ*lBackZ;// The change-of-basis corrects the orientation, but the origin is still the listener.
// Translate the source position by the listener position to finish.
posX+=lPosX;posY+=lPosY;posZ+=lPosZ;}if(panner.positionX){// Assigning to panner.positionX/Y/Z unnecessarily seems to cause performance issues
// See https://github.com/emscripten-core/emscripten/issues/15847
if(posX!=panner.positionX.value)panner.positionX.value=posX;if(posY!=panner.positionY.value)panner.positionY.value=posY;if(posZ!=panner.positionZ.value)panner.positionZ.value=posZ;}else{panner.setPosition(posX,posY,posZ);}if(panner.orientationX){// Assigning to panner.orientation/Y/Z unnecessarily seems to cause performance issues
// See https://github.com/emscripten-core/emscripten/issues/15847
if(dirX!=panner.orientationX.value)panner.orientationX.value=dirX;if(dirY!=panner.orientationY.value)panner.orientationY.value=dirY;if(dirZ!=panner.orientationZ.value)panner.orientationZ.value=dirZ;}else{panner.setOrientation(dirX,dirY,dirZ);}var oldShift=src.dopplerShift;var velX=src.velocity[0];var velY=src.velocity[1];var velZ=src.velocity[2];var lVelX=listener.velocity[0];var lVelY=listener.velocity[1];var lVelZ=listener.velocity[2];if(posX===lPosX&&posY===lPosY&&posZ===lPosZ||velX===lVelX&&velY===lVelY&&velZ===lVelZ){src.dopplerShift=1;}else{// Doppler algorithm from 1.1 spec
var speedOfSound=src.context.speedOfSound;var dopplerFactor=src.context.dopplerFactor;var slX=lPosX-posX;var slY=lPosY-posY;var slZ=lPosZ-posZ;var magSl=Math.sqrt(slX*slX+slY*slY+slZ*slZ);var vls=(slX*lVelX+slY*lVelY+slZ*lVelZ)/magSl;var vss=(slX*velX+slY*velY+slZ*velZ)/magSl;vls=Math.min(vls,speedOfSound/dopplerFactor);vss=Math.min(vss,speedOfSound/dopplerFactor);src.dopplerShift=(speedOfSound-dopplerFactor*vls)/(speedOfSound-dopplerFactor*vss);}if(src.dopplerShift!==oldShift){AL.updateSourceRate(src);}},updateSourceRate:src=>{if(src.state===4114){// clear scheduled buffers
AL.cancelPendingSourceAudio(src);var audioSrc=src.audioQueue[0];if(!audioSrc){return;}// It is possible that AL.scheduleContextAudio() has not yet fed the next buffer, if so, skip.
var duration;if(src.type===4136&&src.looping){duration=Number.POSITIVE_INFINITY;}else{// audioSrc._duration is expressed after factoring in playbackRate, so when changing playback rate, need
// to recompute/rescale the rate to the new playback speed.
duration=(audioSrc.buffer.duration-audioSrc._startOffset)/src.playbackRate;}audioSrc._duration=duration;audioSrc.playbackRate.value=src.playbackRate;// reschedule buffers with the new playbackRate
AL.scheduleSourceAudio(src);}},sourceDuration:src=>{var length=0;for(var i=0;i<src.bufQueue.length;i++){var audioBuf=src.bufQueue[i].audioBuf;length+=audioBuf?audioBuf.duration:0;}return length;},sourceTell:src=>{AL.updateSourceTime(src);var offset=0;for(var i=0;i<src.bufsProcessed;i++){if(src.bufQueue[i].audioBuf){offset+=src.bufQueue[i].audioBuf.duration;}}offset+=src.bufOffset;return offset;},sourceSeek:(src,offset)=>{var playing=src.state==4114;if(playing){AL.setSourceState(src,4113);}if(src.bufQueue[src.bufsProcessed].audioBuf!==null){src.bufsProcessed=0;while(offset>src.bufQueue[src.bufsProcessed].audioBuf.duration){offset-=src.bufQueue[src.bufsProcessed].audioBuf.duration;src.bufsProcessed++;}src.bufOffset=offset;}if(playing){AL.setSourceState(src,4114);}},getGlobalParam:(funcname,param)=>{if(!AL.currentCtx){return null;}switch(param){case 49152:return AL.currentCtx.dopplerFactor;case 49155:return AL.currentCtx.speedOfSound;case 53248:return AL.currentCtx.distanceModel;default:AL.currentCtx.err=40962;return null;}},setGlobalParam:(funcname,param,value)=>{if(!AL.currentCtx){return;}switch(param){case 49152:if(!Number.isFinite(value)||value<0){// Strictly negative values are disallowed
AL.currentCtx.err=40963;return;}AL.currentCtx.dopplerFactor=value;AL.updateListenerSpace(AL.currentCtx);break;case 49155:if(!Number.isFinite(value)||value<=0){// Negative or zero values are disallowed
AL.currentCtx.err=40963;return;}AL.currentCtx.speedOfSound=value;AL.updateListenerSpace(AL.currentCtx);break;case 53248:switch(value){case 0:case 53249:/* AL_INVERSE_DISTANCE */case 53250:/* AL_INVERSE_DISTANCE_CLAMPED */case 53251:/* AL_LINEAR_DISTANCE */case 53252:/* AL_LINEAR_DISTANCE_CLAMPED */case 53253:/* AL_EXPONENT_DISTANCE */case 53254:/* AL_EXPONENT_DISTANCE_CLAMPED */AL.currentCtx.distanceModel=value;AL.updateContextGlobal(AL.currentCtx);break;default:AL.currentCtx.err=40963;return;}break;default:AL.currentCtx.err=40962;return;}},getListenerParam:(funcname,param)=>{if(!AL.currentCtx){return null;}switch(param){case 4100:return AL.currentCtx.listener.position;case 4102:return AL.currentCtx.listener.velocity;case 4111:return AL.currentCtx.listener.direction.concat(AL.currentCtx.listener.up);case 4106:return AL.currentCtx.gain.gain.value;default:AL.currentCtx.err=40962;return null;}},setListenerParam:(funcname,param,value)=>{if(!AL.currentCtx){return;}if(value===null){AL.currentCtx.err=40962;return;}var listener=AL.currentCtx.listener;switch(param){case 4100:if(!Number.isFinite(value[0])||!Number.isFinite(value[1])||!Number.isFinite(value[2])){AL.currentCtx.err=40963;return;}listener.position[0]=value[0];listener.position[1]=value[1];listener.position[2]=value[2];AL.updateListenerSpace(AL.currentCtx);break;case 4102:if(!Number.isFinite(value[0])||!Number.isFinite(value[1])||!Number.isFinite(value[2])){AL.currentCtx.err=40963;return;}listener.velocity[0]=value[0];listener.velocity[1]=value[1];listener.velocity[2]=value[2];AL.updateListenerSpace(AL.currentCtx);break;case 4106:if(!Number.isFinite(value)||value<0){AL.currentCtx.err=40963;return;}AL.currentCtx.gain.gain.value=value;break;case 4111:if(!Number.isFinite(value[0])||!Number.isFinite(value[1])||!Number.isFinite(value[2])||!Number.isFinite(value[3])||!Number.isFinite(value[4])||!Number.isFinite(value[5])){AL.currentCtx.err=40963;return;}listener.direction[0]=value[0];listener.direction[1]=value[1];listener.direction[2]=value[2];listener.up[0]=value[3];listener.up[1]=value[4];listener.up[2]=value[5];AL.updateListenerSpace(AL.currentCtx);break;default:AL.currentCtx.err=40962;return;}},getBufferParam:(funcname,bufferId,param)=>{if(!AL.currentCtx){return;}var buf=AL.buffers[bufferId];if(!buf||bufferId===0){AL.currentCtx.err=40961;return;}switch(param){case 8193:/* AL_FREQUENCY */return buf.frequency;case 8194:/* AL_BITS */return buf.bytesPerSample*8;case 8195:/* AL_CHANNELS */return buf.channels;case 8196:/* AL_SIZE */return buf.length*buf.bytesPerSample*buf.channels;case 8213:/* AL_LOOP_POINTS_SOFT */if(buf.length===0){return[0,0];}return[(buf.audioBuf._loopStart||0)*buf.frequency,(buf.audioBuf._loopEnd||buf.length)*buf.frequency];default:AL.currentCtx.err=40962;return null;}},setBufferParam:(funcname,bufferId,param,value)=>{if(!AL.currentCtx){return;}var buf=AL.buffers[bufferId];if(!buf||bufferId===0){AL.currentCtx.err=40961;return;}if(value===null){AL.currentCtx.err=40962;return;}switch(param){case 8196:/* AL_SIZE */if(value!==0){AL.currentCtx.err=40963;return;}// Per the spec, setting AL_SIZE to 0 is a legal NOP.
break;case 8213:/* AL_LOOP_POINTS_SOFT */if(value[0]<0||value[0]>buf.length||value[1]<0||value[1]>buf.Length||value[0]>=value[1]){AL.currentCtx.err=40963;return;}if(buf.refCount>0){AL.currentCtx.err=40964;return;}if(buf.audioBuf){buf.audioBuf._loopStart=value[0]/buf.frequency;buf.audioBuf._loopEnd=value[1]/buf.frequency;}break;default:AL.currentCtx.err=40962;return;}},getSourceParam:(funcname,sourceId,param)=>{if(!AL.currentCtx){return null;}var src=AL.currentCtx.sources[sourceId];if(!src){AL.currentCtx.err=40961;return null;}switch(param){case 514:/* AL_SOURCE_RELATIVE */return src.relative;case 4097:/* AL_CONE_INNER_ANGLE */return src.coneInnerAngle;case 4098:/* AL_CONE_OUTER_ANGLE */return src.coneOuterAngle;case 4099:/* AL_PITCH */return src.pitch;case 4100:return src.position;case 4101:return src.direction;case 4102:return src.velocity;case 4103:/* AL_LOOPING */return src.looping;case 4105:/* AL_BUFFER */if(src.type===4136){return src.bufQueue[0].id;}return 0;case 4106:return src.gain.gain.value;case 4109:/* AL_MIN_GAIN */return src.minGain;case 4110:/* AL_MAX_GAIN */return src.maxGain;case 4112:/* AL_SOURCE_STATE */return src.state;case 4117:/* AL_BUFFERS_QUEUED */if(src.bufQueue.length===1&&src.bufQueue[0].id===0){return 0;}return src.bufQueue.length;case 4118:/* AL_BUFFERS_PROCESSED */if(src.bufQueue.length===1&&src.bufQueue[0].id===0||src.looping){return 0;}return src.bufsProcessed;case 4128:/* AL_REFERENCE_DISTANCE */return src.refDistance;case 4129:/* AL_ROLLOFF_FACTOR */return src.rolloffFactor;case 4130:/* AL_CONE_OUTER_GAIN */return src.coneOuterGain;case 4131:/* AL_MAX_DISTANCE */return src.maxDistance;case 4132:/* AL_SEC_OFFSET */return AL.sourceTell(src);case 4133:/* AL_SAMPLE_OFFSET */var offset=AL.sourceTell(src);if(offset>0){offset*=src.bufQueue[0].frequency;}return offset;case 4134:/* AL_BYTE_OFFSET */var offset=AL.sourceTell(src);if(offset>0){offset*=src.bufQueue[0].frequency*src.bufQueue[0].bytesPerSample;}return offset;case 4135:/* AL_SOURCE_TYPE */return src.type;case 4628:/* AL_SOURCE_SPATIALIZE_SOFT */return src.spatialize;case 8201:/* AL_BYTE_LENGTH_SOFT */var length=0;var bytesPerFrame=0;for(var i=0;i<src.bufQueue.length;i++){length+=src.bufQueue[i].length;if(src.bufQueue[i].id!==0){bytesPerFrame=src.bufQueue[i].bytesPerSample*src.bufQueue[i].channels;}}return length*bytesPerFrame;case 8202:/* AL_SAMPLE_LENGTH_SOFT */var length=0;for(var i=0;i<src.bufQueue.length;i++){length+=src.bufQueue[i].length;}return length;case 8203:/* AL_SEC_LENGTH_SOFT */return AL.sourceDuration(src);case 53248:return src.distanceModel;default:AL.currentCtx.err=40962;return null;}},setSourceParam:(funcname,sourceId,param,value)=>{if(!AL.currentCtx){return;}var src=AL.currentCtx.sources[sourceId];if(!src){AL.currentCtx.err=40961;return;}if(value===null){AL.currentCtx.err=40962;return;}switch(param){case 514:/* AL_SOURCE_RELATIVE */if(value===1){src.relative=true;AL.updateSourceSpace(src);}else if(value===0){src.relative=false;AL.updateSourceSpace(src);}else{AL.currentCtx.err=40963;return;}break;case 4097:/* AL_CONE_INNER_ANGLE */if(!Number.isFinite(value)){AL.currentCtx.err=40963;return;}src.coneInnerAngle=value;if(src.panner){src.panner.coneInnerAngle=value%360;}break;case 4098:/* AL_CONE_OUTER_ANGLE */if(!Number.isFinite(value)){AL.currentCtx.err=40963;return;}src.coneOuterAngle=value;if(src.panner){src.panner.coneOuterAngle=value%360;}break;case 4099:/* AL_PITCH */if(!Number.isFinite(value)||value<=0){AL.currentCtx.err=40963;return;}if(src.pitch===value){break;}src.pitch=value;AL.updateSourceRate(src);break;case 4100:if(!Number.isFinite(value[0])||!Number.isFinite(value[1])||!Number.isFinite(value[2])){AL.currentCtx.err=40963;return;}src.position[0]=value[0];src.position[1]=value[1];src.position[2]=value[2];AL.updateSourceSpace(src);break;case 4101:if(!Number.isFinite(value[0])||!Number.isFinite(value[1])||!Number.isFinite(value[2])){AL.currentCtx.err=40963;return;}src.direction[0]=value[0];src.direction[1]=value[1];src.direction[2]=value[2];AL.updateSourceSpace(src);break;case 4102:if(!Number.isFinite(value[0])||!Number.isFinite(value[1])||!Number.isFinite(value[2])){AL.currentCtx.err=40963;return;}src.velocity[0]=value[0];src.velocity[1]=value[1];src.velocity[2]=value[2];AL.updateSourceSpace(src);break;case 4103:/* AL_LOOPING */if(value===1){src.looping=true;AL.updateSourceTime(src);if(src.type===4136&&src.audioQueue.length>0){var audioSrc=src.audioQueue[0];audioSrc.loop=true;audioSrc._duration=Number.POSITIVE_INFINITY;}}else if(value===0){src.looping=false;var currentTime=AL.updateSourceTime(src);if(src.type===4136&&src.audioQueue.length>0){var audioSrc=src.audioQueue[0];audioSrc.loop=false;audioSrc._duration=src.bufQueue[0].audioBuf.duration/src.playbackRate;audioSrc._startTime=currentTime-src.bufOffset/src.playbackRate;}}else{AL.currentCtx.err=40963;return;}break;case 4105:/* AL_BUFFER */if(src.state===4114||src.state===4115){AL.currentCtx.err=40964;return;}if(value===0){for(var i in src.bufQueue){src.bufQueue[i].refCount--;}src.bufQueue.length=1;src.bufQueue[0]=AL.buffers[0];src.bufsProcessed=0;src.type=4144;}else/* AL_UNDETERMINED */{var buf=AL.buffers[value];if(!buf){AL.currentCtx.err=40963;return;}for(var i in src.bufQueue){src.bufQueue[i].refCount--;}src.bufQueue.length=0;buf.refCount++;src.bufQueue=[buf];src.bufsProcessed=0;src.type=4136;}AL.initSourcePanner(src);AL.scheduleSourceAudio(src);break;case 4106:if(!Number.isFinite(value)||value<0){AL.currentCtx.err=40963;return;}src.gain.gain.value=value;break;case 4109:/* AL_MIN_GAIN */if(!Number.isFinite(value)||value<0||value>Math.min(src.maxGain,1)){AL.currentCtx.err=40963;return;}src.minGain=value;break;case 4110:/* AL_MAX_GAIN */if(!Number.isFinite(value)||value<Math.max(0,src.minGain)||value>1){AL.currentCtx.err=40963;return;}src.maxGain=value;break;case 4128:/* AL_REFERENCE_DISTANCE */if(!Number.isFinite(value)||value<0){AL.currentCtx.err=40963;return;}src.refDistance=value;if(src.panner){src.panner.refDistance=value;}break;case 4129:/* AL_ROLLOFF_FACTOR */if(!Number.isFinite(value)||value<0){AL.currentCtx.err=40963;return;}src.rolloffFactor=value;if(src.panner){src.panner.rolloffFactor=value;}break;case 4130:/* AL_CONE_OUTER_GAIN */if(!Number.isFinite(value)||value<0||value>1){AL.currentCtx.err=40963;return;}src.coneOuterGain=value;if(src.panner){src.panner.coneOuterGain=value;}break;case 4131:/* AL_MAX_DISTANCE */if(!Number.isFinite(value)||value<0){AL.currentCtx.err=40963;return;}src.maxDistance=value;if(src.panner){src.panner.maxDistance=value;}break;case 4132:/* AL_SEC_OFFSET */if(value<0||value>AL.sourceDuration(src)){AL.currentCtx.err=40963;return;}AL.sourceSeek(src,value);break;case 4133:/* AL_SAMPLE_OFFSET */var srcLen=AL.sourceDuration(src);if(srcLen>0){var frequency;for(var bufId in src.bufQueue){if(bufId){frequency=src.bufQueue[bufId].frequency;break;}}value/=frequency;}if(value<0||value>srcLen){AL.currentCtx.err=40963;return;}AL.sourceSeek(src,value);break;case 4134:/* AL_BYTE_OFFSET */var srcLen=AL.sourceDuration(src);if(srcLen>0){var bytesPerSec;for(var bufId in src.bufQueue){if(bufId){var buf=src.bufQueue[bufId];bytesPerSec=buf.frequency*buf.bytesPerSample*buf.channels;break;}}value/=bytesPerSec;}if(value<0||value>srcLen){AL.currentCtx.err=40963;return;}AL.sourceSeek(src,value);break;case 4628:/* AL_SOURCE_SPATIALIZE_SOFT */if(value!==0&&value!==1&&value!==2)/* AL_AUTO_SOFT */{AL.currentCtx.err=40963;return;}src.spatialize=value;AL.initSourcePanner(src);break;case 8201:/* AL_BYTE_LENGTH_SOFT */case 8202:/* AL_SAMPLE_LENGTH_SOFT */case 8203:/* AL_SEC_LENGTH_SOFT */AL.currentCtx.err=40964;break;case 53248:switch(value){case 0:case 53249:/* AL_INVERSE_DISTANCE */case 53250:/* AL_INVERSE_DISTANCE_CLAMPED */case 53251:/* AL_LINEAR_DISTANCE */case 53252:/* AL_LINEAR_DISTANCE_CLAMPED */case 53253:/* AL_EXPONENT_DISTANCE */case 53254:/* AL_EXPONENT_DISTANCE_CLAMPED */src.distanceModel=value;if(AL.currentCtx.sourceDistanceModel){AL.updateContextGlobal(AL.currentCtx);}break;default:AL.currentCtx.err=40963;return;}break;default:AL.currentCtx.err=40962;return;}},captures:{},sharedCaptureAudioCtx:null,requireValidCaptureDevice:(deviceId,funcname)=>{if(deviceId===0){AL.alcErr=40961;return null;}var c=AL.captures[deviceId];if(!c){AL.alcErr=40961;return null;}var err=c.mediaStreamError;if(err){AL.alcErr=40961;return null;}return c;}};var _alBuffer3f=(bufferId,param,value0,value1,value2)=>{AL.setBufferParam("alBuffer3f",bufferId,param,null);};_alBuffer3f.sig="viifff";var _alBuffer3i=(bufferId,param,value0,value1,value2)=>{AL.setBufferParam("alBuffer3i",bufferId,param,null);};_alBuffer3i.sig="viiiii";function _alBufferData(bufferId,format,pData,size,freq){pData>>>=0;if(!AL.currentCtx){return;}var buf=AL.buffers[bufferId];if(!buf){AL.currentCtx.err=40963;return;}if(freq<=0){AL.currentCtx.err=40963;return;}var audioBuf=null;try{switch(format){case 4352:/* AL_FORMAT_MONO8 */if(size>0){audioBuf=AL.currentCtx.audioCtx.createBuffer(1,size,freq);var channel0=audioBuf.getChannelData(0);for(var i=0;i<size;++i){channel0[i]=HEAPU8[pData++>>>0]*.0078125-/* 1/128 */1;}}buf.bytesPerSample=1;buf.channels=1;buf.length=size;break;case 4353:/* AL_FORMAT_MONO16 */if(size>0){audioBuf=AL.currentCtx.audioCtx.createBuffer(1,size>>1,freq);var channel0=audioBuf.getChannelData(0);pData>>=1;for(var i=0;i<size>>1;++i){channel0[i]=HEAP16[pData++>>>0]*30517578125e-15;}}buf.bytesPerSample=2;buf.channels=1;buf.length=size>>1;break;case 4354:/* AL_FORMAT_STEREO8 */if(size>0){audioBuf=AL.currentCtx.audioCtx.createBuffer(2,size>>1,freq);var channel0=audioBuf.getChannelData(0);var channel1=audioBuf.getChannelData(1);for(var i=0;i<size>>1;++i){channel0[i]=HEAPU8[pData++>>>0]*.0078125-/* 1/128 */1;channel1[i]=HEAPU8[pData++>>>0]*.0078125-/* 1/128 */1;}}buf.bytesPerSample=1;buf.channels=2;buf.length=size>>1;break;case 4355:/* AL_FORMAT_STEREO16 */if(size>0){audioBuf=AL.currentCtx.audioCtx.createBuffer(2,size>>2,freq);var channel0=audioBuf.getChannelData(0);var channel1=audioBuf.getChannelData(1);pData>>=1;for(var i=0;i<size>>2;++i){channel0[i]=HEAP16[pData++>>>0]*30517578125e-15;/* 1/32768 */channel1[i]=HEAP16[pData++>>>0]*30517578125e-15;}}buf.bytesPerSample=2;buf.channels=2;buf.length=size>>2;break;case 65552:/* AL_FORMAT_MONO_FLOAT32 */if(size>0){audioBuf=AL.currentCtx.audioCtx.createBuffer(1,size>>2,freq);var channel0=audioBuf.getChannelData(0);pData>>=2;for(var i=0;i<size>>2;++i){channel0[i]=HEAPF32[pData++>>>0];}}buf.bytesPerSample=4;buf.channels=1;buf.length=size>>2;break;case 65553:/* AL_FORMAT_STEREO_FLOAT32 */if(size>0){audioBuf=AL.currentCtx.audioCtx.createBuffer(2,size>>3,freq);var channel0=audioBuf.getChannelData(0);var channel1=audioBuf.getChannelData(1);pData>>=2;for(var i=0;i<size>>3;++i){channel0[i]=HEAPF32[pData++>>>0];channel1[i]=HEAPF32[pData++>>>0];}}buf.bytesPerSample=4;buf.channels=2;buf.length=size>>3;break;default:AL.currentCtx.err=40963;return;}buf.frequency=freq;buf.audioBuf=audioBuf;}catch(e){AL.currentCtx.err=40963;return;}}_alBufferData.sig="viipii";var _alBufferf=(bufferId,param,value)=>{AL.setBufferParam("alBufferf",bufferId,param,null);};_alBufferf.sig="viif";function _alBufferfv(bufferId,param,pValues){pValues>>>=0;if(!AL.currentCtx){return;}if(!pValues){AL.currentCtx.err=40963;return;}AL.setBufferParam("alBufferfv",bufferId,param,null);}_alBufferfv.sig="viip";var _alBufferi=(bufferId,param,value)=>{AL.setBufferParam("alBufferi",bufferId,param,null);};_alBufferi.sig="viii";function _alBufferiv(bufferId,param,pValues){pValues>>>=0;if(!AL.currentCtx){return;}if(!pValues){AL.currentCtx.err=40963;return;}switch(param){case 8213:/* AL_LOOP_POINTS_SOFT */AL.paramArray[0]=HEAP32[pValues>>>2>>>0];AL.paramArray[1]=HEAP32[pValues+4>>>2>>>0];AL.setBufferParam("alBufferiv",bufferId,param,AL.paramArray);break;default:AL.setBufferParam("alBufferiv",bufferId,param,null);break;}}_alBufferiv.sig="viip";function _alDeleteBuffers(count,pBufferIds){pBufferIds>>>=0;if(!AL.currentCtx){return;}for(var i=0;i<count;++i){var bufId=HEAP32[pBufferIds+i*4>>>2>>>0];/// Deleting the zero buffer is a legal NOP, so ignore it
if(bufId===0){continue;}// Make sure the buffer index is valid.
if(!AL.buffers[bufId]){AL.currentCtx.err=40961;return;}// Make sure the buffer is no longer in use.
if(AL.buffers[bufId].refCount){AL.currentCtx.err=40964;return;}}for(var i=0;i<count;++i){var bufId=HEAP32[pBufferIds+i*4>>>2>>>0];if(bufId===0){continue;}AL.deviceRefCounts[AL.buffers[bufId].deviceId]--;delete AL.buffers[bufId];AL.freeIds.push(bufId);}}_alDeleteBuffers.sig="vip";var _alSourcei=(sourceId,param,value)=>{switch(param){case 514:/* AL_SOURCE_RELATIVE */case 4097:/* AL_CONE_INNER_ANGLE */case 4098:/* AL_CONE_OUTER_ANGLE */case 4103:/* AL_LOOPING */case 4105:/* AL_BUFFER */case 4128:/* AL_REFERENCE_DISTANCE */case 4129:/* AL_ROLLOFF_FACTOR */case 4131:/* AL_MAX_DISTANCE */case 4132:/* AL_SEC_OFFSET */case 4133:/* AL_SAMPLE_OFFSET */case 4134:/* AL_BYTE_OFFSET */case 4628:/* AL_SOURCE_SPATIALIZE_SOFT */case 8201:/* AL_BYTE_LENGTH_SOFT */case 8202:/* AL_SAMPLE_LENGTH_SOFT */case 53248:AL.setSourceParam("alSourcei",sourceId,param,value);break;default:AL.setSourceParam("alSourcei",sourceId,param,null);break;}};_alSourcei.sig="viii";function _alDeleteSources(count,pSourceIds){pSourceIds>>>=0;if(!AL.currentCtx){return;}for(var i=0;i<count;++i){var srcId=HEAP32[pSourceIds+i*4>>>2>>>0];if(!AL.currentCtx.sources[srcId]){AL.currentCtx.err=40961;return;}}for(var i=0;i<count;++i){var srcId=HEAP32[pSourceIds+i*4>>>2>>>0];AL.setSourceState(AL.currentCtx.sources[srcId],4116);_alSourcei(srcId,4105,/* AL_BUFFER */0);delete AL.currentCtx.sources[srcId];AL.freeIds.push(srcId);}}_alDeleteSources.sig="vip";var _alDisable=param=>{if(!AL.currentCtx){return;}switch(param){case 512:/* AL_SOURCE_DISTANCE_MODEL */AL.currentCtx.sourceDistanceModel=false;AL.updateContextGlobal(AL.currentCtx);break;default:AL.currentCtx.err=40962;return;}};_alDisable.sig="vi";var _alDistanceModel=model=>{AL.setGlobalParam("alDistanceModel",53248,model);};_alDistanceModel.sig="vi";var _alDopplerFactor=value=>{AL.setGlobalParam("alDopplerFactor",49152,value);};_alDopplerFactor.sig="vf";var _alDopplerVelocity=value=>{warnOnce("alDopplerVelocity() is deprecated, and only kept for compatibility with OpenAL 1.0. Use alSpeedOfSound() instead.");if(!AL.currentCtx){return;}if(value<=0){// Negative or zero values are disallowed
AL.currentCtx.err=40963;return;}};_alDopplerVelocity.sig="vf";var _alEnable=param=>{if(!AL.currentCtx){return;}switch(param){case 512:/* AL_SOURCE_DISTANCE_MODEL */AL.currentCtx.sourceDistanceModel=true;AL.updateContextGlobal(AL.currentCtx);break;default:AL.currentCtx.err=40962;return;}};_alEnable.sig="vi";function _alGenBuffers(count,pBufferIds){pBufferIds>>>=0;if(!AL.currentCtx){return;}for(var i=0;i<count;++i){var buf={deviceId:AL.currentCtx.deviceId,id:AL.newId(),refCount:0,audioBuf:null,frequency:0,bytesPerSample:2,channels:1,length:0};AL.deviceRefCounts[buf.deviceId]++;AL.buffers[buf.id]=buf;HEAP32[pBufferIds+i*4>>>2>>>0]=buf.id;}}_alGenBuffers.sig="vip";function _alGenSources(count,pSourceIds){pSourceIds>>>=0;if(!AL.currentCtx){return;}for(var i=0;i<count;++i){var gain=AL.currentCtx.audioCtx.createGain();gain.connect(AL.currentCtx.gain);var src={context:AL.currentCtx,id:AL.newId(),type:4144,/* AL_UNDETERMINED */state:4113,bufQueue:[AL.buffers[0]],audioQueue:[],looping:false,pitch:1,dopplerShift:1,gain,minGain:0,maxGain:1,panner:null,bufsProcessed:0,bufStartTime:Number.NEGATIVE_INFINITY,bufOffset:0,relative:false,refDistance:1,maxDistance:340282e33,/* FLT_MAX */rolloffFactor:1,position:[0,0,0],velocity:[0,0,0],direction:[0,0,0],coneOuterGain:0,coneInnerAngle:360,coneOuterAngle:360,distanceModel:53250,/* AL_INVERSE_DISTANCE_CLAMPED */spatialize:2,/* AL_AUTO_SOFT */get playbackRate(){return this.pitch*this.dopplerShift;}};AL.currentCtx.sources[src.id]=src;HEAP32[pSourceIds+i*4>>>2>>>0]=src.id;}}_alGenSources.sig="vip";var _alGetBoolean=param=>{var val=AL.getGlobalParam("alGetBoolean",param);if(val===null){return 0;}switch(param){case 49152:case 49155:case 53248:return val!==0?1:0;default:AL.currentCtx.err=40962;return 0;}};_alGetBoolean.sig="ii";function _alGetBooleanv(param,pValues){pValues>>>=0;var val=AL.getGlobalParam("alGetBooleanv",param);// Silently ignore null destinations, as per the spec for global state functions
if(val===null||!pValues){return;}switch(param){case 49152:case 49155:case 53248:HEAP8[pValues>>>0]=val;break;default:AL.currentCtx.err=40962;return;}}_alGetBooleanv.sig="vip";function _alGetBuffer3f(bufferId,param,pValue0,pValue1,pValue2){pValue0>>>=0;pValue1>>>=0;pValue2>>>=0;var val=AL.getBufferParam("alGetBuffer3f",bufferId,param);if(val===null){return;}if(!pValue0||!pValue1||!pValue2){AL.currentCtx.err=40963;return;}AL.currentCtx.err=40962;}_alGetBuffer3f.sig="viippp";function _alGetBuffer3i(bufferId,param,pValue0,pValue1,pValue2){pValue0>>>=0;pValue1>>>=0;pValue2>>>=0;var val=AL.getBufferParam("alGetBuffer3i",bufferId,param);if(val===null){return;}if(!pValue0||!pValue1||!pValue2){AL.currentCtx.err=40963;return;}AL.currentCtx.err=40962;}_alGetBuffer3i.sig="viippp";function _alGetBufferf(bufferId,param,pValue){pValue>>>=0;var val=AL.getBufferParam("alGetBufferf",bufferId,param);if(val===null){return;}if(!pValue){AL.currentCtx.err=40963;return;}AL.currentCtx.err=40962;}_alGetBufferf.sig="viip";function _alGetBufferfv(bufferId,param,pValues){pValues>>>=0;var val=AL.getBufferParam("alGetBufferfv",bufferId,param);if(val===null){return;}if(!pValues){AL.currentCtx.err=40963;return;}AL.currentCtx.err=40962;}_alGetBufferfv.sig="viip";function _alGetBufferi(bufferId,param,pValue){pValue>>>=0;var val=AL.getBufferParam("alGetBufferi",bufferId,param);if(val===null){return;}if(!pValue){AL.currentCtx.err=40963;return;}switch(param){case 8193:/* AL_FREQUENCY */case 8194:/* AL_BITS */case 8195:/* AL_CHANNELS */case 8196:/* AL_SIZE */HEAP32[pValue>>>2>>>0]=val;break;default:AL.currentCtx.err=40962;return;}}_alGetBufferi.sig="viip";function _alGetBufferiv(bufferId,param,pValues){pValues>>>=0;var val=AL.getBufferParam("alGetBufferiv",bufferId,param);if(val===null){return;}if(!pValues){AL.currentCtx.err=40963;return;}switch(param){case 8193:/* AL_FREQUENCY */case 8194:/* AL_BITS */case 8195:/* AL_CHANNELS */case 8196:/* AL_SIZE */HEAP32[pValues>>>2>>>0]=val;break;case 8213:/* AL_LOOP_POINTS_SOFT */HEAP32[pValues>>>2>>>0]=val[0];HEAP32[pValues+4>>>2>>>0]=val[1];break;default:AL.currentCtx.err=40962;return;}}_alGetBufferiv.sig="viip";var _alGetDouble=param=>{var val=AL.getGlobalParam("alGetDouble",param);if(val===null){return 0;}switch(param){case 49152:case 49155:case 53248:return val;default:AL.currentCtx.err=40962;return 0;}};_alGetDouble.sig="di";function _alGetDoublev(param,pValues){pValues>>>=0;var val=AL.getGlobalParam("alGetDoublev",param);// Silently ignore null destinations, as per the spec for global state functions
if(val===null||!pValues){return;}switch(param){case 49152:case 49155:case 53248:HEAPF64[pValues>>>3>>>0]=val;break;default:AL.currentCtx.err=40962;return;}}_alGetDoublev.sig="vip";function _alGetEnumValue(pEnumName){pEnumName>>>=0;if(!AL.currentCtx){return 0;}if(!pEnumName){AL.currentCtx.err=40963;return 0;}var name=UTF8ToString(pEnumName);switch(name){// Spec doesn't clearly state that alGetEnumValue() is required to
// support _only_ extension tokens.
// We should probably follow OpenAL-Soft's example and support all
// of the names we know.
// See http://repo.or.cz/openal-soft.git/blob/HEAD:/Alc/ALc.c
case"AL_BITS":return 8194;case"AL_BUFFER":return 4105;case"AL_BUFFERS_PROCESSED":return 4118;case"AL_BUFFERS_QUEUED":return 4117;case"AL_BYTE_OFFSET":return 4134;case"AL_CHANNELS":return 8195;case"AL_CONE_INNER_ANGLE":return 4097;case"AL_CONE_OUTER_ANGLE":return 4098;case"AL_CONE_OUTER_GAIN":return 4130;case"AL_DIRECTION":return 4101;case"AL_DISTANCE_MODEL":return 53248;case"AL_DOPPLER_FACTOR":return 49152;case"AL_DOPPLER_VELOCITY":return 49153;case"AL_EXPONENT_DISTANCE":return 53253;case"AL_EXPONENT_DISTANCE_CLAMPED":return 53254;case"AL_EXTENSIONS":return 45060;case"AL_FORMAT_MONO16":return 4353;case"AL_FORMAT_MONO8":return 4352;case"AL_FORMAT_STEREO16":return 4355;case"AL_FORMAT_STEREO8":return 4354;case"AL_FREQUENCY":return 8193;case"AL_GAIN":return 4106;case"AL_INITIAL":return 4113;case"AL_INVALID":return-1;case"AL_ILLEGAL_ENUM":// fallthrough
case"AL_INVALID_ENUM":return 40962;case"AL_INVALID_NAME":return 40961;case"AL_ILLEGAL_COMMAND":// fallthrough
case"AL_INVALID_OPERATION":return 40964;case"AL_INVALID_VALUE":return 40963;case"AL_INVERSE_DISTANCE":return 53249;case"AL_INVERSE_DISTANCE_CLAMPED":return 53250;case"AL_LINEAR_DISTANCE":return 53251;case"AL_LINEAR_DISTANCE_CLAMPED":return 53252;case"AL_LOOPING":return 4103;case"AL_MAX_DISTANCE":return 4131;case"AL_MAX_GAIN":return 4110;case"AL_MIN_GAIN":return 4109;case"AL_NONE":return 0;case"AL_NO_ERROR":return 0;case"AL_ORIENTATION":return 4111;case"AL_OUT_OF_MEMORY":return 40965;case"AL_PAUSED":return 4115;case"AL_PENDING":return 8209;case"AL_PITCH":return 4099;case"AL_PLAYING":return 4114;case"AL_POSITION":return 4100;case"AL_PROCESSED":return 8210;case"AL_REFERENCE_DISTANCE":return 4128;case"AL_RENDERER":return 45059;case"AL_ROLLOFF_FACTOR":return 4129;case"AL_SAMPLE_OFFSET":return 4133;case"AL_SEC_OFFSET":return 4132;case"AL_SIZE":return 8196;case"AL_SOURCE_RELATIVE":return 514;case"AL_SOURCE_STATE":return 4112;case"AL_SOURCE_TYPE":return 4135;case"AL_SPEED_OF_SOUND":return 49155;case"AL_STATIC":return 4136;case"AL_STOPPED":return 4116;case"AL_STREAMING":return 4137;case"AL_UNDETERMINED":return 4144;case"AL_UNUSED":return 8208;case"AL_VELOCITY":return 4102;case"AL_VENDOR":return 45057;case"AL_VERSION":return 45058;/* Extensions */case"AL_AUTO_SOFT":return 2;case"AL_SOURCE_DISTANCE_MODEL":return 512;case"AL_SOURCE_SPATIALIZE_SOFT":return 4628;case"AL_LOOP_POINTS_SOFT":return 8213;case"AL_BYTE_LENGTH_SOFT":return 8201;case"AL_SAMPLE_LENGTH_SOFT":return 8202;case"AL_SEC_LENGTH_SOFT":return 8203;case"AL_FORMAT_MONO_FLOAT32":return 65552;case"AL_FORMAT_STEREO_FLOAT32":return 65553;default:AL.currentCtx.err=40963;return 0;}}_alGetEnumValue.sig="ip";var _alGetError=()=>{if(!AL.currentCtx){return 40964;}// Reset error on get.
var err=AL.currentCtx.err;AL.currentCtx.err=0;return err;};_alGetError.sig="i";var _alGetFloat=param=>{var val=AL.getGlobalParam("alGetFloat",param);if(val===null){return 0;}switch(param){case 49152:case 49155:case 53248:return val;default:return 0;}};_alGetFloat.sig="fi";function _alGetFloatv(param,pValues){pValues>>>=0;var val=AL.getGlobalParam("alGetFloatv",param);// Silently ignore null destinations, as per the spec for global state functions
if(val===null||!pValues){return;}switch(param){case 49152:case 49155:case 53248:HEAPF32[pValues>>>2>>>0]=val;break;default:AL.currentCtx.err=40962;return;}}_alGetFloatv.sig="vip";var _alGetInteger=param=>{var val=AL.getGlobalParam("alGetInteger",param);if(val===null){return 0;}switch(param){case 49152:case 49155:case 53248:return val;default:AL.currentCtx.err=40962;return 0;}};_alGetInteger.sig="ii";function _alGetIntegerv(param,pValues){pValues>>>=0;var val=AL.getGlobalParam("alGetIntegerv",param);// Silently ignore null destinations, as per the spec for global state functions
if(val===null||!pValues){return;}switch(param){case 49152:case 49155:case 53248:HEAP32[pValues>>>2>>>0]=val;break;default:AL.currentCtx.err=40962;return;}}_alGetIntegerv.sig="vip";function _alGetListener3f(param,pValue0,pValue1,pValue2){pValue0>>>=0;pValue1>>>=0;pValue2>>>=0;var val=AL.getListenerParam("alGetListener3f",param);if(val===null){return;}if(!pValue0||!pValue1||!pValue2){AL.currentCtx.err=40963;return;}switch(param){case 4100:case 4102:HEAPF32[pValue0>>>2>>>0]=val[0];HEAPF32[pValue1>>>2>>>0]=val[1];HEAPF32[pValue2>>>2>>>0]=val[2];break;default:AL.currentCtx.err=40962;return;}}_alGetListener3f.sig="vippp";function _alGetListener3i(param,pValue0,pValue1,pValue2){pValue0>>>=0;pValue1>>>=0;pValue2>>>=0;var val=AL.getListenerParam("alGetListener3i",param);if(val===null){return;}if(!pValue0||!pValue1||!pValue2){AL.currentCtx.err=40963;return;}switch(param){case 4100:case 4102:HEAP32[pValue0>>>2>>>0]=val[0];HEAP32[pValue1>>>2>>>0]=val[1];HEAP32[pValue2>>>2>>>0]=val[2];break;default:AL.currentCtx.err=40962;return;}}_alGetListener3i.sig="vippp";function _alGetListenerf(param,pValue){pValue>>>=0;var val=AL.getListenerParam("alGetListenerf",param);if(val===null){return;}if(!pValue){AL.currentCtx.err=40963;return;}switch(param){case 4106:HEAPF32[pValue>>>2>>>0]=val;break;default:AL.currentCtx.err=40962;return;}}_alGetListenerf.sig="vip";function _alGetListenerfv(param,pValues){pValues>>>=0;var val=AL.getListenerParam("alGetListenerfv",param);if(val===null){return;}if(!pValues){AL.currentCtx.err=40963;return;}switch(param){case 4100:case 4102:HEAPF32[pValues>>>2>>>0]=val[0];HEAPF32[pValues+4>>>2>>>0]=val[1];HEAPF32[pValues+8>>>2>>>0]=val[2];break;case 4111:HEAPF32[pValues>>>2>>>0]=val[0];HEAPF32[pValues+4>>>2>>>0]=val[1];HEAPF32[pValues+8>>>2>>>0]=val[2];HEAPF32[pValues+12>>>2>>>0]=val[3];HEAPF32[pValues+16>>>2>>>0]=val[4];HEAPF32[pValues+20>>>2>>>0]=val[5];break;default:AL.currentCtx.err=40962;return;}}_alGetListenerfv.sig="vip";function _alGetListeneri(param,pValue){pValue>>>=0;var val=AL.getListenerParam("alGetListeneri",param);if(val===null){return;}if(!pValue){AL.currentCtx.err=40963;return;}AL.currentCtx.err=40962;}_alGetListeneri.sig="vip";function _alGetListeneriv(param,pValues){pValues>>>=0;var val=AL.getListenerParam("alGetListeneriv",param);if(val===null){return;}if(!pValues){AL.currentCtx.err=40963;return;}switch(param){case 4100:case 4102:HEAP32[pValues>>>2>>>0]=val[0];HEAP32[pValues+4>>>2>>>0]=val[1];HEAP32[pValues+8>>>2>>>0]=val[2];break;case 4111:HEAP32[pValues>>>2>>>0]=val[0];HEAP32[pValues+4>>>2>>>0]=val[1];HEAP32[pValues+8>>>2>>>0]=val[2];HEAP32[pValues+12>>>2>>>0]=val[3];HEAP32[pValues+16>>>2>>>0]=val[4];HEAP32[pValues+20>>>2>>>0]=val[5];break;default:AL.currentCtx.err=40962;return;}}_alGetListeneriv.sig="vip";function _alGetSource3f(sourceId,param,pValue0,pValue1,pValue2){pValue0>>>=0;pValue1>>>=0;pValue2>>>=0;var val=AL.getSourceParam("alGetSource3f",sourceId,param);if(val===null){return;}if(!pValue0||!pValue1||!pValue2){AL.currentCtx.err=40963;return;}switch(param){case 4100:case 4101:case 4102:HEAPF32[pValue0>>>2>>>0]=val[0];HEAPF32[pValue1>>>2>>>0]=val[1];HEAPF32[pValue2>>>2>>>0]=val[2];break;default:AL.currentCtx.err=40962;return;}}_alGetSource3f.sig="viippp";function _alGetSource3i(sourceId,param,pValue0,pValue1,pValue2){pValue0>>>=0;pValue1>>>=0;pValue2>>>=0;var val=AL.getSourceParam("alGetSource3i",sourceId,param);if(val===null){return;}if(!pValue0||!pValue1||!pValue2){AL.currentCtx.err=40963;return;}switch(param){case 4100:case 4101:case 4102:HEAP32[pValue0>>>2>>>0]=val[0];HEAP32[pValue1>>>2>>>0]=val[1];HEAP32[pValue2>>>2>>>0]=val[2];break;default:AL.currentCtx.err=40962;return;}}_alGetSource3i.sig="viippp";function _alGetSourcef(sourceId,param,pValue){pValue>>>=0;var val=AL.getSourceParam("alGetSourcef",sourceId,param);if(val===null){return;}if(!pValue){AL.currentCtx.err=40963;return;}switch(param){case 4097:/* AL_CONE_INNER_ANGLE */case 4098:/* AL_CONE_OUTER_ANGLE */case 4099:/* AL_PITCH */case 4106:case 4109:/* AL_MIN_GAIN */case 4110:/* AL_MAX_GAIN */case 4128:/* AL_REFERENCE_DISTANCE */case 4129:/* AL_ROLLOFF_FACTOR */case 4130:/* AL_CONE_OUTER_GAIN */case 4131:/* AL_MAX_DISTANCE */case 4132:/* AL_SEC_OFFSET */case 4133:/* AL_SAMPLE_OFFSET */case 4134:/* AL_BYTE_OFFSET */case 8203:/* AL_SEC_LENGTH_SOFT */HEAPF32[pValue>>>2>>>0]=val;break;default:AL.currentCtx.err=40962;return;}}_alGetSourcef.sig="viip";function _alGetSourcefv(sourceId,param,pValues){pValues>>>=0;var val=AL.getSourceParam("alGetSourcefv",sourceId,param);if(val===null){return;}if(!pValues){AL.currentCtx.err=40963;return;}switch(param){case 4097:/* AL_CONE_INNER_ANGLE */case 4098:/* AL_CONE_OUTER_ANGLE */case 4099:/* AL_PITCH */case 4106:case 4109:/* AL_MIN_GAIN */case 4110:/* AL_MAX_GAIN */case 4128:/* AL_REFERENCE_DISTANCE */case 4129:/* AL_ROLLOFF_FACTOR */case 4130:/* AL_CONE_OUTER_GAIN */case 4131:/* AL_MAX_DISTANCE */case 4132:/* AL_SEC_OFFSET */case 4133:/* AL_SAMPLE_OFFSET */case 4134:/* AL_BYTE_OFFSET */case 8203:/* AL_SEC_LENGTH_SOFT */HEAPF32[pValues>>>2>>>0]=val[0];break;case 4100:case 4101:case 4102:HEAPF32[pValues>>>2>>>0]=val[0];HEAPF32[pValues+4>>>2>>>0]=val[1];HEAPF32[pValues+8>>>2>>>0]=val[2];break;default:AL.currentCtx.err=40962;return;}}_alGetSourcefv.sig="viip";function _alGetSourcei(sourceId,param,pValue){pValue>>>=0;var val=AL.getSourceParam("alGetSourcei",sourceId,param);if(val===null){return;}if(!pValue){AL.currentCtx.err=40963;return;}switch(param){case 514:/* AL_SOURCE_RELATIVE */case 4097:/* AL_CONE_INNER_ANGLE */case 4098:/* AL_CONE_OUTER_ANGLE */case 4103:/* AL_LOOPING */case 4105:/* AL_BUFFER */case 4112:/* AL_SOURCE_STATE */case 4117:/* AL_BUFFERS_QUEUED */case 4118:/* AL_BUFFERS_PROCESSED */case 4128:/* AL_REFERENCE_DISTANCE */case 4129:/* AL_ROLLOFF_FACTOR */case 4131:/* AL_MAX_DISTANCE */case 4132:/* AL_SEC_OFFSET */case 4133:/* AL_SAMPLE_OFFSET */case 4134:/* AL_BYTE_OFFSET */case 4135:/* AL_SOURCE_TYPE */case 4628:/* AL_SOURCE_SPATIALIZE_SOFT */case 8201:/* AL_BYTE_LENGTH_SOFT */case 8202:/* AL_SAMPLE_LENGTH_SOFT */case 53248:HEAP32[pValue>>>2>>>0]=val;break;default:AL.currentCtx.err=40962;return;}}_alGetSourcei.sig="viip";function _alGetSourceiv(sourceId,param,pValues){pValues>>>=0;var val=AL.getSourceParam("alGetSourceiv",sourceId,param);if(val===null){return;}if(!pValues){AL.currentCtx.err=40963;return;}switch(param){case 514:/* AL_SOURCE_RELATIVE */case 4097:/* AL_CONE_INNER_ANGLE */case 4098:/* AL_CONE_OUTER_ANGLE */case 4103:/* AL_LOOPING */case 4105:/* AL_BUFFER */case 4112:/* AL_SOURCE_STATE */case 4117:/* AL_BUFFERS_QUEUED */case 4118:/* AL_BUFFERS_PROCESSED */case 4128:/* AL_REFERENCE_DISTANCE */case 4129:/* AL_ROLLOFF_FACTOR */case 4131:/* AL_MAX_DISTANCE */case 4132:/* AL_SEC_OFFSET */case 4133:/* AL_SAMPLE_OFFSET */case 4134:/* AL_BYTE_OFFSET */case 4135:/* AL_SOURCE_TYPE */case 4628:/* AL_SOURCE_SPATIALIZE_SOFT */case 8201:/* AL_BYTE_LENGTH_SOFT */case 8202:/* AL_SAMPLE_LENGTH_SOFT */case 53248:HEAP32[pValues>>>2>>>0]=val;break;case 4100:case 4101:case 4102:HEAP32[pValues>>>2>>>0]=val[0];HEAP32[pValues+4>>>2>>>0]=val[1];HEAP32[pValues+8>>>2>>>0]=val[2];break;default:AL.currentCtx.err=40962;return;}}_alGetSourceiv.sig="viip";var stringToNewUTF8=str=>{var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8(str,ret,size);return ret;};function _alGetString(param){if(AL.stringCache[param]){return AL.stringCache[param];}var ret;switch(param){case 0:ret="No Error";break;case 40961:ret="Invalid Name";break;case 40962:ret="Invalid Enum";break;case 40963:ret="Invalid Value";break;case 40964:ret="Invalid Operation";break;case 40965:/* AL_OUT_OF_MEMORY */ret="Out of Memory";break;case 45057:/* AL_VENDOR */ret="Emscripten";break;case 45058:/* AL_VERSION */ret="1.1";break;case 45059:/* AL_RENDERER */ret="WebAudio";break;case 45060:/* AL_EXTENSIONS */ret=Object.keys(AL.AL_EXTENSIONS).join(" ");break;default:if(AL.currentCtx){AL.currentCtx.err=40962;}else{}return 0;}ret=stringToNewUTF8(ret);AL.stringCache[param]=ret;return ret;}_alGetString.sig="pi";var _alIsBuffer=bufferId=>{if(!AL.currentCtx){return false;}if(bufferId>AL.buffers.length){return false;}if(!AL.buffers[bufferId]){return false;}return true;};_alIsBuffer.sig="ii";var _alIsEnabled=param=>{if(!AL.currentCtx){return 0;}switch(param){case 512:/* AL_SOURCE_DISTANCE_MODEL */return AL.currentCtx.sourceDistanceModel?0:1;default:AL.currentCtx.err=40962;return 0;}};_alIsEnabled.sig="ii";function _alIsExtensionPresent(pExtName){pExtName>>>=0;var name=UTF8ToString(pExtName);return AL.AL_EXTENSIONS[name]?1:0;}_alIsExtensionPresent.sig="ip";var _alIsSource=sourceId=>{if(!AL.currentCtx){return false;}if(!AL.currentCtx.sources[sourceId]){return false;}return true;};_alIsSource.sig="ii";var _alListener3f=(param,value0,value1,value2)=>{switch(param){case 4100:case 4102:AL.paramArray[0]=value0;AL.paramArray[1]=value1;AL.paramArray[2]=value2;AL.setListenerParam("alListener3f",param,AL.paramArray);break;default:AL.setListenerParam("alListener3f",param,null);break;}};_alListener3f.sig="vifff";var _alListener3i=(param,value0,value1,value2)=>{switch(param){case 4100:case 4102:AL.paramArray[0]=value0;AL.paramArray[1]=value1;AL.paramArray[2]=value2;AL.setListenerParam("alListener3i",param,AL.paramArray);break;default:AL.setListenerParam("alListener3i",param,null);break;}};_alListener3i.sig="viiii";var _alListenerf=(param,value)=>{switch(param){case 4106:AL.setListenerParam("alListenerf",param,value);break;default:AL.setListenerParam("alListenerf",param,null);break;}};_alListenerf.sig="vif";function _alListenerfv(param,pValues){pValues>>>=0;if(!AL.currentCtx){return;}if(!pValues){AL.currentCtx.err=40963;return;}switch(param){case 4100:case 4102:AL.paramArray[0]=HEAPF32[pValues>>>2>>>0];AL.paramArray[1]=HEAPF32[pValues+4>>>2>>>0];AL.paramArray[2]=HEAPF32[pValues+8>>>2>>>0];AL.setListenerParam("alListenerfv",param,AL.paramArray);break;case 4111:AL.paramArray[0]=HEAPF32[pValues>>>2>>>0];AL.paramArray[1]=HEAPF32[pValues+4>>>2>>>0];AL.paramArray[2]=HEAPF32[pValues+8>>>2>>>0];AL.paramArray[3]=HEAPF32[pValues+12>>>2>>>0];AL.paramArray[4]=HEAPF32[pValues+16>>>2>>>0];AL.paramArray[5]=HEAPF32[pValues+20>>>2>>>0];AL.setListenerParam("alListenerfv",param,AL.paramArray);break;default:AL.setListenerParam("alListenerfv",param,null);break;}}_alListenerfv.sig="vip";var _alListeneri=(param,value)=>{AL.setListenerParam("alListeneri",param,null);};_alListeneri.sig="vii";function _alListeneriv(param,pValues){pValues>>>=0;if(!AL.currentCtx){return;}if(!pValues){AL.currentCtx.err=40963;return;}switch(param){case 4100:case 4102:AL.paramArray[0]=HEAP32[pValues>>>2>>>0];AL.paramArray[1]=HEAP32[pValues+4>>>2>>>0];AL.paramArray[2]=HEAP32[pValues+8>>>2>>>0];AL.setListenerParam("alListeneriv",param,AL.paramArray);break;case 4111:AL.paramArray[0]=HEAP32[pValues>>>2>>>0];AL.paramArray[1]=HEAP32[pValues+4>>>2>>>0];AL.paramArray[2]=HEAP32[pValues+8>>>2>>>0];AL.paramArray[3]=HEAP32[pValues+12>>>2>>>0];AL.paramArray[4]=HEAP32[pValues+16>>>2>>>0];AL.paramArray[5]=HEAP32[pValues+20>>>2>>>0];AL.setListenerParam("alListeneriv",param,AL.paramArray);break;default:AL.setListenerParam("alListeneriv",param,null);break;}}_alListeneriv.sig="vip";var _alSource3f=(sourceId,param,value0,value1,value2)=>{switch(param){case 4100:case 4101:case 4102:AL.paramArray[0]=value0;AL.paramArray[1]=value1;AL.paramArray[2]=value2;AL.setSourceParam("alSource3f",sourceId,param,AL.paramArray);break;default:AL.setSourceParam("alSource3f",sourceId,param,null);break;}};_alSource3f.sig="viifff";var _alSource3i=(sourceId,param,value0,value1,value2)=>{switch(param){case 4100:case 4101:case 4102:AL.paramArray[0]=value0;AL.paramArray[1]=value1;AL.paramArray[2]=value2;AL.setSourceParam("alSource3i",sourceId,param,AL.paramArray);break;default:AL.setSourceParam("alSource3i",sourceId,param,null);break;}};_alSource3i.sig="viiiii";var _alSourcePause=sourceId=>{if(!AL.currentCtx){return;}var src=AL.currentCtx.sources[sourceId];if(!src){AL.currentCtx.err=40961;return;}AL.setSourceState(src,4115);};_alSourcePause.sig="vi";function _alSourcePausev(count,pSourceIds){pSourceIds>>>=0;if(!AL.currentCtx){return;}if(!pSourceIds){AL.currentCtx.err=40963;}for(var i=0;i<count;++i){if(!AL.currentCtx.sources[HEAP32[pSourceIds+i*4>>>2>>>0]]){AL.currentCtx.err=40961;return;}}for(var i=0;i<count;++i){var srcId=HEAP32[pSourceIds+i*4>>>2>>>0];AL.setSourceState(AL.currentCtx.sources[srcId],4115);}}_alSourcePausev.sig="vip";var _alSourcePlay=sourceId=>{if(!AL.currentCtx){return;}var src=AL.currentCtx.sources[sourceId];if(!src){AL.currentCtx.err=40961;return;}AL.setSourceState(src,4114);};_alSourcePlay.sig="vi";function _alSourcePlayv(count,pSourceIds){pSourceIds>>>=0;if(!AL.currentCtx){return;}if(!pSourceIds){AL.currentCtx.err=40963;}for(var i=0;i<count;++i){if(!AL.currentCtx.sources[HEAP32[pSourceIds+i*4>>>2>>>0]]){AL.currentCtx.err=40961;return;}}for(var i=0;i<count;++i){var srcId=HEAP32[pSourceIds+i*4>>>2>>>0];AL.setSourceState(AL.currentCtx.sources[srcId],4114);}}_alSourcePlayv.sig="vip";function _alSourceQueueBuffers(sourceId,count,pBufferIds){pBufferIds>>>=0;if(!AL.currentCtx){return;}var src=AL.currentCtx.sources[sourceId];if(!src){AL.currentCtx.err=40961;return;}if(src.type===4136){AL.currentCtx.err=40964;return;}if(count===0){return;}// Find the first non-zero buffer in the queue to determine the proper format
var templateBuf=AL.buffers[0];for(var i=0;i<src.bufQueue.length;i++){if(src.bufQueue[i].id!==0){templateBuf=src.bufQueue[i];break;}}for(var i=0;i<count;++i){var bufId=HEAP32[pBufferIds+i*4>>>2>>>0];var buf=AL.buffers[bufId];if(!buf){AL.currentCtx.err=40961;return;}// Check that the added buffer has the correct format. If the template is the zero buffer, any format is valid.
if(templateBuf.id!==0&&(buf.frequency!==templateBuf.frequency||buf.bytesPerSample!==templateBuf.bytesPerSample||buf.channels!==templateBuf.channels)){AL.currentCtx.err=40964;}}// If the only buffer in the queue is the zero buffer, clear the queue before we add anything.
if(src.bufQueue.length===1&&src.bufQueue[0].id===0){src.bufQueue.length=0;}src.type=4137;/* AL_STREAMING */for(var i=0;i<count;++i){var bufId=HEAP32[pBufferIds+i*4>>>2>>>0];var buf=AL.buffers[bufId];buf.refCount++;src.bufQueue.push(buf);}// if the source is looping, cancel the schedule so we can reschedule the loop order
if(src.looping){AL.cancelPendingSourceAudio(src);}AL.initSourcePanner(src);AL.scheduleSourceAudio(src);}_alSourceQueueBuffers.sig="viip";var _alSourceRewind=sourceId=>{if(!AL.currentCtx){return;}var src=AL.currentCtx.sources[sourceId];if(!src){AL.currentCtx.err=40961;return;}// Stop the source first to clear the source queue
AL.setSourceState(src,4116);// Now set the state of AL_INITIAL according to the specification
AL.setSourceState(src,4113);};_alSourceRewind.sig="vi";function _alSourceRewindv(count,pSourceIds){pSourceIds>>>=0;if(!AL.currentCtx){return;}if(!pSourceIds){AL.currentCtx.err=40963;}for(var i=0;i<count;++i){if(!AL.currentCtx.sources[HEAP32[pSourceIds+i*4>>>2>>>0]]){AL.currentCtx.err=40961;return;}}for(var i=0;i<count;++i){var srcId=HEAP32[pSourceIds+i*4>>>2>>>0];AL.setSourceState(AL.currentCtx.sources[srcId],4113);}}_alSourceRewindv.sig="vip";var _alSourceStop=sourceId=>{if(!AL.currentCtx){return;}var src=AL.currentCtx.sources[sourceId];if(!src){AL.currentCtx.err=40961;return;}AL.setSourceState(src,4116);};_alSourceStop.sig="vi";function _alSourceStopv(count,pSourceIds){pSourceIds>>>=0;if(!AL.currentCtx){return;}if(!pSourceIds){AL.currentCtx.err=40963;}for(var i=0;i<count;++i){if(!AL.currentCtx.sources[HEAP32[pSourceIds+i*4>>>2>>>0]]){AL.currentCtx.err=40961;return;}}for(var i=0;i<count;++i){var srcId=HEAP32[pSourceIds+i*4>>>2>>>0];AL.setSourceState(AL.currentCtx.sources[srcId],4116);}}_alSourceStopv.sig="vip";function _alSourceUnqueueBuffers(sourceId,count,pBufferIds){pBufferIds>>>=0;if(!AL.currentCtx){return;}var src=AL.currentCtx.sources[sourceId];if(!src){AL.currentCtx.err=40961;return;}if(count>(src.bufQueue.length===1&&src.bufQueue[0].id===0?0:src.bufsProcessed)){AL.currentCtx.err=40963;return;}if(count===0){return;}for(var i=0;i<count;i++){var buf=src.bufQueue.shift();buf.refCount--;// Write the buffers index out to the return list.
HEAP32[pBufferIds+i*4>>>2>>>0]=buf.id;src.bufsProcessed--;}/// If the queue is empty, put the zero buffer back in
if(src.bufQueue.length===0){src.bufQueue.push(AL.buffers[0]);}AL.initSourcePanner(src);AL.scheduleSourceAudio(src);}_alSourceUnqueueBuffers.sig="viip";var _alSourcef=(sourceId,param,value)=>{switch(param){case 4097:/* AL_CONE_INNER_ANGLE */case 4098:/* AL_CONE_OUTER_ANGLE */case 4099:/* AL_PITCH */case 4106:case 4109:/* AL_MIN_GAIN */case 4110:/* AL_MAX_GAIN */case 4128:/* AL_REFERENCE_DISTANCE */case 4129:/* AL_ROLLOFF_FACTOR */case 4130:/* AL_CONE_OUTER_GAIN */case 4131:/* AL_MAX_DISTANCE */case 4132:/* AL_SEC_OFFSET */case 4133:/* AL_SAMPLE_OFFSET */case 4134:/* AL_BYTE_OFFSET */case 8203:/* AL_SEC_LENGTH_SOFT */AL.setSourceParam("alSourcef",sourceId,param,value);break;default:AL.setSourceParam("alSourcef",sourceId,param,null);break;}};_alSourcef.sig="viif";function _alSourcefv(sourceId,param,pValues){pValues>>>=0;if(!AL.currentCtx){return;}if(!pValues){AL.currentCtx.err=40963;return;}switch(param){case 4097:/* AL_CONE_INNER_ANGLE */case 4098:/* AL_CONE_OUTER_ANGLE */case 4099:/* AL_PITCH */case 4106:case 4109:/* AL_MIN_GAIN */case 4110:/* AL_MAX_GAIN */case 4128:/* AL_REFERENCE_DISTANCE */case 4129:/* AL_ROLLOFF_FACTOR */case 4130:/* AL_CONE_OUTER_GAIN */case 4131:/* AL_MAX_DISTANCE */case 4132:/* AL_SEC_OFFSET */case 4133:/* AL_SAMPLE_OFFSET */case 4134:/* AL_BYTE_OFFSET */case 8203:/* AL_SEC_LENGTH_SOFT */var val=HEAPF32[pValues>>>2>>>0];AL.setSourceParam("alSourcefv",sourceId,param,val);break;case 4100:case 4101:case 4102:AL.paramArray[0]=HEAPF32[pValues>>>2>>>0];AL.paramArray[1]=HEAPF32[pValues+4>>>2>>>0];AL.paramArray[2]=HEAPF32[pValues+8>>>2>>>0];AL.setSourceParam("alSourcefv",sourceId,param,AL.paramArray);break;default:AL.setSourceParam("alSourcefv",sourceId,param,null);break;}}_alSourcefv.sig="viip";function _alSourceiv(sourceId,param,pValues){pValues>>>=0;if(!AL.currentCtx){return;}if(!pValues){AL.currentCtx.err=40963;return;}switch(param){case 514:/* AL_SOURCE_RELATIVE */case 4097:/* AL_CONE_INNER_ANGLE */case 4098:/* AL_CONE_OUTER_ANGLE */case 4103:/* AL_LOOPING */case 4105:/* AL_BUFFER */case 4128:/* AL_REFERENCE_DISTANCE */case 4129:/* AL_ROLLOFF_FACTOR */case 4131:/* AL_MAX_DISTANCE */case 4132:/* AL_SEC_OFFSET */case 4133:/* AL_SAMPLE_OFFSET */case 4134:/* AL_BYTE_OFFSET */case 4628:/* AL_SOURCE_SPATIALIZE_SOFT */case 8201:/* AL_BYTE_LENGTH_SOFT */case 8202:/* AL_SAMPLE_LENGTH_SOFT */case 53248:var val=HEAP32[pValues>>>2>>>0];AL.setSourceParam("alSourceiv",sourceId,param,val);break;case 4100:case 4101:case 4102:AL.paramArray[0]=HEAP32[pValues>>>2>>>0];AL.paramArray[1]=HEAP32[pValues+4>>>2>>>0];AL.paramArray[2]=HEAP32[pValues+8>>>2>>>0];AL.setSourceParam("alSourceiv",sourceId,param,AL.paramArray);break;default:AL.setSourceParam("alSourceiv",sourceId,param,null);break;}}_alSourceiv.sig="viip";var _alSpeedOfSound=value=>{AL.setGlobalParam("alSpeedOfSound",49155,value);};_alSpeedOfSound.sig="vf";var _alcCaptureCloseDevice=function(deviceId){deviceId>>>=0;var c=AL.requireValidCaptureDevice(deviceId,"alcCaptureCloseDevice");if(!c)return false;delete AL.captures[deviceId];AL.freeIds.push(deviceId);// This clean-up might be unnecessary (paranoid) ?
// May happen if user hasn't decided to grant or deny input
c.mediaStreamSourceNode?.disconnect();c.mergerNode?.disconnect();c.splitterNode?.disconnect();// May happen if user hasn't decided to grant or deny input
c.scriptProcessorNode?.disconnect();if(c.mediaStream){// Disabling the microphone of the browser.
// Without this operation, the red dot on the browser tab page will remain.
c.mediaStream.getTracks().forEach(track=>track.stop());}delete c.buffers;c.capturedFrameCount=0;c.isCapturing=false;return true;};_alcCaptureCloseDevice.sig="ip";var listenOnce=(object,event,func)=>{object.addEventListener(event,func,{"once":true});};/** @param {Object=} elements */var autoResumeAudioContext=(ctx,elements)=>{if(!elements){elements=[document,document.getElementById("canvas")];}["keydown","mousedown","touchstart"].forEach(event=>{elements.forEach(element=>{if(element){listenOnce(element,event,()=>{if(ctx.state==="suspended")ctx.resume();});}});});};function _alcCaptureOpenDevice(pDeviceName,requestedSampleRate,format,bufferFrameCapacity){pDeviceName>>>=0;var resolvedDeviceName=AL.CAPTURE_DEVICE_NAME;// NULL is a valid device name here (resolves to default);
if(pDeviceName!==0){resolvedDeviceName=UTF8ToString(pDeviceName);if(resolvedDeviceName!==AL.CAPTURE_DEVICE_NAME){// ALC_OUT_OF_MEMORY
// From the programmer's guide, ALC_OUT_OF_MEMORY's meaning is
// overloaded here, to mean:
// 'The specified device is invalid, or can not capture audio.'
// This may be misleading to API users, but well...
AL.alcErr=40965;/* ALC_OUT_OF_MEMORY */return 0;}}// Otherwise it's probably okay (though useless) for bufferFrameCapacity to be zero.
if(bufferFrameCapacity<0){// ALCsizei is signed int
AL.alcErr=40964;return 0;}navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;var has_getUserMedia=navigator.getUserMedia||navigator.mediaDevices&&navigator.mediaDevices.getUserMedia;if(!has_getUserMedia){// See previously mentioned rationale for ALC_OUT_OF_MEMORY
AL.alcErr=40965;/* ALC_OUT_OF_MEMORY */return 0;}var AudioContext=window.AudioContext||window.webkitAudioContext;if(!AL.sharedCaptureAudioCtx){try{AL.sharedCaptureAudioCtx=new AudioContext();}catch(e){// See previously mentioned rationale for ALC_OUT_OF_MEMORY
AL.alcErr=40965;/* ALC_OUT_OF_MEMORY */return 0;}}autoResumeAudioContext(AL.sharedCaptureAudioCtx);var outputChannelCount;switch(format){case 65552:/* AL_FORMAT_MONO_FLOAT32 */case 4353:/* AL_FORMAT_MONO16 */case 4352:/* AL_FORMAT_MONO8 */outputChannelCount=1;break;case 65553:/* AL_FORMAT_STEREO_FLOAT32 */case 4355:/* AL_FORMAT_STEREO16 */case 4354:/* AL_FORMAT_STEREO8 */outputChannelCount=2;break;default:AL.alcErr=40964;return 0;}function newF32Array(cap){return new Float32Array(cap);}function newI16Array(cap){return new Int16Array(cap);}function newU8Array(cap){return new Uint8Array(cap);}var requestedSampleType;var newSampleArray;switch(format){case 65552:/* AL_FORMAT_MONO_FLOAT32 */case 65553:/* AL_FORMAT_STEREO_FLOAT32 */requestedSampleType="f32";newSampleArray=newF32Array;break;case 4353:/* AL_FORMAT_MONO16 */case 4355:/* AL_FORMAT_STEREO16 */requestedSampleType="i16";newSampleArray=newI16Array;break;case 4352:/* AL_FORMAT_MONO8 */case 4354:/* AL_FORMAT_STEREO8 */requestedSampleType="u8";newSampleArray=newU8Array;break;}var buffers=[];try{for(var chan=0;chan<outputChannelCount;++chan){buffers[chan]=newSampleArray(bufferFrameCapacity);}}catch(e){AL.alcErr=40965;/* ALC_OUT_OF_MEMORY */return 0;}// What we'll place into the `AL.captures` array in the end,
// declared here for closures to access it
var newCapture={audioCtx:AL.sharedCaptureAudioCtx,deviceName:resolvedDeviceName,requestedSampleRate,requestedSampleType,outputChannelCount,inputChannelCount:null,// Not known until the getUserMedia() promise resolves
mediaStreamError:null,// Used by other functions to return early and report an error.
mediaStreamSourceNode:null,mediaStream:null,// Either one, or none of the below two, is active.
mergerNode:null,splitterNode:null,scriptProcessorNode:null,isCapturing:false,buffers,get bufferFrameCapacity(){return buffers[0].length;},capturePlayhead:0,// current write position, in sample frames
captureReadhead:0,capturedFrameCount:0};// Preparing for getUserMedia()
var onError=mediaStreamError=>{newCapture.mediaStreamError=mediaStreamError;};var onSuccess=mediaStream=>{newCapture.mediaStreamSourceNode=newCapture.audioCtx.createMediaStreamSource(mediaStream);newCapture.mediaStream=mediaStream;var inputChannelCount=1;switch(newCapture.mediaStreamSourceNode.channelCountMode){case"max":inputChannelCount=outputChannelCount;break;case"clamped-max":inputChannelCount=Math.min(outputChannelCount,newCapture.mediaStreamSourceNode.channelCount);break;case"explicit":inputChannelCount=newCapture.mediaStreamSourceNode.channelCount;break;}newCapture.inputChannelCount=inputChannelCount;// Have to pick a size from 256, 512, 1024, 2048, 4096, 8192, 16384.
// One can also set it to zero, which leaves the decision up to the impl.
// An extension could allow specifying this value.
var processorFrameCount=512;newCapture.scriptProcessorNode=newCapture.audioCtx.createScriptProcessor(processorFrameCount,inputChannelCount,outputChannelCount);if(inputChannelCount>outputChannelCount){newCapture.mergerNode=newCapture.audioCtx.createChannelMerger(inputChannelCount);newCapture.mediaStreamSourceNode.connect(newCapture.mergerNode);newCapture.mergerNode.connect(newCapture.scriptProcessorNode);}else if(inputChannelCount<outputChannelCount){newCapture.splitterNode=newCapture.audioCtx.createChannelSplitter(outputChannelCount);newCapture.mediaStreamSourceNode.connect(newCapture.splitterNode);newCapture.splitterNode.connect(newCapture.scriptProcessorNode);}else{newCapture.mediaStreamSourceNode.connect(newCapture.scriptProcessorNode);}newCapture.scriptProcessorNode.connect(newCapture.audioCtx.destination);newCapture.scriptProcessorNode.onaudioprocess=audioProcessingEvent=>{if(!newCapture.isCapturing){return;}var c=newCapture;var srcBuf=audioProcessingEvent.inputBuffer;// Actually just copy srcBuf's channel data into
// c.buffers, optimizing for each case.
switch(format){case 65552:/* AL_FORMAT_MONO_FLOAT32 */var channel0=srcBuf.getChannelData(0);for(var i=0;i<srcBuf.length;++i){var wi=(c.capturePlayhead+i)%c.bufferFrameCapacity;c.buffers[0][wi]=channel0[i];}break;case 65553:/* AL_FORMAT_STEREO_FLOAT32 */var channel0=srcBuf.getChannelData(0);var channel1=srcBuf.getChannelData(1);for(var i=0;i<srcBuf.length;++i){var wi=(c.capturePlayhead+i)%c.bufferFrameCapacity;c.buffers[0][wi]=channel0[i];c.buffers[1][wi]=channel1[i];}break;case 4353:/* AL_FORMAT_MONO16 */var channel0=srcBuf.getChannelData(0);for(var i=0;i<srcBuf.length;++i){var wi=(c.capturePlayhead+i)%c.bufferFrameCapacity;c.buffers[0][wi]=channel0[i]*32767;}break;case 4355:/* AL_FORMAT_STEREO16 */var channel0=srcBuf.getChannelData(0);var channel1=srcBuf.getChannelData(1);for(var i=0;i<srcBuf.length;++i){var wi=(c.capturePlayhead+i)%c.bufferFrameCapacity;c.buffers[0][wi]=channel0[i]*32767;c.buffers[1][wi]=channel1[i]*32767;}break;case 4352:/* AL_FORMAT_MONO8 */var channel0=srcBuf.getChannelData(0);for(var i=0;i<srcBuf.length;++i){var wi=(c.capturePlayhead+i)%c.bufferFrameCapacity;c.buffers[0][wi]=(channel0[i]+1)*127;}break;case 4354:/* AL_FORMAT_STEREO8 */var channel0=srcBuf.getChannelData(0);var channel1=srcBuf.getChannelData(1);for(var i=0;i<srcBuf.length;++i){var wi=(c.capturePlayhead+i)%c.bufferFrameCapacity;c.buffers[0][wi]=(channel0[i]+1)*127;c.buffers[1][wi]=(channel1[i]+1)*127;}break;}c.capturePlayhead+=srcBuf.length;c.capturePlayhead%=c.bufferFrameCapacity;c.capturedFrameCount+=srcBuf.length;c.capturedFrameCount=Math.min(c.capturedFrameCount,c.bufferFrameCapacity);};};// The latest way to call getUserMedia()
if(navigator.mediaDevices?.getUserMedia){navigator.mediaDevices.getUserMedia({audio:true}).then(onSuccess).catch(onError);}else{// The usual (now deprecated) way
navigator.getUserMedia({audio:true},onSuccess,onError);}var id=AL.newId();AL.captures[id]=newCapture;return id;}_alcCaptureOpenDevice.sig="ppiii";function _alcCaptureSamples(deviceId,pFrames,requestedFrameCount){deviceId>>>=0;pFrames>>>=0;var c=AL.requireValidCaptureDevice(deviceId,"alcCaptureSamples");if(!c)return;// ALCsizei is actually 32-bit signed int, so could be negative
// Also, spec says :
//   Requesting more sample frames than are currently available is
//   an error.
var dstfreq=c.requestedSampleRate;var srcfreq=c.audioCtx.sampleRate;var fratio=srcfreq/dstfreq;if(requestedFrameCount<0||requestedFrameCount>c.capturedFrameCount/fratio){AL.alcErr=40964;return;}function setF32Sample(i,sample){HEAPF32[pFrames+4*i>>>2>>>0]=sample;}function setI16Sample(i,sample){HEAP16[pFrames+2*i>>>1>>>0]=sample;}function setU8Sample(i,sample){HEAP8[pFrames+i>>>0]=sample;}var setSample;switch(c.requestedSampleType){case"f32":setSample=setF32Sample;break;case"i16":setSample=setI16Sample;break;case"u8":setSample=setU8Sample;break;default:return;}// If fratio is an integer we don't need linear resampling, just skip samples
if(Math.floor(fratio)==fratio){for(var i=0,frame_i=0;frame_i<requestedFrameCount;++frame_i){for(var chan=0;chan<c.buffers.length;++chan,++i){setSample(i,c.buffers[chan][c.captureReadhead]);}c.captureReadhead=(fratio+c.captureReadhead)%c.bufferFrameCapacity;}}else{// Perform linear resampling.
// There is room for improvement - right now we're fine with linear resampling.
// We don't use OfflineAudioContexts for this: See the discussion at
// https://github.com/jpernst/emscripten/issues/2#issuecomment-312729735
// if you're curious about why.
for(var i=0,frame_i=0;frame_i<requestedFrameCount;++frame_i){var lefti=Math.floor(c.captureReadhead);var righti=Math.ceil(c.captureReadhead);var d=c.captureReadhead-lefti;for(var chan=0;chan<c.buffers.length;++chan,++i){var lefts=c.buffers[chan][lefti];var rights=c.buffers[chan][righti];setSample(i,(1-d)*lefts+d*rights);}c.captureReadhead=(c.captureReadhead+fratio)%c.bufferFrameCapacity;}}// Spec doesn't say if alcCaptureSamples() must zero the number
// of available captured sample-frames, but not only would it
// be insane not to do, OpenAL-Soft happens to do that as well.
c.capturedFrameCount=0;}_alcCaptureSamples.sig="vppi";function _alcCaptureStart(deviceId){deviceId>>>=0;var c=AL.requireValidCaptureDevice(deviceId,"alcCaptureStart");if(!c)return;if(c.isCapturing){// NOTE: Spec says (emphasis mine):
//     The amount of audio samples available after **restarting** a
//     stopped capture device is reset to zero.
// So redundant calls to alcCaptureStart() must have no effect.
return;}c.isCapturing=true;c.capturedFrameCount=0;c.capturePlayhead=0;}_alcCaptureStart.sig="vp";function _alcCaptureStop(deviceId){deviceId>>>=0;var c=AL.requireValidCaptureDevice(deviceId,"alcCaptureStop");if(!c)return;c.isCapturing=false;}_alcCaptureStop.sig="vp";function _alcCloseDevice(deviceId){deviceId>>>=0;if(!(deviceId in AL.deviceRefCounts)||AL.deviceRefCounts[deviceId]>0){return 0;}delete AL.deviceRefCounts[deviceId];AL.freeIds.push(deviceId);return 1;}_alcCloseDevice.sig="ip";function _alcCreateContext(deviceId,pAttrList){deviceId>>>=0;pAttrList>>>=0;if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;/* ALC_INVALID_DEVICE */return 0;}var options=null;var attrs=[];var hrtf=null;pAttrList>>=2;if(pAttrList){var attr=0;var val=0;while(true){attr=HEAP32[pAttrList++>>>0];attrs.push(attr);if(attr===0){break;}val=HEAP32[pAttrList++>>>0];attrs.push(val);switch(attr){case 4103:/* ALC_FREQUENCY */if(!options){options={};}options.sampleRate=val;break;case 4112:// fallthrough
case 4113:// Do nothing; these hints are satisfied by default
break;case 6546:/* ALC_HRTF_SOFT */switch(val){case 0:hrtf=false;break;case 1:hrtf=true;break;case 2:/* ALC_DONT_CARE_SOFT */break;default:AL.alcErr=40964;return 0;}break;case 6550:/* ALC_HRTF_ID_SOFT */if(val!==0){AL.alcErr=40964;return 0;}break;default:AL.alcErr=40964;/* ALC_INVALID_VALUE */return 0;}}}var AudioContext=window.AudioContext||window.webkitAudioContext;var ac=null;try{// Only try to pass options if there are any, for compat with browsers that don't support this
if(options){ac=new AudioContext(options);}else{ac=new AudioContext();}}catch(e){if(e.name==="NotSupportedError"){AL.alcErr=40964;}else/* ALC_INVALID_VALUE */{AL.alcErr=40961;}/* ALC_INVALID_DEVICE */return 0;}autoResumeAudioContext(ac);// Old Web Audio API (e.g. Safari 6.0.5) had an inconsistently named createGainNode function.
if(typeof ac.createGain=="undefined"){ac.createGain=ac.createGainNode;}var gain=ac.createGain();gain.connect(ac.destination);var ctx={deviceId,id:AL.newId(),attrs,audioCtx:ac,listener:{position:[0,0,0],velocity:[0,0,0],direction:[0,0,0],up:[0,0,0]},sources:[],interval:setInterval(()=>AL.scheduleContextAudio(ctx),AL.QUEUE_INTERVAL),gain,distanceModel:53250,/* AL_INVERSE_DISTANCE_CLAMPED */speedOfSound:343.3,dopplerFactor:1,sourceDistanceModel:false,hrtf:hrtf||false,_err:0,get err(){return this._err;},set err(val){// Errors should not be overwritten by later errors until they are cleared by a query.
if(this._err===0||val===0){this._err=val;}}};AL.deviceRefCounts[deviceId]++;AL.contexts[ctx.id]=ctx;if(hrtf!==null){// Apply hrtf attrib to all contexts for this device
for(var ctxId in AL.contexts){var c=AL.contexts[ctxId];if(c.deviceId===deviceId){c.hrtf=hrtf;AL.updateContextGlobal(c);}}}return ctx.id;}_alcCreateContext.sig="ppp";function _alcDestroyContext(contextId){contextId>>>=0;var ctx=AL.contexts[contextId];if(AL.currentCtx===ctx){AL.alcErr=40962;/* ALC_INVALID_CONTEXT */return;}// Stop playback, etc
if(AL.contexts[contextId].interval){clearInterval(AL.contexts[contextId].interval);}AL.deviceRefCounts[ctx.deviceId]--;delete AL.contexts[contextId];AL.freeIds.push(contextId);}_alcDestroyContext.sig="vp";function _alcGetContextsDevice(contextId){contextId>>>=0;if(contextId in AL.contexts){return AL.contexts[contextId].deviceId;}return 0;}_alcGetContextsDevice.sig="pp";function _alcGetCurrentContext(){if(AL.currentCtx!==null){return AL.currentCtx.id;}return 0;}_alcGetCurrentContext.sig="p";function _alcGetEnumValue(deviceId,pEnumName){deviceId>>>=0;pEnumName>>>=0;// Spec says :
// Using a NULL handle is legal, but only the
// tokens defined by the AL core are guaranteed.
if(deviceId!==0&&!(deviceId in AL.deviceRefCounts)){// ALC_INVALID_DEVICE is not listed as a possible error state for
// this function, sadly.
return 0;}else if(!pEnumName){AL.alcErr=40964;return 0;}var name=UTF8ToString(pEnumName);// See alGetEnumValue(), but basically behave the same as OpenAL-Soft
switch(name){case"ALC_NO_ERROR":return 0;case"ALC_INVALID_DEVICE":return 40961;case"ALC_INVALID_CONTEXT":return 40962;case"ALC_INVALID_ENUM":return 40963;case"ALC_INVALID_VALUE":return 40964;case"ALC_OUT_OF_MEMORY":return 40965;case"ALC_MAJOR_VERSION":return 4096;case"ALC_MINOR_VERSION":return 4097;case"ALC_ATTRIBUTES_SIZE":return 4098;case"ALC_ALL_ATTRIBUTES":return 4099;case"ALC_DEFAULT_DEVICE_SPECIFIER":return 4100;case"ALC_DEVICE_SPECIFIER":return 4101;case"ALC_EXTENSIONS":return 4102;case"ALC_FREQUENCY":return 4103;case"ALC_REFRESH":return 4104;case"ALC_SYNC":return 4105;case"ALC_MONO_SOURCES":return 4112;case"ALC_STEREO_SOURCES":return 4113;case"ALC_CAPTURE_DEVICE_SPECIFIER":return 784;case"ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER":return 785;case"ALC_CAPTURE_SAMPLES":return 786;/* Extensions */case"ALC_HRTF_SOFT":return 6546;case"ALC_HRTF_ID_SOFT":return 6550;case"ALC_DONT_CARE_SOFT":return 2;case"ALC_HRTF_STATUS_SOFT":return 6547;case"ALC_NUM_HRTF_SPECIFIERS_SOFT":return 6548;case"ALC_HRTF_SPECIFIER_SOFT":return 6549;case"ALC_HRTF_DISABLED_SOFT":return 0;case"ALC_HRTF_ENABLED_SOFT":return 1;case"ALC_HRTF_DENIED_SOFT":return 2;case"ALC_HRTF_REQUIRED_SOFT":return 3;case"ALC_HRTF_HEADPHONES_DETECTED_SOFT":return 4;case"ALC_HRTF_UNSUPPORTED_FORMAT_SOFT":return 5;default:AL.alcErr=40964;return 0;}}_alcGetEnumValue.sig="ipp";function _alcGetError(deviceId){deviceId>>>=0;var err=AL.alcErr;AL.alcErr=0;return err;}_alcGetError.sig="ip";function _alcGetIntegerv(deviceId,param,size,pValues){deviceId>>>=0;pValues>>>=0;if(size===0||!pValues){// Ignore the query, per the spec
return;}switch(param){case 4096:/* ALC_MAJOR_VERSION */HEAP32[pValues>>>2>>>0]=1;break;case 4097:/* ALC_MINOR_VERSION */HEAP32[pValues>>>2>>>0]=1;break;case 4098:/* ALC_ATTRIBUTES_SIZE */if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return;}if(!AL.currentCtx){AL.alcErr=40962;/* ALC_INVALID_CONTEXT */return;}HEAP32[pValues>>>2>>>0]=AL.currentCtx.attrs.length;break;case 4099:/* ALC_ALL_ATTRIBUTES */if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return;}if(!AL.currentCtx){AL.alcErr=40962;/* ALC_INVALID_CONTEXT */return;}for(var i=0;i<AL.currentCtx.attrs.length;i++){HEAP32[pValues+i*4>>>2>>>0]=AL.currentCtx.attrs[i];}break;case 4103:/* ALC_FREQUENCY */if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return;}if(!AL.currentCtx){AL.alcErr=40962;/* ALC_INVALID_CONTEXT */return;}HEAP32[pValues>>>2>>>0]=AL.currentCtx.audioCtx.sampleRate;break;case 4112:/* ALC_MONO_SOURCES */case 4113:/* ALC_STEREO_SOURCES */if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return;}if(!AL.currentCtx){AL.alcErr=40962;/* ALC_INVALID_CONTEXT */return;}HEAP32[pValues>>>2>>>0]=2147483647;break;case 6546:/* ALC_HRTF_SOFT */case 6547:/* ALC_HRTF_STATUS_SOFT */if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return;}var hrtfStatus=0;/* ALC_HRTF_DISABLED_SOFT */for(var ctxId in AL.contexts){var ctx=AL.contexts[ctxId];if(ctx.deviceId===deviceId){hrtfStatus=ctx.hrtf?1:/* ALC_HRTF_ENABLED_SOFT */0;}}HEAP32[pValues>>>2>>>0]=hrtfStatus;break;case 6548:/* ALC_NUM_HRTF_SPECIFIERS_SOFT */if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return;}HEAP32[pValues>>>2>>>0]=1;break;case 131075:/* ALC_MAX_AUXILIARY_SENDS */if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return;}if(!AL.currentCtx){AL.alcErr=40962;/* ALC_INVALID_CONTEXT */return;}HEAP32[pValues>>>2>>>0]=1;case 786:/* ALC_CAPTURE_SAMPLES */var c=AL.requireValidCaptureDevice(deviceId,"alcGetIntegerv");if(!c){return;}var n=c.capturedFrameCount;var dstfreq=c.requestedSampleRate;var srcfreq=c.audioCtx.sampleRate;var nsamples=Math.floor(n*(dstfreq/srcfreq));HEAP32[pValues>>>2>>>0]=nsamples;break;default:AL.alcErr=40963;return;}}_alcGetIntegerv.sig="vpiip";function _alcGetString(deviceId,param){deviceId>>>=0;if(AL.alcStringCache[param]){return AL.alcStringCache[param];}var ret;switch(param){case 0:ret="No Error";break;case 40961:ret="Invalid Device";break;case 40962:/* ALC_INVALID_CONTEXT */ret="Invalid Context";break;case 40963:ret="Invalid Enum";break;case 40964:ret="Invalid Value";break;case 40965:/* ALC_OUT_OF_MEMORY */ret="Out of Memory";break;case 4100:/* ALC_DEFAULT_DEVICE_SPECIFIER */if(typeof AudioContext!="undefined"||typeof webkitAudioContext!="undefined"){ret=AL.DEVICE_NAME;}else{return 0;}break;case 4101:/* ALC_DEVICE_SPECIFIER */if(typeof AudioContext!="undefined"||typeof webkitAudioContext!="undefined"){ret=AL.DEVICE_NAME+"\0";}else{ret="\0";}break;case 785:/* ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER */ret=AL.CAPTURE_DEVICE_NAME;break;case 784:/* ALC_CAPTURE_DEVICE_SPECIFIER */if(deviceId===0){ret=AL.CAPTURE_DEVICE_NAME+"\0";}else{var c=AL.requireValidCaptureDevice(deviceId,"alcGetString");if(!c){return 0;}ret=c.deviceName;}break;case 4102:/* ALC_EXTENSIONS */if(!deviceId){AL.alcErr=40961;return 0;}ret=Object.keys(AL.ALC_EXTENSIONS).join(" ");break;default:AL.alcErr=40963;return 0;}ret=stringToNewUTF8(ret);AL.alcStringCache[param]=ret;return ret;}_alcGetString.sig="ppi";function _alcIsExtensionPresent(deviceId,pExtName){deviceId>>>=0;pExtName>>>=0;var name=UTF8ToString(pExtName);return AL.ALC_EXTENSIONS[name]?1:0;}_alcIsExtensionPresent.sig="ipp";function _alcMakeContextCurrent(contextId){contextId>>>=0;if(contextId===0){AL.currentCtx=null;}else{AL.currentCtx=AL.contexts[contextId];}return 1;}_alcMakeContextCurrent.sig="ip";function _alcOpenDevice(pDeviceName){pDeviceName>>>=0;if(pDeviceName){var name=UTF8ToString(pDeviceName);if(name!==AL.DEVICE_NAME){return 0;}}if(typeof AudioContext!="undefined"||typeof webkitAudioContext!="undefined"){var deviceId=AL.newId();AL.deviceRefCounts[deviceId]=0;return deviceId;}return 0;}_alcOpenDevice.sig="pp";function _alcProcessContext(contextId){contextId>>>=0;}_alcProcessContext.sig="vp";function _alcSuspendContext(contextId){contextId>>>=0;}_alcSuspendContext.sig="vp";function _docbDefaultSAXHandler(...args){return asyncifyStubs["docbDefaultSAXHandler"](...args);}_docbDefaultSAXHandler.stub=true;asyncifyStubs["docbDefaultSAXHandler"]=undefined;var _emscripten_alcDevicePauseSOFT=deviceId=>{if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return;}if(AL.paused){return;}AL.paused=true;for(var ctxId in AL.contexts){var ctx=AL.contexts[ctxId];if(ctx.deviceId!==deviceId){continue;}ctx.audioCtx.suspend();clearInterval(ctx.interval);ctx.interval=null;}};_emscripten_alcDevicePauseSOFT.sig="vi";var _emscripten_alcDeviceResumeSOFT=deviceId=>{if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return;}if(!AL.paused){return;}AL.paused=false;for(var ctxId in AL.contexts){var ctx=AL.contexts[ctxId];if(ctx.deviceId!==deviceId){continue;}ctx.interval=setInterval(()=>AL.scheduleContextAudio(ctx),AL.QUEUE_INTERVAL);ctx.audioCtx.resume();}};_emscripten_alcDeviceResumeSOFT.sig="vi";var _emscripten_alcGetStringiSOFT=(deviceId,param,index)=>{if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return 0;}if(AL.alcStringCache[param]){return AL.alcStringCache[param];}var ret;switch(param){case 6549:/* ALC_HRTF_SPECIFIER_SOFT */if(index===0){ret="Web Audio HRTF";}else{AL.alcErr=40964;return 0;}break;default:if(index!==0){AL.alcErr=40963;return 0;}return _alcGetString(deviceId,param);}ret=stringToNewUTF8(ret);AL.alcStringCache[param]=ret;return ret;};_emscripten_alcGetStringiSOFT.sig="iiii";var _emscripten_alcResetDeviceSOFT=(deviceId,pAttrList)=>{if(!(deviceId in AL.deviceRefCounts)){AL.alcErr=40961;return 0;}var hrtf=null;pAttrList>>=2;if(pAttrList){var attr=0;var val=0;while(true){attr=HEAP32[pAttrList++>>>0];if(attr===0){break;}val=HEAP32[pAttrList++>>>0];switch(attr){case 6546:/* ALC_HRTF_SOFT */if(val===1){hrtf=true;}else if(val===0){hrtf=false;}break;}}}if(hrtf!==null){// Apply hrtf attrib to all contexts for this device
for(var ctxId in AL.contexts){var ctx=AL.contexts[ctxId];if(ctx.deviceId===deviceId){ctx.hrtf=hrtf;AL.updateContextGlobal(ctx);}}}return 1;};_emscripten_alcResetDeviceSOFT.sig="iii";var readEmAsmArgsArray=[];var readEmAsmArgs=(sigPtr,buf)=>{readEmAsmArgsArray.length=0;var ch;// Most arguments are i32s, so shift the buffer pointer so it is a plain
// index into HEAP32.
while(ch=HEAPU8[sigPtr++>>>0]){// Floats are always passed as doubles, so all types except for 'i'
// are 8 bytes and require alignment.
var wide=ch!=105;wide&=ch!=112;buf+=wide&&buf%8?4:0;readEmAsmArgsArray.push(// Special case for pointers under wasm64 or CAN_ADDRESS_2GB mode.
ch==112?HEAPU32[buf>>>2>>>0]:ch==105?HEAP32[buf>>>2>>>0]:HEAPF64[buf>>>3>>>0]);buf+=wide?8:4;}return readEmAsmArgsArray;};var runEmAsmFunction=(code,sigPtr,argbuf)=>{var args=readEmAsmArgs(sigPtr,argbuf);return ASM_CONSTS[code](...args);};function _emscripten_asm_const_int(code,sigPtr,argbuf){code>>>=0;sigPtr>>>=0;argbuf>>>=0;return runEmAsmFunction(code,sigPtr,argbuf);}_emscripten_asm_const_int.sig="ippp";function _emscripten_asm_const_ptr(code,sigPtr,argbuf){code>>>=0;sigPtr>>>=0;argbuf>>>=0;return runEmAsmFunction(code,sigPtr,argbuf);}_emscripten_asm_const_ptr.sig="pppp";function _emscripten_console_error(str){str>>>=0;console.error(UTF8ToString(str));}_emscripten_console_error.sig="vp";function _emscripten_console_log(str){str>>>=0;console.log(UTF8ToString(str));}_emscripten_console_log.sig="vp";function _emscripten_console_trace(str){str>>>=0;console.trace(UTF8ToString(str));}_emscripten_console_trace.sig="vp";function _emscripten_console_warn(str){str>>>=0;console.warn(UTF8ToString(str));}_emscripten_console_warn.sig="vp";var _emscripten_date_now=()=>Date.now();_emscripten_date_now.sig="d";function _emscripten_err(str){str>>>=0;return err(UTF8ToString(str));}_emscripten_err.sig="vp";var getHeapMax=()=>// Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
// full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
// for any code that deals with heap sizes, which would require special
// casing all heap size related code to treat 0 specially.
4294901760;function _emscripten_get_heap_max(){return getHeapMax();}_emscripten_get_heap_max.sig="p";var _emscripten_get_now_res=()=>1e3;// microseconds (1/1000 of a millisecond)
_emscripten_get_now_res.sig="d";var GLctx;var webgl_enable_ANGLE_instanced_arrays=ctx=>{// Extension available in WebGL 1 from Firefox 26 and Google Chrome 30 onwards. Core feature in WebGL 2.
var ext=ctx.getExtension("ANGLE_instanced_arrays");// Because this extension is a core function in WebGL 2, assign the extension entry points in place of
// where the core functions will reside in WebGL 2. This way the calling code can call these without
// having to dynamically branch depending if running against WebGL 1 or WebGL 2.
if(ext){ctx["vertexAttribDivisor"]=(index,divisor)=>ext["vertexAttribDivisorANGLE"](index,divisor);ctx["drawArraysInstanced"]=(mode,first,count,primcount)=>ext["drawArraysInstancedANGLE"](mode,first,count,primcount);ctx["drawElementsInstanced"]=(mode,count,type,indices,primcount)=>ext["drawElementsInstancedANGLE"](mode,count,type,indices,primcount);return 1;}};var webgl_enable_OES_vertex_array_object=ctx=>{// Extension available in WebGL 1 from Firefox 25 and WebKit 536.28/desktop Safari 6.0.3 onwards. Core feature in WebGL 2.
var ext=ctx.getExtension("OES_vertex_array_object");if(ext){ctx["createVertexArray"]=()=>ext["createVertexArrayOES"]();ctx["deleteVertexArray"]=vao=>ext["deleteVertexArrayOES"](vao);ctx["bindVertexArray"]=vao=>ext["bindVertexArrayOES"](vao);ctx["isVertexArray"]=vao=>ext["isVertexArrayOES"](vao);return 1;}};var webgl_enable_WEBGL_draw_buffers=ctx=>{// Extension available in WebGL 1 from Firefox 28 onwards. Core feature in WebGL 2.
var ext=ctx.getExtension("WEBGL_draw_buffers");if(ext){ctx["drawBuffers"]=(n,bufs)=>ext["drawBuffersWEBGL"](n,bufs);return 1;}};var webgl_enable_EXT_polygon_offset_clamp=ctx=>!!(ctx.extPolygonOffsetClamp=ctx.getExtension("EXT_polygon_offset_clamp"));var webgl_enable_EXT_clip_control=ctx=>!!(ctx.extClipControl=ctx.getExtension("EXT_clip_control"));var webgl_enable_WEBGL_polygon_mode=ctx=>!!(ctx.webglPolygonMode=ctx.getExtension("WEBGL_polygon_mode"));var webgl_enable_WEBGL_multi_draw=ctx=>!!(ctx.multiDrawWebgl=ctx.getExtension("WEBGL_multi_draw"));var getEmscriptenSupportedExtensions=ctx=>{// Restrict the list of advertised extensions to those that we actually
// support.
var supportedExtensions=[// WebGL 1 extensions
"ANGLE_instanced_arrays","EXT_blend_minmax","EXT_disjoint_timer_query","EXT_frag_depth","EXT_shader_texture_lod","EXT_sRGB","OES_element_index_uint","OES_fbo_render_mipmap","OES_standard_derivatives","OES_texture_float","OES_texture_half_float","OES_texture_half_float_linear","OES_vertex_array_object","WEBGL_color_buffer_float","WEBGL_depth_texture","WEBGL_draw_buffers",// WebGL 1 and WebGL 2 extensions
"EXT_clip_control","EXT_color_buffer_half_float","EXT_depth_clamp","EXT_float_blend","EXT_polygon_offset_clamp","EXT_texture_compression_bptc","EXT_texture_compression_rgtc","EXT_texture_filter_anisotropic","KHR_parallel_shader_compile","OES_texture_float_linear","WEBGL_blend_func_extended","WEBGL_compressed_texture_astc","WEBGL_compressed_texture_etc","WEBGL_compressed_texture_etc1","WEBGL_compressed_texture_s3tc","WEBGL_compressed_texture_s3tc_srgb","WEBGL_debug_renderer_info","WEBGL_debug_shaders","WEBGL_lose_context","WEBGL_multi_draw","WEBGL_polygon_mode"];// .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
return(ctx.getSupportedExtensions()||[]).filter(ext=>supportedExtensions.includes(ext));};var GL={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:[],offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,unpackRowLength:0,recordError:errorCode=>{if(!GL.lastError){GL.lastError=errorCode;}},getNewId:table=>{var ret=GL.counter++;for(var i=table.length;i<ret;i++){table[i]=null;}return ret;},genObject:(n,buffers,createFunction,objectTable)=>{for(var i=0;i<n;i++){var buffer=GLctx[createFunction]();var id=buffer&&GL.getNewId(objectTable);if(buffer){buffer.name=id;objectTable[id]=buffer;}else{GL.recordError(1282);}HEAP32[buffers+i*4>>>2>>>0]=id;}},getSource:(shader,count,string,length)=>{var source="";for(var i=0;i<count;++i){var len=length?HEAPU32[length+i*4>>>2>>>0]:undefined;source+=UTF8ToString(HEAPU32[string+i*4>>>2>>>0],len);}return source;},createContext:(/** @type {HTMLCanvasElement} */canvas,webGLContextAttributes)=>{// BUG: Workaround Safari WebGL issue: After successfully acquiring WebGL
// context on a canvas, calling .getContext() will always return that
// context independent of which 'webgl' or 'webgl2'
// context version was passed. See:
//   https://bugs.webkit.org/show_bug.cgi?id=222758
// and:
//   https://github.com/emscripten-core/emscripten/issues/13295.
// TODO: Once the bug is fixed and shipped in Safari, adjust the Safari
// version field in above check.
if(!canvas.getContextSafariWebGL2Fixed){canvas.getContextSafariWebGL2Fixed=canvas.getContext;/** @type {function(this:HTMLCanvasElement, string, (Object|null)=): (Object|null)} */function fixedGetContext(ver,attrs){var gl=canvas.getContextSafariWebGL2Fixed(ver,attrs);return ver=="webgl"==gl instanceof WebGLRenderingContext?gl:null;}canvas.getContext=fixedGetContext;}var ctx=canvas.getContext("webgl",webGLContextAttributes);// https://caniuse.com/#feat=webgl
if(!ctx)return 0;var handle=GL.registerContext(ctx,webGLContextAttributes);return handle;},registerContext:(ctx,webGLContextAttributes)=>{// without pthreads a context is just an integer ID
var handle=GL.getNewId(GL.contexts);var context={handle,attributes:webGLContextAttributes,version:webGLContextAttributes.majorVersion,GLctx:ctx};// Store the created context object so that we can access the context
// given a canvas without having to pass the parameters again.
if(ctx.canvas)ctx.canvas.GLctxObject=context;GL.contexts[handle]=context;if(typeof webGLContextAttributes.enableExtensionsByDefault=="undefined"||webGLContextAttributes.enableExtensionsByDefault){GL.initExtensions(context);}return handle;},makeContextCurrent:contextHandle=>{// Active Emscripten GL layer context object.
GL.currentContext=GL.contexts[contextHandle];// Active WebGL context object.
Module.ctx=GLctx=GL.currentContext?.GLctx;return!(contextHandle&&!GLctx);},getContext:contextHandle=>GL.contexts[contextHandle],deleteContext:contextHandle=>{if(GL.currentContext===GL.contexts[contextHandle]){GL.currentContext=null;}if(typeof JSEvents=="object"){// Release all JS event handlers on the DOM element that the GL context is
// associated with since the context is now deleted.
JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);}// Make sure the canvas object no longer refers to the context object so
// there are no GC surprises.
if(GL.contexts[contextHandle]&&GL.contexts[contextHandle].GLctx.canvas){GL.contexts[contextHandle].GLctx.canvas.GLctxObject=undefined;}GL.contexts[contextHandle]=null;},initExtensions:context=>{// If this function is called without a specific context object, init the
// extensions of the currently active context.
context||=GL.currentContext;if(context.initExtensionsDone)return;context.initExtensionsDone=true;var GLctx=context.GLctx;// Detect the presence of a few extensions manually, ction GL interop
// layer itself will need to know if they exist.
// Extensions that are available in both WebGL 1 and WebGL 2
webgl_enable_WEBGL_multi_draw(GLctx);webgl_enable_EXT_polygon_offset_clamp(GLctx);webgl_enable_EXT_clip_control(GLctx);webgl_enable_WEBGL_polygon_mode(GLctx);// Extensions that are only available in WebGL 1 (the calls will be no-ops
// if called on a WebGL 2 context active)
webgl_enable_ANGLE_instanced_arrays(GLctx);webgl_enable_OES_vertex_array_object(GLctx);webgl_enable_WEBGL_draw_buffers(GLctx);{GLctx.disjointTimerQueryExt=GLctx.getExtension("EXT_disjoint_timer_query");}getEmscriptenSupportedExtensions(GLctx).forEach(ext=>{// WEBGL_lose_context, WEBGL_debug_renderer_info and WEBGL_debug_shaders
// are not enabled by default.
if(!ext.includes("lose_context")&&!ext.includes("debug")){// Call .getExtension() to enable that extension permanently.
GLctx.getExtension(ext);}});}};/** @suppress {duplicate } */var _glActiveTexture=x0=>GLctx.activeTexture(x0);_glActiveTexture.sig="vi";var _emscripten_glActiveTexture=_glActiveTexture;_emscripten_glActiveTexture.sig="vi";/** @suppress {duplicate } */var _glAttachShader=(program,shader)=>{GLctx.attachShader(GL.programs[program],GL.shaders[shader]);};_glAttachShader.sig="vii";var _emscripten_glAttachShader=_glAttachShader;_emscripten_glAttachShader.sig="vii";/** @suppress {duplicate } */var _glBeginQueryEXT=(target,id)=>{GLctx.disjointTimerQueryExt["beginQueryEXT"](target,GL.queries[id]);};_glBeginQueryEXT.sig="vii";var _emscripten_glBeginQueryEXT=_glBeginQueryEXT;/** @suppress {duplicate } */function _glBindAttribLocation(program,index,name){name>>>=0;GLctx.bindAttribLocation(GL.programs[program],index,UTF8ToString(name));}_glBindAttribLocation.sig="viip";var _emscripten_glBindAttribLocation=_glBindAttribLocation;_emscripten_glBindAttribLocation.sig="viip";/** @suppress {duplicate } */var _glBindBuffer=(target,buffer)=>{GLctx.bindBuffer(target,GL.buffers[buffer]);};_glBindBuffer.sig="vii";var _emscripten_glBindBuffer=_glBindBuffer;_emscripten_glBindBuffer.sig="vii";/** @suppress {duplicate } */var _glBindFramebuffer=(target,framebuffer)=>{GLctx.bindFramebuffer(target,GL.framebuffers[framebuffer]);};_glBindFramebuffer.sig="vii";var _emscripten_glBindFramebuffer=_glBindFramebuffer;_emscripten_glBindFramebuffer.sig="vii";/** @suppress {duplicate } */var _glBindRenderbuffer=(target,renderbuffer)=>{GLctx.bindRenderbuffer(target,GL.renderbuffers[renderbuffer]);};_glBindRenderbuffer.sig="vii";var _emscripten_glBindRenderbuffer=_glBindRenderbuffer;_emscripten_glBindRenderbuffer.sig="vii";/** @suppress {duplicate } */var _glBindTexture=(target,texture)=>{GLctx.bindTexture(target,GL.textures[texture]);};_glBindTexture.sig="vii";var _emscripten_glBindTexture=_glBindTexture;_emscripten_glBindTexture.sig="vii";/** @suppress {duplicate } */var _glBindVertexArray=vao=>{GLctx.bindVertexArray(GL.vaos[vao]);};_glBindVertexArray.sig="vi";/** @suppress {duplicate } */var _glBindVertexArrayOES=_glBindVertexArray;_glBindVertexArrayOES.sig="vi";var _emscripten_glBindVertexArrayOES=_glBindVertexArrayOES;_emscripten_glBindVertexArrayOES.sig="vi";/** @suppress {duplicate } */var _glBlendColor=(x0,x1,x2,x3)=>GLctx.blendColor(x0,x1,x2,x3);_glBlendColor.sig="vffff";var _emscripten_glBlendColor=_glBlendColor;_emscripten_glBlendColor.sig="vffff";/** @suppress {duplicate } */var _glBlendEquation=x0=>GLctx.blendEquation(x0);_glBlendEquation.sig="vi";var _emscripten_glBlendEquation=_glBlendEquation;_emscripten_glBlendEquation.sig="vi";/** @suppress {duplicate } */var _glBlendEquationSeparate=(x0,x1)=>GLctx.blendEquationSeparate(x0,x1);_glBlendEquationSeparate.sig="vii";var _emscripten_glBlendEquationSeparate=_glBlendEquationSeparate;_emscripten_glBlendEquationSeparate.sig="vii";/** @suppress {duplicate } */var _glBlendFunc=(x0,x1)=>GLctx.blendFunc(x0,x1);_glBlendFunc.sig="vii";var _emscripten_glBlendFunc=_glBlendFunc;_emscripten_glBlendFunc.sig="vii";/** @suppress {duplicate } */var _glBlendFuncSeparate=(x0,x1,x2,x3)=>GLctx.blendFuncSeparate(x0,x1,x2,x3);_glBlendFuncSeparate.sig="viiii";var _emscripten_glBlendFuncSeparate=_glBlendFuncSeparate;_emscripten_glBlendFuncSeparate.sig="viiii";/** @suppress {duplicate } */function _glBufferData(target,size,data,usage){size>>>=0;data>>>=0;// N.b. here first form specifies a heap subarray, second form an integer
// size, so the ?: code here is polymorphic. It is advised to avoid
// randomly mixing both uses in calling code, to avoid any potential JS
// engine JIT issues.
GLctx.bufferData(target,data?HEAPU8.subarray(data>>>0,data+size>>>0):size,usage);}_glBufferData.sig="vippi";var _emscripten_glBufferData=_glBufferData;_emscripten_glBufferData.sig="vippi";/** @suppress {duplicate } */function _glBufferSubData(target,offset,size,data){offset>>>=0;size>>>=0;data>>>=0;GLctx.bufferSubData(target,offset,HEAPU8.subarray(data>>>0,data+size>>>0));}_glBufferSubData.sig="vippp";var _emscripten_glBufferSubData=_glBufferSubData;_emscripten_glBufferSubData.sig="vippp";/** @suppress {duplicate } */var _glCheckFramebufferStatus=x0=>GLctx.checkFramebufferStatus(x0);_glCheckFramebufferStatus.sig="ii";var _emscripten_glCheckFramebufferStatus=_glCheckFramebufferStatus;_emscripten_glCheckFramebufferStatus.sig="ii";/** @suppress {duplicate } */var _glClear=x0=>GLctx.clear(x0);_glClear.sig="vi";var _emscripten_glClear=_glClear;_emscripten_glClear.sig="vi";/** @suppress {duplicate } */var _glClearColor=(x0,x1,x2,x3)=>GLctx.clearColor(x0,x1,x2,x3);_glClearColor.sig="vffff";var _emscripten_glClearColor=_glClearColor;_emscripten_glClearColor.sig="vffff";/** @suppress {duplicate } */var _glClearDepthf=x0=>GLctx.clearDepth(x0);_glClearDepthf.sig="vf";var _emscripten_glClearDepthf=_glClearDepthf;_emscripten_glClearDepthf.sig="vf";/** @suppress {duplicate } */var _glClearStencil=x0=>GLctx.clearStencil(x0);_glClearStencil.sig="vi";var _emscripten_glClearStencil=_glClearStencil;_emscripten_glClearStencil.sig="vi";/** @suppress {duplicate } */var _glClipControlEXT=(origin,depth)=>{GLctx.extClipControl["clipControlEXT"](origin,depth);};_glClipControlEXT.sig="vii";var _emscripten_glClipControlEXT=_glClipControlEXT;/** @suppress {duplicate } */var _glColorMask=(red,green,blue,alpha)=>{GLctx.colorMask(!!red,!!green,!!blue,!!alpha);};_glColorMask.sig="viiii";var _emscripten_glColorMask=_glColorMask;_emscripten_glColorMask.sig="viiii";/** @suppress {duplicate } */var _glCompileShader=shader=>{GLctx.compileShader(GL.shaders[shader]);};_glCompileShader.sig="vi";var _emscripten_glCompileShader=_glCompileShader;_emscripten_glCompileShader.sig="vi";/** @suppress {duplicate } */function _glCompressedTexImage2D(target,level,internalFormat,width,height,border,imageSize,data){data>>>=0;// `data` may be null here, which means "allocate uniniitalized space but
// don't upload" in GLES parlance, but `compressedTexImage2D` requires the
// final data parameter, so we simply pass a heap view starting at zero
// effectively uploading whatever happens to be near address zero.  See
// https://github.com/emscripten-core/emscripten/issues/19300.
GLctx.compressedTexImage2D(target,level,internalFormat,width,height,border,HEAPU8.subarray(data>>>0,data+imageSize>>>0));}_glCompressedTexImage2D.sig="viiiiiiip";var _emscripten_glCompressedTexImage2D=_glCompressedTexImage2D;_emscripten_glCompressedTexImage2D.sig="viiiiiiip";/** @suppress {duplicate } */function _glCompressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,imageSize,data){data>>>=0;GLctx.compressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,HEAPU8.subarray(data>>>0,data+imageSize>>>0));}_glCompressedTexSubImage2D.sig="viiiiiiiip";var _emscripten_glCompressedTexSubImage2D=_glCompressedTexSubImage2D;_emscripten_glCompressedTexSubImage2D.sig="viiiiiiiip";/** @suppress {duplicate } */var _glCopyTexImage2D=(x0,x1,x2,x3,x4,x5,x6,x7)=>GLctx.copyTexImage2D(x0,x1,x2,x3,x4,x5,x6,x7);_glCopyTexImage2D.sig="viiiiiiii";var _emscripten_glCopyTexImage2D=_glCopyTexImage2D;_emscripten_glCopyTexImage2D.sig="viiiiiiii";/** @suppress {duplicate } */var _glCopyTexSubImage2D=(x0,x1,x2,x3,x4,x5,x6,x7)=>GLctx.copyTexSubImage2D(x0,x1,x2,x3,x4,x5,x6,x7);_glCopyTexSubImage2D.sig="viiiiiiii";var _emscripten_glCopyTexSubImage2D=_glCopyTexSubImage2D;_emscripten_glCopyTexSubImage2D.sig="viiiiiiii";/** @suppress {duplicate } */var _glCreateProgram=()=>{var id=GL.getNewId(GL.programs);var program=GLctx.createProgram();// Store additional information needed for each shader program:
program.name=id;// Lazy cache results of
// glGetProgramiv(GL_ACTIVE_UNIFORM_MAX_LENGTH/GL_ACTIVE_ATTRIBUTE_MAX_LENGTH/GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH)
program.maxUniformLength=program.maxAttributeLength=program.maxUniformBlockNameLength=0;program.uniformIdCounter=1;GL.programs[id]=program;return id;};_glCreateProgram.sig="i";var _emscripten_glCreateProgram=_glCreateProgram;_emscripten_glCreateProgram.sig="i";/** @suppress {duplicate } */var _glCreateShader=shaderType=>{var id=GL.getNewId(GL.shaders);GL.shaders[id]=GLctx.createShader(shaderType);return id;};_glCreateShader.sig="ii";var _emscripten_glCreateShader=_glCreateShader;_emscripten_glCreateShader.sig="ii";/** @suppress {duplicate } */var _glCullFace=x0=>GLctx.cullFace(x0);_glCullFace.sig="vi";var _emscripten_glCullFace=_glCullFace;_emscripten_glCullFace.sig="vi";/** @suppress {duplicate } */function _glDeleteBuffers(n,buffers){buffers>>>=0;for(var i=0;i<n;i++){var id=HEAP32[buffers+i*4>>>2>>>0];var buffer=GL.buffers[id];// From spec: "glDeleteBuffers silently ignores 0's and names that do not
// correspond to existing buffer objects."
if(!buffer)continue;GLctx.deleteBuffer(buffer);buffer.name=0;GL.buffers[id]=null;}}_glDeleteBuffers.sig="vip";var _emscripten_glDeleteBuffers=_glDeleteBuffers;_emscripten_glDeleteBuffers.sig="vip";/** @suppress {duplicate } */function _glDeleteFramebuffers(n,framebuffers){framebuffers>>>=0;for(var i=0;i<n;++i){var id=HEAP32[framebuffers+i*4>>>2>>>0];var framebuffer=GL.framebuffers[id];if(!framebuffer)continue;// GL spec: "glDeleteFramebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
GLctx.deleteFramebuffer(framebuffer);framebuffer.name=0;GL.framebuffers[id]=null;}}_glDeleteFramebuffers.sig="vip";var _emscripten_glDeleteFramebuffers=_glDeleteFramebuffers;_emscripten_glDeleteFramebuffers.sig="vip";/** @suppress {duplicate } */var _glDeleteProgram=id=>{if(!id)return;var program=GL.programs[id];if(!program){// glDeleteProgram actually signals an error when deleting a nonexisting
// object, unlike some other GL delete functions.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}GLctx.deleteProgram(program);program.name=0;GL.programs[id]=null;};_glDeleteProgram.sig="vi";var _emscripten_glDeleteProgram=_glDeleteProgram;_emscripten_glDeleteProgram.sig="vi";/** @suppress {duplicate } */function _glDeleteQueriesEXT(n,ids){ids>>>=0;for(var i=0;i<n;i++){var id=HEAP32[ids+i*4>>>2>>>0];var query=GL.queries[id];if(!query)continue;// GL spec: "unused names in ids are ignored, as is the name zero."
GLctx.disjointTimerQueryExt["deleteQueryEXT"](query);GL.queries[id]=null;}}_glDeleteQueriesEXT.sig="vip";var _emscripten_glDeleteQueriesEXT=_glDeleteQueriesEXT;/** @suppress {duplicate } */function _glDeleteRenderbuffers(n,renderbuffers){renderbuffers>>>=0;for(var i=0;i<n;i++){var id=HEAP32[renderbuffers+i*4>>>2>>>0];var renderbuffer=GL.renderbuffers[id];if(!renderbuffer)continue;// GL spec: "glDeleteRenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
GLctx.deleteRenderbuffer(renderbuffer);renderbuffer.name=0;GL.renderbuffers[id]=null;}}_glDeleteRenderbuffers.sig="vip";var _emscripten_glDeleteRenderbuffers=_glDeleteRenderbuffers;_emscripten_glDeleteRenderbuffers.sig="vip";/** @suppress {duplicate } */var _glDeleteShader=id=>{if(!id)return;var shader=GL.shaders[id];if(!shader){// glDeleteShader actually signals an error when deleting a nonexisting
// object, unlike some other GL delete functions.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}GLctx.deleteShader(shader);GL.shaders[id]=null;};_glDeleteShader.sig="vi";var _emscripten_glDeleteShader=_glDeleteShader;_emscripten_glDeleteShader.sig="vi";/** @suppress {duplicate } */function _glDeleteTextures(n,textures){textures>>>=0;for(var i=0;i<n;i++){var id=HEAP32[textures+i*4>>>2>>>0];var texture=GL.textures[id];// GL spec: "glDeleteTextures silently ignores 0s and names that do not
// correspond to existing textures".
if(!texture)continue;GLctx.deleteTexture(texture);texture.name=0;GL.textures[id]=null;}}_glDeleteTextures.sig="vip";var _emscripten_glDeleteTextures=_glDeleteTextures;_emscripten_glDeleteTextures.sig="vip";/** @suppress {duplicate } */function _glDeleteVertexArrays(n,vaos){vaos>>>=0;for(var i=0;i<n;i++){var id=HEAP32[vaos+i*4>>>2>>>0];GLctx.deleteVertexArray(GL.vaos[id]);GL.vaos[id]=null;}}_glDeleteVertexArrays.sig="vip";/** @suppress {duplicate } */var _glDeleteVertexArraysOES=_glDeleteVertexArrays;_glDeleteVertexArraysOES.sig="vip";var _emscripten_glDeleteVertexArraysOES=_glDeleteVertexArraysOES;_emscripten_glDeleteVertexArraysOES.sig="vip";/** @suppress {duplicate } */var _glDepthFunc=x0=>GLctx.depthFunc(x0);_glDepthFunc.sig="vi";var _emscripten_glDepthFunc=_glDepthFunc;_emscripten_glDepthFunc.sig="vi";/** @suppress {duplicate } */var _glDepthMask=flag=>{GLctx.depthMask(!!flag);};_glDepthMask.sig="vi";var _emscripten_glDepthMask=_glDepthMask;_emscripten_glDepthMask.sig="vi";/** @suppress {duplicate } */var _glDepthRangef=(x0,x1)=>GLctx.depthRange(x0,x1);_glDepthRangef.sig="vff";var _emscripten_glDepthRangef=_glDepthRangef;_emscripten_glDepthRangef.sig="vff";/** @suppress {duplicate } */var _glDetachShader=(program,shader)=>{GLctx.detachShader(GL.programs[program],GL.shaders[shader]);};_glDetachShader.sig="vii";var _emscripten_glDetachShader=_glDetachShader;_emscripten_glDetachShader.sig="vii";/** @suppress {duplicate } */var _glDisable=x0=>GLctx.disable(x0);_glDisable.sig="vi";var _emscripten_glDisable=_glDisable;_emscripten_glDisable.sig="vi";/** @suppress {duplicate } */var _glDisableVertexAttribArray=index=>{GLctx.disableVertexAttribArray(index);};_glDisableVertexAttribArray.sig="vi";var _emscripten_glDisableVertexAttribArray=_glDisableVertexAttribArray;_emscripten_glDisableVertexAttribArray.sig="vi";/** @suppress {duplicate } */var _glDrawArrays=(mode,first,count)=>{GLctx.drawArrays(mode,first,count);};_glDrawArrays.sig="viii";var _emscripten_glDrawArrays=_glDrawArrays;_emscripten_glDrawArrays.sig="viii";/** @suppress {duplicate } */var _glDrawArraysInstanced=(mode,first,count,primcount)=>{GLctx.drawArraysInstanced(mode,first,count,primcount);};_glDrawArraysInstanced.sig="viiii";/** @suppress {duplicate } */var _glDrawArraysInstancedANGLE=_glDrawArraysInstanced;var _emscripten_glDrawArraysInstancedANGLE=_glDrawArraysInstancedANGLE;var tempFixedLengthArray=[];/** @suppress {duplicate } */function _glDrawBuffers(n,bufs){bufs>>>=0;var bufArray=tempFixedLengthArray[n];for(var i=0;i<n;i++){bufArray[i]=HEAP32[bufs+i*4>>>2>>>0];}GLctx.drawBuffers(bufArray);}_glDrawBuffers.sig="vip";/** @suppress {duplicate } */var _glDrawBuffersWEBGL=_glDrawBuffers;var _emscripten_glDrawBuffersWEBGL=_glDrawBuffersWEBGL;/** @suppress {duplicate } */function _glDrawElements(mode,count,type,indices){indices>>>=0;GLctx.drawElements(mode,count,type,indices);}_glDrawElements.sig="viiip";var _emscripten_glDrawElements=_glDrawElements;_emscripten_glDrawElements.sig="viiip";/** @suppress {duplicate } */function _glDrawElementsInstanced(mode,count,type,indices,primcount){indices>>>=0;GLctx.drawElementsInstanced(mode,count,type,indices,primcount);}_glDrawElementsInstanced.sig="viiipi";/** @suppress {duplicate } */var _glDrawElementsInstancedANGLE=_glDrawElementsInstanced;var _emscripten_glDrawElementsInstancedANGLE=_glDrawElementsInstancedANGLE;/** @suppress {duplicate } */var _glEnable=x0=>GLctx.enable(x0);_glEnable.sig="vi";var _emscripten_glEnable=_glEnable;_emscripten_glEnable.sig="vi";/** @suppress {duplicate } */var _glEnableVertexAttribArray=index=>{GLctx.enableVertexAttribArray(index);};_glEnableVertexAttribArray.sig="vi";var _emscripten_glEnableVertexAttribArray=_glEnableVertexAttribArray;_emscripten_glEnableVertexAttribArray.sig="vi";/** @suppress {duplicate } */var _glEndQueryEXT=target=>{GLctx.disjointTimerQueryExt["endQueryEXT"](target);};_glEndQueryEXT.sig="vi";var _emscripten_glEndQueryEXT=_glEndQueryEXT;/** @suppress {duplicate } */var _glFinish=()=>GLctx.finish();_glFinish.sig="v";var _emscripten_glFinish=_glFinish;_emscripten_glFinish.sig="v";/** @suppress {duplicate } */var _glFlush=()=>GLctx.flush();_glFlush.sig="v";var _emscripten_glFlush=_glFlush;_emscripten_glFlush.sig="v";/** @suppress {duplicate } */var _glFramebufferRenderbuffer=(target,attachment,renderbuffertarget,renderbuffer)=>{GLctx.framebufferRenderbuffer(target,attachment,renderbuffertarget,GL.renderbuffers[renderbuffer]);};_glFramebufferRenderbuffer.sig="viiii";var _emscripten_glFramebufferRenderbuffer=_glFramebufferRenderbuffer;_emscripten_glFramebufferRenderbuffer.sig="viiii";/** @suppress {duplicate } */var _glFramebufferTexture2D=(target,attachment,textarget,texture,level)=>{GLctx.framebufferTexture2D(target,attachment,textarget,GL.textures[texture],level);};_glFramebufferTexture2D.sig="viiiii";var _emscripten_glFramebufferTexture2D=_glFramebufferTexture2D;_emscripten_glFramebufferTexture2D.sig="viiiii";/** @suppress {duplicate } */var _glFrontFace=x0=>GLctx.frontFace(x0);_glFrontFace.sig="vi";var _emscripten_glFrontFace=_glFrontFace;_emscripten_glFrontFace.sig="vi";/** @suppress {duplicate } */function _glGenBuffers(n,buffers){buffers>>>=0;GL.genObject(n,buffers,"createBuffer",GL.buffers);}_glGenBuffers.sig="vip";var _emscripten_glGenBuffers=_glGenBuffers;_emscripten_glGenBuffers.sig="vip";/** @suppress {duplicate } */function _glGenFramebuffers(n,ids){ids>>>=0;GL.genObject(n,ids,"createFramebuffer",GL.framebuffers);}_glGenFramebuffers.sig="vip";var _emscripten_glGenFramebuffers=_glGenFramebuffers;_emscripten_glGenFramebuffers.sig="vip";/** @suppress {duplicate } */function _glGenQueriesEXT(n,ids){ids>>>=0;for(var i=0;i<n;i++){var query=GLctx.disjointTimerQueryExt["createQueryEXT"]();if(!query){GL.recordError(1282);/* GL_INVALID_OPERATION */while(i<n)HEAP32[ids+i++*4>>>2>>>0]=0;return;}var id=GL.getNewId(GL.queries);query.name=id;GL.queries[id]=query;HEAP32[ids+i*4>>>2>>>0]=id;}}_glGenQueriesEXT.sig="vip";var _emscripten_glGenQueriesEXT=_glGenQueriesEXT;/** @suppress {duplicate } */function _glGenRenderbuffers(n,renderbuffers){renderbuffers>>>=0;GL.genObject(n,renderbuffers,"createRenderbuffer",GL.renderbuffers);}_glGenRenderbuffers.sig="vip";var _emscripten_glGenRenderbuffers=_glGenRenderbuffers;_emscripten_glGenRenderbuffers.sig="vip";/** @suppress {duplicate } */function _glGenTextures(n,textures){textures>>>=0;GL.genObject(n,textures,"createTexture",GL.textures);}_glGenTextures.sig="vip";var _emscripten_glGenTextures=_glGenTextures;_emscripten_glGenTextures.sig="vip";/** @suppress {duplicate } */function _glGenVertexArrays(n,arrays){arrays>>>=0;GL.genObject(n,arrays,"createVertexArray",GL.vaos);}_glGenVertexArrays.sig="vip";/** @suppress {duplicate } */var _glGenVertexArraysOES=_glGenVertexArrays;_glGenVertexArraysOES.sig="vip";var _emscripten_glGenVertexArraysOES=_glGenVertexArraysOES;_emscripten_glGenVertexArraysOES.sig="vip";/** @suppress {duplicate } */var _glGenerateMipmap=x0=>GLctx.generateMipmap(x0);_glGenerateMipmap.sig="vi";var _emscripten_glGenerateMipmap=_glGenerateMipmap;_emscripten_glGenerateMipmap.sig="vi";var __glGetActiveAttribOrUniform=(funcName,program,index,bufSize,length,size,type,name)=>{program=GL.programs[program];var info=GLctx[funcName](program,index);if(info){// If an error occurs, nothing will be written to length, size and type and name.
var numBytesWrittenExclNull=name&&stringToUTF8(info.name,name,bufSize);if(length)HEAP32[length>>>2>>>0]=numBytesWrittenExclNull;if(size)HEAP32[size>>>2>>>0]=info.size;if(type)HEAP32[type>>>2>>>0]=info.type;}};/** @suppress {duplicate } */function _glGetActiveAttrib(program,index,bufSize,length,size,type,name){length>>>=0;size>>>=0;type>>>=0;name>>>=0;__glGetActiveAttribOrUniform("getActiveAttrib",program,index,bufSize,length,size,type,name);}_glGetActiveAttrib.sig="viiipppp";var _emscripten_glGetActiveAttrib=_glGetActiveAttrib;_emscripten_glGetActiveAttrib.sig="viiipppp";/** @suppress {duplicate } */function _glGetActiveUniform(program,index,bufSize,length,size,type,name){length>>>=0;size>>>=0;type>>>=0;name>>>=0;__glGetActiveAttribOrUniform("getActiveUniform",program,index,bufSize,length,size,type,name);}_glGetActiveUniform.sig="viiipppp";var _emscripten_glGetActiveUniform=_glGetActiveUniform;_emscripten_glGetActiveUniform.sig="viiipppp";/** @suppress {duplicate } */function _glGetAttachedShaders(program,maxCount,count,shaders){count>>>=0;shaders>>>=0;var result=GLctx.getAttachedShaders(GL.programs[program]);var len=result.length;if(len>maxCount){len=maxCount;}HEAP32[count>>>2>>>0]=len;for(var i=0;i<len;++i){var id=GL.shaders.indexOf(result[i]);HEAP32[shaders+i*4>>>2>>>0]=id;}}_glGetAttachedShaders.sig="viipp";var _emscripten_glGetAttachedShaders=_glGetAttachedShaders;_emscripten_glGetAttachedShaders.sig="viipp";/** @suppress {duplicate } */function _glGetAttribLocation(program,name){name>>>=0;return GLctx.getAttribLocation(GL.programs[program],UTF8ToString(name));}_glGetAttribLocation.sig="iip";var _emscripten_glGetAttribLocation=_glGetAttribLocation;_emscripten_glGetAttribLocation.sig="iip";var writeI53ToI64=(ptr,num)=>{HEAPU32[ptr>>>2>>>0]=num;var lower=HEAPU32[ptr>>>2>>>0];HEAPU32[ptr+4>>>2>>>0]=(num-lower)/4294967296;};var emscriptenWebGLGet=(name_,p,type)=>{// Guard against user passing a null pointer.
// Note that GLES2 spec does not say anything about how passing a null
// pointer should be treated.  Testing on desktop core GL 3, the application
// crashes on glGetIntegerv to a null pointer, but better to report an error
// instead of doing anything random.
if(!p){GL.recordError(1281);/* GL_INVALID_VALUE */return;}var ret=undefined;switch(name_){// Handle a few trivial GLES values
case 36346:// GL_SHADER_COMPILER
ret=1;break;case 36344:// GL_SHADER_BINARY_FORMATS
if(type!=0&&type!=1){GL.recordError(1280);}// Do not write anything to the out pointer, since no binary formats are
// supported.
return;case 36345:// GL_NUM_SHADER_BINARY_FORMATS
ret=0;break;case 34466:// GL_NUM_COMPRESSED_TEXTURE_FORMATS
// WebGL doesn't have GL_NUM_COMPRESSED_TEXTURE_FORMATS (it's obsolete
// since GL_COMPRESSED_TEXTURE_FORMATS returns a JS array that can be
// queried for length), so implement it ourselves to allow C++ GLES2
// code get the length.
var formats=GLctx.getParameter(34467);/*GL_COMPRESSED_TEXTURE_FORMATS*/ret=formats?formats.length:0;break;}if(ret===undefined){var result=GLctx.getParameter(name_);switch(typeof result){case"number":ret=result;break;case"boolean":ret=result?1:0;break;case"string":GL.recordError(1280);// GL_INVALID_ENUM
return;case"object":if(result===null){// null is a valid result for some (e.g., which buffer is bound -
// perhaps nothing is bound), but otherwise can mean an invalid
// name_, which we need to report as an error
switch(name_){case 34964:// ARRAY_BUFFER_BINDING
case 35725:// CURRENT_PROGRAM
case 34965:// ELEMENT_ARRAY_BUFFER_BINDING
case 36006:// FRAMEBUFFER_BINDING or DRAW_FRAMEBUFFER_BINDING
case 36007:// RENDERBUFFER_BINDING
case 32873:// TEXTURE_BINDING_2D
case 34229:// WebGL 2 GL_VERTEX_ARRAY_BINDING, or WebGL 1 extension OES_vertex_array_object GL_VERTEX_ARRAY_BINDING_OES
case 34068:{// TEXTURE_BINDING_CUBE_MAP
ret=0;break;}default:{GL.recordError(1280);// GL_INVALID_ENUM
return;}}}else if(result instanceof Float32Array||result instanceof Uint32Array||result instanceof Int32Array||result instanceof Array){for(var i=0;i<result.length;++i){switch(type){case 0:HEAP32[p+i*4>>>2>>>0]=result[i];break;case 2:HEAPF32[p+i*4>>>2>>>0]=result[i];break;case 4:HEAP8[p+i>>>0]=result[i]?1:0;break;}}return;}else{try{ret=result.name|0;}catch(e){GL.recordError(1280);// GL_INVALID_ENUM
err(`GL_INVALID_ENUM in glGet${type}v: Unknown object returned from WebGL getParameter(${name_})! (error: ${e})`);return;}}break;default:GL.recordError(1280);// GL_INVALID_ENUM
err(`GL_INVALID_ENUM in glGet${type}v: Native code calling glGet${type}v(${name_}) and it returns ${result} of type ${typeof result}!`);return;}}switch(type){case 1:writeI53ToI64(p,ret);break;case 0:HEAP32[p>>>2>>>0]=ret;break;case 2:HEAPF32[p>>>2>>>0]=ret;break;case 4:HEAP8[p>>>0]=ret?1:0;break;}};/** @suppress {duplicate } */function _glGetBooleanv(name_,p){p>>>=0;return emscriptenWebGLGet(name_,p,4);}_glGetBooleanv.sig="vip";var _emscripten_glGetBooleanv=_glGetBooleanv;_emscripten_glGetBooleanv.sig="vip";/** @suppress {duplicate } */function _glGetBufferParameteriv(target,value,data){data>>>=0;if(!data){// GLES2 specification does not specify how to behave if data is a null
// pointer. Since calling this function does not make sense if data ==
// null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}HEAP32[data>>>2>>>0]=GLctx.getBufferParameter(target,value);}_glGetBufferParameteriv.sig="viip";var _emscripten_glGetBufferParameteriv=_glGetBufferParameteriv;_emscripten_glGetBufferParameteriv.sig="viip";/** @suppress {duplicate } */var _glGetError=()=>{var error=GLctx.getError()||GL.lastError;GL.lastError=0;/*GL_NO_ERROR*/return error;};_glGetError.sig="i";var _emscripten_glGetError=_glGetError;_emscripten_glGetError.sig="i";/** @suppress {duplicate } */function _glGetFloatv(name_,p){p>>>=0;return emscriptenWebGLGet(name_,p,2);}_glGetFloatv.sig="vip";var _emscripten_glGetFloatv=_glGetFloatv;_emscripten_glGetFloatv.sig="vip";/** @suppress {duplicate } */function _glGetFramebufferAttachmentParameteriv(target,attachment,pname,params){params>>>=0;var result=GLctx.getFramebufferAttachmentParameter(target,attachment,pname);if(result instanceof WebGLRenderbuffer||result instanceof WebGLTexture){result=result.name|0;}HEAP32[params>>>2>>>0]=result;}_glGetFramebufferAttachmentParameteriv.sig="viiip";var _emscripten_glGetFramebufferAttachmentParameteriv=_glGetFramebufferAttachmentParameteriv;_emscripten_glGetFramebufferAttachmentParameteriv.sig="viiip";/** @suppress {duplicate } */function _glGetIntegerv(name_,p){p>>>=0;return emscriptenWebGLGet(name_,p,0);}_glGetIntegerv.sig="vip";var _emscripten_glGetIntegerv=_glGetIntegerv;_emscripten_glGetIntegerv.sig="vip";/** @suppress {duplicate } */function _glGetProgramInfoLog(program,maxLength,length,infoLog){length>>>=0;infoLog>>>=0;var log=GLctx.getProgramInfoLog(GL.programs[program]);if(log===null)log="(unknown error)";var numBytesWrittenExclNull=maxLength>0&&infoLog?stringToUTF8(log,infoLog,maxLength):0;if(length)HEAP32[length>>>2>>>0]=numBytesWrittenExclNull;}_glGetProgramInfoLog.sig="viipp";var _emscripten_glGetProgramInfoLog=_glGetProgramInfoLog;_emscripten_glGetProgramInfoLog.sig="viipp";/** @suppress {duplicate } */function _glGetProgramiv(program,pname,p){p>>>=0;if(!p){// GLES2 specification does not specify how to behave if p is a null
// pointer. Since calling this function does not make sense if p == null,
// issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}if(program>=GL.counter){GL.recordError(1281);/* GL_INVALID_VALUE */return;}program=GL.programs[program];if(pname==35716){// GL_INFO_LOG_LENGTH
var log=GLctx.getProgramInfoLog(program);if(log===null)log="(unknown error)";HEAP32[p>>>2>>>0]=log.length+1;}else if(pname==35719)/* GL_ACTIVE_UNIFORM_MAX_LENGTH */{if(!program.maxUniformLength){var numActiveUniforms=GLctx.getProgramParameter(program,35718);/*GL_ACTIVE_UNIFORMS*/for(var i=0;i<numActiveUniforms;++i){program.maxUniformLength=Math.max(program.maxUniformLength,GLctx.getActiveUniform(program,i).name.length+1);}}HEAP32[p>>>2>>>0]=program.maxUniformLength;}else if(pname==35722)/* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */{if(!program.maxAttributeLength){var numActiveAttributes=GLctx.getProgramParameter(program,35721);/*GL_ACTIVE_ATTRIBUTES*/for(var i=0;i<numActiveAttributes;++i){program.maxAttributeLength=Math.max(program.maxAttributeLength,GLctx.getActiveAttrib(program,i).name.length+1);}}HEAP32[p>>>2>>>0]=program.maxAttributeLength;}else if(pname==35381)/* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */{if(!program.maxUniformBlockNameLength){var numActiveUniformBlocks=GLctx.getProgramParameter(program,35382);/*GL_ACTIVE_UNIFORM_BLOCKS*/for(var i=0;i<numActiveUniformBlocks;++i){program.maxUniformBlockNameLength=Math.max(program.maxUniformBlockNameLength,GLctx.getActiveUniformBlockName(program,i).length+1);}}HEAP32[p>>>2>>>0]=program.maxUniformBlockNameLength;}else{HEAP32[p>>>2>>>0]=GLctx.getProgramParameter(program,pname);}}_glGetProgramiv.sig="viip";var _emscripten_glGetProgramiv=_glGetProgramiv;_emscripten_glGetProgramiv.sig="viip";/** @suppress {duplicate } */function _glGetQueryObjecti64vEXT(id,pname,params){params>>>=0;if(!params){// GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
// if p == null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}var query=GL.queries[id];var param;{param=GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query,pname);}var ret;if(typeof param=="boolean"){ret=param?1:0;}else{ret=param;}writeI53ToI64(params,ret);}_glGetQueryObjecti64vEXT.sig="viip";var _emscripten_glGetQueryObjecti64vEXT=_glGetQueryObjecti64vEXT;/** @suppress {duplicate } */function _glGetQueryObjectivEXT(id,pname,params){params>>>=0;if(!params){// GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
// if p == null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}var query=GL.queries[id];var param=GLctx.disjointTimerQueryExt["getQueryObjectEXT"](query,pname);var ret;if(typeof param=="boolean"){ret=param?1:0;}else{ret=param;}HEAP32[params>>>2>>>0]=ret;}_glGetQueryObjectivEXT.sig="viip";var _emscripten_glGetQueryObjectivEXT=_glGetQueryObjectivEXT;/** @suppress {duplicate } */var _glGetQueryObjectui64vEXT=_glGetQueryObjecti64vEXT;var _emscripten_glGetQueryObjectui64vEXT=_glGetQueryObjectui64vEXT;/** @suppress {duplicate } */var _glGetQueryObjectuivEXT=_glGetQueryObjectivEXT;var _emscripten_glGetQueryObjectuivEXT=_glGetQueryObjectuivEXT;/** @suppress {duplicate } */function _glGetQueryivEXT(target,pname,params){params>>>=0;if(!params){// GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
// if p == null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}HEAP32[params>>>2>>>0]=GLctx.disjointTimerQueryExt["getQueryEXT"](target,pname);}_glGetQueryivEXT.sig="viip";var _emscripten_glGetQueryivEXT=_glGetQueryivEXT;/** @suppress {duplicate } */function _glGetRenderbufferParameteriv(target,pname,params){params>>>=0;if(!params){// GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
// if params == null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}HEAP32[params>>>2>>>0]=GLctx.getRenderbufferParameter(target,pname);}_glGetRenderbufferParameteriv.sig="viip";var _emscripten_glGetRenderbufferParameteriv=_glGetRenderbufferParameteriv;_emscripten_glGetRenderbufferParameteriv.sig="viip";/** @suppress {duplicate } */function _glGetShaderInfoLog(shader,maxLength,length,infoLog){length>>>=0;infoLog>>>=0;var log=GLctx.getShaderInfoLog(GL.shaders[shader]);if(log===null)log="(unknown error)";var numBytesWrittenExclNull=maxLength>0&&infoLog?stringToUTF8(log,infoLog,maxLength):0;if(length)HEAP32[length>>>2>>>0]=numBytesWrittenExclNull;}_glGetShaderInfoLog.sig="viipp";var _emscripten_glGetShaderInfoLog=_glGetShaderInfoLog;_emscripten_glGetShaderInfoLog.sig="viipp";/** @suppress {duplicate } */function _glGetShaderPrecisionFormat(shaderType,precisionType,range,precision){range>>>=0;precision>>>=0;var result=GLctx.getShaderPrecisionFormat(shaderType,precisionType);HEAP32[range>>>2>>>0]=result.rangeMin;HEAP32[range+4>>>2>>>0]=result.rangeMax;HEAP32[precision>>>2>>>0]=result.precision;}_glGetShaderPrecisionFormat.sig="viipp";var _emscripten_glGetShaderPrecisionFormat=_glGetShaderPrecisionFormat;_emscripten_glGetShaderPrecisionFormat.sig="viipp";/** @suppress {duplicate } */function _glGetShaderSource(shader,bufSize,length,source){length>>>=0;source>>>=0;var result=GLctx.getShaderSource(GL.shaders[shader]);if(!result)return;// If an error occurs, nothing will be written to length or source.
var numBytesWrittenExclNull=bufSize>0&&source?stringToUTF8(result,source,bufSize):0;if(length)HEAP32[length>>>2>>>0]=numBytesWrittenExclNull;}_glGetShaderSource.sig="viipp";var _emscripten_glGetShaderSource=_glGetShaderSource;_emscripten_glGetShaderSource.sig="viipp";/** @suppress {duplicate } */function _glGetShaderiv(shader,pname,p){p>>>=0;if(!p){// GLES2 specification does not specify how to behave if p is a null
// pointer. Since calling this function does not make sense if p == null,
// issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}if(pname==35716){// GL_INFO_LOG_LENGTH
var log=GLctx.getShaderInfoLog(GL.shaders[shader]);if(log===null)log="(unknown error)";// The GLES2 specification says that if the shader has an empty info log,
// a value of 0 is returned. Otherwise the log has a null char appended.
// (An empty string is falsey, so we can just check that instead of
// looking at log.length.)
var logLength=log?log.length+1:0;HEAP32[p>>>2>>>0]=logLength;}else if(pname==35720){// GL_SHADER_SOURCE_LENGTH
var source=GLctx.getShaderSource(GL.shaders[shader]);// source may be a null, or the empty string, both of which are falsey
// values that we report a 0 length for.
var sourceLength=source?source.length+1:0;HEAP32[p>>>2>>>0]=sourceLength;}else{HEAP32[p>>>2>>>0]=GLctx.getShaderParameter(GL.shaders[shader],pname);}}_glGetShaderiv.sig="viip";var _emscripten_glGetShaderiv=_glGetShaderiv;_emscripten_glGetShaderiv.sig="viip";var webglGetExtensions=function $webglGetExtensions(){var exts=getEmscriptenSupportedExtensions(GLctx);exts=exts.concat(exts.map(e=>"GL_"+e));return exts;};/** @suppress {duplicate } */function _glGetString(name_){var ret=GL.stringCache[name_];if(!ret){switch(name_){case 7939:/* GL_EXTENSIONS */ret=stringToNewUTF8(webglGetExtensions().join(" "));break;case 7936:/* GL_VENDOR */case 7937:/* GL_RENDERER */case 37445:/* UNMASKED_VENDOR_WEBGL */case 37446:/* UNMASKED_RENDERER_WEBGL */var s=GLctx.getParameter(name_);if(!s){GL.recordError(1280);}ret=s?stringToNewUTF8(s):0;break;case 7938:/* GL_VERSION */var webGLVersion=GLctx.getParameter(7938);// return GLES version string corresponding to the version of the WebGL context
var glVersion=`OpenGL ES 2.0 (${webGLVersion})`;ret=stringToNewUTF8(glVersion);break;case 35724:/* GL_SHADING_LANGUAGE_VERSION */var glslVersion=GLctx.getParameter(35724);// extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'
var ver_re=/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;var ver_num=glslVersion.match(ver_re);if(ver_num!==null){if(ver_num[1].length==3)ver_num[1]=ver_num[1]+"0";// ensure minor version has 2 digits
glslVersion=`OpenGL ES GLSL ES ${ver_num[1]} (${glslVersion})`;}ret=stringToNewUTF8(glslVersion);break;default:GL.recordError(1280);}// fall through
GL.stringCache[name_]=ret;}return ret;}_glGetString.sig="pi";var _emscripten_glGetString=_glGetString;_emscripten_glGetString.sig="pi";/** @suppress {duplicate } */function _glGetTexParameterfv(target,pname,params){params>>>=0;if(!params){// GLES2 specification does not specify how to behave if params is a null
// pointer. Since calling this function does not make sense if p == null,
// issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}HEAPF32[params>>>2>>>0]=GLctx.getTexParameter(target,pname);}_glGetTexParameterfv.sig="viip";var _emscripten_glGetTexParameterfv=_glGetTexParameterfv;_emscripten_glGetTexParameterfv.sig="viip";/** @suppress {duplicate } */function _glGetTexParameteriv(target,pname,params){params>>>=0;if(!params){// GLES2 specification does not specify how to behave if params is a null
// pointer. Since calling this function does not make sense if p == null,
// issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}HEAP32[params>>>2>>>0]=GLctx.getTexParameter(target,pname);}_glGetTexParameteriv.sig="viip";var _emscripten_glGetTexParameteriv=_glGetTexParameteriv;_emscripten_glGetTexParameteriv.sig="viip";/** @noinline */var webglGetLeftBracePos=name=>name.slice(-1)=="]"&&name.lastIndexOf("[");var webglPrepareUniformLocationsBeforeFirstUse=program=>{var uniformLocsById=program.uniformLocsById,// Maps GLuint -> WebGLUniformLocation
uniformSizeAndIdsByName=program.uniformSizeAndIdsByName,// Maps name -> [uniform array length, GLuint]
i,j;// On the first time invocation of glGetUniformLocation on this shader program:
// initialize cache data structures and discover which uniforms are arrays.
if(!uniformLocsById){// maps GLint integer locations to WebGLUniformLocations
program.uniformLocsById=uniformLocsById={};// maps integer locations back to uniform name strings, so that we can lazily fetch uniform array locations
program.uniformArrayNamesById={};var numActiveUniforms=GLctx.getProgramParameter(program,35718);/*GL_ACTIVE_UNIFORMS*/for(i=0;i<numActiveUniforms;++i){var u=GLctx.getActiveUniform(program,i);var nm=u.name;var sz=u.size;var lb=webglGetLeftBracePos(nm);var arrayName=lb>0?nm.slice(0,lb):nm;// Assign a new location.
var id=program.uniformIdCounter;program.uniformIdCounter+=sz;// Eagerly get the location of the uniformArray[0] base element.
// The remaining indices >0 will be left for lazy evaluation to
// improve performance. Those may never be needed to fetch, if the
// application fills arrays always in full starting from the first
// element of the array.
uniformSizeAndIdsByName[arrayName]=[sz,id];// Store placeholder integers in place that highlight that these
// >0 index locations are array indices pending population.
for(j=0;j<sz;++j){uniformLocsById[id]=j;program.uniformArrayNamesById[id++]=arrayName;}}}};/** @suppress {duplicate } */function _glGetUniformLocation(program,name){name>>>=0;name=UTF8ToString(name);if(program=GL.programs[program]){webglPrepareUniformLocationsBeforeFirstUse(program);var uniformLocsById=program.uniformLocsById;// Maps GLuint -> WebGLUniformLocation
var arrayIndex=0;var uniformBaseName=name;// Invariant: when populating integer IDs for uniform locations, we must
// maintain the precondition that arrays reside in contiguous addresses,
// i.e. for a 'vec4 colors[10];', colors[4] must be at location
// colors[0]+4.  However, user might call glGetUniformLocation(program,
// "colors") for an array, so we cannot discover based on the user input
// arguments whether the uniform we are dealing with is an array. The only
// way to discover which uniforms are arrays is to enumerate over all the
// active uniforms in the program.
var leftBrace=webglGetLeftBracePos(name);// If user passed an array accessor "[index]", parse the array index off the accessor.
if(leftBrace>0){arrayIndex=jstoi_q(name.slice(leftBrace+1))>>>0;// "index]", coerce parseInt(']') with >>>0 to treat "foo[]" as "foo[0]" and foo[-1] as unsigned out-of-bounds.
uniformBaseName=name.slice(0,leftBrace);}// Have we cached the location of this uniform before?
// A pair [array length, GLint of the uniform location]
var sizeAndId=program.uniformSizeAndIdsByName[uniformBaseName];// If an uniform with this name exists, and if its index is within the
// array limits (if it's even an array), query the WebGLlocation, or
// return an existing cached location.
if(sizeAndId&&arrayIndex<sizeAndId[0]){arrayIndex+=sizeAndId[1];// Add the base location of the uniform to the array index offset.
if(uniformLocsById[arrayIndex]=uniformLocsById[arrayIndex]||GLctx.getUniformLocation(program,name)){return arrayIndex;}}}else{// N.b. we are currently unable to distinguish between GL program IDs that
// never existed vs GL program IDs that have been deleted, so report
// GL_INVALID_VALUE in both cases.
GL.recordError(1281);}/* GL_INVALID_VALUE */return-1;}_glGetUniformLocation.sig="iip";var _emscripten_glGetUniformLocation=_glGetUniformLocation;_emscripten_glGetUniformLocation.sig="iip";var webglGetUniformLocation=location=>{var p=GLctx.currentProgram;if(p){var webglLoc=p.uniformLocsById[location];// p.uniformLocsById[location] stores either an integer, or a
// WebGLUniformLocation.
// If an integer, we have not yet bound the location, so do it now. The
// integer value specifies the array index we should bind to.
if(typeof webglLoc=="number"){p.uniformLocsById[location]=webglLoc=GLctx.getUniformLocation(p,p.uniformArrayNamesById[location]+(webglLoc>0?`[${webglLoc}]`:""));}// Else an already cached WebGLUniformLocation, return it.
return webglLoc;}else{GL.recordError(1282);}};/** @suppress{checkTypes} */var emscriptenWebGLGetUniform=(program,location,params,type)=>{if(!params){// GLES2 specification does not specify how to behave if params is a null
// pointer. Since calling this function does not make sense if params ==
// null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}program=GL.programs[program];webglPrepareUniformLocationsBeforeFirstUse(program);var data=GLctx.getUniform(program,webglGetUniformLocation(location));if(typeof data=="number"||typeof data=="boolean"){switch(type){case 0:HEAP32[params>>>2>>>0]=data;break;case 2:HEAPF32[params>>>2>>>0]=data;break;}}else{for(var i=0;i<data.length;i++){switch(type){case 0:HEAP32[params+i*4>>>2>>>0]=data[i];break;case 2:HEAPF32[params+i*4>>>2>>>0]=data[i];break;}}}};/** @suppress {duplicate } */function _glGetUniformfv(program,location,params){params>>>=0;emscriptenWebGLGetUniform(program,location,params,2);}_glGetUniformfv.sig="viip";var _emscripten_glGetUniformfv=_glGetUniformfv;_emscripten_glGetUniformfv.sig="viip";/** @suppress {duplicate } */function _glGetUniformiv(program,location,params){params>>>=0;emscriptenWebGLGetUniform(program,location,params,0);}_glGetUniformiv.sig="viip";var _emscripten_glGetUniformiv=_glGetUniformiv;_emscripten_glGetUniformiv.sig="viip";/** @suppress {duplicate } */function _glGetVertexAttribPointerv(index,pname,pointer){pointer>>>=0;if(!pointer){// GLES2 specification does not specify how to behave if pointer is a null
// pointer. Since calling this function does not make sense if pointer ==
// null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}HEAP32[pointer>>>2>>>0]=GLctx.getVertexAttribOffset(index,pname);}_glGetVertexAttribPointerv.sig="viip";var _emscripten_glGetVertexAttribPointerv=_glGetVertexAttribPointerv;_emscripten_glGetVertexAttribPointerv.sig="viip";/** @suppress{checkTypes} */var emscriptenWebGLGetVertexAttrib=(index,pname,params,type)=>{if(!params){// GLES2 specification does not specify how to behave if params is a null
// pointer. Since calling this function does not make sense if params ==
// null, issue a GL error to notify user about it.
GL.recordError(1281);/* GL_INVALID_VALUE */return;}var data=GLctx.getVertexAttrib(index,pname);if(pname==34975)/*VERTEX_ATTRIB_ARRAY_BUFFER_BINDING*/{HEAP32[params>>>2>>>0]=data&&data["name"];}else if(typeof data=="number"||typeof data=="boolean"){switch(type){case 0:HEAP32[params>>>2>>>0]=data;break;case 2:HEAPF32[params>>>2>>>0]=data;break;case 5:HEAP32[params>>>2>>>0]=Math.fround(data);break;}}else{for(var i=0;i<data.length;i++){switch(type){case 0:HEAP32[params+i*4>>>2>>>0]=data[i];break;case 2:HEAPF32[params+i*4>>>2>>>0]=data[i];break;case 5:HEAP32[params+i*4>>>2>>>0]=Math.fround(data[i]);break;}}}};/** @suppress {duplicate } */function _glGetVertexAttribfv(index,pname,params){params>>>=0;// N.B. This function may only be called if the vertex attribute was
// specified using the function glVertexAttrib*f(), otherwise the results
// are undefined. (GLES3 spec 6.1.12)
emscriptenWebGLGetVertexAttrib(index,pname,params,2);}_glGetVertexAttribfv.sig="viip";var _emscripten_glGetVertexAttribfv=_glGetVertexAttribfv;_emscripten_glGetVertexAttribfv.sig="viip";/** @suppress {duplicate } */function _glGetVertexAttribiv(index,pname,params){params>>>=0;// N.B. This function may only be called if the vertex attribute was
// specified using the function glVertexAttrib*f(), otherwise the results
// are undefined. (GLES3 spec 6.1.12)
emscriptenWebGLGetVertexAttrib(index,pname,params,5);}_glGetVertexAttribiv.sig="viip";var _emscripten_glGetVertexAttribiv=_glGetVertexAttribiv;_emscripten_glGetVertexAttribiv.sig="viip";/** @suppress {duplicate } */var _glHint=(x0,x1)=>GLctx.hint(x0,x1);_glHint.sig="vii";var _emscripten_glHint=_glHint;_emscripten_glHint.sig="vii";/** @suppress {duplicate } */var _glIsBuffer=buffer=>{var b=GL.buffers[buffer];if(!b)return 0;return GLctx.isBuffer(b);};_glIsBuffer.sig="ii";var _emscripten_glIsBuffer=_glIsBuffer;_emscripten_glIsBuffer.sig="ii";/** @suppress {duplicate } */var _glIsEnabled=x0=>GLctx.isEnabled(x0);_glIsEnabled.sig="ii";var _emscripten_glIsEnabled=_glIsEnabled;_emscripten_glIsEnabled.sig="ii";/** @suppress {duplicate } */var _glIsFramebuffer=framebuffer=>{var fb=GL.framebuffers[framebuffer];if(!fb)return 0;return GLctx.isFramebuffer(fb);};_glIsFramebuffer.sig="ii";var _emscripten_glIsFramebuffer=_glIsFramebuffer;_emscripten_glIsFramebuffer.sig="ii";/** @suppress {duplicate } */var _glIsProgram=program=>{program=GL.programs[program];if(!program)return 0;return GLctx.isProgram(program);};_glIsProgram.sig="ii";var _emscripten_glIsProgram=_glIsProgram;_emscripten_glIsProgram.sig="ii";/** @suppress {duplicate } */var _glIsQueryEXT=id=>{var query=GL.queries[id];if(!query)return 0;return GLctx.disjointTimerQueryExt["isQueryEXT"](query);};_glIsQueryEXT.sig="ii";var _emscripten_glIsQueryEXT=_glIsQueryEXT;/** @suppress {duplicate } */var _glIsRenderbuffer=renderbuffer=>{var rb=GL.renderbuffers[renderbuffer];if(!rb)return 0;return GLctx.isRenderbuffer(rb);};_glIsRenderbuffer.sig="ii";var _emscripten_glIsRenderbuffer=_glIsRenderbuffer;_emscripten_glIsRenderbuffer.sig="ii";/** @suppress {duplicate } */var _glIsShader=shader=>{var s=GL.shaders[shader];if(!s)return 0;return GLctx.isShader(s);};_glIsShader.sig="ii";var _emscripten_glIsShader=_glIsShader;_emscripten_glIsShader.sig="ii";/** @suppress {duplicate } */var _glIsTexture=id=>{var texture=GL.textures[id];if(!texture)return 0;return GLctx.isTexture(texture);};_glIsTexture.sig="ii";var _emscripten_glIsTexture=_glIsTexture;_emscripten_glIsTexture.sig="ii";/** @suppress {duplicate } */var _glIsVertexArray=array=>{var vao=GL.vaos[array];if(!vao)return 0;return GLctx.isVertexArray(vao);};_glIsVertexArray.sig="ii";/** @suppress {duplicate } */var _glIsVertexArrayOES=_glIsVertexArray;_glIsVertexArrayOES.sig="ii";var _emscripten_glIsVertexArrayOES=_glIsVertexArrayOES;_emscripten_glIsVertexArrayOES.sig="ii";/** @suppress {duplicate } */var _glLineWidth=x0=>GLctx.lineWidth(x0);_glLineWidth.sig="vf";var _emscripten_glLineWidth=_glLineWidth;_emscripten_glLineWidth.sig="vf";/** @suppress {duplicate } */var _glLinkProgram=program=>{program=GL.programs[program];GLctx.linkProgram(program);// Invalidate earlier computed uniform->ID mappings, those have now become stale
program.uniformLocsById=0;// Mark as null-like so that glGetUniformLocation() knows to populate this again.
program.uniformSizeAndIdsByName={};};_glLinkProgram.sig="vi";var _emscripten_glLinkProgram=_glLinkProgram;_emscripten_glLinkProgram.sig="vi";/** @suppress {duplicate } */var _glPixelStorei=(pname,param)=>{if(pname==3317){GL.unpackAlignment=param;}else if(pname==3314){GL.unpackRowLength=param;}GLctx.pixelStorei(pname,param);};_glPixelStorei.sig="vii";var _emscripten_glPixelStorei=_glPixelStorei;_emscripten_glPixelStorei.sig="vii";/** @suppress {duplicate } */var _glPolygonModeWEBGL=(face,mode)=>{GLctx.webglPolygonMode["polygonModeWEBGL"](face,mode);};_glPolygonModeWEBGL.sig="vii";var _emscripten_glPolygonModeWEBGL=_glPolygonModeWEBGL;/** @suppress {duplicate } */var _glPolygonOffset=(x0,x1)=>GLctx.polygonOffset(x0,x1);_glPolygonOffset.sig="vff";var _emscripten_glPolygonOffset=_glPolygonOffset;_emscripten_glPolygonOffset.sig="vff";/** @suppress {duplicate } */var _glPolygonOffsetClampEXT=(factor,units,clamp)=>{GLctx.extPolygonOffsetClamp["polygonOffsetClampEXT"](factor,units,clamp);};_glPolygonOffsetClampEXT.sig="vfff";var _emscripten_glPolygonOffsetClampEXT=_glPolygonOffsetClampEXT;/** @suppress {duplicate } */var _glQueryCounterEXT=(id,target)=>{GLctx.disjointTimerQueryExt["queryCounterEXT"](GL.queries[id],target);};_glQueryCounterEXT.sig="vii";var _emscripten_glQueryCounterEXT=_glQueryCounterEXT;var computeUnpackAlignedImageSize=(width,height,sizePerPixel)=>{function roundedToNextMultipleOf(x,y){return x+y-1&-y;}var plainRowSize=(GL.unpackRowLength||width)*sizePerPixel;var alignedRowSize=roundedToNextMultipleOf(plainRowSize,GL.unpackAlignment);return height*alignedRowSize;};var colorChannelsInGlTextureFormat=format=>{// Micro-optimizations for size: map format to size by subtracting smallest
// enum value (0x1902) from all values first.  Also omit the most common
// size value (1) from the list, which is assumed by formats not on the
// list.
var colorChannels={// 0x1902 /* GL_DEPTH_COMPONENT */ - 0x1902: 1,
// 0x1906 /* GL_ALPHA */ - 0x1902: 1,
5:3,6:4,// 0x1909 /* GL_LUMINANCE */ - 0x1902: 1,
8:2,29502:3,29504:4};return colorChannels[format-6402]||1;};var heapObjectForWebGLType=type=>{// Micro-optimization for size: Subtract lowest GL enum number (0x1400/* GL_BYTE */) from type to compare
// smaller values for the heap, for shorter generated code size.
// Also the type HEAPU16 is not tested for explicitly, but any unrecognized type will return out HEAPU16.
// (since most types are HEAPU16)
type-=5120;if(type==1)return HEAPU8;if(type==4)return HEAP32;if(type==6)return HEAPF32;if(type==5||type==28922)return HEAPU32;return HEAPU16;};var toTypedArrayIndex=(pointer,heap)=>pointer>>>31-Math.clz32(heap.BYTES_PER_ELEMENT);var emscriptenWebGLGetTexPixelData=(type,format,width,height,pixels,internalFormat)=>{var heap=heapObjectForWebGLType(type);var sizePerPixel=colorChannelsInGlTextureFormat(format)*heap.BYTES_PER_ELEMENT;var bytes=computeUnpackAlignedImageSize(width,height,sizePerPixel);return heap.subarray(toTypedArrayIndex(pixels,heap)>>>0,toTypedArrayIndex(pixels+bytes,heap)>>>0);};/** @suppress {duplicate } */function _glReadPixels(x,y,width,height,format,type,pixels){pixels>>>=0;var pixelData=emscriptenWebGLGetTexPixelData(type,format,width,height,pixels,format);if(!pixelData){GL.recordError(1280);/*GL_INVALID_ENUM*/return;}GLctx.readPixels(x,y,width,height,format,type,pixelData);}_glReadPixels.sig="viiiiiip";var _emscripten_glReadPixels=_glReadPixels;_emscripten_glReadPixels.sig="viiiiiip";/** @suppress {duplicate } */var _glReleaseShaderCompiler=()=>{};// NOP (as allowed by GLES 2.0 spec)
_glReleaseShaderCompiler.sig="v";var _emscripten_glReleaseShaderCompiler=_glReleaseShaderCompiler;_emscripten_glReleaseShaderCompiler.sig="v";/** @suppress {duplicate } */var _glRenderbufferStorage=(x0,x1,x2,x3)=>GLctx.renderbufferStorage(x0,x1,x2,x3);_glRenderbufferStorage.sig="viiii";var _emscripten_glRenderbufferStorage=_glRenderbufferStorage;_emscripten_glRenderbufferStorage.sig="viiii";/** @suppress {duplicate } */var _glSampleCoverage=(value,invert)=>{GLctx.sampleCoverage(value,!!invert);};_glSampleCoverage.sig="vfi";var _emscripten_glSampleCoverage=_glSampleCoverage;_emscripten_glSampleCoverage.sig="vfi";/** @suppress {duplicate } */var _glScissor=(x0,x1,x2,x3)=>GLctx.scissor(x0,x1,x2,x3);_glScissor.sig="viiii";var _emscripten_glScissor=_glScissor;_emscripten_glScissor.sig="viiii";/** @suppress {duplicate } */function _glShaderBinary(count,shaders,binaryformat,binary,length){shaders>>>=0;binary>>>=0;GL.recordError(1280);}_glShaderBinary.sig="vipipi";var _emscripten_glShaderBinary=_glShaderBinary;_emscripten_glShaderBinary.sig="vipipi";/** @suppress {duplicate } */function _glShaderSource(shader,count,string,length){string>>>=0;length>>>=0;var source=GL.getSource(shader,count,string,length);GLctx.shaderSource(GL.shaders[shader],source);}_glShaderSource.sig="viipp";var _emscripten_glShaderSource=_glShaderSource;_emscripten_glShaderSource.sig="viipp";/** @suppress {duplicate } */var _glStencilFunc=(x0,x1,x2)=>GLctx.stencilFunc(x0,x1,x2);_glStencilFunc.sig="viii";var _emscripten_glStencilFunc=_glStencilFunc;_emscripten_glStencilFunc.sig="viii";/** @suppress {duplicate } */var _glStencilFuncSeparate=(x0,x1,x2,x3)=>GLctx.stencilFuncSeparate(x0,x1,x2,x3);_glStencilFuncSeparate.sig="viiii";var _emscripten_glStencilFuncSeparate=_glStencilFuncSeparate;_emscripten_glStencilFuncSeparate.sig="viiii";/** @suppress {duplicate } */var _glStencilMask=x0=>GLctx.stencilMask(x0);_glStencilMask.sig="vi";var _emscripten_glStencilMask=_glStencilMask;_emscripten_glStencilMask.sig="vi";/** @suppress {duplicate } */var _glStencilMaskSeparate=(x0,x1)=>GLctx.stencilMaskSeparate(x0,x1);_glStencilMaskSeparate.sig="vii";var _emscripten_glStencilMaskSeparate=_glStencilMaskSeparate;_emscripten_glStencilMaskSeparate.sig="vii";/** @suppress {duplicate } */var _glStencilOp=(x0,x1,x2)=>GLctx.stencilOp(x0,x1,x2);_glStencilOp.sig="viii";var _emscripten_glStencilOp=_glStencilOp;_emscripten_glStencilOp.sig="viii";/** @suppress {duplicate } */var _glStencilOpSeparate=(x0,x1,x2,x3)=>GLctx.stencilOpSeparate(x0,x1,x2,x3);_glStencilOpSeparate.sig="viiii";var _emscripten_glStencilOpSeparate=_glStencilOpSeparate;_emscripten_glStencilOpSeparate.sig="viiii";/** @suppress {duplicate } */function _glTexImage2D(target,level,internalFormat,width,height,border,format,type,pixels){pixels>>>=0;var pixelData=pixels?emscriptenWebGLGetTexPixelData(type,format,width,height,pixels,internalFormat):null;GLctx.texImage2D(target,level,internalFormat,width,height,border,format,type,pixelData);}_glTexImage2D.sig="viiiiiiiip";var _emscripten_glTexImage2D=_glTexImage2D;_emscripten_glTexImage2D.sig="viiiiiiiip";/** @suppress {duplicate } */var _glTexParameterf=(x0,x1,x2)=>GLctx.texParameterf(x0,x1,x2);_glTexParameterf.sig="viif";var _emscripten_glTexParameterf=_glTexParameterf;_emscripten_glTexParameterf.sig="viif";/** @suppress {duplicate } */function _glTexParameterfv(target,pname,params){params>>>=0;var param=HEAPF32[params>>>2>>>0];GLctx.texParameterf(target,pname,param);}_glTexParameterfv.sig="viip";var _emscripten_glTexParameterfv=_glTexParameterfv;_emscripten_glTexParameterfv.sig="viip";/** @suppress {duplicate } */var _glTexParameteri=(x0,x1,x2)=>GLctx.texParameteri(x0,x1,x2);_glTexParameteri.sig="viii";var _emscripten_glTexParameteri=_glTexParameteri;_emscripten_glTexParameteri.sig="viii";/** @suppress {duplicate } */function _glTexParameteriv(target,pname,params){params>>>=0;var param=HEAP32[params>>>2>>>0];GLctx.texParameteri(target,pname,param);}_glTexParameteriv.sig="viip";var _emscripten_glTexParameteriv=_glTexParameteriv;_emscripten_glTexParameteriv.sig="viip";/** @suppress {duplicate } */function _glTexSubImage2D(target,level,xoffset,yoffset,width,height,format,type,pixels){pixels>>>=0;var pixelData=pixels?emscriptenWebGLGetTexPixelData(type,format,width,height,pixels,0):null;GLctx.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,pixelData);}_glTexSubImage2D.sig="viiiiiiiip";var _emscripten_glTexSubImage2D=_glTexSubImage2D;_emscripten_glTexSubImage2D.sig="viiiiiiiip";/** @suppress {duplicate } */var _glUniform1f=(location,v0)=>{GLctx.uniform1f(webglGetUniformLocation(location),v0);};_glUniform1f.sig="vif";var _emscripten_glUniform1f=_glUniform1f;_emscripten_glUniform1f.sig="vif";var miniTempWebGLFloatBuffers=[];/** @suppress {duplicate } */function _glUniform1fv(location,count,value){value>>>=0;if(count<=288){// avoid allocation when uploading few enough uniforms
var view=miniTempWebGLFloatBuffers[count];for(var i=0;i<count;++i){view[i]=HEAPF32[value+4*i>>>2>>>0];}}else{var view=HEAPF32.subarray(value>>>2>>>0,value+count*4>>>2>>>0);}GLctx.uniform1fv(webglGetUniformLocation(location),view);}_glUniform1fv.sig="viip";var _emscripten_glUniform1fv=_glUniform1fv;_emscripten_glUniform1fv.sig="viip";/** @suppress {duplicate } */var _glUniform1i=(location,v0)=>{GLctx.uniform1i(webglGetUniformLocation(location),v0);};_glUniform1i.sig="vii";var _emscripten_glUniform1i=_glUniform1i;_emscripten_glUniform1i.sig="vii";var miniTempWebGLIntBuffers=[];/** @suppress {duplicate } */function _glUniform1iv(location,count,value){value>>>=0;if(count<=288){// avoid allocation when uploading few enough uniforms
var view=miniTempWebGLIntBuffers[count];for(var i=0;i<count;++i){view[i]=HEAP32[value+4*i>>>2>>>0];}}else{var view=HEAP32.subarray(value>>>2>>>0,value+count*4>>>2>>>0);}GLctx.uniform1iv(webglGetUniformLocation(location),view);}_glUniform1iv.sig="viip";var _emscripten_glUniform1iv=_glUniform1iv;_emscripten_glUniform1iv.sig="viip";/** @suppress {duplicate } */var _glUniform2f=(location,v0,v1)=>{GLctx.uniform2f(webglGetUniformLocation(location),v0,v1);};_glUniform2f.sig="viff";var _emscripten_glUniform2f=_glUniform2f;_emscripten_glUniform2f.sig="viff";/** @suppress {duplicate } */function _glUniform2fv(location,count,value){value>>>=0;if(count<=144){// avoid allocation when uploading few enough uniforms
count*=2;var view=miniTempWebGLFloatBuffers[count];for(var i=0;i<count;i+=2){view[i]=HEAPF32[value+4*i>>>2>>>0];view[i+1]=HEAPF32[value+(4*i+4)>>>2>>>0];}}else{var view=HEAPF32.subarray(value>>>2>>>0,value+count*8>>>2>>>0);}GLctx.uniform2fv(webglGetUniformLocation(location),view);}_glUniform2fv.sig="viip";var _emscripten_glUniform2fv=_glUniform2fv;_emscripten_glUniform2fv.sig="viip";/** @suppress {duplicate } */var _glUniform2i=(location,v0,v1)=>{GLctx.uniform2i(webglGetUniformLocation(location),v0,v1);};_glUniform2i.sig="viii";var _emscripten_glUniform2i=_glUniform2i;_emscripten_glUniform2i.sig="viii";/** @suppress {duplicate } */function _glUniform2iv(location,count,value){value>>>=0;if(count<=144){// avoid allocation when uploading few enough uniforms
count*=2;var view=miniTempWebGLIntBuffers[count];for(var i=0;i<count;i+=2){view[i]=HEAP32[value+4*i>>>2>>>0];view[i+1]=HEAP32[value+(4*i+4)>>>2>>>0];}}else{var view=HEAP32.subarray(value>>>2>>>0,value+count*8>>>2>>>0);}GLctx.uniform2iv(webglGetUniformLocation(location),view);}_glUniform2iv.sig="viip";var _emscripten_glUniform2iv=_glUniform2iv;_emscripten_glUniform2iv.sig="viip";/** @suppress {duplicate } */var _glUniform3f=(location,v0,v1,v2)=>{GLctx.uniform3f(webglGetUniformLocation(location),v0,v1,v2);};_glUniform3f.sig="vifff";var _emscripten_glUniform3f=_glUniform3f;_emscripten_glUniform3f.sig="vifff";/** @suppress {duplicate } */function _glUniform3fv(location,count,value){value>>>=0;if(count<=96){// avoid allocation when uploading few enough uniforms
count*=3;var view=miniTempWebGLFloatBuffers[count];for(var i=0;i<count;i+=3){view[i]=HEAPF32[value+4*i>>>2>>>0];view[i+1]=HEAPF32[value+(4*i+4)>>>2>>>0];view[i+2]=HEAPF32[value+(4*i+8)>>>2>>>0];}}else{var view=HEAPF32.subarray(value>>>2>>>0,value+count*12>>>2>>>0);}GLctx.uniform3fv(webglGetUniformLocation(location),view);}_glUniform3fv.sig="viip";var _emscripten_glUniform3fv=_glUniform3fv;_emscripten_glUniform3fv.sig="viip";/** @suppress {duplicate } */var _glUniform3i=(location,v0,v1,v2)=>{GLctx.uniform3i(webglGetUniformLocation(location),v0,v1,v2);};_glUniform3i.sig="viiii";var _emscripten_glUniform3i=_glUniform3i;_emscripten_glUniform3i.sig="viiii";/** @suppress {duplicate } */function _glUniform3iv(location,count,value){value>>>=0;if(count<=96){// avoid allocation when uploading few enough uniforms
count*=3;var view=miniTempWebGLIntBuffers[count];for(var i=0;i<count;i+=3){view[i]=HEAP32[value+4*i>>>2>>>0];view[i+1]=HEAP32[value+(4*i+4)>>>2>>>0];view[i+2]=HEAP32[value+(4*i+8)>>>2>>>0];}}else{var view=HEAP32.subarray(value>>>2>>>0,value+count*12>>>2>>>0);}GLctx.uniform3iv(webglGetUniformLocation(location),view);}_glUniform3iv.sig="viip";var _emscripten_glUniform3iv=_glUniform3iv;_emscripten_glUniform3iv.sig="viip";/** @suppress {duplicate } */var _glUniform4f=(location,v0,v1,v2,v3)=>{GLctx.uniform4f(webglGetUniformLocation(location),v0,v1,v2,v3);};_glUniform4f.sig="viffff";var _emscripten_glUniform4f=_glUniform4f;_emscripten_glUniform4f.sig="viffff";/** @suppress {duplicate } */function _glUniform4fv(location,count,value){value>>>=0;if(count<=72){// avoid allocation when uploading few enough uniforms
var view=miniTempWebGLFloatBuffers[4*count];// hoist the heap out of the loop for size and for pthreads+growth.
var heap=HEAPF32;value=value>>>2;count*=4;for(var i=0;i<count;i+=4){var dst=value+i;view[i]=heap[dst>>>0];view[i+1]=heap[dst+1>>>0];view[i+2]=heap[dst+2>>>0];view[i+3]=heap[dst+3>>>0];}}else{var view=HEAPF32.subarray(value>>>2>>>0,value+count*16>>>2>>>0);}GLctx.uniform4fv(webglGetUniformLocation(location),view);}_glUniform4fv.sig="viip";var _emscripten_glUniform4fv=_glUniform4fv;_emscripten_glUniform4fv.sig="viip";/** @suppress {duplicate } */var _glUniform4i=(location,v0,v1,v2,v3)=>{GLctx.uniform4i(webglGetUniformLocation(location),v0,v1,v2,v3);};_glUniform4i.sig="viiiii";var _emscripten_glUniform4i=_glUniform4i;_emscripten_glUniform4i.sig="viiiii";/** @suppress {duplicate } */function _glUniform4iv(location,count,value){value>>>=0;if(count<=72){// avoid allocation when uploading few enough uniforms
count*=4;var view=miniTempWebGLIntBuffers[count];for(var i=0;i<count;i+=4){view[i]=HEAP32[value+4*i>>>2>>>0];view[i+1]=HEAP32[value+(4*i+4)>>>2>>>0];view[i+2]=HEAP32[value+(4*i+8)>>>2>>>0];view[i+3]=HEAP32[value+(4*i+12)>>>2>>>0];}}else{var view=HEAP32.subarray(value>>>2>>>0,value+count*16>>>2>>>0);}GLctx.uniform4iv(webglGetUniformLocation(location),view);}_glUniform4iv.sig="viip";var _emscripten_glUniform4iv=_glUniform4iv;_emscripten_glUniform4iv.sig="viip";/** @suppress {duplicate } */function _glUniformMatrix2fv(location,count,transpose,value){value>>>=0;if(count<=72){// avoid allocation when uploading few enough uniforms
count*=4;var view=miniTempWebGLFloatBuffers[count];for(var i=0;i<count;i+=4){view[i]=HEAPF32[value+4*i>>>2>>>0];view[i+1]=HEAPF32[value+(4*i+4)>>>2>>>0];view[i+2]=HEAPF32[value+(4*i+8)>>>2>>>0];view[i+3]=HEAPF32[value+(4*i+12)>>>2>>>0];}}else{var view=HEAPF32.subarray(value>>>2>>>0,value+count*16>>>2>>>0);}GLctx.uniformMatrix2fv(webglGetUniformLocation(location),!!transpose,view);}_glUniformMatrix2fv.sig="viiip";var _emscripten_glUniformMatrix2fv=_glUniformMatrix2fv;_emscripten_glUniformMatrix2fv.sig="viiip";/** @suppress {duplicate } */function _glUniformMatrix3fv(location,count,transpose,value){value>>>=0;if(count<=32){// avoid allocation when uploading few enough uniforms
count*=9;var view=miniTempWebGLFloatBuffers[count];for(var i=0;i<count;i+=9){view[i]=HEAPF32[value+4*i>>>2>>>0];view[i+1]=HEAPF32[value+(4*i+4)>>>2>>>0];view[i+2]=HEAPF32[value+(4*i+8)>>>2>>>0];view[i+3]=HEAPF32[value+(4*i+12)>>>2>>>0];view[i+4]=HEAPF32[value+(4*i+16)>>>2>>>0];view[i+5]=HEAPF32[value+(4*i+20)>>>2>>>0];view[i+6]=HEAPF32[value+(4*i+24)>>>2>>>0];view[i+7]=HEAPF32[value+(4*i+28)>>>2>>>0];view[i+8]=HEAPF32[value+(4*i+32)>>>2>>>0];}}else{var view=HEAPF32.subarray(value>>>2>>>0,value+count*36>>>2>>>0);}GLctx.uniformMatrix3fv(webglGetUniformLocation(location),!!transpose,view);}_glUniformMatrix3fv.sig="viiip";var _emscripten_glUniformMatrix3fv=_glUniformMatrix3fv;_emscripten_glUniformMatrix3fv.sig="viiip";/** @suppress {duplicate } */function _glUniformMatrix4fv(location,count,transpose,value){value>>>=0;if(count<=18){// avoid allocation when uploading few enough uniforms
var view=miniTempWebGLFloatBuffers[16*count];// hoist the heap out of the loop for size and for pthreads+growth.
var heap=HEAPF32;value=value>>>2;count*=16;for(var i=0;i<count;i+=16){var dst=value+i;view[i]=heap[dst>>>0];view[i+1]=heap[dst+1>>>0];view[i+2]=heap[dst+2>>>0];view[i+3]=heap[dst+3>>>0];view[i+4]=heap[dst+4>>>0];view[i+5]=heap[dst+5>>>0];view[i+6]=heap[dst+6>>>0];view[i+7]=heap[dst+7>>>0];view[i+8]=heap[dst+8>>>0];view[i+9]=heap[dst+9>>>0];view[i+10]=heap[dst+10>>>0];view[i+11]=heap[dst+11>>>0];view[i+12]=heap[dst+12>>>0];view[i+13]=heap[dst+13>>>0];view[i+14]=heap[dst+14>>>0];view[i+15]=heap[dst+15>>>0];}}else{var view=HEAPF32.subarray(value>>>2>>>0,value+count*64>>>2>>>0);}GLctx.uniformMatrix4fv(webglGetUniformLocation(location),!!transpose,view);}_glUniformMatrix4fv.sig="viiip";var _emscripten_glUniformMatrix4fv=_glUniformMatrix4fv;_emscripten_glUniformMatrix4fv.sig="viiip";/** @suppress {duplicate } */var _glUseProgram=program=>{program=GL.programs[program];GLctx.useProgram(program);// Record the currently active program so that we can access the uniform
// mapping table of that program.
GLctx.currentProgram=program;};_glUseProgram.sig="vi";var _emscripten_glUseProgram=_glUseProgram;_emscripten_glUseProgram.sig="vi";/** @suppress {duplicate } */var _glValidateProgram=program=>{GLctx.validateProgram(GL.programs[program]);};_glValidateProgram.sig="vi";var _emscripten_glValidateProgram=_glValidateProgram;_emscripten_glValidateProgram.sig="vi";/** @suppress {duplicate } */var _glVertexAttrib1f=(x0,x1)=>GLctx.vertexAttrib1f(x0,x1);_glVertexAttrib1f.sig="vif";var _emscripten_glVertexAttrib1f=_glVertexAttrib1f;_emscripten_glVertexAttrib1f.sig="vif";/** @suppress {duplicate } */function _glVertexAttrib1fv(index,v){v>>>=0;GLctx.vertexAttrib1f(index,HEAPF32[v>>>2]);}_glVertexAttrib1fv.sig="vip";var _emscripten_glVertexAttrib1fv=_glVertexAttrib1fv;_emscripten_glVertexAttrib1fv.sig="vip";/** @suppress {duplicate } */var _glVertexAttrib2f=(x0,x1,x2)=>GLctx.vertexAttrib2f(x0,x1,x2);_glVertexAttrib2f.sig="viff";var _emscripten_glVertexAttrib2f=_glVertexAttrib2f;_emscripten_glVertexAttrib2f.sig="viff";/** @suppress {duplicate } */function _glVertexAttrib2fv(index,v){v>>>=0;GLctx.vertexAttrib2f(index,HEAPF32[v>>>2],HEAPF32[v+4>>>2]);}_glVertexAttrib2fv.sig="vip";var _emscripten_glVertexAttrib2fv=_glVertexAttrib2fv;_emscripten_glVertexAttrib2fv.sig="vip";/** @suppress {duplicate } */var _glVertexAttrib3f=(x0,x1,x2,x3)=>GLctx.vertexAttrib3f(x0,x1,x2,x3);_glVertexAttrib3f.sig="vifff";var _emscripten_glVertexAttrib3f=_glVertexAttrib3f;_emscripten_glVertexAttrib3f.sig="vifff";/** @suppress {duplicate } */function _glVertexAttrib3fv(index,v){v>>>=0;GLctx.vertexAttrib3f(index,HEAPF32[v>>>2],HEAPF32[v+4>>>2],HEAPF32[v+8>>>2]);}_glVertexAttrib3fv.sig="vip";var _emscripten_glVertexAttrib3fv=_glVertexAttrib3fv;_emscripten_glVertexAttrib3fv.sig="vip";/** @suppress {duplicate } */var _glVertexAttrib4f=(x0,x1,x2,x3,x4)=>GLctx.vertexAttrib4f(x0,x1,x2,x3,x4);_glVertexAttrib4f.sig="viffff";var _emscripten_glVertexAttrib4f=_glVertexAttrib4f;_emscripten_glVertexAttrib4f.sig="viffff";/** @suppress {duplicate } */function _glVertexAttrib4fv(index,v){v>>>=0;GLctx.vertexAttrib4f(index,HEAPF32[v>>>2],HEAPF32[v+4>>>2],HEAPF32[v+8>>>2],HEAPF32[v+12>>>2]);}_glVertexAttrib4fv.sig="vip";var _emscripten_glVertexAttrib4fv=_glVertexAttrib4fv;_emscripten_glVertexAttrib4fv.sig="vip";/** @suppress {duplicate } */var _glVertexAttribDivisor=(index,divisor)=>{GLctx.vertexAttribDivisor(index,divisor);};_glVertexAttribDivisor.sig="vii";/** @suppress {duplicate } */var _glVertexAttribDivisorANGLE=_glVertexAttribDivisor;var _emscripten_glVertexAttribDivisorANGLE=_glVertexAttribDivisorANGLE;/** @suppress {duplicate } */function _glVertexAttribPointer(index,size,type,normalized,stride,ptr){ptr>>>=0;GLctx.vertexAttribPointer(index,size,type,!!normalized,stride,ptr);}_glVertexAttribPointer.sig="viiiiip";var _emscripten_glVertexAttribPointer=_glVertexAttribPointer;_emscripten_glVertexAttribPointer.sig="viiiiip";/** @suppress {duplicate } */var _glViewport=(x0,x1,x2,x3)=>GLctx.viewport(x0,x1,x2,x3);_glViewport.sig="viiii";var _emscripten_glViewport=_glViewport;_emscripten_glViewport.sig="viiii";function _emscripten_out(str){str>>>=0;return out(UTF8ToString(str));}_emscripten_out.sig="vp";class HandleAllocator{constructor(){// TODO(https://github.com/emscripten-core/emscripten/issues/21414):
// Use inline field declarations.
this.allocated=[undefined];this.freelist=[];}get(id){return this.allocated[id];}has(id){return this.allocated[id]!==undefined;}allocate(handle){var id=this.freelist.pop()||this.allocated.length;this.allocated[id]=handle;return id;}free(id){// Set the slot to `undefined` rather than using `delete` here since
// apparently arrays with holes in them can be less efficient.
this.allocated[id]=undefined;this.freelist.push(id);}}var promiseMap=new HandleAllocator();var makePromise=()=>{var promiseInfo={};promiseInfo.promise=new Promise((resolve,reject)=>{promiseInfo.reject=reject;promiseInfo.resolve=resolve;});promiseInfo.id=promiseMap.allocate(promiseInfo);return promiseInfo;};function _emscripten_promise_create(){return makePromise().id;}_emscripten_promise_create.sig="p";function _emscripten_promise_destroy(id){id>>>=0;promiseMap.free(id);}_emscripten_promise_destroy.sig="vp";var getPromise=id=>promiseMap.get(id).promise;function _emscripten_promise_resolve(id,result,value){id>>>=0;value>>>=0;var info=promiseMap.get(id);switch(result){case 0:info.resolve(value);return;case 1:info.resolve(getPromise(value));return;case 2:info.resolve(getPromise(value));_emscripten_promise_destroy(value);return;case 3:info.reject(value);return;}}_emscripten_promise_resolve.sig="vpip";var growMemory=size=>{var b=wasmMemory.buffer;var pages=(size-b.byteLength+65535)/65536;try{// round size grow request up to wasm page size (fixed 64KB per spec)
wasmMemory.grow(pages);// .grow() takes a delta compared to the previous size
updateMemoryViews();return 1;}/*success*/catch(e){}};// implicit 0 return to save code size (caller will cast "undefined" into 0
// anyhow)
function _emscripten_resize_heap(requestedSize){requestedSize>>>=0;var oldSize=HEAPU8.length;// With multithreaded builds, races can happen (another thread might increase the size
// in between), so return a failure, and let the caller retry.
// Memory resize rules:
// 1.  Always increase heap size to at least the requested size, rounded up
//     to next page multiple.
// 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
//     geometrically: increase the heap size according to
//     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
//     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
// 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
//     linearly: increase the heap size by at least
//     MEMORY_GROWTH_LINEAR_STEP bytes.
// 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
//     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
// 4.  If we were unable to allocate as much memory, it may be due to
//     over-eager decision to excessively reserve due to (3) above.
//     Hence if an allocation fails, cut down on the amount of excess
//     growth, in an attempt to succeed to perform a smaller allocation.
// A limit is set for how much we can grow. We should not exceed that
// (the wasm binary specifies it, so if we tried, we'd fail anyhow).
var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false;}// Loop through potential heap size increases. If we attempt a too eager
// reservation that fails, cut down on the attempted size and reserve a
// smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);// ensure geometric growth
// but limit overreserving (default to capping at +96MB overgrowth at most)
overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignMemory(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true;}}return false;}_emscripten_resize_heap.sig="ip";var _emscripten_wget_data=function(url,pbuffer,pnum,perror){url>>>=0;pbuffer>>>=0;pnum>>>=0;perror>>>=0;return Asyncify.handleSleep(wakeUp=>{asyncLoad(UTF8ToString(url),byteArray=>{// can only allocate the buffer after the wakeUp, not during an asyncing
var buffer=_malloc(byteArray.length);// must be freed by caller!
HEAPU8.set(byteArray,buffer>>>0);HEAPU32[pbuffer>>>2>>>0]=buffer;HEAP32[pnum>>>2>>>0]=byteArray.length;HEAP32[perror>>>2>>>0]=0;wakeUp();},()=>{HEAP32[perror>>>2>>>0]=1;wakeUp();},true);});};_emscripten_wget_data.sig="vpppp";_emscripten_wget_data.isAsync=true;var getEnvStrings=()=>{if(!getEnvStrings.strings){// Default values.
// Browser language detection #8751
var lang=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};// Apply the user-provided values, if any.
for(var x in ENV){// x is a key in ENV; if ENV[x] is undefined, that means it was
// explicitly set to be so. We allow user code to do that to
// force variables with default values to remain unset.
if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x];}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`);}getEnvStrings.strings=strings;}return getEnvStrings.strings;};var stringToAscii=(str,buffer)=>{for(var i=0;i<str.length;++i){HEAP8[buffer++>>>0]=str.charCodeAt(i);}// Null-terminate the string
HEAP8[buffer>>>0]=0;};var _environ_get=function(__environ,environ_buf){__environ>>>=0;environ_buf>>>=0;var bufSize=0;getEnvStrings().forEach((string,i)=>{var ptr=environ_buf+bufSize;HEAPU32[__environ+i*4>>>2>>>0]=ptr;stringToAscii(string,ptr);bufSize+=string.length+1;});return 0;};_environ_get.sig="ipp";var _environ_sizes_get=function(penviron_count,penviron_buf_size){penviron_count>>>=0;penviron_buf_size>>>=0;var strings=getEnvStrings();HEAPU32[penviron_count>>>2>>>0]=strings.length;var bufSize=0;strings.forEach(string=>bufSize+=string.length+1);HEAPU32[penviron_buf_size>>>2>>>0]=bufSize;return 0;};_environ_sizes_get.sig="ipp";function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return e.errno;}}_fd_close.sig="ii";function _fd_fdstat_get(fd,pbuf){pbuf>>>=0;try{var rightsBase=0;var rightsInheriting=0;var flags=0;{var stream=SYSCALLS.getStreamFromFD(fd);// All character devices are terminals (other things a Linux system would
// assume is a character device, like the mouse, we have special APIs for).
var type=stream.tty?2:FS.isDir(stream.mode)?3:FS.isLink(stream.mode)?7:4;}HEAP8[pbuf>>>0]=type;HEAP16[pbuf+2>>>1>>>0]=flags;tempI64=[rightsBase>>>0,(tempDouble=rightsBase,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[pbuf+8>>>2>>>0]=tempI64[0],HEAP32[pbuf+12>>>2>>>0]=tempI64[1];tempI64=[rightsInheriting>>>0,(tempDouble=rightsInheriting,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[pbuf+16>>>2>>>0]=tempI64[0],HEAP32[pbuf+20>>>2>>>0]=tempI64[1];return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return e.errno;}}_fd_fdstat_get.sig="iip";/** @param {number=} offset */var doReadv=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>>2>>>0];var len=HEAPU32[iov+4>>>2>>>0];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break;// nothing more to read
if(typeof offset!="undefined"){offset+=curr;}}return ret;};function _fd_pread(fd,iov,iovcnt,offset_low,offset_high,pnum){iov>>>=0;iovcnt>>>=0;var offset=convertI32PairToI53Checked(offset_low,offset_high);pnum>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt,offset);HEAPU32[pnum>>>2>>>0]=num;return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return e.errno;}}_fd_pread.sig="iippiip";/** @param {number=} offset */var doWritev=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>>2>>>0];var len=HEAPU32[iov+4>>>2>>>0];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len){// No more space to write.
break;}if(typeof offset!="undefined"){offset+=curr;}}return ret;};function _fd_pwrite(fd,iov,iovcnt,offset_low,offset_high,pnum){iov>>>=0;iovcnt>>>=0;var offset=convertI32PairToI53Checked(offset_low,offset_high);pnum>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt,offset);HEAPU32[pnum>>>2>>>0]=num;return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return e.errno;}}_fd_pwrite.sig="iippiip";function _fd_read(fd,iov,iovcnt,pnum){iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAPU32[pnum>>>2>>>0]=num;return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return e.errno;}}_fd_read.sig="iippp";function _fd_seek(fd,offset_low,offset_high,whence,newOffset){var offset=convertI32PairToI53Checked(offset_low,offset_high);newOffset>>>=0;try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>>2>>>0]=tempI64[0],HEAP32[newOffset+4>>>2>>>0]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;// reset readdir state
return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return e.errno;}}_fd_seek.sig="iiiiip";var _fd_sync=function(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);return Asyncify.handleSleep(wakeUp=>{var mount=stream.node.mount;if(!mount.type.syncfs){// We write directly to the file system, so there's nothing to do here.
wakeUp(0);return;}mount.type.syncfs(mount,false,err=>{if(err){wakeUp(29);return;}wakeUp(0);});});}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return e.errno;}};_fd_sync.sig="ii";_fd_sync.isAsync=true;function _fd_write(fd,iov,iovcnt,pnum){iov>>>=0;iovcnt>>>=0;pnum>>>=0;try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAPU32[pnum>>>2>>>0]=num;return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return e.errno;}}_fd_write.sig="iippp";function _getaddrinfo(node,service,hint,out){node>>>=0;service>>>=0;hint>>>=0;out>>>=0;// Note getaddrinfo currently only returns a single addrinfo with ai_next defaulting to NULL. When NULL
// hints are specified or ai_family set to AF_UNSPEC or ai_socktype or ai_protocol set to 0 then we
// really should provide a linked list of suitable addrinfo values.
var addrs=[];var canon=null;var addr=0;var port=0;var flags=0;var family=0;var type=0;var proto=0;var ai,last;function allocaddrinfo(family,type,proto,canon,addr,port){var sa,salen,ai;var errno;salen=family===10?28:16;addr=family===10?inetNtop6(addr):inetNtop4(addr);sa=_malloc(salen);errno=writeSockaddr(sa,family,addr,port);assert(!errno);ai=_malloc(32);HEAP32[ai+4>>>2>>>0]=family;HEAP32[ai+8>>>2>>>0]=type;HEAP32[ai+12>>>2>>>0]=proto;HEAPU32[ai+24>>>2>>>0]=canon;HEAPU32[ai+20>>>2>>>0]=sa;if(family===10){HEAP32[ai+16>>>2>>>0]=28;}else{HEAP32[ai+16>>>2>>>0]=16;}HEAP32[ai+28>>>2>>>0]=0;return ai;}if(hint){flags=HEAP32[hint>>>2>>>0];family=HEAP32[hint+4>>>2>>>0];type=HEAP32[hint+8>>>2>>>0];proto=HEAP32[hint+12>>>2>>>0];}if(type&&!proto){proto=type===2?17:6;}if(!type&&proto){type=proto===17?2:1;}// If type or proto are set to zero in hints we should really be returning multiple addrinfo values, but for
// now default to a TCP STREAM socket so we can at least return a sensible addrinfo given NULL hints.
if(proto===0){proto=6;}if(type===0){type=1;}if(!node&&!service){return-2;}if(flags&~(1|2|4|1024|8|16|32)){return-1;}if(hint!==0&&HEAP32[hint>>>2>>>0]&2&&!node){return-1;}if(flags&32){// TODO
return-2;}if(type!==0&&type!==1&&type!==2){return-7;}if(family!==0&&family!==2&&family!==10){return-6;}if(service){service=UTF8ToString(service);port=parseInt(service,10);if(isNaN(port)){if(flags&1024){return-2;}// TODO support resolving well-known service names from:
// http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt
return-8;}}if(!node){if(family===0){family=2;}if((flags&1)===0){if(family===2){addr=_htonl(2130706433);}else{addr=[0,0,0,1];}}ai=allocaddrinfo(family,type,proto,null,addr,port);HEAPU32[out>>>2>>>0]=ai;return 0;}// try as a numeric address
node=UTF8ToString(node);addr=inetPton4(node);if(addr!==null){// incoming node is a valid ipv4 address
if(family===0||family===2){family=2;}else if(family===10&&flags&8){addr=[0,0,_htonl(65535),addr];family=10;}else{return-2;}}else{addr=inetPton6(node);if(addr!==null){// incoming node is a valid ipv6 address
if(family===0||family===10){family=10;}else{return-2;}}}if(addr!=null){ai=allocaddrinfo(family,type,proto,node,addr,port);HEAPU32[out>>>2>>>0]=ai;return 0;}if(flags&4){return-2;}// try as a hostname
// resolve the hostname to a temporary fake address
node=DNS.lookup_name(node);addr=inetPton4(node);if(family===0){family=2;}else if(family===10){addr=[0,0,_htonl(65535),addr];}ai=allocaddrinfo(family,type,proto,null,addr,port);HEAPU32[out>>>2>>>0]=ai;return 0;}_getaddrinfo.sig="ipppp";function _getcontext(...args){return asyncifyStubs["getcontext"](...args);}_getcontext.stub=true;asyncifyStubs["getcontext"]=undefined;function _getdtablesize(...args){return asyncifyStubs["getdtablesize"](...args);}_getdtablesize.stub=true;asyncifyStubs["getdtablesize"]=undefined;function _getentropy(buffer,size){buffer>>>=0;size>>>=0;randomFill(HEAPU8.subarray(buffer>>>0,buffer+size>>>0));return 0;}_getentropy.sig="ipp";function _getnameinfo(sa,salen,node,nodelen,serv,servlen,flags){sa>>>=0;node>>>=0;serv>>>=0;var info=readSockaddr(sa,salen);if(info.errno){return-6;}var port=info.port;var addr=info.addr;var overflowed=false;if(node&&nodelen){var lookup;if(flags&1||!(lookup=DNS.lookup_addr(addr))){if(flags&8){return-2;}}else{addr=lookup;}var numBytesWrittenExclNull=stringToUTF8(addr,node,nodelen);if(numBytesWrittenExclNull+1>=nodelen){overflowed=true;}}if(serv&&servlen){port=""+port;var numBytesWrittenExclNull=stringToUTF8(port,serv,servlen);if(numBytesWrittenExclNull+1>=servlen){overflowed=true;}}if(overflowed){// Note: even when we overflow, getnameinfo() is specced to write out the truncated results.
return-12;}return 0;}_getnameinfo.sig="ipipipii";var Protocols={list:[],map:{}};var _setprotoent=stayopen=>{// void setprotoent(int stayopen);
// Allocate and populate a protoent structure given a name, protocol number and array of aliases
function allocprotoent(name,proto,aliases){// write name into buffer
var nameBuf=_malloc(name.length+1);stringToAscii(name,nameBuf);// write aliases into buffer
var j=0;var length=aliases.length;var aliasListBuf=_malloc((length+1)*4);// Use length + 1 so we have space for the terminating NULL ptr.
for(var i=0;i<length;i++,j+=4){var alias=aliases[i];var aliasBuf=_malloc(alias.length+1);stringToAscii(alias,aliasBuf);HEAPU32[aliasListBuf+j>>>2>>>0]=aliasBuf;}HEAPU32[aliasListBuf+j>>>2>>>0]=0;// Terminating NULL pointer.
// generate protoent
var pe=_malloc(12);HEAPU32[pe>>>2>>>0]=nameBuf;HEAPU32[pe+4>>>2>>>0]=aliasListBuf;HEAP32[pe+8>>>2>>>0]=proto;return pe;}// Populate the protocol 'database'. The entries are limited to tcp and udp, though it is fairly trivial
// to add extra entries from /etc/protocols if desired - though not sure if that'd actually be useful.
var list=Protocols.list;var map=Protocols.map;if(list.length===0){var entry=allocprotoent("tcp",6,["TCP"]);list.push(entry);map["tcp"]=map["6"]=entry;entry=allocprotoent("udp",17,["UDP"]);list.push(entry);map["udp"]=map["17"]=entry;}_setprotoent.index=0;};_setprotoent.sig="vi";function _getprotobyname(name){name>>>=0;// struct protoent *getprotobyname(const char *);
name=UTF8ToString(name);_setprotoent(true);var result=Protocols.map[name];return result;}_getprotobyname.sig="pp";function _getprotobynumber(number){// struct protoent *getprotobynumber(int proto);
_setprotoent(true);var result=Protocols.map[number];return result;}_getprotobynumber.sig="pi";function _htmlDefaultSAXHandler(...args){return asyncifyStubs["htmlDefaultSAXHandler"](...args);}_htmlDefaultSAXHandler.stub=true;asyncifyStubs["htmlDefaultSAXHandler"]=undefined;function _isolat1ToUTF8(...args){return asyncifyStubs["isolat1ToUTF8"](...args);}_isolat1ToUTF8.stub=true;asyncifyStubs["isolat1ToUTF8"]=undefined;function _makecontext(...args){return asyncifyStubs["makecontext"](...args);}_makecontext.stub=true;asyncifyStubs["makecontext"]=undefined;function _oldXMLWDcompatibility(...args){return asyncifyStubs["oldXMLWDcompatibility"](...args);}_oldXMLWDcompatibility.stub=true;asyncifyStubs["oldXMLWDcompatibility"]=undefined;function _php_embed_init(...args){return asyncifyStubs["php_embed_init"](...args);}_php_embed_init.stub=true;asyncifyStubs["php_embed_init"]=undefined;function _php_embed_shutdown(...args){return asyncifyStubs["php_embed_shutdown"](...args);}_php_embed_shutdown.stub=true;asyncifyStubs["php_embed_shutdown"]=undefined;function _posix_spawnp(...args){return asyncifyStubs["posix_spawnp"](...args);}_posix_spawnp.stub=true;asyncifyStubs["posix_spawnp"]=undefined;var arraySum=(array,index)=>{var sum=0;for(var i=0;i<=index;sum+=array[i++]){}// no-op
return sum;};var MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];var addDays=(date,days)=>{var newDate=new Date(date.getTime());while(days>0){var leap=isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){// we spill over to next month
days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1);}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1);}}else{// we stay in current month
newDate.setDate(newDate.getDate()+days);return newDate;}}return newDate;};function _strptime(buf,format,tm){buf>>>=0;format>>>=0;tm>>>=0;// char *strptime(const char *restrict buf, const char *restrict format, struct tm *restrict tm);
// http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html
var pattern=UTF8ToString(format);// escape special characters
// TODO: not sure we really need to escape all of these in JS regexps
var SPECIAL_CHARS="\\!@#$^&*()+=-[]/{}|:<>?,.";for(var i=0,ii=SPECIAL_CHARS.length;i<ii;++i){pattern=pattern.replace(new RegExp("\\"+SPECIAL_CHARS[i],"g"),"\\"+SPECIAL_CHARS[i]);}// reduce number of matchers
var EQUIVALENT_MATCHERS={"A":"%a","B":"%b","c":"%a %b %d %H:%M:%S %Y","D":"%m\\/%d\\/%y","e":"%d","F":"%Y-%m-%d","h":"%b","R":"%H\\:%M","r":"%I\\:%M\\:%S\\s%p","T":"%H\\:%M\\:%S","x":"%m\\/%d\\/(?:%y|%Y)","X":"%H\\:%M\\:%S"};// TODO: take care of locale
var DATE_PATTERNS={/* weekday name */"a":"(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)",/* month name */"b":"(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)",/* century */"C":"\\d\\d",/* day of month */"d":"0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31",/* hour (24hr) */"H":"\\d(?!\\d)|[0,1]\\d|20|21|22|23",/* hour (12hr) */"I":"\\d(?!\\d)|0\\d|10|11|12",/* day of year */"j":"00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d",/* month */"m":"0[1-9]|[1-9](?!\\d)|10|11|12",/* minutes */"M":"0\\d|\\d(?!\\d)|[1-5]\\d",/* whitespace */"n":" ",/* AM/PM */"p":"AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.",/* seconds */"S":"0\\d|\\d(?!\\d)|[1-5]\\d|60",/* week number */"U":"0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",/* week number */"W":"0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53",/* weekday number */"w":"[0-6]",/* 2-digit year */"y":"\\d\\d",/* 4-digit year */"Y":"\\d\\d\\d\\d",/* whitespace */"t":" ",/* time zone */"z":"Z|(?:[\\+\\-]\\d\\d:?(?:\\d\\d)?)"};var MONTH_NUMBERS={JAN:0,FEB:1,MAR:2,APR:3,MAY:4,JUN:5,JUL:6,AUG:7,SEP:8,OCT:9,NOV:10,DEC:11};var DAY_NUMBERS_SUN_FIRST={SUN:0,MON:1,TUE:2,WED:3,THU:4,FRI:5,SAT:6};var DAY_NUMBERS_MON_FIRST={MON:0,TUE:1,WED:2,THU:3,FRI:4,SAT:5,SUN:6};var capture=[];var pattern_out=pattern.replace(/%(.)/g,(m,c)=>EQUIVALENT_MATCHERS[c]||m).replace(/%(.)/g,(_,c)=>{let pat=DATE_PATTERNS[c];if(pat){capture.push(c);return`(${pat})`;}else{return c;}}).replace(// any number of space or tab characters match zero or more spaces
/\s+/g,"\\s*");var matches=new RegExp("^"+pattern_out,"i").exec(UTF8ToString(buf));function initDate(){function fixup(value,min,max){return typeof value!="number"||isNaN(value)?min:value>=min?value<=max?value:max:min;}return{year:fixup(HEAP32[tm+20>>>2>>>0]+1900,1970,9999),month:fixup(HEAP32[tm+16>>>2>>>0],0,11),day:fixup(HEAP32[tm+12>>>2>>>0],1,31),hour:fixup(HEAP32[tm+8>>>2>>>0],0,23),min:fixup(HEAP32[tm+4>>>2>>>0],0,59),sec:fixup(HEAP32[tm>>>2>>>0],0,59),gmtoff:0};}if(matches){var date=initDate();var value;var getMatch=symbol=>{var pos=capture.indexOf(symbol);// check if symbol appears in regexp
if(pos>=0){// return matched value or null (falsy!) for non-matches
return matches[pos+1];}return;};// seconds
if(value=getMatch("S")){date.sec=jstoi_q(value);}// minutes
if(value=getMatch("M")){date.min=jstoi_q(value);}// hours
if(value=getMatch("H")){// 24h clock
date.hour=jstoi_q(value);}else if(value=getMatch("I")){// AM/PM clock
var hour=jstoi_q(value);if(value=getMatch("p")){hour+=value.toUpperCase()[0]==="P"?12:0;}date.hour=hour;}// year
if(value=getMatch("Y")){// parse from four-digit year
date.year=jstoi_q(value);}else if(value=getMatch("y")){// parse from two-digit year...
var year=jstoi_q(value);if(value=getMatch("C")){// ...and century
year+=jstoi_q(value)*100;}else{// ...and rule-of-thumb
year+=year<69?2e3:1900;}date.year=year;}// month
if(value=getMatch("m")){// parse from month number
date.month=jstoi_q(value)-1;}else if(value=getMatch("b")){// parse from month name
date.month=MONTH_NUMBERS[value.substring(0,3).toUpperCase()]||0;}// day
if(value=getMatch("d")){// get day of month directly
date.day=jstoi_q(value);}else if(value=getMatch("j")){// get day of month from day of year ...
var day=jstoi_q(value);var leapYear=isLeapYear(date.year);for(var month=0;month<12;++month){var daysUntilMonth=arraySum(leapYear?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR,month-1);if(day<=daysUntilMonth+(leapYear?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR)[month]){date.day=day-daysUntilMonth;}}}else if(value=getMatch("a")){// get day of month from weekday ...
var weekDay=value.substring(0,3).toUpperCase();if(value=getMatch("U")){// ... and week number (Sunday being first day of week)
// Week number of the year (Sunday as the first day of the week) as a decimal number [00,53].
// All days in a new year preceding the first Sunday are considered to be in week 0.
var weekDayNumber=DAY_NUMBERS_SUN_FIRST[weekDay];var weekNumber=jstoi_q(value);// January 1st
var janFirst=new Date(date.year,0,1);var endDate;if(janFirst.getDay()===0){// Jan 1st is a Sunday, and, hence in the 1st CW
endDate=addDays(janFirst,weekDayNumber+7*(weekNumber-1));}else{// Jan 1st is not a Sunday, and, hence still in the 0th CW
endDate=addDays(janFirst,7-janFirst.getDay()+weekDayNumber+7*(weekNumber-1));}date.day=endDate.getDate();date.month=endDate.getMonth();}else if(value=getMatch("W")){// ... and week number (Monday being first day of week)
// Week number of the year (Monday as the first day of the week) as a decimal number [00,53].
// All days in a new year preceding the first Monday are considered to be in week 0.
var weekDayNumber=DAY_NUMBERS_MON_FIRST[weekDay];var weekNumber=jstoi_q(value);// January 1st
var janFirst=new Date(date.year,0,1);var endDate;if(janFirst.getDay()===1){// Jan 1st is a Monday, and, hence in the 1st CW
endDate=addDays(janFirst,weekDayNumber+7*(weekNumber-1));}else{// Jan 1st is not a Monday, and, hence still in the 0th CW
endDate=addDays(janFirst,7-janFirst.getDay()+1+weekDayNumber+7*(weekNumber-1));}date.day=endDate.getDate();date.month=endDate.getMonth();}}// time zone
if(value=getMatch("z")){// GMT offset as either 'Z' or +-HH:MM or +-HH or +-HHMM
if(value.toLowerCase()==="z"){date.gmtoff=0;}else{var match=value.match(/^((?:\-|\+)\d\d):?(\d\d)?/);date.gmtoff=match[1]*3600;if(match[2]){date.gmtoff+=date.gmtoff>0?match[2]*60:-match[2]*60;}}}/*
        tm_sec  int seconds after the minute  0-61*
        tm_min  int minutes after the hour  0-59
        tm_hour int hours since midnight  0-23
        tm_mday int day of the month  1-31
        tm_mon  int months since January  0-11
        tm_year int years since 1900
        tm_wday int days since Sunday 0-6
        tm_yday int days since January 1  0-365
        tm_isdst  int Daylight Saving Time flag
        tm_gmtoff long offset from GMT (seconds)
        */var fullDate=new Date(date.year,date.month,date.day,date.hour,date.min,date.sec,0);HEAP32[tm>>>2>>>0]=fullDate.getSeconds();HEAP32[tm+4>>>2>>>0]=fullDate.getMinutes();HEAP32[tm+8>>>2>>>0]=fullDate.getHours();HEAP32[tm+12>>>2>>>0]=fullDate.getDate();HEAP32[tm+16>>>2>>>0]=fullDate.getMonth();HEAP32[tm+20>>>2>>>0]=fullDate.getFullYear()-1900;HEAP32[tm+24>>>2>>>0]=fullDate.getDay();HEAP32[tm+28>>>2>>>0]=arraySum(isLeapYear(fullDate.getFullYear())?MONTH_DAYS_LEAP:MONTH_DAYS_REGULAR,fullDate.getMonth()-1)+fullDate.getDate()-1;HEAP32[tm+32>>>2>>>0]=0;HEAP32[tm+36>>>2>>>0]=date.gmtoff;// we need to convert the matched sequence into an integer array to take care of UTF-8 characters > 0x7F
// TODO: not sure that intArrayFromString handles all unicode characters correctly
return buf+intArrayFromString(matches[0]).length-1;}return 0;}_strptime.sig="pppp";function _swapcontext(...args){return asyncifyStubs["swapcontext"](...args);}_swapcontext.stub=true;asyncifyStubs["swapcontext"]=undefined;function _xmlAllocOutputBuffer(...args){return asyncifyStubs["xmlAllocOutputBuffer"](...args);}_xmlAllocOutputBuffer.stub=true;asyncifyStubs["xmlAllocOutputBuffer"]=undefined;function _xmlAllocParserInputBuffer(...args){return asyncifyStubs["xmlAllocParserInputBuffer"](...args);}_xmlAllocParserInputBuffer.stub=true;asyncifyStubs["xmlAllocParserInputBuffer"]=undefined;function _xmlBufferAllocScheme(...args){return asyncifyStubs["xmlBufferAllocScheme"](...args);}_xmlBufferAllocScheme.stub=true;asyncifyStubs["xmlBufferAllocScheme"]=undefined;function _xmlCopyError(...args){return asyncifyStubs["xmlCopyError"](...args);}_xmlCopyError.stub=true;asyncifyStubs["xmlCopyError"]=undefined;function _xmlDefaultBufferSize(...args){return asyncifyStubs["xmlDefaultBufferSize"](...args);}_xmlDefaultBufferSize.stub=true;asyncifyStubs["xmlDefaultBufferSize"]=undefined;function _xmlDefaultSAXHandler(...args){return asyncifyStubs["xmlDefaultSAXHandler"](...args);}_xmlDefaultSAXHandler.stub=true;asyncifyStubs["xmlDefaultSAXHandler"]=undefined;function _xmlDefaultSAXLocator(...args){return asyncifyStubs["xmlDefaultSAXLocator"](...args);}_xmlDefaultSAXLocator.stub=true;asyncifyStubs["xmlDefaultSAXLocator"]=undefined;function _xmlDeregisterNodeDefaultValue(...args){return asyncifyStubs["xmlDeregisterNodeDefaultValue"](...args);}_xmlDeregisterNodeDefaultValue.stub=true;asyncifyStubs["xmlDeregisterNodeDefaultValue"]=undefined;function _xmlDictOwns(...args){return asyncifyStubs["xmlDictOwns"](...args);}_xmlDictOwns.stub=true;asyncifyStubs["xmlDictOwns"]=undefined;function _xmlDoValidityCheckingDefaultValue(...args){return asyncifyStubs["xmlDoValidityCheckingDefaultValue"](...args);}_xmlDoValidityCheckingDefaultValue.stub=true;asyncifyStubs["xmlDoValidityCheckingDefaultValue"]=undefined;function _xmlFileClose(...args){return asyncifyStubs["xmlFileClose"](...args);}_xmlFileClose.stub=true;asyncifyStubs["xmlFileClose"]=undefined;function _xmlFileMatch(...args){return asyncifyStubs["xmlFileMatch"](...args);}_xmlFileMatch.stub=true;asyncifyStubs["xmlFileMatch"]=undefined;function _xmlFileOpen(...args){return asyncifyStubs["xmlFileOpen"](...args);}_xmlFileOpen.stub=true;asyncifyStubs["xmlFileOpen"]=undefined;function _xmlFileRead(...args){return asyncifyStubs["xmlFileRead"](...args);}_xmlFileRead.stub=true;asyncifyStubs["xmlFileRead"]=undefined;function _xmlFree(...args){return asyncifyStubs["xmlFree"](...args);}_xmlFree.stub=true;asyncifyStubs["xmlFree"]=undefined;function _xmlFreeDoc(...args){return asyncifyStubs["xmlFreeDoc"](...args);}_xmlFreeDoc.stub=true;asyncifyStubs["xmlFreeDoc"]=undefined;function _xmlFreeNode(...args){return asyncifyStubs["xmlFreeNode"](...args);}_xmlFreeNode.stub=true;asyncifyStubs["xmlFreeNode"]=undefined;function _xmlFreeNodeList(...args){return asyncifyStubs["xmlFreeNodeList"](...args);}_xmlFreeNodeList.stub=true;asyncifyStubs["xmlFreeNodeList"]=undefined;function _xmlFreeNs(...args){return asyncifyStubs["xmlFreeNs"](...args);}_xmlFreeNs.stub=true;asyncifyStubs["xmlFreeNs"]=undefined;function _xmlFreeParserInputBuffer(...args){return asyncifyStubs["xmlFreeParserInputBuffer"](...args);}_xmlFreeParserInputBuffer.stub=true;asyncifyStubs["xmlFreeParserInputBuffer"]=undefined;function _xmlFreeProp(...args){return asyncifyStubs["xmlFreeProp"](...args);}_xmlFreeProp.stub=true;asyncifyStubs["xmlFreeProp"]=undefined;function _xmlFreeURI(...args){return asyncifyStubs["xmlFreeURI"](...args);}_xmlFreeURI.stub=true;asyncifyStubs["xmlFreeURI"]=undefined;function _xmlGenericError(...args){return asyncifyStubs["xmlGenericError"](...args);}_xmlGenericError.stub=true;asyncifyStubs["xmlGenericError"]=undefined;function _xmlGenericErrorContext(...args){return asyncifyStubs["xmlGenericErrorContext"](...args);}_xmlGenericErrorContext.stub=true;asyncifyStubs["xmlGenericErrorContext"]=undefined;function _xmlGenericErrorDefaultFunc(...args){return asyncifyStubs["xmlGenericErrorDefaultFunc"](...args);}_xmlGenericErrorDefaultFunc.stub=true;asyncifyStubs["xmlGenericErrorDefaultFunc"]=undefined;function _xmlGetExternalEntityLoader(...args){return asyncifyStubs["xmlGetExternalEntityLoader"](...args);}_xmlGetExternalEntityLoader.stub=true;asyncifyStubs["xmlGetExternalEntityLoader"]=undefined;function _xmlGetLastError(...args){return asyncifyStubs["xmlGetLastError"](...args);}_xmlGetLastError.stub=true;asyncifyStubs["xmlGetLastError"]=undefined;function _xmlGetWarningsDefaultValue(...args){return asyncifyStubs["xmlGetWarningsDefaultValue"](...args);}_xmlGetWarningsDefaultValue.stub=true;asyncifyStubs["xmlGetWarningsDefaultValue"]=undefined;function _xmlHashDefaultDeallocator(...args){return asyncifyStubs["xmlHashDefaultDeallocator"](...args);}_xmlHashDefaultDeallocator.stub=true;asyncifyStubs["xmlHashDefaultDeallocator"]=undefined;function _xmlHashLookup(...args){return asyncifyStubs["xmlHashLookup"](...args);}_xmlHashLookup.stub=true;asyncifyStubs["xmlHashLookup"]=undefined;function _xmlHashRemoveEntry(...args){return asyncifyStubs["xmlHashRemoveEntry"](...args);}_xmlHashRemoveEntry.stub=true;asyncifyStubs["xmlHashRemoveEntry"]=undefined;function _xmlHashScan(...args){return asyncifyStubs["xmlHashScan"](...args);}_xmlHashScan.stub=true;asyncifyStubs["xmlHashScan"]=undefined;function _xmlIndentTreeOutput(...args){return asyncifyStubs["xmlIndentTreeOutput"](...args);}_xmlIndentTreeOutput.stub=true;asyncifyStubs["xmlIndentTreeOutput"]=undefined;function _xmlInitParser(...args){return asyncifyStubs["xmlInitParser"](...args);}_xmlInitParser.stub=true;asyncifyStubs["xmlInitParser"]=undefined;function _xmlInputReadCallbackNop(...args){return asyncifyStubs["xmlInputReadCallbackNop"](...args);}_xmlInputReadCallbackNop.stub=true;asyncifyStubs["xmlInputReadCallbackNop"]=undefined;function _xmlIsBaseCharGroup(...args){return asyncifyStubs["xmlIsBaseCharGroup"](...args);}_xmlIsBaseCharGroup.stub=true;asyncifyStubs["xmlIsBaseCharGroup"]=undefined;function _xmlIsCombiningGroup(...args){return asyncifyStubs["xmlIsCombiningGroup"](...args);}_xmlIsCombiningGroup.stub=true;asyncifyStubs["xmlIsCombiningGroup"]=undefined;function _xmlIsDigitGroup(...args){return asyncifyStubs["xmlIsDigitGroup"](...args);}_xmlIsDigitGroup.stub=true;asyncifyStubs["xmlIsDigitGroup"]=undefined;function _xmlIsExtenderGroup(...args){return asyncifyStubs["xmlIsExtenderGroup"](...args);}_xmlIsExtenderGroup.stub=true;asyncifyStubs["xmlIsExtenderGroup"]=undefined;function _xmlIsPubidChar_tab(...args){return asyncifyStubs["xmlIsPubidChar_tab"](...args);}_xmlIsPubidChar_tab.stub=true;asyncifyStubs["xmlIsPubidChar_tab"]=undefined;function _xmlKeepBlanksDefaultValue(...args){return asyncifyStubs["xmlKeepBlanksDefaultValue"](...args);}_xmlKeepBlanksDefaultValue.stub=true;asyncifyStubs["xmlKeepBlanksDefaultValue"]=undefined;function _xmlLastError(...args){return asyncifyStubs["xmlLastError"](...args);}_xmlLastError.stub=true;asyncifyStubs["xmlLastError"]=undefined;function _xmlLineNumbersDefaultValue(...args){return asyncifyStubs["xmlLineNumbersDefaultValue"](...args);}_xmlLineNumbersDefaultValue.stub=true;asyncifyStubs["xmlLineNumbersDefaultValue"]=undefined;function _xmlLoadExtDtdDefaultValue(...args){return asyncifyStubs["xmlLoadExtDtdDefaultValue"](...args);}_xmlLoadExtDtdDefaultValue.stub=true;asyncifyStubs["xmlLoadExtDtdDefaultValue"]=undefined;function _xmlMalloc(...args){return asyncifyStubs["xmlMalloc"](...args);}_xmlMalloc.stub=true;asyncifyStubs["xmlMalloc"]=undefined;function _xmlMallocAtomic(...args){return asyncifyStubs["xmlMallocAtomic"](...args);}_xmlMallocAtomic.stub=true;asyncifyStubs["xmlMallocAtomic"]=undefined;function _xmlMemStrdup(...args){return asyncifyStubs["xmlMemStrdup"](...args);}_xmlMemStrdup.stub=true;asyncifyStubs["xmlMemStrdup"]=undefined;function _xmlNewIOInputStream(...args){return asyncifyStubs["xmlNewIOInputStream"](...args);}_xmlNewIOInputStream.stub=true;asyncifyStubs["xmlNewIOInputStream"]=undefined;function _xmlNewInputFromFile(...args){return asyncifyStubs["xmlNewInputFromFile"](...args);}_xmlNewInputFromFile.stub=true;asyncifyStubs["xmlNewInputFromFile"]=undefined;function _xmlOutputBufferCreateFilenameDefault(...args){return asyncifyStubs["xmlOutputBufferCreateFilenameDefault"](...args);}_xmlOutputBufferCreateFilenameDefault.stub=true;asyncifyStubs["xmlOutputBufferCreateFilenameDefault"]=undefined;function _xmlOutputBufferCreateFilenameValue(...args){return asyncifyStubs["xmlOutputBufferCreateFilenameValue"](...args);}_xmlOutputBufferCreateFilenameValue.stub=true;asyncifyStubs["xmlOutputBufferCreateFilenameValue"]=undefined;function _xmlParseCharEncoding(...args){return asyncifyStubs["xmlParseCharEncoding"](...args);}_xmlParseCharEncoding.stub=true;asyncifyStubs["xmlParseCharEncoding"]=undefined;function _xmlParseURI(...args){return asyncifyStubs["xmlParseURI"](...args);}_xmlParseURI.stub=true;asyncifyStubs["xmlParseURI"]=undefined;function _xmlParserDebugEntities(...args){return asyncifyStubs["xmlParserDebugEntities"](...args);}_xmlParserDebugEntities.stub=true;asyncifyStubs["xmlParserDebugEntities"]=undefined;function _xmlParserError(...args){return asyncifyStubs["xmlParserError"](...args);}_xmlParserError.stub=true;asyncifyStubs["xmlParserError"]=undefined;function _xmlParserInputBufferCreateFilenameDefault(...args){return asyncifyStubs["xmlParserInputBufferCreateFilenameDefault"](...args);}_xmlParserInputBufferCreateFilenameDefault.stub=true;asyncifyStubs["xmlParserInputBufferCreateFilenameDefault"]=undefined;function _xmlParserInputBufferCreateFilenameValue(...args){return asyncifyStubs["xmlParserInputBufferCreateFilenameValue"](...args);}_xmlParserInputBufferCreateFilenameValue.stub=true;asyncifyStubs["xmlParserInputBufferCreateFilenameValue"]=undefined;function _xmlParserMaxDepth(...args){return asyncifyStubs["xmlParserMaxDepth"](...args);}_xmlParserMaxDepth.stub=true;asyncifyStubs["xmlParserMaxDepth"]=undefined;function _xmlParserValidityError(...args){return asyncifyStubs["xmlParserValidityError"](...args);}_xmlParserValidityError.stub=true;asyncifyStubs["xmlParserValidityError"]=undefined;function _xmlParserValidityWarning(...args){return asyncifyStubs["xmlParserValidityWarning"](...args);}_xmlParserValidityWarning.stub=true;asyncifyStubs["xmlParserValidityWarning"]=undefined;function _xmlParserVersion(...args){return asyncifyStubs["xmlParserVersion"](...args);}_xmlParserVersion.stub=true;asyncifyStubs["xmlParserVersion"]=undefined;function _xmlParserWarning(...args){return asyncifyStubs["xmlParserWarning"](...args);}_xmlParserWarning.stub=true;asyncifyStubs["xmlParserWarning"]=undefined;function _xmlPedanticParserDefaultValue(...args){return asyncifyStubs["xmlPedanticParserDefaultValue"](...args);}_xmlPedanticParserDefaultValue.stub=true;asyncifyStubs["xmlPedanticParserDefaultValue"]=undefined;function _xmlRealloc(...args){return asyncifyStubs["xmlRealloc"](...args);}_xmlRealloc.stub=true;asyncifyStubs["xmlRealloc"]=undefined;function _xmlReconciliateNs(...args){return asyncifyStubs["xmlReconciliateNs"](...args);}_xmlReconciliateNs.stub=true;asyncifyStubs["xmlReconciliateNs"]=undefined;function _xmlRegisterNodeDefaultValue(...args){return asyncifyStubs["xmlRegisterNodeDefaultValue"](...args);}_xmlRegisterNodeDefaultValue.stub=true;asyncifyStubs["xmlRegisterNodeDefaultValue"]=undefined;function _xmlRelaxNGCleanupTypes(...args){return asyncifyStubs["xmlRelaxNGCleanupTypes"](...args);}_xmlRelaxNGCleanupTypes.stub=true;asyncifyStubs["xmlRelaxNGCleanupTypes"]=undefined;function _xmlRemoveID(...args){return asyncifyStubs["xmlRemoveID"](...args);}_xmlRemoveID.stub=true;asyncifyStubs["xmlRemoveID"]=undefined;function _xmlResetError(...args){return asyncifyStubs["xmlResetError"](...args);}_xmlResetError.stub=true;asyncifyStubs["xmlResetError"]=undefined;function _xmlResetLastError(...args){return asyncifyStubs["xmlResetLastError"](...args);}_xmlResetLastError.stub=true;asyncifyStubs["xmlResetLastError"]=undefined;function _xmlSAX2AttributeDecl(...args){return asyncifyStubs["xmlSAX2AttributeDecl"](...args);}_xmlSAX2AttributeDecl.stub=true;asyncifyStubs["xmlSAX2AttributeDecl"]=undefined;function _xmlSAX2CDataBlock(...args){return asyncifyStubs["xmlSAX2CDataBlock"](...args);}_xmlSAX2CDataBlock.stub=true;asyncifyStubs["xmlSAX2CDataBlock"]=undefined;function _xmlSAX2Characters(...args){return asyncifyStubs["xmlSAX2Characters"](...args);}_xmlSAX2Characters.stub=true;asyncifyStubs["xmlSAX2Characters"]=undefined;function _xmlSAX2Comment(...args){return asyncifyStubs["xmlSAX2Comment"](...args);}_xmlSAX2Comment.stub=true;asyncifyStubs["xmlSAX2Comment"]=undefined;function _xmlSAX2ElementDecl(...args){return asyncifyStubs["xmlSAX2ElementDecl"](...args);}_xmlSAX2ElementDecl.stub=true;asyncifyStubs["xmlSAX2ElementDecl"]=undefined;function _xmlSAX2EndDocument(...args){return asyncifyStubs["xmlSAX2EndDocument"](...args);}_xmlSAX2EndDocument.stub=true;asyncifyStubs["xmlSAX2EndDocument"]=undefined;function _xmlSAX2EndElement(...args){return asyncifyStubs["xmlSAX2EndElement"](...args);}_xmlSAX2EndElement.stub=true;asyncifyStubs["xmlSAX2EndElement"]=undefined;function _xmlSAX2EndElementNs(...args){return asyncifyStubs["xmlSAX2EndElementNs"](...args);}_xmlSAX2EndElementNs.stub=true;asyncifyStubs["xmlSAX2EndElementNs"]=undefined;function _xmlSAX2EntityDecl(...args){return asyncifyStubs["xmlSAX2EntityDecl"](...args);}_xmlSAX2EntityDecl.stub=true;asyncifyStubs["xmlSAX2EntityDecl"]=undefined;function _xmlSAX2ExternalSubset(...args){return asyncifyStubs["xmlSAX2ExternalSubset"](...args);}_xmlSAX2ExternalSubset.stub=true;asyncifyStubs["xmlSAX2ExternalSubset"]=undefined;function _xmlSAX2GetColumnNumber(...args){return asyncifyStubs["xmlSAX2GetColumnNumber"](...args);}_xmlSAX2GetColumnNumber.stub=true;asyncifyStubs["xmlSAX2GetColumnNumber"]=undefined;function _xmlSAX2GetEntity(...args){return asyncifyStubs["xmlSAX2GetEntity"](...args);}_xmlSAX2GetEntity.stub=true;asyncifyStubs["xmlSAX2GetEntity"]=undefined;function _xmlSAX2GetLineNumber(...args){return asyncifyStubs["xmlSAX2GetLineNumber"](...args);}_xmlSAX2GetLineNumber.stub=true;asyncifyStubs["xmlSAX2GetLineNumber"]=undefined;function _xmlSAX2GetParameterEntity(...args){return asyncifyStubs["xmlSAX2GetParameterEntity"](...args);}_xmlSAX2GetParameterEntity.stub=true;asyncifyStubs["xmlSAX2GetParameterEntity"]=undefined;function _xmlSAX2GetPublicId(...args){return asyncifyStubs["xmlSAX2GetPublicId"](...args);}_xmlSAX2GetPublicId.stub=true;asyncifyStubs["xmlSAX2GetPublicId"]=undefined;function _xmlSAX2GetSystemId(...args){return asyncifyStubs["xmlSAX2GetSystemId"](...args);}_xmlSAX2GetSystemId.stub=true;asyncifyStubs["xmlSAX2GetSystemId"]=undefined;function _xmlSAX2HasExternalSubset(...args){return asyncifyStubs["xmlSAX2HasExternalSubset"](...args);}_xmlSAX2HasExternalSubset.stub=true;asyncifyStubs["xmlSAX2HasExternalSubset"]=undefined;function _xmlSAX2HasInternalSubset(...args){return asyncifyStubs["xmlSAX2HasInternalSubset"](...args);}_xmlSAX2HasInternalSubset.stub=true;asyncifyStubs["xmlSAX2HasInternalSubset"]=undefined;function _xmlSAX2IgnorableWhitespace(...args){return asyncifyStubs["xmlSAX2IgnorableWhitespace"](...args);}_xmlSAX2IgnorableWhitespace.stub=true;asyncifyStubs["xmlSAX2IgnorableWhitespace"]=undefined;function _xmlSAX2InternalSubset(...args){return asyncifyStubs["xmlSAX2InternalSubset"](...args);}_xmlSAX2InternalSubset.stub=true;asyncifyStubs["xmlSAX2InternalSubset"]=undefined;function _xmlSAX2IsStandalone(...args){return asyncifyStubs["xmlSAX2IsStandalone"](...args);}_xmlSAX2IsStandalone.stub=true;asyncifyStubs["xmlSAX2IsStandalone"]=undefined;function _xmlSAX2NotationDecl(...args){return asyncifyStubs["xmlSAX2NotationDecl"](...args);}_xmlSAX2NotationDecl.stub=true;asyncifyStubs["xmlSAX2NotationDecl"]=undefined;function _xmlSAX2ProcessingInstruction(...args){return asyncifyStubs["xmlSAX2ProcessingInstruction"](...args);}_xmlSAX2ProcessingInstruction.stub=true;asyncifyStubs["xmlSAX2ProcessingInstruction"]=undefined;function _xmlSAX2Reference(...args){return asyncifyStubs["xmlSAX2Reference"](...args);}_xmlSAX2Reference.stub=true;asyncifyStubs["xmlSAX2Reference"]=undefined;function _xmlSAX2ResolveEntity(...args){return asyncifyStubs["xmlSAX2ResolveEntity"](...args);}_xmlSAX2ResolveEntity.stub=true;asyncifyStubs["xmlSAX2ResolveEntity"]=undefined;function _xmlSAX2SetDocumentLocator(...args){return asyncifyStubs["xmlSAX2SetDocumentLocator"](...args);}_xmlSAX2SetDocumentLocator.stub=true;asyncifyStubs["xmlSAX2SetDocumentLocator"]=undefined;function _xmlSAX2StartDocument(...args){return asyncifyStubs["xmlSAX2StartDocument"](...args);}_xmlSAX2StartDocument.stub=true;asyncifyStubs["xmlSAX2StartDocument"]=undefined;function _xmlSAX2StartElement(...args){return asyncifyStubs["xmlSAX2StartElement"](...args);}_xmlSAX2StartElement.stub=true;asyncifyStubs["xmlSAX2StartElement"]=undefined;function _xmlSAX2StartElementNs(...args){return asyncifyStubs["xmlSAX2StartElementNs"](...args);}_xmlSAX2StartElementNs.stub=true;asyncifyStubs["xmlSAX2StartElementNs"]=undefined;function _xmlSAX2UnparsedEntityDecl(...args){return asyncifyStubs["xmlSAX2UnparsedEntityDecl"](...args);}_xmlSAX2UnparsedEntityDecl.stub=true;asyncifyStubs["xmlSAX2UnparsedEntityDecl"]=undefined;function _xmlSaveNoEmptyTags(...args){return asyncifyStubs["xmlSaveNoEmptyTags"](...args);}_xmlSaveNoEmptyTags.stub=true;asyncifyStubs["xmlSaveNoEmptyTags"]=undefined;function _xmlSetExternalEntityLoader(...args){return asyncifyStubs["xmlSetExternalEntityLoader"](...args);}_xmlSetExternalEntityLoader.stub=true;asyncifyStubs["xmlSetExternalEntityLoader"]=undefined;function _xmlSetGenericErrorFunc(...args){return asyncifyStubs["xmlSetGenericErrorFunc"](...args);}_xmlSetGenericErrorFunc.stub=true;asyncifyStubs["xmlSetGenericErrorFunc"]=undefined;function _xmlSetStructuredErrorFunc(...args){return asyncifyStubs["xmlSetStructuredErrorFunc"](...args);}_xmlSetStructuredErrorFunc.stub=true;asyncifyStubs["xmlSetStructuredErrorFunc"]=undefined;function _xmlStrdup(...args){return asyncifyStubs["xmlStrdup"](...args);}_xmlStrdup.stub=true;asyncifyStubs["xmlStrdup"]=undefined;function _xmlStringComment(...args){return asyncifyStubs["xmlStringComment"](...args);}_xmlStringComment.stub=true;asyncifyStubs["xmlStringComment"]=undefined;function _xmlStringText(...args){return asyncifyStubs["xmlStringText"](...args);}_xmlStringText.stub=true;asyncifyStubs["xmlStringText"]=undefined;function _xmlStringTextNoenc(...args){return asyncifyStubs["xmlStringTextNoenc"](...args);}_xmlStringTextNoenc.stub=true;asyncifyStubs["xmlStringTextNoenc"]=undefined;function _xmlStrncmp(...args){return asyncifyStubs["xmlStrncmp"](...args);}_xmlStrncmp.stub=true;asyncifyStubs["xmlStrncmp"]=undefined;function _xmlStructuredError(...args){return asyncifyStubs["xmlStructuredError"](...args);}_xmlStructuredError.stub=true;asyncifyStubs["xmlStructuredError"]=undefined;function _xmlStructuredErrorContext(...args){return asyncifyStubs["xmlStructuredErrorContext"](...args);}_xmlStructuredErrorContext.stub=true;asyncifyStubs["xmlStructuredErrorContext"]=undefined;function _xmlSubstituteEntitiesDefaultValue(...args){return asyncifyStubs["xmlSubstituteEntitiesDefaultValue"](...args);}_xmlSubstituteEntitiesDefaultValue.stub=true;asyncifyStubs["xmlSubstituteEntitiesDefaultValue"]=undefined;function _xmlTreeIndentString(...args){return asyncifyStubs["xmlTreeIndentString"](...args);}_xmlTreeIndentString.stub=true;asyncifyStubs["xmlTreeIndentString"]=undefined;function _xmlUCSIsAegeanNumbers(...args){return asyncifyStubs["xmlUCSIsAegeanNumbers"](...args);}_xmlUCSIsAegeanNumbers.stub=true;asyncifyStubs["xmlUCSIsAegeanNumbers"]=undefined;function _xmlUCSIsAlphabeticPresentationForms(...args){return asyncifyStubs["xmlUCSIsAlphabeticPresentationForms"](...args);}_xmlUCSIsAlphabeticPresentationForms.stub=true;asyncifyStubs["xmlUCSIsAlphabeticPresentationForms"]=undefined;function _xmlUCSIsArabic(...args){return asyncifyStubs["xmlUCSIsArabic"](...args);}_xmlUCSIsArabic.stub=true;asyncifyStubs["xmlUCSIsArabic"]=undefined;function _xmlUCSIsArabicPresentationFormsA(...args){return asyncifyStubs["xmlUCSIsArabicPresentationFormsA"](...args);}_xmlUCSIsArabicPresentationFormsA.stub=true;asyncifyStubs["xmlUCSIsArabicPresentationFormsA"]=undefined;function _xmlUCSIsArabicPresentationFormsB(...args){return asyncifyStubs["xmlUCSIsArabicPresentationFormsB"](...args);}_xmlUCSIsArabicPresentationFormsB.stub=true;asyncifyStubs["xmlUCSIsArabicPresentationFormsB"]=undefined;function _xmlUCSIsArmenian(...args){return asyncifyStubs["xmlUCSIsArmenian"](...args);}_xmlUCSIsArmenian.stub=true;asyncifyStubs["xmlUCSIsArmenian"]=undefined;function _xmlUCSIsArrows(...args){return asyncifyStubs["xmlUCSIsArrows"](...args);}_xmlUCSIsArrows.stub=true;asyncifyStubs["xmlUCSIsArrows"]=undefined;function _xmlUCSIsBasicLatin(...args){return asyncifyStubs["xmlUCSIsBasicLatin"](...args);}_xmlUCSIsBasicLatin.stub=true;asyncifyStubs["xmlUCSIsBasicLatin"]=undefined;function _xmlUCSIsBengali(...args){return asyncifyStubs["xmlUCSIsBengali"](...args);}_xmlUCSIsBengali.stub=true;asyncifyStubs["xmlUCSIsBengali"]=undefined;function _xmlUCSIsBlockElements(...args){return asyncifyStubs["xmlUCSIsBlockElements"](...args);}_xmlUCSIsBlockElements.stub=true;asyncifyStubs["xmlUCSIsBlockElements"]=undefined;function _xmlUCSIsBopomofo(...args){return asyncifyStubs["xmlUCSIsBopomofo"](...args);}_xmlUCSIsBopomofo.stub=true;asyncifyStubs["xmlUCSIsBopomofo"]=undefined;function _xmlUCSIsBopomofoExtended(...args){return asyncifyStubs["xmlUCSIsBopomofoExtended"](...args);}_xmlUCSIsBopomofoExtended.stub=true;asyncifyStubs["xmlUCSIsBopomofoExtended"]=undefined;function _xmlUCSIsBoxDrawing(...args){return asyncifyStubs["xmlUCSIsBoxDrawing"](...args);}_xmlUCSIsBoxDrawing.stub=true;asyncifyStubs["xmlUCSIsBoxDrawing"]=undefined;function _xmlUCSIsBraillePatterns(...args){return asyncifyStubs["xmlUCSIsBraillePatterns"](...args);}_xmlUCSIsBraillePatterns.stub=true;asyncifyStubs["xmlUCSIsBraillePatterns"]=undefined;function _xmlUCSIsBuhid(...args){return asyncifyStubs["xmlUCSIsBuhid"](...args);}_xmlUCSIsBuhid.stub=true;asyncifyStubs["xmlUCSIsBuhid"]=undefined;function _xmlUCSIsByzantineMusicalSymbols(...args){return asyncifyStubs["xmlUCSIsByzantineMusicalSymbols"](...args);}_xmlUCSIsByzantineMusicalSymbols.stub=true;asyncifyStubs["xmlUCSIsByzantineMusicalSymbols"]=undefined;function _xmlUCSIsCJKCompatibility(...args){return asyncifyStubs["xmlUCSIsCJKCompatibility"](...args);}_xmlUCSIsCJKCompatibility.stub=true;asyncifyStubs["xmlUCSIsCJKCompatibility"]=undefined;function _xmlUCSIsCJKCompatibilityForms(...args){return asyncifyStubs["xmlUCSIsCJKCompatibilityForms"](...args);}_xmlUCSIsCJKCompatibilityForms.stub=true;asyncifyStubs["xmlUCSIsCJKCompatibilityForms"]=undefined;function _xmlUCSIsCJKCompatibilityIdeographs(...args){return asyncifyStubs["xmlUCSIsCJKCompatibilityIdeographs"](...args);}_xmlUCSIsCJKCompatibilityIdeographs.stub=true;asyncifyStubs["xmlUCSIsCJKCompatibilityIdeographs"]=undefined;function _xmlUCSIsCJKCompatibilityIdeographsSupplement(...args){return asyncifyStubs["xmlUCSIsCJKCompatibilityIdeographsSupplement"](...args);}_xmlUCSIsCJKCompatibilityIdeographsSupplement.stub=true;asyncifyStubs["xmlUCSIsCJKCompatibilityIdeographsSupplement"]=undefined;function _xmlUCSIsCJKRadicalsSupplement(...args){return asyncifyStubs["xmlUCSIsCJKRadicalsSupplement"](...args);}_xmlUCSIsCJKRadicalsSupplement.stub=true;asyncifyStubs["xmlUCSIsCJKRadicalsSupplement"]=undefined;function _xmlUCSIsCJKSymbolsandPunctuation(...args){return asyncifyStubs["xmlUCSIsCJKSymbolsandPunctuation"](...args);}_xmlUCSIsCJKSymbolsandPunctuation.stub=true;asyncifyStubs["xmlUCSIsCJKSymbolsandPunctuation"]=undefined;function _xmlUCSIsCJKUnifiedIdeographs(...args){return asyncifyStubs["xmlUCSIsCJKUnifiedIdeographs"](...args);}_xmlUCSIsCJKUnifiedIdeographs.stub=true;asyncifyStubs["xmlUCSIsCJKUnifiedIdeographs"]=undefined;function _xmlUCSIsCJKUnifiedIdeographsExtensionA(...args){return asyncifyStubs["xmlUCSIsCJKUnifiedIdeographsExtensionA"](...args);}_xmlUCSIsCJKUnifiedIdeographsExtensionA.stub=true;asyncifyStubs["xmlUCSIsCJKUnifiedIdeographsExtensionA"]=undefined;function _xmlUCSIsCJKUnifiedIdeographsExtensionB(...args){return asyncifyStubs["xmlUCSIsCJKUnifiedIdeographsExtensionB"](...args);}_xmlUCSIsCJKUnifiedIdeographsExtensionB.stub=true;asyncifyStubs["xmlUCSIsCJKUnifiedIdeographsExtensionB"]=undefined;function _xmlUCSIsCatC(...args){return asyncifyStubs["xmlUCSIsCatC"](...args);}_xmlUCSIsCatC.stub=true;asyncifyStubs["xmlUCSIsCatC"]=undefined;function _xmlUCSIsCatCc(...args){return asyncifyStubs["xmlUCSIsCatCc"](...args);}_xmlUCSIsCatCc.stub=true;asyncifyStubs["xmlUCSIsCatCc"]=undefined;function _xmlUCSIsCatCf(...args){return asyncifyStubs["xmlUCSIsCatCf"](...args);}_xmlUCSIsCatCf.stub=true;asyncifyStubs["xmlUCSIsCatCf"]=undefined;function _xmlUCSIsCatCo(...args){return asyncifyStubs["xmlUCSIsCatCo"](...args);}_xmlUCSIsCatCo.stub=true;asyncifyStubs["xmlUCSIsCatCo"]=undefined;function _xmlUCSIsCatCs(...args){return asyncifyStubs["xmlUCSIsCatCs"](...args);}_xmlUCSIsCatCs.stub=true;asyncifyStubs["xmlUCSIsCatCs"]=undefined;function _xmlUCSIsCatL(...args){return asyncifyStubs["xmlUCSIsCatL"](...args);}_xmlUCSIsCatL.stub=true;asyncifyStubs["xmlUCSIsCatL"]=undefined;function _xmlUCSIsCatLl(...args){return asyncifyStubs["xmlUCSIsCatLl"](...args);}_xmlUCSIsCatLl.stub=true;asyncifyStubs["xmlUCSIsCatLl"]=undefined;function _xmlUCSIsCatLm(...args){return asyncifyStubs["xmlUCSIsCatLm"](...args);}_xmlUCSIsCatLm.stub=true;asyncifyStubs["xmlUCSIsCatLm"]=undefined;function _xmlUCSIsCatLo(...args){return asyncifyStubs["xmlUCSIsCatLo"](...args);}_xmlUCSIsCatLo.stub=true;asyncifyStubs["xmlUCSIsCatLo"]=undefined;function _xmlUCSIsCatLt(...args){return asyncifyStubs["xmlUCSIsCatLt"](...args);}_xmlUCSIsCatLt.stub=true;asyncifyStubs["xmlUCSIsCatLt"]=undefined;function _xmlUCSIsCatLu(...args){return asyncifyStubs["xmlUCSIsCatLu"](...args);}_xmlUCSIsCatLu.stub=true;asyncifyStubs["xmlUCSIsCatLu"]=undefined;function _xmlUCSIsCatM(...args){return asyncifyStubs["xmlUCSIsCatM"](...args);}_xmlUCSIsCatM.stub=true;asyncifyStubs["xmlUCSIsCatM"]=undefined;function _xmlUCSIsCatMc(...args){return asyncifyStubs["xmlUCSIsCatMc"](...args);}_xmlUCSIsCatMc.stub=true;asyncifyStubs["xmlUCSIsCatMc"]=undefined;function _xmlUCSIsCatMe(...args){return asyncifyStubs["xmlUCSIsCatMe"](...args);}_xmlUCSIsCatMe.stub=true;asyncifyStubs["xmlUCSIsCatMe"]=undefined;function _xmlUCSIsCatMn(...args){return asyncifyStubs["xmlUCSIsCatMn"](...args);}_xmlUCSIsCatMn.stub=true;asyncifyStubs["xmlUCSIsCatMn"]=undefined;function _xmlUCSIsCatN(...args){return asyncifyStubs["xmlUCSIsCatN"](...args);}_xmlUCSIsCatN.stub=true;asyncifyStubs["xmlUCSIsCatN"]=undefined;function _xmlUCSIsCatNd(...args){return asyncifyStubs["xmlUCSIsCatNd"](...args);}_xmlUCSIsCatNd.stub=true;asyncifyStubs["xmlUCSIsCatNd"]=undefined;function _xmlUCSIsCatNl(...args){return asyncifyStubs["xmlUCSIsCatNl"](...args);}_xmlUCSIsCatNl.stub=true;asyncifyStubs["xmlUCSIsCatNl"]=undefined;function _xmlUCSIsCatNo(...args){return asyncifyStubs["xmlUCSIsCatNo"](...args);}_xmlUCSIsCatNo.stub=true;asyncifyStubs["xmlUCSIsCatNo"]=undefined;function _xmlUCSIsCatP(...args){return asyncifyStubs["xmlUCSIsCatP"](...args);}_xmlUCSIsCatP.stub=true;asyncifyStubs["xmlUCSIsCatP"]=undefined;function _xmlUCSIsCatPc(...args){return asyncifyStubs["xmlUCSIsCatPc"](...args);}_xmlUCSIsCatPc.stub=true;asyncifyStubs["xmlUCSIsCatPc"]=undefined;function _xmlUCSIsCatPd(...args){return asyncifyStubs["xmlUCSIsCatPd"](...args);}_xmlUCSIsCatPd.stub=true;asyncifyStubs["xmlUCSIsCatPd"]=undefined;function _xmlUCSIsCatPe(...args){return asyncifyStubs["xmlUCSIsCatPe"](...args);}_xmlUCSIsCatPe.stub=true;asyncifyStubs["xmlUCSIsCatPe"]=undefined;function _xmlUCSIsCatPf(...args){return asyncifyStubs["xmlUCSIsCatPf"](...args);}_xmlUCSIsCatPf.stub=true;asyncifyStubs["xmlUCSIsCatPf"]=undefined;function _xmlUCSIsCatPi(...args){return asyncifyStubs["xmlUCSIsCatPi"](...args);}_xmlUCSIsCatPi.stub=true;asyncifyStubs["xmlUCSIsCatPi"]=undefined;function _xmlUCSIsCatPo(...args){return asyncifyStubs["xmlUCSIsCatPo"](...args);}_xmlUCSIsCatPo.stub=true;asyncifyStubs["xmlUCSIsCatPo"]=undefined;function _xmlUCSIsCatPs(...args){return asyncifyStubs["xmlUCSIsCatPs"](...args);}_xmlUCSIsCatPs.stub=true;asyncifyStubs["xmlUCSIsCatPs"]=undefined;function _xmlUCSIsCatS(...args){return asyncifyStubs["xmlUCSIsCatS"](...args);}_xmlUCSIsCatS.stub=true;asyncifyStubs["xmlUCSIsCatS"]=undefined;function _xmlUCSIsCatSc(...args){return asyncifyStubs["xmlUCSIsCatSc"](...args);}_xmlUCSIsCatSc.stub=true;asyncifyStubs["xmlUCSIsCatSc"]=undefined;function _xmlUCSIsCatSk(...args){return asyncifyStubs["xmlUCSIsCatSk"](...args);}_xmlUCSIsCatSk.stub=true;asyncifyStubs["xmlUCSIsCatSk"]=undefined;function _xmlUCSIsCatSm(...args){return asyncifyStubs["xmlUCSIsCatSm"](...args);}_xmlUCSIsCatSm.stub=true;asyncifyStubs["xmlUCSIsCatSm"]=undefined;function _xmlUCSIsCatSo(...args){return asyncifyStubs["xmlUCSIsCatSo"](...args);}_xmlUCSIsCatSo.stub=true;asyncifyStubs["xmlUCSIsCatSo"]=undefined;function _xmlUCSIsCatZ(...args){return asyncifyStubs["xmlUCSIsCatZ"](...args);}_xmlUCSIsCatZ.stub=true;asyncifyStubs["xmlUCSIsCatZ"]=undefined;function _xmlUCSIsCatZl(...args){return asyncifyStubs["xmlUCSIsCatZl"](...args);}_xmlUCSIsCatZl.stub=true;asyncifyStubs["xmlUCSIsCatZl"]=undefined;function _xmlUCSIsCatZp(...args){return asyncifyStubs["xmlUCSIsCatZp"](...args);}_xmlUCSIsCatZp.stub=true;asyncifyStubs["xmlUCSIsCatZp"]=undefined;function _xmlUCSIsCatZs(...args){return asyncifyStubs["xmlUCSIsCatZs"](...args);}_xmlUCSIsCatZs.stub=true;asyncifyStubs["xmlUCSIsCatZs"]=undefined;function _xmlUCSIsCherokee(...args){return asyncifyStubs["xmlUCSIsCherokee"](...args);}_xmlUCSIsCherokee.stub=true;asyncifyStubs["xmlUCSIsCherokee"]=undefined;function _xmlUCSIsCombiningDiacriticalMarks(...args){return asyncifyStubs["xmlUCSIsCombiningDiacriticalMarks"](...args);}_xmlUCSIsCombiningDiacriticalMarks.stub=true;asyncifyStubs["xmlUCSIsCombiningDiacriticalMarks"]=undefined;function _xmlUCSIsCombiningDiacriticalMarksforSymbols(...args){return asyncifyStubs["xmlUCSIsCombiningDiacriticalMarksforSymbols"](...args);}_xmlUCSIsCombiningDiacriticalMarksforSymbols.stub=true;asyncifyStubs["xmlUCSIsCombiningDiacriticalMarksforSymbols"]=undefined;function _xmlUCSIsCombiningHalfMarks(...args){return asyncifyStubs["xmlUCSIsCombiningHalfMarks"](...args);}_xmlUCSIsCombiningHalfMarks.stub=true;asyncifyStubs["xmlUCSIsCombiningHalfMarks"]=undefined;function _xmlUCSIsCombiningMarksforSymbols(...args){return asyncifyStubs["xmlUCSIsCombiningMarksforSymbols"](...args);}_xmlUCSIsCombiningMarksforSymbols.stub=true;asyncifyStubs["xmlUCSIsCombiningMarksforSymbols"]=undefined;function _xmlUCSIsControlPictures(...args){return asyncifyStubs["xmlUCSIsControlPictures"](...args);}_xmlUCSIsControlPictures.stub=true;asyncifyStubs["xmlUCSIsControlPictures"]=undefined;function _xmlUCSIsCurrencySymbols(...args){return asyncifyStubs["xmlUCSIsCurrencySymbols"](...args);}_xmlUCSIsCurrencySymbols.stub=true;asyncifyStubs["xmlUCSIsCurrencySymbols"]=undefined;function _xmlUCSIsCypriotSyllabary(...args){return asyncifyStubs["xmlUCSIsCypriotSyllabary"](...args);}_xmlUCSIsCypriotSyllabary.stub=true;asyncifyStubs["xmlUCSIsCypriotSyllabary"]=undefined;function _xmlUCSIsCyrillic(...args){return asyncifyStubs["xmlUCSIsCyrillic"](...args);}_xmlUCSIsCyrillic.stub=true;asyncifyStubs["xmlUCSIsCyrillic"]=undefined;function _xmlUCSIsCyrillicSupplement(...args){return asyncifyStubs["xmlUCSIsCyrillicSupplement"](...args);}_xmlUCSIsCyrillicSupplement.stub=true;asyncifyStubs["xmlUCSIsCyrillicSupplement"]=undefined;function _xmlUCSIsDeseret(...args){return asyncifyStubs["xmlUCSIsDeseret"](...args);}_xmlUCSIsDeseret.stub=true;asyncifyStubs["xmlUCSIsDeseret"]=undefined;function _xmlUCSIsDevanagari(...args){return asyncifyStubs["xmlUCSIsDevanagari"](...args);}_xmlUCSIsDevanagari.stub=true;asyncifyStubs["xmlUCSIsDevanagari"]=undefined;function _xmlUCSIsDingbats(...args){return asyncifyStubs["xmlUCSIsDingbats"](...args);}_xmlUCSIsDingbats.stub=true;asyncifyStubs["xmlUCSIsDingbats"]=undefined;function _xmlUCSIsEnclosedAlphanumerics(...args){return asyncifyStubs["xmlUCSIsEnclosedAlphanumerics"](...args);}_xmlUCSIsEnclosedAlphanumerics.stub=true;asyncifyStubs["xmlUCSIsEnclosedAlphanumerics"]=undefined;function _xmlUCSIsEnclosedCJKLettersandMonths(...args){return asyncifyStubs["xmlUCSIsEnclosedCJKLettersandMonths"](...args);}_xmlUCSIsEnclosedCJKLettersandMonths.stub=true;asyncifyStubs["xmlUCSIsEnclosedCJKLettersandMonths"]=undefined;function _xmlUCSIsEthiopic(...args){return asyncifyStubs["xmlUCSIsEthiopic"](...args);}_xmlUCSIsEthiopic.stub=true;asyncifyStubs["xmlUCSIsEthiopic"]=undefined;function _xmlUCSIsGeneralPunctuation(...args){return asyncifyStubs["xmlUCSIsGeneralPunctuation"](...args);}_xmlUCSIsGeneralPunctuation.stub=true;asyncifyStubs["xmlUCSIsGeneralPunctuation"]=undefined;function _xmlUCSIsGeometricShapes(...args){return asyncifyStubs["xmlUCSIsGeometricShapes"](...args);}_xmlUCSIsGeometricShapes.stub=true;asyncifyStubs["xmlUCSIsGeometricShapes"]=undefined;function _xmlUCSIsGeorgian(...args){return asyncifyStubs["xmlUCSIsGeorgian"](...args);}_xmlUCSIsGeorgian.stub=true;asyncifyStubs["xmlUCSIsGeorgian"]=undefined;function _xmlUCSIsGothic(...args){return asyncifyStubs["xmlUCSIsGothic"](...args);}_xmlUCSIsGothic.stub=true;asyncifyStubs["xmlUCSIsGothic"]=undefined;function _xmlUCSIsGreek(...args){return asyncifyStubs["xmlUCSIsGreek"](...args);}_xmlUCSIsGreek.stub=true;asyncifyStubs["xmlUCSIsGreek"]=undefined;function _xmlUCSIsGreekExtended(...args){return asyncifyStubs["xmlUCSIsGreekExtended"](...args);}_xmlUCSIsGreekExtended.stub=true;asyncifyStubs["xmlUCSIsGreekExtended"]=undefined;function _xmlUCSIsGreekandCoptic(...args){return asyncifyStubs["xmlUCSIsGreekandCoptic"](...args);}_xmlUCSIsGreekandCoptic.stub=true;asyncifyStubs["xmlUCSIsGreekandCoptic"]=undefined;function _xmlUCSIsGujarati(...args){return asyncifyStubs["xmlUCSIsGujarati"](...args);}_xmlUCSIsGujarati.stub=true;asyncifyStubs["xmlUCSIsGujarati"]=undefined;function _xmlUCSIsGurmukhi(...args){return asyncifyStubs["xmlUCSIsGurmukhi"](...args);}_xmlUCSIsGurmukhi.stub=true;asyncifyStubs["xmlUCSIsGurmukhi"]=undefined;function _xmlUCSIsHalfwidthandFullwidthForms(...args){return asyncifyStubs["xmlUCSIsHalfwidthandFullwidthForms"](...args);}_xmlUCSIsHalfwidthandFullwidthForms.stub=true;asyncifyStubs["xmlUCSIsHalfwidthandFullwidthForms"]=undefined;function _xmlUCSIsHangulCompatibilityJamo(...args){return asyncifyStubs["xmlUCSIsHangulCompatibilityJamo"](...args);}_xmlUCSIsHangulCompatibilityJamo.stub=true;asyncifyStubs["xmlUCSIsHangulCompatibilityJamo"]=undefined;function _xmlUCSIsHangulJamo(...args){return asyncifyStubs["xmlUCSIsHangulJamo"](...args);}_xmlUCSIsHangulJamo.stub=true;asyncifyStubs["xmlUCSIsHangulJamo"]=undefined;function _xmlUCSIsHangulSyllables(...args){return asyncifyStubs["xmlUCSIsHangulSyllables"](...args);}_xmlUCSIsHangulSyllables.stub=true;asyncifyStubs["xmlUCSIsHangulSyllables"]=undefined;function _xmlUCSIsHanunoo(...args){return asyncifyStubs["xmlUCSIsHanunoo"](...args);}_xmlUCSIsHanunoo.stub=true;asyncifyStubs["xmlUCSIsHanunoo"]=undefined;function _xmlUCSIsHebrew(...args){return asyncifyStubs["xmlUCSIsHebrew"](...args);}_xmlUCSIsHebrew.stub=true;asyncifyStubs["xmlUCSIsHebrew"]=undefined;function _xmlUCSIsHighPrivateUseSurrogates(...args){return asyncifyStubs["xmlUCSIsHighPrivateUseSurrogates"](...args);}_xmlUCSIsHighPrivateUseSurrogates.stub=true;asyncifyStubs["xmlUCSIsHighPrivateUseSurrogates"]=undefined;function _xmlUCSIsHighSurrogates(...args){return asyncifyStubs["xmlUCSIsHighSurrogates"](...args);}_xmlUCSIsHighSurrogates.stub=true;asyncifyStubs["xmlUCSIsHighSurrogates"]=undefined;function _xmlUCSIsHiragana(...args){return asyncifyStubs["xmlUCSIsHiragana"](...args);}_xmlUCSIsHiragana.stub=true;asyncifyStubs["xmlUCSIsHiragana"]=undefined;function _xmlUCSIsIPAExtensions(...args){return asyncifyStubs["xmlUCSIsIPAExtensions"](...args);}_xmlUCSIsIPAExtensions.stub=true;asyncifyStubs["xmlUCSIsIPAExtensions"]=undefined;function _xmlUCSIsIdeographicDescriptionCharacters(...args){return asyncifyStubs["xmlUCSIsIdeographicDescriptionCharacters"](...args);}_xmlUCSIsIdeographicDescriptionCharacters.stub=true;asyncifyStubs["xmlUCSIsIdeographicDescriptionCharacters"]=undefined;function _xmlUCSIsKanbun(...args){return asyncifyStubs["xmlUCSIsKanbun"](...args);}_xmlUCSIsKanbun.stub=true;asyncifyStubs["xmlUCSIsKanbun"]=undefined;function _xmlUCSIsKangxiRadicals(...args){return asyncifyStubs["xmlUCSIsKangxiRadicals"](...args);}_xmlUCSIsKangxiRadicals.stub=true;asyncifyStubs["xmlUCSIsKangxiRadicals"]=undefined;function _xmlUCSIsKannada(...args){return asyncifyStubs["xmlUCSIsKannada"](...args);}_xmlUCSIsKannada.stub=true;asyncifyStubs["xmlUCSIsKannada"]=undefined;function _xmlUCSIsKatakana(...args){return asyncifyStubs["xmlUCSIsKatakana"](...args);}_xmlUCSIsKatakana.stub=true;asyncifyStubs["xmlUCSIsKatakana"]=undefined;function _xmlUCSIsKatakanaPhoneticExtensions(...args){return asyncifyStubs["xmlUCSIsKatakanaPhoneticExtensions"](...args);}_xmlUCSIsKatakanaPhoneticExtensions.stub=true;asyncifyStubs["xmlUCSIsKatakanaPhoneticExtensions"]=undefined;function _xmlUCSIsKhmer(...args){return asyncifyStubs["xmlUCSIsKhmer"](...args);}_xmlUCSIsKhmer.stub=true;asyncifyStubs["xmlUCSIsKhmer"]=undefined;function _xmlUCSIsKhmerSymbols(...args){return asyncifyStubs["xmlUCSIsKhmerSymbols"](...args);}_xmlUCSIsKhmerSymbols.stub=true;asyncifyStubs["xmlUCSIsKhmerSymbols"]=undefined;function _xmlUCSIsLao(...args){return asyncifyStubs["xmlUCSIsLao"](...args);}_xmlUCSIsLao.stub=true;asyncifyStubs["xmlUCSIsLao"]=undefined;function _xmlUCSIsLatin1Supplement(...args){return asyncifyStubs["xmlUCSIsLatin1Supplement"](...args);}_xmlUCSIsLatin1Supplement.stub=true;asyncifyStubs["xmlUCSIsLatin1Supplement"]=undefined;function _xmlUCSIsLatinExtendedA(...args){return asyncifyStubs["xmlUCSIsLatinExtendedA"](...args);}_xmlUCSIsLatinExtendedA.stub=true;asyncifyStubs["xmlUCSIsLatinExtendedA"]=undefined;function _xmlUCSIsLatinExtendedAdditional(...args){return asyncifyStubs["xmlUCSIsLatinExtendedAdditional"](...args);}_xmlUCSIsLatinExtendedAdditional.stub=true;asyncifyStubs["xmlUCSIsLatinExtendedAdditional"]=undefined;function _xmlUCSIsLatinExtendedB(...args){return asyncifyStubs["xmlUCSIsLatinExtendedB"](...args);}_xmlUCSIsLatinExtendedB.stub=true;asyncifyStubs["xmlUCSIsLatinExtendedB"]=undefined;function _xmlUCSIsLetterlikeSymbols(...args){return asyncifyStubs["xmlUCSIsLetterlikeSymbols"](...args);}_xmlUCSIsLetterlikeSymbols.stub=true;asyncifyStubs["xmlUCSIsLetterlikeSymbols"]=undefined;function _xmlUCSIsLimbu(...args){return asyncifyStubs["xmlUCSIsLimbu"](...args);}_xmlUCSIsLimbu.stub=true;asyncifyStubs["xmlUCSIsLimbu"]=undefined;function _xmlUCSIsLinearBIdeograms(...args){return asyncifyStubs["xmlUCSIsLinearBIdeograms"](...args);}_xmlUCSIsLinearBIdeograms.stub=true;asyncifyStubs["xmlUCSIsLinearBIdeograms"]=undefined;function _xmlUCSIsLinearBSyllabary(...args){return asyncifyStubs["xmlUCSIsLinearBSyllabary"](...args);}_xmlUCSIsLinearBSyllabary.stub=true;asyncifyStubs["xmlUCSIsLinearBSyllabary"]=undefined;function _xmlUCSIsLowSurrogates(...args){return asyncifyStubs["xmlUCSIsLowSurrogates"](...args);}_xmlUCSIsLowSurrogates.stub=true;asyncifyStubs["xmlUCSIsLowSurrogates"]=undefined;function _xmlUCSIsMalayalam(...args){return asyncifyStubs["xmlUCSIsMalayalam"](...args);}_xmlUCSIsMalayalam.stub=true;asyncifyStubs["xmlUCSIsMalayalam"]=undefined;function _xmlUCSIsMathematicalAlphanumericSymbols(...args){return asyncifyStubs["xmlUCSIsMathematicalAlphanumericSymbols"](...args);}_xmlUCSIsMathematicalAlphanumericSymbols.stub=true;asyncifyStubs["xmlUCSIsMathematicalAlphanumericSymbols"]=undefined;function _xmlUCSIsMathematicalOperators(...args){return asyncifyStubs["xmlUCSIsMathematicalOperators"](...args);}_xmlUCSIsMathematicalOperators.stub=true;asyncifyStubs["xmlUCSIsMathematicalOperators"]=undefined;function _xmlUCSIsMiscellaneousMathematicalSymbolsA(...args){return asyncifyStubs["xmlUCSIsMiscellaneousMathematicalSymbolsA"](...args);}_xmlUCSIsMiscellaneousMathematicalSymbolsA.stub=true;asyncifyStubs["xmlUCSIsMiscellaneousMathematicalSymbolsA"]=undefined;function _xmlUCSIsMiscellaneousMathematicalSymbolsB(...args){return asyncifyStubs["xmlUCSIsMiscellaneousMathematicalSymbolsB"](...args);}_xmlUCSIsMiscellaneousMathematicalSymbolsB.stub=true;asyncifyStubs["xmlUCSIsMiscellaneousMathematicalSymbolsB"]=undefined;function _xmlUCSIsMiscellaneousSymbols(...args){return asyncifyStubs["xmlUCSIsMiscellaneousSymbols"](...args);}_xmlUCSIsMiscellaneousSymbols.stub=true;asyncifyStubs["xmlUCSIsMiscellaneousSymbols"]=undefined;function _xmlUCSIsMiscellaneousSymbolsandArrows(...args){return asyncifyStubs["xmlUCSIsMiscellaneousSymbolsandArrows"](...args);}_xmlUCSIsMiscellaneousSymbolsandArrows.stub=true;asyncifyStubs["xmlUCSIsMiscellaneousSymbolsandArrows"]=undefined;function _xmlUCSIsMiscellaneousTechnical(...args){return asyncifyStubs["xmlUCSIsMiscellaneousTechnical"](...args);}_xmlUCSIsMiscellaneousTechnical.stub=true;asyncifyStubs["xmlUCSIsMiscellaneousTechnical"]=undefined;function _xmlUCSIsMongolian(...args){return asyncifyStubs["xmlUCSIsMongolian"](...args);}_xmlUCSIsMongolian.stub=true;asyncifyStubs["xmlUCSIsMongolian"]=undefined;function _xmlUCSIsMusicalSymbols(...args){return asyncifyStubs["xmlUCSIsMusicalSymbols"](...args);}_xmlUCSIsMusicalSymbols.stub=true;asyncifyStubs["xmlUCSIsMusicalSymbols"]=undefined;function _xmlUCSIsMyanmar(...args){return asyncifyStubs["xmlUCSIsMyanmar"](...args);}_xmlUCSIsMyanmar.stub=true;asyncifyStubs["xmlUCSIsMyanmar"]=undefined;function _xmlUCSIsNumberForms(...args){return asyncifyStubs["xmlUCSIsNumberForms"](...args);}_xmlUCSIsNumberForms.stub=true;asyncifyStubs["xmlUCSIsNumberForms"]=undefined;function _xmlUCSIsOgham(...args){return asyncifyStubs["xmlUCSIsOgham"](...args);}_xmlUCSIsOgham.stub=true;asyncifyStubs["xmlUCSIsOgham"]=undefined;function _xmlUCSIsOldItalic(...args){return asyncifyStubs["xmlUCSIsOldItalic"](...args);}_xmlUCSIsOldItalic.stub=true;asyncifyStubs["xmlUCSIsOldItalic"]=undefined;function _xmlUCSIsOpticalCharacterRecognition(...args){return asyncifyStubs["xmlUCSIsOpticalCharacterRecognition"](...args);}_xmlUCSIsOpticalCharacterRecognition.stub=true;asyncifyStubs["xmlUCSIsOpticalCharacterRecognition"]=undefined;function _xmlUCSIsOriya(...args){return asyncifyStubs["xmlUCSIsOriya"](...args);}_xmlUCSIsOriya.stub=true;asyncifyStubs["xmlUCSIsOriya"]=undefined;function _xmlUCSIsOsmanya(...args){return asyncifyStubs["xmlUCSIsOsmanya"](...args);}_xmlUCSIsOsmanya.stub=true;asyncifyStubs["xmlUCSIsOsmanya"]=undefined;function _xmlUCSIsPhoneticExtensions(...args){return asyncifyStubs["xmlUCSIsPhoneticExtensions"](...args);}_xmlUCSIsPhoneticExtensions.stub=true;asyncifyStubs["xmlUCSIsPhoneticExtensions"]=undefined;function _xmlUCSIsPrivateUse(...args){return asyncifyStubs["xmlUCSIsPrivateUse"](...args);}_xmlUCSIsPrivateUse.stub=true;asyncifyStubs["xmlUCSIsPrivateUse"]=undefined;function _xmlUCSIsPrivateUseArea(...args){return asyncifyStubs["xmlUCSIsPrivateUseArea"](...args);}_xmlUCSIsPrivateUseArea.stub=true;asyncifyStubs["xmlUCSIsPrivateUseArea"]=undefined;function _xmlUCSIsRunic(...args){return asyncifyStubs["xmlUCSIsRunic"](...args);}_xmlUCSIsRunic.stub=true;asyncifyStubs["xmlUCSIsRunic"]=undefined;function _xmlUCSIsShavian(...args){return asyncifyStubs["xmlUCSIsShavian"](...args);}_xmlUCSIsShavian.stub=true;asyncifyStubs["xmlUCSIsShavian"]=undefined;function _xmlUCSIsSinhala(...args){return asyncifyStubs["xmlUCSIsSinhala"](...args);}_xmlUCSIsSinhala.stub=true;asyncifyStubs["xmlUCSIsSinhala"]=undefined;function _xmlUCSIsSmallFormVariants(...args){return asyncifyStubs["xmlUCSIsSmallFormVariants"](...args);}_xmlUCSIsSmallFormVariants.stub=true;asyncifyStubs["xmlUCSIsSmallFormVariants"]=undefined;function _xmlUCSIsSpacingModifierLetters(...args){return asyncifyStubs["xmlUCSIsSpacingModifierLetters"](...args);}_xmlUCSIsSpacingModifierLetters.stub=true;asyncifyStubs["xmlUCSIsSpacingModifierLetters"]=undefined;function _xmlUCSIsSpecials(...args){return asyncifyStubs["xmlUCSIsSpecials"](...args);}_xmlUCSIsSpecials.stub=true;asyncifyStubs["xmlUCSIsSpecials"]=undefined;function _xmlUCSIsSuperscriptsandSubscripts(...args){return asyncifyStubs["xmlUCSIsSuperscriptsandSubscripts"](...args);}_xmlUCSIsSuperscriptsandSubscripts.stub=true;asyncifyStubs["xmlUCSIsSuperscriptsandSubscripts"]=undefined;function _xmlUCSIsSupplementalArrowsA(...args){return asyncifyStubs["xmlUCSIsSupplementalArrowsA"](...args);}_xmlUCSIsSupplementalArrowsA.stub=true;asyncifyStubs["xmlUCSIsSupplementalArrowsA"]=undefined;function _xmlUCSIsSupplementalArrowsB(...args){return asyncifyStubs["xmlUCSIsSupplementalArrowsB"](...args);}_xmlUCSIsSupplementalArrowsB.stub=true;asyncifyStubs["xmlUCSIsSupplementalArrowsB"]=undefined;function _xmlUCSIsSupplementalMathematicalOperators(...args){return asyncifyStubs["xmlUCSIsSupplementalMathematicalOperators"](...args);}_xmlUCSIsSupplementalMathematicalOperators.stub=true;asyncifyStubs["xmlUCSIsSupplementalMathematicalOperators"]=undefined;function _xmlUCSIsSupplementaryPrivateUseAreaA(...args){return asyncifyStubs["xmlUCSIsSupplementaryPrivateUseAreaA"](...args);}_xmlUCSIsSupplementaryPrivateUseAreaA.stub=true;asyncifyStubs["xmlUCSIsSupplementaryPrivateUseAreaA"]=undefined;function _xmlUCSIsSupplementaryPrivateUseAreaB(...args){return asyncifyStubs["xmlUCSIsSupplementaryPrivateUseAreaB"](...args);}_xmlUCSIsSupplementaryPrivateUseAreaB.stub=true;asyncifyStubs["xmlUCSIsSupplementaryPrivateUseAreaB"]=undefined;function _xmlUCSIsSyriac(...args){return asyncifyStubs["xmlUCSIsSyriac"](...args);}_xmlUCSIsSyriac.stub=true;asyncifyStubs["xmlUCSIsSyriac"]=undefined;function _xmlUCSIsTagalog(...args){return asyncifyStubs["xmlUCSIsTagalog"](...args);}_xmlUCSIsTagalog.stub=true;asyncifyStubs["xmlUCSIsTagalog"]=undefined;function _xmlUCSIsTagbanwa(...args){return asyncifyStubs["xmlUCSIsTagbanwa"](...args);}_xmlUCSIsTagbanwa.stub=true;asyncifyStubs["xmlUCSIsTagbanwa"]=undefined;function _xmlUCSIsTags(...args){return asyncifyStubs["xmlUCSIsTags"](...args);}_xmlUCSIsTags.stub=true;asyncifyStubs["xmlUCSIsTags"]=undefined;function _xmlUCSIsTaiLe(...args){return asyncifyStubs["xmlUCSIsTaiLe"](...args);}_xmlUCSIsTaiLe.stub=true;asyncifyStubs["xmlUCSIsTaiLe"]=undefined;function _xmlUCSIsTaiXuanJingSymbols(...args){return asyncifyStubs["xmlUCSIsTaiXuanJingSymbols"](...args);}_xmlUCSIsTaiXuanJingSymbols.stub=true;asyncifyStubs["xmlUCSIsTaiXuanJingSymbols"]=undefined;function _xmlUCSIsTamil(...args){return asyncifyStubs["xmlUCSIsTamil"](...args);}_xmlUCSIsTamil.stub=true;asyncifyStubs["xmlUCSIsTamil"]=undefined;function _xmlUCSIsTelugu(...args){return asyncifyStubs["xmlUCSIsTelugu"](...args);}_xmlUCSIsTelugu.stub=true;asyncifyStubs["xmlUCSIsTelugu"]=undefined;function _xmlUCSIsThaana(...args){return asyncifyStubs["xmlUCSIsThaana"](...args);}_xmlUCSIsThaana.stub=true;asyncifyStubs["xmlUCSIsThaana"]=undefined;function _xmlUCSIsThai(...args){return asyncifyStubs["xmlUCSIsThai"](...args);}_xmlUCSIsThai.stub=true;asyncifyStubs["xmlUCSIsThai"]=undefined;function _xmlUCSIsTibetan(...args){return asyncifyStubs["xmlUCSIsTibetan"](...args);}_xmlUCSIsTibetan.stub=true;asyncifyStubs["xmlUCSIsTibetan"]=undefined;function _xmlUCSIsUgaritic(...args){return asyncifyStubs["xmlUCSIsUgaritic"](...args);}_xmlUCSIsUgaritic.stub=true;asyncifyStubs["xmlUCSIsUgaritic"]=undefined;function _xmlUCSIsUnifiedCanadianAboriginalSyllabics(...args){return asyncifyStubs["xmlUCSIsUnifiedCanadianAboriginalSyllabics"](...args);}_xmlUCSIsUnifiedCanadianAboriginalSyllabics.stub=true;asyncifyStubs["xmlUCSIsUnifiedCanadianAboriginalSyllabics"]=undefined;function _xmlUCSIsVariationSelectors(...args){return asyncifyStubs["xmlUCSIsVariationSelectors"](...args);}_xmlUCSIsVariationSelectors.stub=true;asyncifyStubs["xmlUCSIsVariationSelectors"]=undefined;function _xmlUCSIsVariationSelectorsSupplement(...args){return asyncifyStubs["xmlUCSIsVariationSelectorsSupplement"](...args);}_xmlUCSIsVariationSelectorsSupplement.stub=true;asyncifyStubs["xmlUCSIsVariationSelectorsSupplement"]=undefined;function _xmlUCSIsYiRadicals(...args){return asyncifyStubs["xmlUCSIsYiRadicals"](...args);}_xmlUCSIsYiRadicals.stub=true;asyncifyStubs["xmlUCSIsYiRadicals"]=undefined;function _xmlUCSIsYiSyllables(...args){return asyncifyStubs["xmlUCSIsYiSyllables"](...args);}_xmlUCSIsYiSyllables.stub=true;asyncifyStubs["xmlUCSIsYiSyllables"]=undefined;function _xmlUCSIsYijingHexagramSymbols(...args){return asyncifyStubs["xmlUCSIsYijingHexagramSymbols"](...args);}_xmlUCSIsYijingHexagramSymbols.stub=true;asyncifyStubs["xmlUCSIsYijingHexagramSymbols"]=undefined;function _xmlURIUnescapeString(...args){return asyncifyStubs["xmlURIUnescapeString"](...args);}_xmlURIUnescapeString.stub=true;asyncifyStubs["xmlURIUnescapeString"]=undefined;function _xmlUnlinkNode(...args){return asyncifyStubs["xmlUnlinkNode"](...args);}_xmlUnlinkNode.stub=true;asyncifyStubs["xmlUnlinkNode"]=undefined;function _xmlXPathBooleanFunction(...args){return asyncifyStubs["xmlXPathBooleanFunction"](...args);}_xmlXPathBooleanFunction.stub=true;asyncifyStubs["xmlXPathBooleanFunction"]=undefined;function _xmlXPathCeilingFunction(...args){return asyncifyStubs["xmlXPathCeilingFunction"](...args);}_xmlXPathCeilingFunction.stub=true;asyncifyStubs["xmlXPathCeilingFunction"]=undefined;function _xmlXPathConcatFunction(...args){return asyncifyStubs["xmlXPathConcatFunction"](...args);}_xmlXPathConcatFunction.stub=true;asyncifyStubs["xmlXPathConcatFunction"]=undefined;function _xmlXPathContainsFunction(...args){return asyncifyStubs["xmlXPathContainsFunction"](...args);}_xmlXPathContainsFunction.stub=true;asyncifyStubs["xmlXPathContainsFunction"]=undefined;function _xmlXPathCountFunction(...args){return asyncifyStubs["xmlXPathCountFunction"](...args);}_xmlXPathCountFunction.stub=true;asyncifyStubs["xmlXPathCountFunction"]=undefined;function _xmlXPathFalseFunction(...args){return asyncifyStubs["xmlXPathFalseFunction"](...args);}_xmlXPathFalseFunction.stub=true;asyncifyStubs["xmlXPathFalseFunction"]=undefined;function _xmlXPathFloorFunction(...args){return asyncifyStubs["xmlXPathFloorFunction"](...args);}_xmlXPathFloorFunction.stub=true;asyncifyStubs["xmlXPathFloorFunction"]=undefined;function _xmlXPathIdFunction(...args){return asyncifyStubs["xmlXPathIdFunction"](...args);}_xmlXPathIdFunction.stub=true;asyncifyStubs["xmlXPathIdFunction"]=undefined;function _xmlXPathLangFunction(...args){return asyncifyStubs["xmlXPathLangFunction"](...args);}_xmlXPathLangFunction.stub=true;asyncifyStubs["xmlXPathLangFunction"]=undefined;function _xmlXPathLastFunction(...args){return asyncifyStubs["xmlXPathLastFunction"](...args);}_xmlXPathLastFunction.stub=true;asyncifyStubs["xmlXPathLastFunction"]=undefined;function _xmlXPathLocalNameFunction(...args){return asyncifyStubs["xmlXPathLocalNameFunction"](...args);}_xmlXPathLocalNameFunction.stub=true;asyncifyStubs["xmlXPathLocalNameFunction"]=undefined;function _xmlXPathNAN(...args){return asyncifyStubs["xmlXPathNAN"](...args);}_xmlXPathNAN.stub=true;asyncifyStubs["xmlXPathNAN"]=undefined;function _xmlXPathNINF(...args){return asyncifyStubs["xmlXPathNINF"](...args);}_xmlXPathNINF.stub=true;asyncifyStubs["xmlXPathNINF"]=undefined;function _xmlXPathNamespaceURIFunction(...args){return asyncifyStubs["xmlXPathNamespaceURIFunction"](...args);}_xmlXPathNamespaceURIFunction.stub=true;asyncifyStubs["xmlXPathNamespaceURIFunction"]=undefined;function _xmlXPathNextAncestor(...args){return asyncifyStubs["xmlXPathNextAncestor"](...args);}_xmlXPathNextAncestor.stub=true;asyncifyStubs["xmlXPathNextAncestor"]=undefined;function _xmlXPathNextAncestorOrSelf(...args){return asyncifyStubs["xmlXPathNextAncestorOrSelf"](...args);}_xmlXPathNextAncestorOrSelf.stub=true;asyncifyStubs["xmlXPathNextAncestorOrSelf"]=undefined;function _xmlXPathNextAttribute(...args){return asyncifyStubs["xmlXPathNextAttribute"](...args);}_xmlXPathNextAttribute.stub=true;asyncifyStubs["xmlXPathNextAttribute"]=undefined;function _xmlXPathNextChild(...args){return asyncifyStubs["xmlXPathNextChild"](...args);}_xmlXPathNextChild.stub=true;asyncifyStubs["xmlXPathNextChild"]=undefined;function _xmlXPathNextDescendant(...args){return asyncifyStubs["xmlXPathNextDescendant"](...args);}_xmlXPathNextDescendant.stub=true;asyncifyStubs["xmlXPathNextDescendant"]=undefined;function _xmlXPathNextDescendantOrSelf(...args){return asyncifyStubs["xmlXPathNextDescendantOrSelf"](...args);}_xmlXPathNextDescendantOrSelf.stub=true;asyncifyStubs["xmlXPathNextDescendantOrSelf"]=undefined;function _xmlXPathNextFollowing(...args){return asyncifyStubs["xmlXPathNextFollowing"](...args);}_xmlXPathNextFollowing.stub=true;asyncifyStubs["xmlXPathNextFollowing"]=undefined;function _xmlXPathNextFollowingSibling(...args){return asyncifyStubs["xmlXPathNextFollowingSibling"](...args);}_xmlXPathNextFollowingSibling.stub=true;asyncifyStubs["xmlXPathNextFollowingSibling"]=undefined;function _xmlXPathNextNamespace(...args){return asyncifyStubs["xmlXPathNextNamespace"](...args);}_xmlXPathNextNamespace.stub=true;asyncifyStubs["xmlXPathNextNamespace"]=undefined;function _xmlXPathNextParent(...args){return asyncifyStubs["xmlXPathNextParent"](...args);}_xmlXPathNextParent.stub=true;asyncifyStubs["xmlXPathNextParent"]=undefined;function _xmlXPathNextPrecedingSibling(...args){return asyncifyStubs["xmlXPathNextPrecedingSibling"](...args);}_xmlXPathNextPrecedingSibling.stub=true;asyncifyStubs["xmlXPathNextPrecedingSibling"]=undefined;function _xmlXPathNextSelf(...args){return asyncifyStubs["xmlXPathNextSelf"](...args);}_xmlXPathNextSelf.stub=true;asyncifyStubs["xmlXPathNextSelf"]=undefined;function _xmlXPathNormalizeFunction(...args){return asyncifyStubs["xmlXPathNormalizeFunction"](...args);}_xmlXPathNormalizeFunction.stub=true;asyncifyStubs["xmlXPathNormalizeFunction"]=undefined;function _xmlXPathNotFunction(...args){return asyncifyStubs["xmlXPathNotFunction"](...args);}_xmlXPathNotFunction.stub=true;asyncifyStubs["xmlXPathNotFunction"]=undefined;function _xmlXPathNumberFunction(...args){return asyncifyStubs["xmlXPathNumberFunction"](...args);}_xmlXPathNumberFunction.stub=true;asyncifyStubs["xmlXPathNumberFunction"]=undefined;function _xmlXPathPINF(...args){return asyncifyStubs["xmlXPathPINF"](...args);}_xmlXPathPINF.stub=true;asyncifyStubs["xmlXPathPINF"]=undefined;function _xmlXPathPositionFunction(...args){return asyncifyStubs["xmlXPathPositionFunction"](...args);}_xmlXPathPositionFunction.stub=true;asyncifyStubs["xmlXPathPositionFunction"]=undefined;function _xmlXPathRoundFunction(...args){return asyncifyStubs["xmlXPathRoundFunction"](...args);}_xmlXPathRoundFunction.stub=true;asyncifyStubs["xmlXPathRoundFunction"]=undefined;function _xmlXPathStartsWithFunction(...args){return asyncifyStubs["xmlXPathStartsWithFunction"](...args);}_xmlXPathStartsWithFunction.stub=true;asyncifyStubs["xmlXPathStartsWithFunction"]=undefined;function _xmlXPathStringFunction(...args){return asyncifyStubs["xmlXPathStringFunction"](...args);}_xmlXPathStringFunction.stub=true;asyncifyStubs["xmlXPathStringFunction"]=undefined;function _xmlXPathStringLengthFunction(...args){return asyncifyStubs["xmlXPathStringLengthFunction"](...args);}_xmlXPathStringLengthFunction.stub=true;asyncifyStubs["xmlXPathStringLengthFunction"]=undefined;function _xmlXPathSubstringAfterFunction(...args){return asyncifyStubs["xmlXPathSubstringAfterFunction"](...args);}_xmlXPathSubstringAfterFunction.stub=true;asyncifyStubs["xmlXPathSubstringAfterFunction"]=undefined;function _xmlXPathSubstringBeforeFunction(...args){return asyncifyStubs["xmlXPathSubstringBeforeFunction"](...args);}_xmlXPathSubstringBeforeFunction.stub=true;asyncifyStubs["xmlXPathSubstringBeforeFunction"]=undefined;function _xmlXPathSubstringFunction(...args){return asyncifyStubs["xmlXPathSubstringFunction"](...args);}_xmlXPathSubstringFunction.stub=true;asyncifyStubs["xmlXPathSubstringFunction"]=undefined;function _xmlXPathSumFunction(...args){return asyncifyStubs["xmlXPathSumFunction"](...args);}_xmlXPathSumFunction.stub=true;asyncifyStubs["xmlXPathSumFunction"]=undefined;function _xmlXPathTranslateFunction(...args){return asyncifyStubs["xmlXPathTranslateFunction"](...args);}_xmlXPathTranslateFunction.stub=true;asyncifyStubs["xmlXPathTranslateFunction"]=undefined;function _xmlXPathTrueFunction(...args){return asyncifyStubs["xmlXPathTrueFunction"](...args);}_xmlXPathTrueFunction.stub=true;asyncifyStubs["xmlXPathTrueFunction"]=undefined;var runAndAbortIfError=func=>{try{return func();}catch(e){abort(e);}};var Asyncify={instrumentWasmImports(imports){var importPattern=/^(invoke_.*|__asyncjs__.*)$/;for(let[x,original]of Object.entries(imports)){if(typeof original=="function"){let isAsyncifyImport=original.isAsync||importPattern.test(x);}}},instrumentWasmExports(exports){var ret={};for(let[x,original]of Object.entries(exports)){if(typeof original=="function"){ret[x]=(...args)=>{Asyncify.exportCallStack.push(x);try{return original(...args);}finally{if(!ABORT){var y=Asyncify.exportCallStack.pop();Asyncify.maybeStopUnwind();}}};ret[x].orig=original;}else{ret[x]=original;}}return ret;},State:{Normal:0,Unwinding:1,Rewinding:2,Disabled:3},state:0,StackSize:4096,currData:null,handleSleepReturnValue:0,exportCallStack:[],callStackNameToId:{},callStackIdToName:{},callStackId:0,asyncPromiseHandlers:null,sleepCallbacks:[],getCallStackId(funcName){var id=Asyncify.callStackNameToId[funcName];if(id===undefined){id=Asyncify.callStackId++;Asyncify.callStackNameToId[funcName]=id;Asyncify.callStackIdToName[id]=funcName;}return id;},maybeStopUnwind(){if(Asyncify.currData&&Asyncify.state===Asyncify.State.Unwinding&&Asyncify.exportCallStack.length===0){// We just finished unwinding.
// Be sure to set the state before calling any other functions to avoid
// possible infinite recursion here (For example in debug pthread builds
// the dbg() function itself can call back into WebAssembly to get the
// current pthread_self() pointer).
Asyncify.state=Asyncify.State.Normal;runtimeKeepalivePush();// Keep the runtime alive so that a re-wind can be done later.
runAndAbortIfError(_asyncify_stop_unwind);if(typeof Fibers!="undefined"){Fibers.trampoline();}}},whenDone(){return new Promise((resolve,reject)=>{Asyncify.asyncPromiseHandlers={resolve,reject};});},allocateData(){// An asyncify data structure has three fields:
//  0  current stack pos
//  4  max stack pos
//  8  id of function at bottom of the call stack (callStackIdToName[id] == name of js function)
// The Asyncify ABI only interprets the first two fields, the rest is for the runtime.
// We also embed a stack in the same memory region here, right next to the structure.
// This struct is also defined as asyncify_data_t in emscripten/fiber.h
var ptr=_malloc(12+Asyncify.StackSize);Asyncify.setDataHeader(ptr,ptr+12,Asyncify.StackSize);Asyncify.setDataRewindFunc(ptr);return ptr;},setDataHeader(ptr,stack,stackSize){HEAPU32[ptr>>>2>>>0]=stack;HEAPU32[ptr+4>>>2>>>0]=stack+stackSize;},setDataRewindFunc(ptr){var bottomOfCallStack=Asyncify.exportCallStack[0];var rewindId=Asyncify.getCallStackId(bottomOfCallStack);HEAP32[ptr+8>>>2>>>0]=rewindId;},getDataRewindFuncName(ptr){var id=HEAP32[ptr+8>>>2>>>0];var name=Asyncify.callStackIdToName[id];return name;},getDataRewindFunc__deps:["$resolveGlobalSymbol"],getDataRewindFunc(name){var func=wasmExports[name];// Exported functions in side modules are not listed in `wasmExports`,
// So we should use `resolveGlobalSymbol` helper function, which is defined in `library_dylink.js`.
if(!func){func=resolveGlobalSymbol(name,false).sym;}return func;},doRewind(ptr){var name=Asyncify.getDataRewindFuncName(ptr);var func=Asyncify.getDataRewindFunc(name);// Once we have rewound and the stack we no longer need to artificially
// keep the runtime alive.
runtimeKeepalivePop();return func();},handleSleep(startAsync){if(ABORT)return;if(Asyncify.state===Asyncify.State.Normal){// Prepare to sleep. Call startAsync, and see what happens:
// if the code decided to call our callback synchronously,
// then no async operation was in fact begun, and we don't
// need to do anything.
var reachedCallback=false;var reachedAfterCallback=false;startAsync((handleSleepReturnValue=0)=>{if(ABORT)return;Asyncify.handleSleepReturnValue=handleSleepReturnValue;reachedCallback=true;if(!reachedAfterCallback){// We are happening synchronously, so no need for async.
return;}Asyncify.state=Asyncify.State.Rewinding;runAndAbortIfError(()=>_asyncify_start_rewind(Asyncify.currData));if(typeof Browser!="undefined"&&Browser.mainLoop.func){Browser.mainLoop.resume();}var asyncWasmReturnValue,isError=false;try{asyncWasmReturnValue=Asyncify.doRewind(Asyncify.currData);}catch(err){asyncWasmReturnValue=err;isError=true;}// Track whether the return value was handled by any promise handlers.
var handled=false;if(!Asyncify.currData){// All asynchronous execution has finished.
// `asyncWasmReturnValue` now contains the final
// return value of the exported async WASM function.
// Note: `asyncWasmReturnValue` is distinct from
// `Asyncify.handleSleepReturnValue`.
// `Asyncify.handleSleepReturnValue` contains the return
// value of the last C function to have executed
// `Asyncify.handleSleep()`, where as `asyncWasmReturnValue`
// contains the return value of the exported WASM function
// that may have called C functions that
// call `Asyncify.handleSleep()`.
var asyncPromiseHandlers=Asyncify.asyncPromiseHandlers;if(asyncPromiseHandlers){Asyncify.asyncPromiseHandlers=null;(isError?asyncPromiseHandlers.reject:asyncPromiseHandlers.resolve)(asyncWasmReturnValue);handled=true;}}if(isError&&!handled){// If there was an error and it was not handled by now, we have no choice but to
// rethrow that error into the global scope where it can be caught only by
// `onerror` or `onunhandledpromiserejection`.
throw asyncWasmReturnValue;}});reachedAfterCallback=true;if(!reachedCallback){// A true async operation was begun; start a sleep.
Asyncify.state=Asyncify.State.Unwinding;// TODO: reuse, don't alloc/free every sleep
Asyncify.currData=Asyncify.allocateData();if(typeof Browser!="undefined"&&Browser.mainLoop.func){Browser.mainLoop.pause();}runAndAbortIfError(()=>_asyncify_start_unwind(Asyncify.currData));}}else if(Asyncify.state===Asyncify.State.Rewinding){// Stop a resume.
Asyncify.state=Asyncify.State.Normal;runAndAbortIfError(_asyncify_stop_rewind);_free(Asyncify.currData);Asyncify.currData=null;// Call all sleep callbacks now that the sleep-resume is all done.
Asyncify.sleepCallbacks.forEach(callUserCallback);}else{abort(`invalid state: ${Asyncify.state}`);}return Asyncify.handleSleepReturnValue;},handleAsync(startAsync){return Asyncify.handleSleep(wakeUp=>{// TODO: add error handling as a second param when handleSleep implements it.
startAsync().then(wakeUp);});}};var getCFunc=ident=>{var func=Module["_"+ident];// closure exported function
return func;};var writeArrayToMemory=(array,buffer)=>{HEAP8.set(array,buffer>>>0);};/**
     * @param {string|null=} returnType
     * @param {Array=} argTypes
     * @param {Arguments|Array=} args
     * @param {Object=} opts
     */var ccall=(ident,returnType,argTypes,args,opts)=>{// For fast lookup of conversion functions
var toC={"string":str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){// null string
ret=stringToUTF8OnStack(str);}return ret;},"array":arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret;}};function convertReturnValue(ret){if(returnType==="string"){return UTF8ToString(ret);}if(returnType==="boolean")return Boolean(ret);return ret;}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i]);}else{cArgs[i]=args[i];}}}// Data for a previous async operation that was in flight before us.
var previousAsync=Asyncify.currData;var ret=func(...cArgs);function onDone(ret){runtimeKeepalivePop();if(stack!==0)stackRestore(stack);return convertReturnValue(ret);}var asyncMode=opts?.async;// Keep the runtime alive through all calls. Note that this call might not be
// async, but for simplicity we push and pop in all calls.
runtimeKeepalivePush();if(Asyncify.currData!=previousAsync){// This is a new async operation. The wasm is paused and has unwound its stack.
// We need to return a Promise that resolves the return value
// once the stack is rewound and execution finishes.
return Asyncify.whenDone().then(onDone);}ret=onDone(ret);// If this is an async ccall, ensure we return a promise
if(asyncMode)return Promise.resolve(ret);return ret;};var FS_createPath=FS.createPath;var FS_unlink=path=>FS.unlink(path);var FS_createLazyFile=FS.createLazyFile;var FS_createDevice=FS.createDevice;var writeI53ToI64Clamped=(ptr,num)=>{if(num>0x8000000000000000){HEAPU32[ptr>>>2>>>0]=4294967295;HEAPU32[ptr+4>>>2>>>0]=2147483647;}else if(num<-0x8000000000000000){HEAPU32[ptr>>>2>>>0]=0;HEAPU32[ptr+4>>>2>>>0]=2147483648;}else{writeI53ToI64(ptr,num);}};var writeI53ToI64Signaling=(ptr,num)=>{if(num>0x8000000000000000||num<-0x8000000000000000){throw`RangeError: ${num}`;}writeI53ToI64(ptr,num);};var writeI53ToU64Clamped=(ptr,num)=>{if(num>0x10000000000000000){HEAPU32[ptr>>>2>>>0]=4294967295;HEAPU32[ptr+4>>>2>>>0]=4294967295;}else if(num<0){HEAPU32[ptr>>>2>>>0]=0;HEAPU32[ptr+4>>>2>>>0]=0;}else{writeI53ToI64(ptr,num);}};var writeI53ToU64Signaling=(ptr,num)=>{if(num<0||num>0x10000000000000000){throw`RangeError: ${num}`;}writeI53ToI64(ptr,num);};var readI53FromU64=ptr=>HEAPU32[ptr>>>2>>>0]+HEAPU32[ptr+4>>>2>>>0]*4294967296;var convertI32PairToI53=(lo,hi)=>(lo>>>0)+hi*4294967296;var convertU32PairToI53=(lo,hi)=>(lo>>>0)+(hi>>>0)*4294967296;var getTempRet0=val=>__emscripten_tempret_get();var _stackAlloc=stackAlloc;var _stackSave=stackSave;var _stackRestore=stackSave;var ptrToString=ptr=>"0x"+ptr.toString(16).padStart(8,"0");function _emscripten_notify_memory_growth(memoryIndex){memoryIndex>>>=0;updateMemoryViews();}_emscripten_notify_memory_growth.sig="vp";var withStackSave=f=>{var stack=stackSave();var ret=f();stackRestore(stack);return ret;};var ERRNO_CODES={"EPERM":63,"ENOENT":44,"ESRCH":71,"EINTR":27,"EIO":29,"ENXIO":60,"E2BIG":1,"ENOEXEC":45,"EBADF":8,"ECHILD":12,"EAGAIN":6,"EWOULDBLOCK":6,"ENOMEM":48,"EACCES":2,"EFAULT":21,"ENOTBLK":105,"EBUSY":10,"EEXIST":20,"EXDEV":75,"ENODEV":43,"ENOTDIR":54,"EISDIR":31,"EINVAL":28,"ENFILE":41,"EMFILE":33,"ENOTTY":59,"ETXTBSY":74,"EFBIG":22,"ENOSPC":51,"ESPIPE":70,"EROFS":69,"EMLINK":34,"EPIPE":64,"EDOM":18,"ERANGE":68,"ENOMSG":49,"EIDRM":24,"ECHRNG":106,"EL2NSYNC":156,"EL3HLT":107,"EL3RST":108,"ELNRNG":109,"EUNATCH":110,"ENOCSI":111,"EL2HLT":112,"EDEADLK":16,"ENOLCK":46,"EBADE":113,"EBADR":114,"EXFULL":115,"ENOANO":104,"EBADRQC":103,"EBADSLT":102,"EDEADLOCK":16,"EBFONT":101,"ENOSTR":100,"ENODATA":116,"ETIME":117,"ENOSR":118,"ENONET":119,"ENOPKG":120,"EREMOTE":121,"ENOLINK":47,"EADV":122,"ESRMNT":123,"ECOMM":124,"EPROTO":65,"EMULTIHOP":36,"EDOTDOT":125,"EBADMSG":9,"ENOTUNIQ":126,"EBADFD":127,"EREMCHG":128,"ELIBACC":129,"ELIBBAD":130,"ELIBSCN":131,"ELIBMAX":132,"ELIBEXEC":133,"ENOSYS":52,"ENOTEMPTY":55,"ENAMETOOLONG":37,"ELOOP":32,"EOPNOTSUPP":138,"EPFNOSUPPORT":139,"ECONNRESET":15,"ENOBUFS":42,"EAFNOSUPPORT":5,"EPROTOTYPE":67,"ENOTSOCK":57,"ENOPROTOOPT":50,"ESHUTDOWN":140,"ECONNREFUSED":14,"EADDRINUSE":3,"ECONNABORTED":13,"ENETUNREACH":40,"ENETDOWN":38,"ETIMEDOUT":73,"EHOSTDOWN":142,"EHOSTUNREACH":23,"EINPROGRESS":26,"EALREADY":7,"EDESTADDRREQ":17,"EMSGSIZE":35,"EPROTONOSUPPORT":66,"ESOCKTNOSUPPORT":137,"EADDRNOTAVAIL":4,"ENETRESET":39,"EISCONN":30,"ENOTCONN":53,"ETOOMANYREFS":141,"EUSERS":136,"EDQUOT":19,"ESTALE":72,"ENOTSUP":138,"ENOMEDIUM":148,"EILSEQ":25,"EOVERFLOW":61,"ECANCELED":11,"ENOTRECOVERABLE":56,"EOWNERDEAD":62,"ESTRPIPE":135};var strError=errno=>UTF8ToString(_strerror(errno));var _endprotoent=()=>{};// void endprotoent(void);
// We're not using a real protocol database so we don't do a real close.
_endprotoent.sig="v";function _getprotoent(number){// struct protoent *getprotoent(void);
// reads the  next  entry  from  the  protocols 'database' or return NULL if 'eof'
if(_setprotoent.index===Protocols.list.length){return 0;}var result=Protocols.list[_setprotoent.index++];return result;}_getprotoent.sig="p";function _emscripten_run_script(ptr){ptr>>>=0;eval(UTF8ToString(ptr));}_emscripten_run_script.sig="vp";/** @suppress{checkTypes} */function _emscripten_run_script_int(ptr){ptr>>>=0;return eval(UTF8ToString(ptr))|0;}_emscripten_run_script_int.sig="ip";function _emscripten_run_script_string(ptr){ptr>>>=0;var s=eval(UTF8ToString(ptr));if(s==null){return 0;}s+="";var me=_emscripten_run_script_string;var len=lengthBytesUTF8(s);if(!me.bufferSize||me.bufferSize<len+1){if(me.bufferSize)_free(me.buffer);me.bufferSize=len+1;me.buffer=_malloc(me.bufferSize);}stringToUTF8(s,me.buffer,me.bufferSize);return me.buffer;}_emscripten_run_script_string.sig="pp";var _emscripten_random=()=>Math.random();_emscripten_random.sig="f";function jsStackTrace(){return new Error().stack.toString();}/** @param {number=} flags */function getCallstack(flags){var callstack=jsStackTrace();// Find the symbols in the callstack that corresponds to the functions that
// report callstack information, and remove everything up to these from the
// output.
var iThisFunc=callstack.lastIndexOf("_emscripten_log");var iThisFunc2=callstack.lastIndexOf("_emscripten_get_callstack");var iNextLine=callstack.indexOf("\n",Math.max(iThisFunc,iThisFunc2))+1;callstack=callstack.slice(iNextLine);// If user requested to see the original source stack, but no source map
// information is available, just fall back to showing the JS stack.
if(flags&8&&typeof emscripten_source_map=="undefined"){warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');flags^=8;flags|=16;}// Process all lines:
var lines=callstack.split("\n");callstack="";// New FF30 with column info: extract components of form:
// '       Object._main@http://server.com:4324:12'
var newFirefoxRe=new RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)");// Old FF without column info: extract components of form:
// '       Object._main@http://server.com:4324'
var firefoxRe=new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?");// Extract components of form:
// '    at Object._main (http://server.com/file.html:4324:12)'
var chromeRe=new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)");for(var l in lines){var line=lines[l];var symbolName="";var file="";var lineno=0;var column=0;var parts=chromeRe.exec(line);if(parts&&parts.length==5){symbolName=parts[1];file=parts[2];lineno=parts[3];column=parts[4];}else{parts=newFirefoxRe.exec(line)||firefoxRe.exec(line);if(parts&&parts.length>=4){symbolName=parts[1];file=parts[2];lineno=parts[3];// Old Firefox doesn't carry column information, but in new FF30, it
// is present. See https://bugzilla.mozilla.org/show_bug.cgi?id=762556
column=parts[4]|0;}else{// Was not able to extract this line for demangling/sourcemapping
// purposes. Output it as-is.
callstack+=line+"\n";continue;}}var haveSourceMap=false;if(flags&8){var orig=emscripten_source_map.originalPositionFor({line:lineno,column});haveSourceMap=orig?.source;if(haveSourceMap){if(flags&64){orig.source=orig.source.substring(orig.source.replace(/\\/g,"/").lastIndexOf("/")+1);}callstack+=`    at ${symbolName} (${orig.source}:${orig.line}:${orig.column})\n`;}}if(flags&16||!haveSourceMap){if(flags&64){file=file.substring(file.replace(/\\/g,"/").lastIndexOf("/")+1);}callstack+=(haveSourceMap?`     = ${symbolName}`:`    at ${symbolName}`)+` (${file}:${lineno}:${column})\n`;}}// Trim extra whitespace at the end of the output.
callstack=callstack.replace(/\s+$/,"");return callstack;}var emscriptenLog=(flags,str)=>{if(flags&24){str=str.replace(/\s+$/,"");// Ensure the message and the callstack are joined cleanly with exactly one newline.
str+=(str.length>0?"\n":"")+getCallstack(flags);}if(flags&1){if(flags&4){console.error(str);}else if(flags&2){console.warn(str);}else if(flags&512){console.info(str);}else if(flags&256){console.debug(str);}else{console.log(str);}}else if(flags&6){err(str);}else{out(str);}};var reallyNegative=x=>x<0||x===0&&1/x===-Infinity;var reSign=(value,bits)=>{if(value<=0){return value;}var half=bits<=32?Math.abs(1<<bits-1):// abs is needed if bits == 32
Math.pow(2,bits-1);// for huge values, we can hit the precision limit and always get true here.
// so don't do that but, in general there is no perfect solution here. With
// 64-bit ints, we get rounding and errors
// TODO: In i64 mode 1, resign the two parts separately and safely
if(value>=half&&(bits<=32||value>half)){// Cannot bitshift half, as it may be at the limit of the bits JS uses in
// bitshifts
value=-2*half+value;}return value;};var unSign=(value,bits)=>{if(value>=0){return value;}// Need some trickery, since if bits == 32, we are right at the limit of the
// bits JS uses in bitshifts
return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value;};var strLen=ptr=>{var end=ptr;while(HEAPU8[end>>>0])++end;return end-ptr;};var formatString=(format,varargs)=>{var textIndex=format;var argIndex=varargs;// This must be called before reading a double or i64 vararg. It will bump the pointer properly.
// It also does an assert on i32 values, so it's nice to call it before all varargs calls.
function prepVararg(ptr,type){if(type==="double"||type==="i64"){// move so the load is aligned
if(ptr&7){ptr+=4;}}else{}return ptr;}function getNextArg(type){// NOTE: Explicitly ignoring type safety. Otherwise this fails:
//       int x = 4; printf("%c\n", (char)x);
var ret;argIndex=prepVararg(argIndex,type);if(type==="double"){ret=HEAPF64[argIndex>>>3>>>0];argIndex+=8;}else if(type=="i64"){ret=[HEAP32[argIndex>>>2>>>0],HEAP32[argIndex+4>>>2>>>0]];argIndex+=8;}else{type="i32";// varargs are always i32, i64, or double
ret=HEAP32[argIndex>>>2>>>0];argIndex+=4;}return ret;}var ret=[];var curr,next,currArg;while(1){var startTextIndex=textIndex;curr=HEAP8[textIndex>>>0];if(curr===0)break;next=HEAP8[textIndex+1>>>0];if(curr==37){// Handle flags.
var flagAlwaysSigned=false;var flagLeftAlign=false;var flagAlternative=false;var flagZeroPad=false;var flagPadSign=false;flagsLoop:while(1){switch(next){case 43:flagAlwaysSigned=true;break;case 45:flagLeftAlign=true;break;case 35:flagAlternative=true;break;case 48:if(flagZeroPad){break flagsLoop;}else{flagZeroPad=true;break;}case 32:flagPadSign=true;break;default:break flagsLoop;}textIndex++;next=HEAP8[textIndex+1>>>0];}// Handle width.
var width=0;if(next==42){width=getNextArg("i32");textIndex++;next=HEAP8[textIndex+1>>>0];}else{while(next>=48&&next<=57){width=width*10+(next-48);textIndex++;next=HEAP8[textIndex+1>>>0];}}// Handle precision.
var precisionSet=false,precision=-1;if(next==46){precision=0;precisionSet=true;textIndex++;next=HEAP8[textIndex+1>>>0];if(next==42){precision=getNextArg("i32");textIndex++;}else{while(1){var precisionChr=HEAP8[textIndex+1>>>0];if(precisionChr<48||precisionChr>57)break;precision=precision*10+(precisionChr-48);textIndex++;}}next=HEAP8[textIndex+1>>>0];}if(precision<0){precision=6;// Standard default.
precisionSet=false;}// Handle integer sizes. WARNING: These assume a 32-bit architecture!
var argSize;switch(String.fromCharCode(next)){case"h":var nextNext=HEAP8[textIndex+2>>>0];if(nextNext==104){textIndex++;argSize=1;}else// char (actually i32 in varargs)
{argSize=2;}// short (actually i32 in varargs)
break;case"l":var nextNext=HEAP8[textIndex+2>>>0];if(nextNext==108){textIndex++;argSize=8;}else// long long
{argSize=4;}// long
break;case"L":// long long
case"q":// int64_t
case"j":// intmax_t
argSize=8;break;case"z":// size_t
case"t":// ptrdiff_t
case"I":// signed ptrdiff_t or unsigned size_t
argSize=4;break;default:argSize=null;}if(argSize)textIndex++;next=HEAP8[textIndex+1>>>0];// Handle type specifier.
switch(String.fromCharCode(next)){case"d":case"i":case"u":case"o":case"x":case"X":case"p":{// Integer.
var signed=next==100||next==105;argSize=argSize||4;currArg=getNextArg("i"+argSize*8);var argText;// Flatten i64-1 [low, high] into a (slightly rounded) double
if(argSize==8){currArg=next==117?convertU32PairToI53(currArg[0],currArg[1]):convertI32PairToI53(currArg[0],currArg[1]);}// Truncate to requested size.
if(argSize<=4){var limit=Math.pow(256,argSize)-1;currArg=(signed?reSign:unSign)(currArg&limit,argSize*8);}// Format the number.
var currAbsArg=Math.abs(currArg);var prefix="";if(next==100||next==105){argText=reSign(currArg,8*argSize).toString(10);}else if(next==117){argText=unSign(currArg,8*argSize).toString(10);currArg=Math.abs(currArg);}else if(next==111){argText=(flagAlternative?"0":"")+currAbsArg.toString(8);}else if(next==120||next==88){prefix=flagAlternative&&currArg!=0?"0x":"";if(currArg<0){// Represent negative numbers in hex as 2's complement.
currArg=-currArg;argText=(currAbsArg-1).toString(16);var buffer=[];for(var i=0;i<argText.length;i++){buffer.push((15-parseInt(argText[i],16)).toString(16));}argText=buffer.join("");while(argText.length<argSize*2)argText="f"+argText;}else{argText=currAbsArg.toString(16);}if(next==88){prefix=prefix.toUpperCase();argText=argText.toUpperCase();}}else if(next==112){if(currAbsArg===0){argText="(nil)";}else{prefix="0x";argText=currAbsArg.toString(16);}}if(precisionSet){while(argText.length<precision){argText="0"+argText;}}// Add sign if needed
if(currArg>=0){if(flagAlwaysSigned){prefix="+"+prefix;}else if(flagPadSign){prefix=" "+prefix;}}// Move sign to prefix so we zero-pad after the sign
if(argText.charAt(0)=="-"){prefix="-"+prefix;argText=argText.substr(1);}// Add padding.
while(prefix.length+argText.length<width){if(flagLeftAlign){argText+=" ";}else{if(flagZeroPad){argText="0"+argText;}else{prefix=" "+prefix;}}}// Insert the result into the buffer.
argText=prefix+argText;argText.split("").forEach(chr=>ret.push(chr.charCodeAt(0)));break;}case"f":case"F":case"e":case"E":case"g":case"G":{// Float.
currArg=getNextArg("double");var argText;if(isNaN(currArg)){argText="nan";flagZeroPad=false;}else if(!isFinite(currArg)){argText=(currArg<0?"-":"")+"inf";flagZeroPad=false;}else{var isGeneral=false;var effectivePrecision=Math.min(precision,20);// Convert g/G to f/F or e/E, as per:
// http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
if(next==103||next==71){isGeneral=true;precision=precision||1;var exponent=parseInt(currArg.toExponential(effectivePrecision).split("e")[1],10);if(precision>exponent&&exponent>=-4){next=(next==103?"f":"F").charCodeAt(0);precision-=exponent+1;}else{next=(next==103?"e":"E").charCodeAt(0);precision--;}effectivePrecision=Math.min(precision,20);}if(next==101||next==69){argText=currArg.toExponential(effectivePrecision);// Make sure the exponent has at least 2 digits.
if(/[eE][-+]\d$/.test(argText)){argText=argText.slice(0,-1)+"0"+argText.slice(-1);}}else if(next==102||next==70){argText=currArg.toFixed(effectivePrecision);if(currArg===0&&reallyNegative(currArg)){argText="-"+argText;}}var parts=argText.split("e");if(isGeneral&&!flagAlternative){// Discard trailing zeros and periods.
while(parts[0].length>1&&parts[0].includes(".")&&(parts[0].slice(-1)=="0"||parts[0].slice(-1)==".")){parts[0]=parts[0].slice(0,-1);}}else{// Make sure we have a period in alternative mode.
if(flagAlternative&&argText.indexOf(".")==-1)parts[0]+=".";// Zero pad until required precision.
while(precision>effectivePrecision++)parts[0]+="0";}argText=parts[0]+(parts.length>1?"e"+parts[1]:"");// Capitalize 'E' if needed.
if(next==69)argText=argText.toUpperCase();// Add sign.
if(currArg>=0){if(flagAlwaysSigned){argText="+"+argText;}else if(flagPadSign){argText=" "+argText;}}}// Add padding.
while(argText.length<width){if(flagLeftAlign){argText+=" ";}else{if(flagZeroPad&&(argText[0]=="-"||argText[0]=="+")){argText=argText[0]+"0"+argText.slice(1);}else{argText=(flagZeroPad?"0":" ")+argText;}}}// Adjust case.
if(next<97)argText=argText.toUpperCase();// Insert the result into the buffer.
argText.split("").forEach(chr=>ret.push(chr.charCodeAt(0)));break;}case"s":{// String.
var arg=getNextArg("i8*");var argLength=arg?strLen(arg):"(null)".length;if(precisionSet)argLength=Math.min(argLength,precision);if(!flagLeftAlign){while(argLength<width--){ret.push(32);}}if(arg){for(var i=0;i<argLength;i++){ret.push(HEAPU8[arg++>>>0]);}}else{ret=ret.concat(intArrayFromString("(null)".substr(0,argLength),true));}if(flagLeftAlign){while(argLength<width--){ret.push(32);}}break;}case"c":{// Character.
if(flagLeftAlign)ret.push(getNextArg("i8"));while(--width>0){ret.push(32);}if(!flagLeftAlign)ret.push(getNextArg("i8"));break;}case"n":{// Write the length written so far to the next parameter.
var ptr=getNextArg("i32*");HEAP32[ptr>>>2>>>0]=ret.length;break;}case"%":{// Literal percent sign.
ret.push(curr);break;}default:{// Unknown specifiers remain untouched.
for(var i=startTextIndex;i<textIndex+2;i++){ret.push(HEAP8[i>>>0]);}}}textIndex+=2;}else// TODO: Support a/A (hex float) and m (last error) specifiers.
// TODO: Support %1${specifier} for arg selection.
{ret.push(curr);textIndex+=1;}}return ret;};function _emscripten_log(flags,format,varargs){format>>>=0;varargs>>>=0;var result=formatString(format,varargs);var str=UTF8ArrayToString(result,0);emscriptenLog(flags,str);}_emscripten_log.sig="vipp";function _emscripten_get_compiler_setting(name){name>>>=0;throw"You must build with -sRETAIN_COMPILER_SETTINGS for getCompilerSetting or emscripten_get_compiler_setting to work";}_emscripten_get_compiler_setting.sig="pp";var _emscripten_has_asyncify=()=>1;_emscripten_has_asyncify.sig="i";function _emscripten_debugger(){debugger;}_emscripten_debugger.sig="v";function _emscripten_print_double(x,to,max){to>>>=0;var str=x+"";if(to)return stringToUTF8(str,to,max);else return lengthBytesUTF8(str);}_emscripten_print_double.sig="idpi";function _emscripten_asm_const_double(code,sigPtr,argbuf){code>>>=0;sigPtr>>>=0;argbuf>>>=0;return runEmAsmFunction(code,sigPtr,argbuf);}_emscripten_asm_const_double.sig="dppp";var runMainThreadEmAsm=(emAsmAddr,sigPtr,argbuf,sync)=>{var args=readEmAsmArgs(sigPtr,argbuf);return ASM_CONSTS[emAsmAddr](...args);};function _emscripten_asm_const_int_sync_on_main_thread(emAsmAddr,sigPtr,argbuf){emAsmAddr>>>=0;sigPtr>>>=0;argbuf>>>=0;return runMainThreadEmAsm(emAsmAddr,sigPtr,argbuf,1);}_emscripten_asm_const_int_sync_on_main_thread.sig="ippp";function _emscripten_asm_const_ptr_sync_on_main_thread(emAsmAddr,sigPtr,argbuf){emAsmAddr>>>=0;sigPtr>>>=0;argbuf>>>=0;return runMainThreadEmAsm(emAsmAddr,sigPtr,argbuf,1);}_emscripten_asm_const_ptr_sync_on_main_thread.sig="pppp";var _emscripten_asm_const_double_sync_on_main_thread=_emscripten_asm_const_int_sync_on_main_thread;_emscripten_asm_const_double_sync_on_main_thread.sig="dppp";function _emscripten_asm_const_async_on_main_thread(emAsmAddr,sigPtr,argbuf){emAsmAddr>>>=0;sigPtr>>>=0;argbuf>>>=0;return runMainThreadEmAsm(emAsmAddr,sigPtr,argbuf,0);}_emscripten_asm_const_async_on_main_thread.sig="vppp";var jstoi_s=Number;var __Unwind_Backtrace=function(func,arg){func>>>=0;arg>>>=0;var trace=getCallstack();var parts=trace.split("\n");for(var i=0;i<parts.length;i++){var ret=((a1,a2)=>{})(/* a dynamic function call to signature iii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */0,arg);if(ret!==0)return;}};__Unwind_Backtrace.sig="ipp";function __Unwind_GetIPInfo(context,ipBefore){context>>>=0;ipBefore>>>=0;return abort("Unwind_GetIPInfo");}__Unwind_GetIPInfo.sig="ppp";function __Unwind_FindEnclosingFunction(ip){ip>>>=0;return 0;}__Unwind_FindEnclosingFunction.sig="pp";class ExceptionInfo{// excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.
constructor(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;}set_type(type){HEAPU32[this.ptr+4>>>2>>>0]=type;}get_type(){return HEAPU32[this.ptr+4>>>2>>>0];}set_destructor(destructor){HEAPU32[this.ptr+8>>>2>>>0]=destructor;}get_destructor(){return HEAPU32[this.ptr+8>>>2>>>0];}set_caught(caught){caught=caught?1:0;HEAP8[this.ptr+12>>>0]=caught;}get_caught(){return HEAP8[this.ptr+12>>>0]!=0;}set_rethrown(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>>0]=rethrown;}get_rethrown(){return HEAP8[this.ptr+13>>>0]!=0;}// Initialize native structure fields. Should be called once after allocated.
init(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);}set_adjusted_ptr(adjustedPtr){HEAPU32[this.ptr+16>>>2>>>0]=adjustedPtr;}get_adjusted_ptr(){return HEAPU32[this.ptr+16>>>2>>>0];}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){ptr>>>=0;type>>>=0;destructor>>>=0;var info=new ExceptionInfo(ptr);// Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.
info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast;}___cxa_throw.sig="vppp";function __Unwind_RaiseException(ex){ex>>>=0;err("Warning: _Unwind_RaiseException is not correctly implemented");return ___cxa_throw(ex,0,0);}__Unwind_RaiseException.sig="ip";function __Unwind_DeleteException(ex){ex>>>=0;err("TODO: Unwind_DeleteException");}__Unwind_DeleteException.sig="vp";var getDynCaller=(sig,ptr)=>(...args)=>dynCall(sig,ptr,args);var _emscripten_exit_with_live_runtime=()=>{runtimeKeepalivePush();throw"unwind";};_emscripten_exit_with_live_runtime.sig="v";var _emscripten_force_exit=status=>{__emscripten_runtime_keepalive_clear();_exit(status);};_emscripten_force_exit.sig="vi";function _emscripten_outn(str,len){str>>>=0;len>>>=0;return out(UTF8ToString(str,len));}_emscripten_outn.sig="vpp";function _emscripten_errn(str,len){str>>>=0;len>>>=0;return err(UTF8ToString(str,len));}_emscripten_errn.sig="vpp";var _emscripten_throw_number=number=>{throw number;};_emscripten_throw_number.sig="vd";function _emscripten_throw_string(str){str>>>=0;throw UTF8ToString(str);}_emscripten_throw_string.sig="vp";var _emscripten_runtime_keepalive_push=runtimeKeepalivePush;_emscripten_runtime_keepalive_push.sig="v";var _emscripten_runtime_keepalive_pop=runtimeKeepalivePop;_emscripten_runtime_keepalive_pop.sig="v";var _emscripten_runtime_keepalive_check=keepRuntimeAlive;_emscripten_runtime_keepalive_check.sig="i";var asmjsMangle=x=>{if(x=="__main_argc_argv"){x="main";}return x.startsWith("dynCall_")?x:"_"+x;};var ___global_base=1024;function __emscripten_fs_load_embedded_files(ptr){ptr>>>=0;do{var name_addr=HEAPU32[ptr>>>2>>>0];ptr+=4;var len=HEAPU32[ptr>>>2>>>0];ptr+=4;var content=HEAPU32[ptr>>>2>>>0];ptr+=4;var name=UTF8ToString(name_addr);FS.createPath("/",PATH.dirname(name),true,true);// canOwn this data in the filesystem, it is a slice of wasm memory that will never change
FS.createDataFile(name,null,HEAP8.subarray(content>>>0,content+len>>>0),true,true,true);}while(HEAPU32[ptr>>>2>>>0]);}__emscripten_fs_load_embedded_files.sig="vp";var POINTER_SIZE=4;function getNativeTypeSize(type){// prettier-ignore
switch(type){case"i1":case"i8":case"u8":return 1;case"i16":case"u16":return 2;case"i32":case"u32":return 4;case"i64":case"u64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return POINTER_SIZE;}if(type[0]==="i"){const bits=Number(type.substr(1));assert(bits%8===0,`getNativeTypeSize invalid bits ${bits}, ${type} type`);return bits/8;}return 0;}}}var STACK_SIZE=33554432;var STACK_ALIGN=16;var ASSERTIONS=0;/**
     * @param {string=} returnType
     * @param {Array=} argTypes
     * @param {Object=} opts
     */var cwrap=(ident,returnType,argTypes,opts)=>{// When the function takes numbers and returns a number, we can just return
// the original function
var numericArgs=!argTypes||argTypes.every(type=>type==="number"||type==="boolean");var numericRet=returnType!=="string";if(numericRet&&numericArgs&&!opts){return getCFunc(ident);}return(...args)=>ccall(ident,returnType,argTypes,args,opts);};var removeFunction=index=>{functionsInTableMap.delete(getWasmTableEntry(index));setWasmTableEntry(index,null);freeTableIndexes.push(index);};var _emscripten_math_cbrt=Math.cbrt;_emscripten_math_cbrt.sig="dd";var _emscripten_math_pow=Math.pow;_emscripten_math_pow.sig="ddd";var _emscripten_math_random=Math.random;_emscripten_math_random.sig="d";var _emscripten_math_sign=Math.sign;_emscripten_math_sign.sig="dd";var _emscripten_math_sqrt=Math.sqrt;_emscripten_math_sqrt.sig="dd";var _emscripten_math_exp=Math.exp;_emscripten_math_exp.sig="dd";var _emscripten_math_expm1=Math.expm1;_emscripten_math_expm1.sig="dd";var _emscripten_math_fmod=(x,y)=>x%y;_emscripten_math_fmod.sig="ddd";var _emscripten_math_log=Math.log;_emscripten_math_log.sig="dd";var _emscripten_math_log1p=Math.log1p;_emscripten_math_log1p.sig="dd";var _emscripten_math_log10=Math.log10;_emscripten_math_log10.sig="dd";var _emscripten_math_log2=Math.log2;_emscripten_math_log2.sig="dd";var _emscripten_math_round=Math.round;_emscripten_math_round.sig="dd";var _emscripten_math_acos=Math.acos;_emscripten_math_acos.sig="dd";var _emscripten_math_acosh=Math.acosh;_emscripten_math_acosh.sig="dd";var _emscripten_math_asin=Math.asin;_emscripten_math_asin.sig="dd";var _emscripten_math_asinh=Math.asinh;_emscripten_math_asinh.sig="dd";var _emscripten_math_atan=Math.atan;_emscripten_math_atan.sig="dd";var _emscripten_math_atanh=Math.atanh;_emscripten_math_atanh.sig="dd";var _emscripten_math_atan2=Math.atan2;_emscripten_math_atan2.sig="ddd";var _emscripten_math_cos=Math.cos;_emscripten_math_cos.sig="dd";var _emscripten_math_cosh=Math.cosh;_emscripten_math_cosh.sig="dd";function _emscripten_math_hypot(count,varargs){varargs>>>=0;var args=[];for(var i=0;i<count;++i){args.push(HEAPF64[varargs+i*8>>>3>>>0]);}return Math.hypot(...args);}_emscripten_math_hypot.sig="dip";var _emscripten_math_sin=Math.sin;_emscripten_math_sin.sig="dd";var _emscripten_math_sinh=Math.sinh;_emscripten_math_sinh.sig="dd";var _emscripten_math_tan=Math.tan;_emscripten_math_tan.sig="dd";var _emscripten_math_tanh=Math.tanh;_emscripten_math_tanh.sig="dd";function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255;}ret.push(String.fromCharCode(chr));}return ret.join("");}var AsciiToString=ptr=>{ptr>>>=0;var str="";while(1){var ch=HEAPU8[ptr++>>>0];if(!ch)return str;str+=String.fromCharCode(ch);}};var UTF16Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf-16le"):undefined;var UTF16ToString=(ptr,maxBytesToRead)=>{var endPtr=ptr;// TextDecoder needs to know the byte length in advance, it doesn't stop on
// null terminator by itself.
// Also, use the length info to avoid running tiny strings through
// TextDecoder, since .subarray() allocates garbage.
var idx=endPtr>>1;var maxIdx=idx+maxBytesToRead/2;// If maxBytesToRead is not passed explicitly, it will be undefined, and this
// will always evaluate to true. This saves on code size.
while(!(idx>=maxIdx)&&HEAPU16[idx>>>0])++idx;endPtr=idx<<1;if(endPtr-ptr>32&&UTF16Decoder)return UTF16Decoder.decode(HEAPU8.subarray(ptr>>>0,endPtr>>>0));// Fallback: decode without UTF16Decoder
var str="";// If maxBytesToRead is not passed explicitly, it will be undefined, and the
// for-loop's condition will always evaluate to true. The loop is then
// terminated on the first null char.
for(var i=0;!(i>=maxBytesToRead/2);++i){var codeUnit=HEAP16[ptr+i*2>>>1>>>0];if(codeUnit==0)break;// fromCharCode constructs a character from a UTF-16 code unit, so we can
// pass the UTF16 string right through.
str+=String.fromCharCode(codeUnit);}return str;};var stringToUTF16=(str,outPtr,maxBytesToWrite)=>{// Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
maxBytesToWrite??=2147483647;if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;// Null terminator.
var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){// charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
var codeUnit=str.charCodeAt(i);// possibly a lead surrogate
HEAP16[outPtr>>>1>>>0]=codeUnit;outPtr+=2;}// Null-terminate the pointer to the HEAP.
HEAP16[outPtr>>>1>>>0]=0;return outPtr-startPtr;};var lengthBytesUTF16=str=>str.length*2;var UTF32ToString=(ptr,maxBytesToRead)=>{var i=0;var str="";// If maxBytesToRead is not passed explicitly, it will be undefined, and this
// will always evaluate to true. This saves on code size.
while(!(i>=maxBytesToRead/4)){var utf32=HEAP32[ptr+i*4>>>2>>>0];if(utf32==0)break;++i;// Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
// See http://unicode.org/faq/utf_bom.html#utf16-3
if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}else{str+=String.fromCharCode(utf32);}}return str;};var stringToUTF32=(str,outPtr,maxBytesToWrite)=>{outPtr>>>=0;// Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
maxBytesToWrite??=2147483647;if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){// Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
// See http://unicode.org/faq/utf_bom.html#utf16-3
var codeUnit=str.charCodeAt(i);// possibly a lead surrogate
if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++i);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023;}HEAP32[outPtr>>>2>>>0]=codeUnit;outPtr+=4;if(outPtr+4>endPtr)break;}// Null-terminate the pointer to the HEAP.
HEAP32[outPtr>>>2>>>0]=0;return outPtr-startPtr;};var lengthBytesUTF32=str=>{var len=0;for(var i=0;i<str.length;++i){// Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
// See http://unicode.org/faq/utf_bom.html#utf16-3
var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343)++i;// possibly a lead surrogate, so skip over the tail surrogate.
len+=4;}return len;};var JSEvents={removeAllEventListeners(){while(JSEvents.eventHandlers.length){JSEvents._removeHandler(JSEvents.eventHandlers.length-1);}JSEvents.deferredCalls=[];},registerRemoveEventListeners(){if(!JSEvents.removeEventListenersRegistered){__ATEXIT__.push(JSEvents.removeAllEventListeners);JSEvents.removeEventListenersRegistered=true;}},inEventHandler:0,deferredCalls:[],deferCall(targetFunction,precedence,argsList){function arraysHaveEqualContent(arrA,arrB){if(arrA.length!=arrB.length)return false;for(var i in arrA){if(arrA[i]!=arrB[i])return false;}return true;}// Test if the given call was already queued, and if so, don't add it again.
for(var call of JSEvents.deferredCalls){if(call.targetFunction==targetFunction&&arraysHaveEqualContent(call.argsList,argsList)){return;}}JSEvents.deferredCalls.push({targetFunction,precedence,argsList});JSEvents.deferredCalls.sort((x,y)=>x.precedence<y.precedence);},removeDeferredCalls(targetFunction){JSEvents.deferredCalls=JSEvents.deferredCalls.filter(call=>call.targetFunction!=targetFunction);},canPerformEventHandlerRequests(){if(navigator.userActivation){// Verify against transient activation status from UserActivation API
// whether it is possible to perform a request here without needing to defer. See
// https://developer.mozilla.org/en-US/docs/Web/Security/User_activation#transient_activation
// and https://caniuse.com/mdn-api_useractivation
// At the time of writing, Firefox does not support this API: https://bugzilla.mozilla.org/show_bug.cgi?id=1791079
return navigator.userActivation.isActive;}return JSEvents.inEventHandler&&JSEvents.currentEventHandler.allowsDeferredCalls;},runDeferredCalls(){if(!JSEvents.canPerformEventHandlerRequests()){return;}var deferredCalls=JSEvents.deferredCalls;JSEvents.deferredCalls=[];for(var call of deferredCalls){call.targetFunction(...call.argsList);}},eventHandlers:[],removeAllHandlersOnTarget:(target,eventTypeString)=>{for(var i=0;i<JSEvents.eventHandlers.length;++i){if(JSEvents.eventHandlers[i].target==target&&(!eventTypeString||eventTypeString==JSEvents.eventHandlers[i].eventTypeString)){JSEvents._removeHandler(i--);}}},_removeHandler(i){var h=JSEvents.eventHandlers[i];h.target.removeEventListener(h.eventTypeString,h.eventListenerFunc,h.useCapture);JSEvents.eventHandlers.splice(i,1);},registerOrRemoveHandler(eventHandler){if(!eventHandler.target){return-4;}if(eventHandler.callbackfunc){eventHandler.eventListenerFunc=function(event){// Increment nesting count for the event handler.
++JSEvents.inEventHandler;JSEvents.currentEventHandler=eventHandler;// Process any old deferred calls the user has placed.
JSEvents.runDeferredCalls();// Process the actual event, calls back to user C code handler.
eventHandler.handlerFunc(event);// Process any new deferred calls that were placed right now from this event handler.
JSEvents.runDeferredCalls();// Out of event handler - restore nesting count.
--JSEvents.inEventHandler;};eventHandler.target.addEventListener(eventHandler.eventTypeString,eventHandler.eventListenerFunc,eventHandler.useCapture);JSEvents.eventHandlers.push(eventHandler);JSEvents.registerRemoveEventListeners();}else{for(var i=0;i<JSEvents.eventHandlers.length;++i){if(JSEvents.eventHandlers[i].target==eventHandler.target&&JSEvents.eventHandlers[i].eventTypeString==eventHandler.eventTypeString){JSEvents._removeHandler(i--);}}}return 0;},getNodeNameForTarget(target){if(!target)return"";if(target==window)return"#window";if(target==screen)return"#screen";return target?.nodeName||"";},fullscreenEnabled(){return document.fullscreenEnabled||// Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitFullscreenEnabled.
// TODO: If Safari at some point ships with unprefixed version, update the version check above.
document.webkitFullscreenEnabled;}};var maybeCStringToJsString=cString=>cString>2?UTF8ToString(cString):cString;/** @type {Object} */var specialHTMLTargets=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];var findEventTarget=target=>{target=maybeCStringToJsString(target);var domElement=specialHTMLTargets[target]||(typeof document!="undefined"?document.querySelector(target):undefined);return domElement;};var registerKeyEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.keyEvent||=_malloc(160);var keyEventHandlerFunc=e=>{var keyEventData=JSEvents.keyEvent;HEAPF64[keyEventData>>>3>>>0]=e.timeStamp;var idx=keyEventData>>>2;HEAP32[idx+2>>>0]=e.location;HEAP8[keyEventData+12>>>0]=e.ctrlKey;HEAP8[keyEventData+13>>>0]=e.shiftKey;HEAP8[keyEventData+14>>>0]=e.altKey;HEAP8[keyEventData+15>>>0]=e.metaKey;HEAP8[keyEventData+16>>>0]=e.repeat;HEAP32[idx+5>>>0]=e.charCode;HEAP32[idx+6>>>0]=e.keyCode;HEAP32[idx+7>>>0]=e.which;stringToUTF8(e.key||"",keyEventData+32,32);stringToUTF8(e.code||"",keyEventData+64,32);stringToUTF8(e.char||"",keyEventData+96,32);stringToUTF8(e.locale||"",keyEventData+128,32);if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,keyEventData,userData))e.preventDefault();};var eventHandler={target:findEventTarget(target),eventTypeString,callbackfunc,handlerFunc:keyEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};var findCanvasEventTarget=findEventTarget;function _emscripten_set_keypress_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerKeyEventCallback(target,userData,useCapture,callbackfunc,1,"keypress",targetThread);}_emscripten_set_keypress_callback_on_thread.sig="ippipp";function _emscripten_set_keydown_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerKeyEventCallback(target,userData,useCapture,callbackfunc,2,"keydown",targetThread);}_emscripten_set_keydown_callback_on_thread.sig="ippipp";function _emscripten_set_keyup_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerKeyEventCallback(target,userData,useCapture,callbackfunc,3,"keyup",targetThread);}_emscripten_set_keyup_callback_on_thread.sig="ippipp";var getBoundingClientRect=e=>specialHTMLTargets.indexOf(e)<0?e.getBoundingClientRect():{"left":0,"top":0};var fillMouseEventData=(eventStruct,e,target)=>{HEAPF64[eventStruct>>>3>>>0]=e.timeStamp;var idx=eventStruct>>>2;HEAP32[idx+2>>>0]=e.screenX;HEAP32[idx+3>>>0]=e.screenY;HEAP32[idx+4>>>0]=e.clientX;HEAP32[idx+5>>>0]=e.clientY;HEAP8[eventStruct+24>>>0]=e.ctrlKey;HEAP8[eventStruct+25>>>0]=e.shiftKey;HEAP8[eventStruct+26>>>0]=e.altKey;HEAP8[eventStruct+27>>>0]=e.metaKey;HEAP16[idx*2+14>>>0]=e.button;HEAP16[idx*2+15>>>0]=e.buttons;HEAP32[idx+8>>>0]=e["movementX"];HEAP32[idx+9>>>0]=e["movementY"];// Note: rect contains doubles (truncated to placate SAFE_HEAP, which is the same behaviour when writing to HEAP32 anyway)
var rect=getBoundingClientRect(target);HEAP32[idx+10>>>0]=e.clientX-(rect.left|0);HEAP32[idx+11>>>0]=e.clientY-(rect.top|0);};var registerMouseEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.mouseEvent||=_malloc(64);target=findEventTarget(target);var mouseEventHandlerFunc=(e=event)=>{// TODO: Make this access thread safe, or this could update live while app is reading it.
fillMouseEventData(JSEvents.mouseEvent,e,target);if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,JSEvents.mouseEvent,userData))e.preventDefault();};var eventHandler={target,allowsDeferredCalls:eventTypeString!="mousemove"&&eventTypeString!="mouseenter"&&eventTypeString!="mouseleave",// Mouse move events do not allow fullscreen/pointer lock requests to be handled in them!
eventTypeString,callbackfunc,handlerFunc:mouseEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_click_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerMouseEventCallback(target,userData,useCapture,callbackfunc,4,"click",targetThread);}_emscripten_set_click_callback_on_thread.sig="ippipp";function _emscripten_set_mousedown_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerMouseEventCallback(target,userData,useCapture,callbackfunc,5,"mousedown",targetThread);}_emscripten_set_mousedown_callback_on_thread.sig="ippipp";function _emscripten_set_mouseup_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerMouseEventCallback(target,userData,useCapture,callbackfunc,6,"mouseup",targetThread);}_emscripten_set_mouseup_callback_on_thread.sig="ippipp";function _emscripten_set_dblclick_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerMouseEventCallback(target,userData,useCapture,callbackfunc,7,"dblclick",targetThread);}_emscripten_set_dblclick_callback_on_thread.sig="ippipp";function _emscripten_set_mousemove_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerMouseEventCallback(target,userData,useCapture,callbackfunc,8,"mousemove",targetThread);}_emscripten_set_mousemove_callback_on_thread.sig="ippipp";function _emscripten_set_mouseenter_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerMouseEventCallback(target,userData,useCapture,callbackfunc,33,"mouseenter",targetThread);}_emscripten_set_mouseenter_callback_on_thread.sig="ippipp";function _emscripten_set_mouseleave_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerMouseEventCallback(target,userData,useCapture,callbackfunc,34,"mouseleave",targetThread);}_emscripten_set_mouseleave_callback_on_thread.sig="ippipp";function _emscripten_set_mouseover_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerMouseEventCallback(target,userData,useCapture,callbackfunc,35,"mouseover",targetThread);}_emscripten_set_mouseover_callback_on_thread.sig="ippipp";function _emscripten_set_mouseout_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerMouseEventCallback(target,userData,useCapture,callbackfunc,36,"mouseout",targetThread);}_emscripten_set_mouseout_callback_on_thread.sig="ippipp";function _emscripten_get_mouse_status(mouseState){mouseState>>>=0;if(!JSEvents.mouseEvent)return-7;// HTML5 does not really have a polling API for mouse events, so implement one manually by
// returning the data from the most recently received event. This requires that user has registered
// at least some no-op function as an event handler to any of the mouse function.
HEAP8.set(HEAP8.subarray(JSEvents.mouseEvent>>>0,JSEvents.mouseEvent+64>>>0),mouseState>>>0);return 0;}_emscripten_get_mouse_status.sig="ip";var registerWheelEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.wheelEvent||=_malloc(96);// The DOM Level 3 events spec event 'wheel'
var wheelHandlerFunc=(e=event)=>{var wheelEvent=JSEvents.wheelEvent;fillMouseEventData(wheelEvent,e,target);HEAPF64[wheelEvent+64>>>3>>>0]=e["deltaX"];HEAPF64[wheelEvent+72>>>3>>>0]=e["deltaY"];HEAPF64[wheelEvent+80>>>3>>>0]=e["deltaZ"];HEAP32[wheelEvent+88>>>2>>>0]=e["deltaMode"];if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,wheelEvent,userData))e.preventDefault();};var eventHandler={target,allowsDeferredCalls:true,eventTypeString,callbackfunc,handlerFunc:wheelHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_wheel_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;target=findEventTarget(target);if(!target)return-4;if(typeof target.onwheel!="undefined"){return registerWheelEventCallback(target,userData,useCapture,callbackfunc,9,"wheel",targetThread);}else{return-1;}}_emscripten_set_wheel_callback_on_thread.sig="ippipp";var registerUiEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.uiEvent||=_malloc(36);target=findEventTarget(target);var uiEventHandlerFunc=(e=event)=>{if(e.target!=target){// Never take ui events such as scroll via a 'bubbled' route, but always from the direct element that
// was targeted. Otherwise e.g. if app logs a message in response to a page scroll, the Emscripten log
// message box could cause to scroll, generating a new (bubbled) scroll message, causing a new log print,
// causing a new scroll, etc..
return;}var b=document.body;// Take document.body to a variable, Closure compiler does not outline access to it on its own.
if(!b){// During a page unload 'body' can be null, with "Cannot read property 'clientWidth' of null" being thrown
return;}var uiEvent=JSEvents.uiEvent;HEAP32[uiEvent>>>2>>>0]=0;// always zero for resize and scroll
HEAP32[uiEvent+4>>>2>>>0]=b.clientWidth;HEAP32[uiEvent+8>>>2>>>0]=b.clientHeight;HEAP32[uiEvent+12>>>2>>>0]=innerWidth;HEAP32[uiEvent+16>>>2>>>0]=innerHeight;HEAP32[uiEvent+20>>>2>>>0]=outerWidth;HEAP32[uiEvent+24>>>2>>>0]=outerHeight;HEAP32[uiEvent+28>>>2>>>0]=pageXOffset|0;// scroll offsets are float
HEAP32[uiEvent+32>>>2>>>0]=pageYOffset|0;if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,uiEvent,userData))e.preventDefault();};var eventHandler={target,eventTypeString,callbackfunc,handlerFunc:uiEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_resize_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerUiEventCallback(target,userData,useCapture,callbackfunc,10,"resize",targetThread);}_emscripten_set_resize_callback_on_thread.sig="ippipp";function _emscripten_set_scroll_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerUiEventCallback(target,userData,useCapture,callbackfunc,11,"scroll",targetThread);}_emscripten_set_scroll_callback_on_thread.sig="ippipp";var registerFocusEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.focusEvent||=_malloc(256);var focusEventHandlerFunc=(e=event)=>{var nodeName=JSEvents.getNodeNameForTarget(e.target);var id=e.target.id?e.target.id:"";var focusEvent=JSEvents.focusEvent;stringToUTF8(nodeName,focusEvent+0,128);stringToUTF8(id,focusEvent+128,128);if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,focusEvent,userData))e.preventDefault();};var eventHandler={target:findEventTarget(target),eventTypeString,callbackfunc,handlerFunc:focusEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_blur_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerFocusEventCallback(target,userData,useCapture,callbackfunc,12,"blur",targetThread);}_emscripten_set_blur_callback_on_thread.sig="ippipp";function _emscripten_set_focus_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerFocusEventCallback(target,userData,useCapture,callbackfunc,13,"focus",targetThread);}_emscripten_set_focus_callback_on_thread.sig="ippipp";function _emscripten_set_focusin_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerFocusEventCallback(target,userData,useCapture,callbackfunc,14,"focusin",targetThread);}_emscripten_set_focusin_callback_on_thread.sig="ippipp";function _emscripten_set_focusout_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerFocusEventCallback(target,userData,useCapture,callbackfunc,15,"focusout",targetThread);}_emscripten_set_focusout_callback_on_thread.sig="ippipp";var fillDeviceOrientationEventData=(eventStruct,e,target)=>{HEAPF64[eventStruct>>>3>>>0]=e.alpha;HEAPF64[eventStruct+8>>>3>>>0]=e.beta;HEAPF64[eventStruct+16>>>3>>>0]=e.gamma;HEAP8[eventStruct+24>>>0]=e.absolute;};var registerDeviceOrientationEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.deviceOrientationEvent||=_malloc(32);var deviceOrientationEventHandlerFunc=(e=event)=>{fillDeviceOrientationEventData(JSEvents.deviceOrientationEvent,e,target);// TODO: Thread-safety with respect to emscripten_get_deviceorientation_status()
if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,JSEvents.deviceOrientationEvent,userData))e.preventDefault();};var eventHandler={target:findEventTarget(target),eventTypeString,callbackfunc,handlerFunc:deviceOrientationEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_deviceorientation_callback_on_thread(userData,useCapture,callbackfunc,targetThread){userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerDeviceOrientationEventCallback(2,userData,useCapture,callbackfunc,16,"deviceorientation",targetThread);}_emscripten_set_deviceorientation_callback_on_thread.sig="ipipp";function _emscripten_get_deviceorientation_status(orientationState){orientationState>>>=0;if(!JSEvents.deviceOrientationEvent)return-7;// HTML5 does not really have a polling API for device orientation events, so implement one manually by
// returning the data from the most recently received event. This requires that user has registered
// at least some no-op function as an event handler.
HEAP32.set(HEAP32.subarray(JSEvents.deviceOrientationEvent>>>0,32>>>0),orientationState>>>0);return 0;}_emscripten_get_deviceorientation_status.sig="ip";var fillDeviceMotionEventData=(eventStruct,e,target)=>{var supportedFields=0;var a=e["acceleration"];supportedFields|=a&&1;var ag=e["accelerationIncludingGravity"];supportedFields|=ag&&2;var rr=e["rotationRate"];supportedFields|=rr&&4;a=a||{};ag=ag||{};rr=rr||{};HEAPF64[eventStruct>>>3>>>0]=a["x"];HEAPF64[eventStruct+8>>>3>>>0]=a["y"];HEAPF64[eventStruct+16>>>3>>>0]=a["z"];HEAPF64[eventStruct+24>>>3>>>0]=ag["x"];HEAPF64[eventStruct+32>>>3>>>0]=ag["y"];HEAPF64[eventStruct+40>>>3>>>0]=ag["z"];HEAPF64[eventStruct+48>>>3>>>0]=rr["alpha"];HEAPF64[eventStruct+56>>>3>>>0]=rr["beta"];HEAPF64[eventStruct+64>>>3>>>0]=rr["gamma"];};var registerDeviceMotionEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.deviceMotionEvent||=_malloc(80);var deviceMotionEventHandlerFunc=(e=event)=>{fillDeviceMotionEventData(JSEvents.deviceMotionEvent,e,target);// TODO: Thread-safety with respect to emscripten_get_devicemotion_status()
if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,JSEvents.deviceMotionEvent,userData))e.preventDefault();};var eventHandler={target:findEventTarget(target),eventTypeString,callbackfunc,handlerFunc:deviceMotionEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_devicemotion_callback_on_thread(userData,useCapture,callbackfunc,targetThread){userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerDeviceMotionEventCallback(2,userData,useCapture,callbackfunc,17,"devicemotion",targetThread);}_emscripten_set_devicemotion_callback_on_thread.sig="ipipp";function _emscripten_get_devicemotion_status(motionState){motionState>>>=0;if(!JSEvents.deviceMotionEvent)return-7;// HTML5 does not really have a polling API for device motion events, so implement one manually by
// returning the data from the most recently received event. This requires that user has registered
// at least some no-op function as an event handler.
HEAP32.set(HEAP32.subarray(JSEvents.deviceMotionEvent>>>0,80>>>0),motionState>>>0);return 0;}_emscripten_get_devicemotion_status.sig="ip";var screenOrientation=()=>{if(!window.screen)return undefined;return screen.orientation||screen["mozOrientation"]||screen["webkitOrientation"];};var fillOrientationChangeEventData=eventStruct=>{// OrientationType enum
var orientationsType1=["portrait-primary","portrait-secondary","landscape-primary","landscape-secondary"];// alternative selection from OrientationLockType enum
var orientationsType2=["portrait","portrait","landscape","landscape"];var orientationIndex=0;var orientationAngle=0;var screenOrientObj=screenOrientation();if(typeof screenOrientObj==="object"){orientationIndex=orientationsType1.indexOf(screenOrientObj.type);if(orientationIndex<0){orientationIndex=orientationsType2.indexOf(screenOrientObj.type);}if(orientationIndex>=0){orientationIndex=1<<orientationIndex;}orientationAngle=screenOrientObj.angle;}else{// fallback for Safari earlier than 16.4 (March 2023)
orientationAngle=window.orientation;}HEAP32[eventStruct>>>2>>>0]=orientationIndex;HEAP32[eventStruct+4>>>2>>>0]=orientationAngle;};var registerOrientationChangeEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.orientationChangeEvent||=_malloc(8);var orientationChangeEventHandlerFunc=(e=event)=>{var orientationChangeEvent=JSEvents.orientationChangeEvent;fillOrientationChangeEventData(orientationChangeEvent);if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,orientationChangeEvent,userData))e.preventDefault();};var eventHandler={target,eventTypeString,callbackfunc,handlerFunc:orientationChangeEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_orientationchange_callback_on_thread(userData,useCapture,callbackfunc,targetThread){userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;if(!window.screen||!screen.orientation)return-1;return registerOrientationChangeEventCallback(screen.orientation,userData,useCapture,callbackfunc,18,"change",targetThread);}_emscripten_set_orientationchange_callback_on_thread.sig="ipipp";function _emscripten_get_orientation_status(orientationChangeEvent){orientationChangeEvent>>>=0;// screenOrientation() resolving standard, window.orientation being the deprecated mobile-only
if(!screenOrientation()&&typeof orientation=="undefined")return-1;fillOrientationChangeEventData(orientationChangeEvent);return 0;}_emscripten_get_orientation_status.sig="ip";var _emscripten_lock_orientation=allowedOrientations=>{var orientations=[];if(allowedOrientations&1)orientations.push("portrait-primary");if(allowedOrientations&2)orientations.push("portrait-secondary");if(allowedOrientations&4)orientations.push("landscape-primary");if(allowedOrientations&8)orientations.push("landscape-secondary");var succeeded;if(screen.lockOrientation){succeeded=screen.lockOrientation(orientations);}else if(screen.mozLockOrientation){succeeded=screen.mozLockOrientation(orientations);}else if(screen.webkitLockOrientation){succeeded=screen.webkitLockOrientation(orientations);}else{return-1;}if(succeeded){return 0;}return-6;};_emscripten_lock_orientation.sig="ii";var _emscripten_unlock_orientation=()=>{if(screen.unlockOrientation){screen.unlockOrientation();}else if(screen.mozUnlockOrientation){screen.mozUnlockOrientation();}else if(screen.webkitUnlockOrientation){screen.webkitUnlockOrientation();}else{return-1;}return 0;};_emscripten_unlock_orientation.sig="i";var fillFullscreenChangeEventData=eventStruct=>{var fullscreenElement=document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||document.msFullscreenElement;var isFullscreen=!!fullscreenElement;// Assigning a boolean to HEAP32 with expected type coercion.
/** @suppress{checkTypes} */HEAP8[eventStruct>>>0]=isFullscreen;HEAP8[eventStruct+1>>>0]=JSEvents.fullscreenEnabled();// If transitioning to fullscreen, report info about the element that is now fullscreen.
// If transitioning to windowed mode, report info about the element that just was fullscreen.
var reportedElement=isFullscreen?fullscreenElement:JSEvents.previousFullscreenElement;var nodeName=JSEvents.getNodeNameForTarget(reportedElement);var id=reportedElement?.id||"";stringToUTF8(nodeName,eventStruct+2,128);stringToUTF8(id,eventStruct+130,128);HEAP32[eventStruct+260>>>2>>>0]=reportedElement?reportedElement.clientWidth:0;HEAP32[eventStruct+264>>>2>>>0]=reportedElement?reportedElement.clientHeight:0;HEAP32[eventStruct+268>>>2>>>0]=screen.width;HEAP32[eventStruct+272>>>2>>>0]=screen.height;if(isFullscreen){JSEvents.previousFullscreenElement=fullscreenElement;}};var registerFullscreenChangeEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.fullscreenChangeEvent||=_malloc(276);var fullscreenChangeEventhandlerFunc=(e=event)=>{var fullscreenChangeEvent=JSEvents.fullscreenChangeEvent;fillFullscreenChangeEventData(fullscreenChangeEvent);if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,fullscreenChangeEvent,userData))e.preventDefault();};var eventHandler={target,eventTypeString,callbackfunc,handlerFunc:fullscreenChangeEventhandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_fullscreenchange_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;if(!JSEvents.fullscreenEnabled())return-1;target=findEventTarget(target);if(!target)return-4;// Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
// As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
registerFullscreenChangeEventCallback(target,userData,useCapture,callbackfunc,19,"webkitfullscreenchange",targetThread);return registerFullscreenChangeEventCallback(target,userData,useCapture,callbackfunc,19,"fullscreenchange",targetThread);}_emscripten_set_fullscreenchange_callback_on_thread.sig="ippipp";function _emscripten_get_fullscreen_status(fullscreenStatus){fullscreenStatus>>>=0;if(!JSEvents.fullscreenEnabled())return-1;fillFullscreenChangeEventData(fullscreenStatus);return 0;}_emscripten_get_fullscreen_status.sig="ip";function _emscripten_get_canvas_element_size(target,width,height){target>>>=0;width>>>=0;height>>>=0;var canvas=findCanvasEventTarget(target);if(!canvas)return-4;HEAP32[width>>>2>>>0]=canvas.width;HEAP32[height>>>2>>>0]=canvas.height;}_emscripten_get_canvas_element_size.sig="ippp";var getCanvasElementSize=target=>{var sp=stackSave();var w=stackAlloc(8);var h=w+4;var targetInt=stringToUTF8OnStack(target.id);var ret=_emscripten_get_canvas_element_size(targetInt,w,h);var size=[HEAP32[w>>>2>>>0],HEAP32[h>>>2>>>0]];stackRestore(sp);return size;};function _emscripten_set_canvas_element_size(target,width,height){target>>>=0;var canvas=findCanvasEventTarget(target);if(!canvas)return-4;canvas.width=width;canvas.height=height;return 0;}_emscripten_set_canvas_element_size.sig="ipii";var setCanvasElementSize=(target,width,height)=>{if(!target.controlTransferredOffscreen){target.width=width;target.height=height;}else{// This function is being called from high-level JavaScript code instead of asm.js/Wasm,
// and it needs to synchronously proxy over to another thread, so marshal the string onto the heap to do the call.
var sp=stackSave();var targetInt=stringToUTF8OnStack(target.id);_emscripten_set_canvas_element_size(targetInt,width,height);stackRestore(sp);}};var registerRestoreOldStyle=canvas=>{var canvasSize=getCanvasElementSize(canvas);var oldWidth=canvasSize[0];var oldHeight=canvasSize[1];var oldCssWidth=canvas.style.width;var oldCssHeight=canvas.style.height;var oldBackgroundColor=canvas.style.backgroundColor;// Chrome reads color from here.
var oldDocumentBackgroundColor=document.body.style.backgroundColor;// IE11 reads color from here.
// Firefox always has black background color.
var oldPaddingLeft=canvas.style.paddingLeft;// Chrome, FF, Safari
var oldPaddingRight=canvas.style.paddingRight;var oldPaddingTop=canvas.style.paddingTop;var oldPaddingBottom=canvas.style.paddingBottom;var oldMarginLeft=canvas.style.marginLeft;// IE11
var oldMarginRight=canvas.style.marginRight;var oldMarginTop=canvas.style.marginTop;var oldMarginBottom=canvas.style.marginBottom;var oldDocumentBodyMargin=document.body.style.margin;var oldDocumentOverflow=document.documentElement.style.overflow;// Chrome, Firefox
var oldDocumentScroll=document.body.scroll;// IE
var oldImageRendering=canvas.style.imageRendering;function restoreOldStyle(){var fullscreenElement=document.fullscreenElement||document.webkitFullscreenElement;if(!fullscreenElement){document.removeEventListener("fullscreenchange",restoreOldStyle);// Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
// As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
document.removeEventListener("webkitfullscreenchange",restoreOldStyle);setCanvasElementSize(canvas,oldWidth,oldHeight);canvas.style.width=oldCssWidth;canvas.style.height=oldCssHeight;canvas.style.backgroundColor=oldBackgroundColor;// Chrome
// IE11 hack: assigning 'undefined' or an empty string to document.body.style.backgroundColor has no effect, so first assign back the default color
// before setting the undefined value. Setting undefined value is also important, or otherwise we would later treat that as something that the user
// had explicitly set so subsequent fullscreen transitions would not set background color properly.
if(!oldDocumentBackgroundColor)document.body.style.backgroundColor="white";document.body.style.backgroundColor=oldDocumentBackgroundColor;// IE11
canvas.style.paddingLeft=oldPaddingLeft;// Chrome, FF, Safari
canvas.style.paddingRight=oldPaddingRight;canvas.style.paddingTop=oldPaddingTop;canvas.style.paddingBottom=oldPaddingBottom;canvas.style.marginLeft=oldMarginLeft;// IE11
canvas.style.marginRight=oldMarginRight;canvas.style.marginTop=oldMarginTop;canvas.style.marginBottom=oldMarginBottom;document.body.style.margin=oldDocumentBodyMargin;document.documentElement.style.overflow=oldDocumentOverflow;// Chrome, Firefox
document.body.scroll=oldDocumentScroll;// IE
canvas.style.imageRendering=oldImageRendering;if(canvas.GLctxObject)canvas.GLctxObject.GLctx.viewport(0,0,oldWidth,oldHeight);if(currentFullscreenStrategy.canvasResizedCallback){((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */37,0,currentFullscreenStrategy.canvasResizedCallbackUserData);}}}document.addEventListener("fullscreenchange",restoreOldStyle);// Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
// As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
document.addEventListener("webkitfullscreenchange",restoreOldStyle);return restoreOldStyle;};var setLetterbox=(element,topBottom,leftRight)=>{// Cannot use margin to specify letterboxes in FF or Chrome, since those ignore margins in fullscreen mode.
element.style.paddingLeft=element.style.paddingRight=leftRight+"px";element.style.paddingTop=element.style.paddingBottom=topBottom+"px";};var JSEvents_resizeCanvasForFullscreen=(target,strategy)=>{var restoreOldStyle=registerRestoreOldStyle(target);var cssWidth=strategy.softFullscreen?innerWidth:screen.width;var cssHeight=strategy.softFullscreen?innerHeight:screen.height;var rect=getBoundingClientRect(target);var windowedCssWidth=rect.width;var windowedCssHeight=rect.height;var canvasSize=getCanvasElementSize(target);var windowedRttWidth=canvasSize[0];var windowedRttHeight=canvasSize[1];if(strategy.scaleMode==3){setLetterbox(target,(cssHeight-windowedCssHeight)/2,(cssWidth-windowedCssWidth)/2);cssWidth=windowedCssWidth;cssHeight=windowedCssHeight;}else if(strategy.scaleMode==2){if(cssWidth*windowedRttHeight<windowedRttWidth*cssHeight){var desiredCssHeight=windowedRttHeight*cssWidth/windowedRttWidth;setLetterbox(target,(cssHeight-desiredCssHeight)/2,0);cssHeight=desiredCssHeight;}else{var desiredCssWidth=windowedRttWidth*cssHeight/windowedRttHeight;setLetterbox(target,0,(cssWidth-desiredCssWidth)/2);cssWidth=desiredCssWidth;}}// If we are adding padding, must choose a background color or otherwise Chrome will give the
// padding a default white color. Do it only if user has not customized their own background color.
target.style.backgroundColor||="black";// IE11 does the same, but requires the color to be set in the document body.
document.body.style.backgroundColor||="black";// IE11
// Firefox always shows black letterboxes independent of style color.
target.style.width=cssWidth+"px";target.style.height=cssHeight+"px";if(strategy.filteringMode==1){target.style.imageRendering="optimizeSpeed";target.style.imageRendering="-moz-crisp-edges";target.style.imageRendering="-o-crisp-edges";target.style.imageRendering="-webkit-optimize-contrast";target.style.imageRendering="optimize-contrast";target.style.imageRendering="crisp-edges";target.style.imageRendering="pixelated";}var dpiScale=strategy.canvasResolutionScaleMode==2?devicePixelRatio:1;if(strategy.canvasResolutionScaleMode!=0){var newWidth=cssWidth*dpiScale|0;var newHeight=cssHeight*dpiScale|0;setCanvasElementSize(target,newWidth,newHeight);if(target.GLctxObject)target.GLctxObject.GLctx.viewport(0,0,newWidth,newHeight);}return restoreOldStyle;};var JSEvents_requestFullscreen=(target,strategy)=>{// EMSCRIPTEN_FULLSCREEN_SCALE_DEFAULT + EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_NONE is a mode where no extra logic is performed to the DOM elements.
if(strategy.scaleMode!=0||strategy.canvasResolutionScaleMode!=0){JSEvents_resizeCanvasForFullscreen(target,strategy);}if(target.requestFullscreen){target.requestFullscreen();}else if(target.webkitRequestFullscreen){target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);}else{return JSEvents.fullscreenEnabled()?-3:-1;}currentFullscreenStrategy=strategy;if(strategy.canvasResizedCallback){((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */37,0,strategy.canvasResizedCallbackUserData);}return 0;};var hideEverythingExceptGivenElement=onlyVisibleElement=>{var child=onlyVisibleElement;var parent=child.parentNode;var hiddenElements=[];while(child!=document.body){var children=parent.children;for(var i=0;i<children.length;++i){if(children[i]!=child){hiddenElements.push({node:children[i],displayState:children[i].style.display});children[i].style.display="none";}}child=parent;parent=parent.parentNode;}return hiddenElements;};var restoreHiddenElements=hiddenElements=>{for(var elem of hiddenElements){elem.node.style.display=elem.displayState;}};var currentFullscreenStrategy={};var restoreOldWindowedStyle=null;var softFullscreenResizeWebGLRenderTarget=()=>{var dpr=devicePixelRatio;var inHiDPIFullscreenMode=currentFullscreenStrategy.canvasResolutionScaleMode==2;var inAspectRatioFixedFullscreenMode=currentFullscreenStrategy.scaleMode==2;var inPixelPerfectFullscreenMode=currentFullscreenStrategy.canvasResolutionScaleMode!=0;var inCenteredWithoutScalingFullscreenMode=currentFullscreenStrategy.scaleMode==3;var screenWidth=inHiDPIFullscreenMode?Math.round(innerWidth*dpr):innerWidth;var screenHeight=inHiDPIFullscreenMode?Math.round(innerHeight*dpr):innerHeight;var w=screenWidth;var h=screenHeight;var canvas=currentFullscreenStrategy.target;var canvasSize=getCanvasElementSize(canvas);var x=canvasSize[0];var y=canvasSize[1];var topMargin;if(inAspectRatioFixedFullscreenMode){if(w*y<x*h)h=w*y/x|0;else if(w*y>x*h)w=h*x/y|0;topMargin=(screenHeight-h)/2|0;}if(inPixelPerfectFullscreenMode){setCanvasElementSize(canvas,w,h);if(canvas.GLctxObject)canvas.GLctxObject.GLctx.viewport(0,0,w,h);}// Back to CSS pixels.
if(inHiDPIFullscreenMode){topMargin/=dpr;w/=dpr;h/=dpr;// Round to nearest 4 digits of precision.
w=Math.round(w*1e4)/1e4;h=Math.round(h*1e4)/1e4;topMargin=Math.round(topMargin*1e4)/1e4;}if(inCenteredWithoutScalingFullscreenMode){var t=(innerHeight-jstoi_q(canvas.style.height))/2;var b=(innerWidth-jstoi_q(canvas.style.width))/2;setLetterbox(canvas,t,b);}else{canvas.style.width=w+"px";canvas.style.height=h+"px";var b=(innerWidth-w)/2;setLetterbox(canvas,topMargin,b);}if(!inCenteredWithoutScalingFullscreenMode&&currentFullscreenStrategy.canvasResizedCallback){((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */37,0,currentFullscreenStrategy.canvasResizedCallbackUserData);}};var doRequestFullscreen=(target,strategy)=>{if(!JSEvents.fullscreenEnabled())return-1;target=findEventTarget(target);if(!target)return-4;if(!target.requestFullscreen&&!target.webkitRequestFullscreen){return-3;}// Queue this function call if we're not currently in an event handler and
// the user saw it appropriate to do so.
if(!JSEvents.canPerformEventHandlerRequests()){if(strategy.deferUntilInEventHandler){JSEvents.deferCall(JSEvents_requestFullscreen,1,/* priority over pointer lock */[target,strategy]);return 1;}return-2;}return JSEvents_requestFullscreen(target,strategy);};function _emscripten_request_fullscreen(target,deferUntilInEventHandler){target>>>=0;var strategy={// These options perform no added logic, but just bare request fullscreen.
scaleMode:0,canvasResolutionScaleMode:0,filteringMode:0,deferUntilInEventHandler,canvasResizedCallbackTargetThread:2};return doRequestFullscreen(target,strategy);}_emscripten_request_fullscreen.sig="ipi";function _emscripten_request_fullscreen_strategy(target,deferUntilInEventHandler,fullscreenStrategy){target>>>=0;fullscreenStrategy>>>=0;var strategy={scaleMode:HEAP32[fullscreenStrategy>>>2>>>0],canvasResolutionScaleMode:HEAP32[fullscreenStrategy+4>>>2>>>0],filteringMode:HEAP32[fullscreenStrategy+8>>>2>>>0],deferUntilInEventHandler,canvasResizedCallback:HEAP32[fullscreenStrategy+12>>>2>>>0],canvasResizedCallbackUserData:HEAP32[fullscreenStrategy+16>>>2>>>0]};return doRequestFullscreen(target,strategy);}_emscripten_request_fullscreen_strategy.sig="ipip";function _emscripten_enter_soft_fullscreen(target,fullscreenStrategy){target>>>=0;fullscreenStrategy>>>=0;target=findEventTarget(target);if(!target)return-4;var strategy={scaleMode:HEAP32[fullscreenStrategy>>>2>>>0],canvasResolutionScaleMode:HEAP32[fullscreenStrategy+4>>>2>>>0],filteringMode:HEAP32[fullscreenStrategy+8>>>2>>>0],canvasResizedCallback:HEAP32[fullscreenStrategy+12>>>2>>>0],canvasResizedCallbackUserData:HEAP32[fullscreenStrategy+16>>>2>>>0],target,softFullscreen:true};var restoreOldStyle=JSEvents_resizeCanvasForFullscreen(target,strategy);document.documentElement.style.overflow="hidden";// Firefox, Chrome
document.body.scroll="no";// IE11
document.body.style.margin="0px";// Override default document margin area on all browsers.
var hiddenElements=hideEverythingExceptGivenElement(target);function restoreWindowedState(){restoreOldStyle();restoreHiddenElements(hiddenElements);removeEventListener("resize",softFullscreenResizeWebGLRenderTarget);if(strategy.canvasResizedCallback){((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */37,0,strategy.canvasResizedCallbackUserData);}currentFullscreenStrategy=0;}restoreOldWindowedStyle=restoreWindowedState;currentFullscreenStrategy=strategy;addEventListener("resize",softFullscreenResizeWebGLRenderTarget);// Inform the caller that the canvas size has changed.
if(strategy.canvasResizedCallback){((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */37,0,strategy.canvasResizedCallbackUserData);}return 0;}_emscripten_enter_soft_fullscreen.sig="ipp";var _emscripten_exit_soft_fullscreen=()=>{restoreOldWindowedStyle?.();restoreOldWindowedStyle=null;return 0;};_emscripten_exit_soft_fullscreen.sig="i";var _emscripten_exit_fullscreen=()=>{if(!JSEvents.fullscreenEnabled())return-1;// Make sure no queued up calls will fire after this.
JSEvents.removeDeferredCalls(JSEvents_requestFullscreen);var d=specialHTMLTargets[1];if(d.exitFullscreen){d.fullscreenElement&&d.exitFullscreen();}else if(d.webkitExitFullscreen){d.webkitFullscreenElement&&d.webkitExitFullscreen();}else{return-1;}return 0;};_emscripten_exit_fullscreen.sig="i";var fillPointerlockChangeEventData=eventStruct=>{var pointerLockElement=document.pointerLockElement||document.mozPointerLockElement||document.webkitPointerLockElement||document.msPointerLockElement;var isPointerlocked=!!pointerLockElement;// Assigning a boolean to HEAP32 with expected type coercion.
/** @suppress{checkTypes} */HEAP8[eventStruct>>>0]=isPointerlocked;var nodeName=JSEvents.getNodeNameForTarget(pointerLockElement);var id=pointerLockElement?.id||"";stringToUTF8(nodeName,eventStruct+1,128);stringToUTF8(id,eventStruct+129,128);};var registerPointerlockChangeEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.pointerlockChangeEvent||=_malloc(257);var pointerlockChangeEventHandlerFunc=(e=event)=>{var pointerlockChangeEvent=JSEvents.pointerlockChangeEvent;fillPointerlockChangeEventData(pointerlockChangeEvent);if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,pointerlockChangeEvent,userData))e.preventDefault();};var eventHandler={target,eventTypeString,callbackfunc,handlerFunc:pointerlockChangeEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};/** @suppress {missingProperties} */function _emscripten_set_pointerlockchange_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;// TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
if(!document||!document.body||!document.body.requestPointerLock&&!document.body.mozRequestPointerLock&&!document.body.webkitRequestPointerLock&&!document.body.msRequestPointerLock){return-1;}target=findEventTarget(target);if(!target)return-4;registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"mozpointerlockchange",targetThread);registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"webkitpointerlockchange",targetThread);registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"mspointerlockchange",targetThread);return registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"pointerlockchange",targetThread);}_emscripten_set_pointerlockchange_callback_on_thread.sig="ippipp";var registerPointerlockErrorEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{var pointerlockErrorEventHandlerFunc=(e=event)=>{if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,0,userData))e.preventDefault();};var eventHandler={target,eventTypeString,callbackfunc,handlerFunc:pointerlockErrorEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};/** @suppress {missingProperties} */function _emscripten_set_pointerlockerror_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;// TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
if(!document||!document.body.requestPointerLock&&!document.body.mozRequestPointerLock&&!document.body.webkitRequestPointerLock&&!document.body.msRequestPointerLock){return-1;}target=findEventTarget(target);if(!target)return-4;registerPointerlockErrorEventCallback(target,userData,useCapture,callbackfunc,38,"mozpointerlockerror",targetThread);registerPointerlockErrorEventCallback(target,userData,useCapture,callbackfunc,38,"webkitpointerlockerror",targetThread);registerPointerlockErrorEventCallback(target,userData,useCapture,callbackfunc,38,"mspointerlockerror",targetThread);return registerPointerlockErrorEventCallback(target,userData,useCapture,callbackfunc,38,"pointerlockerror",targetThread);}_emscripten_set_pointerlockerror_callback_on_thread.sig="ippipp";/** @suppress {missingProperties} */function _emscripten_get_pointerlock_status(pointerlockStatus){pointerlockStatus>>>=0;if(pointerlockStatus)fillPointerlockChangeEventData(pointerlockStatus);if(!document.body||!document.body.requestPointerLock&&!document.body.mozRequestPointerLock&&!document.body.webkitRequestPointerLock&&!document.body.msRequestPointerLock){return-1;}return 0;}_emscripten_get_pointerlock_status.sig="ip";var requestPointerLock=target=>{if(target.requestPointerLock){target.requestPointerLock();}else{// document.body is known to accept pointer lock, so use that to differentiate if the user passed a bad element,
// or if the whole browser just doesn't support the feature.
if(document.body.requestPointerLock){return-3;}return-1;}return 0;};function _emscripten_request_pointerlock(target,deferUntilInEventHandler){target>>>=0;target=findEventTarget(target);if(!target)return-4;if(!target.requestPointerLock){return-1;}// Queue this function call if we're not currently in an event handler and
// the user saw it appropriate to do so.
if(!JSEvents.canPerformEventHandlerRequests()){if(deferUntilInEventHandler){JSEvents.deferCall(requestPointerLock,2,/* priority below fullscreen */[target]);return 1;}return-2;}return requestPointerLock(target);}_emscripten_request_pointerlock.sig="ipi";var _emscripten_exit_pointerlock=()=>{// Make sure no queued up calls will fire after this.
JSEvents.removeDeferredCalls(requestPointerLock);if(document.exitPointerLock){document.exitPointerLock();}else{return-1;}return 0;};_emscripten_exit_pointerlock.sig="i";var _emscripten_vibrate=msecs=>{if(!navigator.vibrate)return-1;navigator.vibrate(msecs);return 0;};_emscripten_vibrate.sig="ii";function _emscripten_vibrate_pattern(msecsArray,numEntries){msecsArray>>>=0;if(!navigator.vibrate)return-1;var vibrateList=[];for(var i=0;i<numEntries;++i){var msecs=HEAP32[msecsArray+i*4>>>2>>>0];vibrateList.push(msecs);}navigator.vibrate(vibrateList);return 0;}_emscripten_vibrate_pattern.sig="ipi";var fillVisibilityChangeEventData=eventStruct=>{var visibilityStates=["hidden","visible","prerender","unloaded"];var visibilityState=visibilityStates.indexOf(document.visibilityState);// Assigning a boolean to HEAP32 with expected type coercion.
/** @suppress{checkTypes} */HEAP8[eventStruct>>>0]=document.hidden;HEAP32[eventStruct+4>>>2>>>0]=visibilityState;};var registerVisibilityChangeEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.visibilityChangeEvent||=_malloc(8);var visibilityChangeEventHandlerFunc=(e=event)=>{var visibilityChangeEvent=JSEvents.visibilityChangeEvent;fillVisibilityChangeEventData(visibilityChangeEvent);if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,visibilityChangeEvent,userData))e.preventDefault();};var eventHandler={target,eventTypeString,callbackfunc,handlerFunc:visibilityChangeEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_visibilitychange_callback_on_thread(userData,useCapture,callbackfunc,targetThread){userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;if(!specialHTMLTargets[1]){return-4;}return registerVisibilityChangeEventCallback(specialHTMLTargets[1],userData,useCapture,callbackfunc,21,"visibilitychange",targetThread);}_emscripten_set_visibilitychange_callback_on_thread.sig="ipipp";function _emscripten_get_visibility_status(visibilityStatus){visibilityStatus>>>=0;if(typeof document.visibilityState=="undefined"&&typeof document.hidden=="undefined"){return-1;}fillVisibilityChangeEventData(visibilityStatus);return 0;}_emscripten_get_visibility_status.sig="ip";var registerTouchEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.touchEvent||=_malloc(1552);target=findEventTarget(target);var touchEventHandlerFunc=e=>{var t,touches={},et=e.touches;// To ease marshalling different kinds of touches that browser reports (all touches are listed in e.touches,
// only changed touches in e.changedTouches, and touches on target at a.targetTouches), mark a boolean in
// each Touch object so that we can later loop only once over all touches we see to marshall over to Wasm.
for(let t of et){// Browser might recycle the generated Touch objects between each frame (Firefox on Android), so reset any
// changed/target states we may have set from previous frame.
t.isChanged=t.onTarget=0;touches[t.identifier]=t;}// Mark which touches are part of the changedTouches list.
for(let t of e.changedTouches){t.isChanged=1;touches[t.identifier]=t;}// Mark which touches are part of the targetTouches list.
for(let t of e.targetTouches){touches[t.identifier].onTarget=1;}var touchEvent=JSEvents.touchEvent;HEAPF64[touchEvent>>>3>>>0]=e.timeStamp;HEAP8[touchEvent+12>>>0]=e.ctrlKey;HEAP8[touchEvent+13>>>0]=e.shiftKey;HEAP8[touchEvent+14>>>0]=e.altKey;HEAP8[touchEvent+15>>>0]=e.metaKey;var idx=touchEvent+16;var targetRect=getBoundingClientRect(target);var numTouches=0;for(let t of Object.values(touches)){var idx32=idx>>>2;// Pre-shift the ptr to index to HEAP32 to save code size
HEAP32[idx32+0>>>0]=t.identifier;HEAP32[idx32+1>>>0]=t.screenX;HEAP32[idx32+2>>>0]=t.screenY;HEAP32[idx32+3>>>0]=t.clientX;HEAP32[idx32+4>>>0]=t.clientY;HEAP32[idx32+5>>>0]=t.pageX;HEAP32[idx32+6>>>0]=t.pageY;HEAP8[idx+28>>>0]=t.isChanged;HEAP8[idx+29>>>0]=t.onTarget;HEAP32[idx32+8>>>0]=t.clientX-(targetRect.left|0);HEAP32[idx32+9>>>0]=t.clientY-(targetRect.top|0);idx+=48;if(++numTouches>31){break;}}HEAP32[touchEvent+8>>>2>>>0]=numTouches;if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,touchEvent,userData))e.preventDefault();};var eventHandler={target,allowsDeferredCalls:eventTypeString=="touchstart"||eventTypeString=="touchend",eventTypeString,callbackfunc,handlerFunc:touchEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_touchstart_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerTouchEventCallback(target,userData,useCapture,callbackfunc,22,"touchstart",targetThread);}_emscripten_set_touchstart_callback_on_thread.sig="ippipp";function _emscripten_set_touchend_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerTouchEventCallback(target,userData,useCapture,callbackfunc,23,"touchend",targetThread);}_emscripten_set_touchend_callback_on_thread.sig="ippipp";function _emscripten_set_touchmove_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerTouchEventCallback(target,userData,useCapture,callbackfunc,24,"touchmove",targetThread);}_emscripten_set_touchmove_callback_on_thread.sig="ippipp";function _emscripten_set_touchcancel_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;return registerTouchEventCallback(target,userData,useCapture,callbackfunc,25,"touchcancel",targetThread);}_emscripten_set_touchcancel_callback_on_thread.sig="ippipp";var fillGamepadEventData=(eventStruct,e)=>{HEAPF64[eventStruct>>>3>>>0]=e.timestamp;for(var i=0;i<e.axes.length;++i){HEAPF64[eventStruct+i*8+16>>>3>>>0]=e.axes[i];}for(var i=0;i<e.buttons.length;++i){if(typeof e.buttons[i]=="object"){HEAPF64[eventStruct+i*8+528>>>3>>>0]=e.buttons[i].value;}else{HEAPF64[eventStruct+i*8+528>>>3>>>0]=e.buttons[i];}}for(var i=0;i<e.buttons.length;++i){if(typeof e.buttons[i]=="object"){HEAP8[eventStruct+i+1040>>>0]=e.buttons[i].pressed;}else{// Assigning a boolean to HEAP32, that's ok, but Closure would like to warn about it:
/** @suppress {checkTypes} */HEAP8[eventStruct+i+1040>>>0]=e.buttons[i]==1;}}HEAP8[eventStruct+1104>>>0]=e.connected;HEAP32[eventStruct+1108>>>2>>>0]=e.index;HEAP32[eventStruct+8>>>2>>>0]=e.axes.length;HEAP32[eventStruct+12>>>2>>>0]=e.buttons.length;stringToUTF8(e.id,eventStruct+1112,64);stringToUTF8(e.mapping,eventStruct+1176,64);};var registerGamepadEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.gamepadEvent||=_malloc(1240);var gamepadEventHandlerFunc=(e=event)=>{var gamepadEvent=JSEvents.gamepadEvent;fillGamepadEventData(gamepadEvent,e["gamepad"]);if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,gamepadEvent,userData))e.preventDefault();};var eventHandler={target:findEventTarget(target),allowsDeferredCalls:true,eventTypeString,callbackfunc,handlerFunc:gamepadEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};/** @suppress {checkTypes} */var _emscripten_sample_gamepad_data=()=>{try{if(navigator.getGamepads)return(JSEvents.lastGamepadState=navigator.getGamepads())?0:-1;}catch(e){navigator.getGamepads=null;}// Disable getGamepads() so that it won't be attempted to be used again.
return-1;};_emscripten_sample_gamepad_data.sig="i";function _emscripten_set_gamepadconnected_callback_on_thread(userData,useCapture,callbackfunc,targetThread){userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;if(_emscripten_sample_gamepad_data())return-1;return registerGamepadEventCallback(2,userData,useCapture,callbackfunc,26,"gamepadconnected",targetThread);}_emscripten_set_gamepadconnected_callback_on_thread.sig="ipipp";function _emscripten_set_gamepaddisconnected_callback_on_thread(userData,useCapture,callbackfunc,targetThread){userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;if(_emscripten_sample_gamepad_data())return-1;return registerGamepadEventCallback(2,userData,useCapture,callbackfunc,27,"gamepaddisconnected",targetThread);}_emscripten_set_gamepaddisconnected_callback_on_thread.sig="ipipp";var _emscripten_get_num_gamepads=()=>JSEvents.lastGamepadState.length;_emscripten_get_num_gamepads.sig="i";function _emscripten_get_gamepad_status(index,gamepadState){gamepadState>>>=0;// INVALID_PARAM is returned on a Gamepad index that never was there.
if(index<0||index>=JSEvents.lastGamepadState.length)return-5;// NO_DATA is returned on a Gamepad index that was removed.
// For previously disconnected gamepads there should be an empty slot (null/undefined/false) at the index.
// This is because gamepads must keep their original position in the array.
// For example, removing the first of two gamepads produces [null/undefined/false, gamepad].
if(!JSEvents.lastGamepadState[index])return-7;fillGamepadEventData(gamepadState,JSEvents.lastGamepadState[index]);return 0;}_emscripten_get_gamepad_status.sig="iip";var registerBeforeUnloadEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString)=>{var beforeUnloadEventHandlerFunc=(e=event)=>{// Note: This is always called on the main browser thread, since it needs synchronously return a value!
var confirmationMessage=((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,0,userData);if(confirmationMessage){confirmationMessage=UTF8ToString(confirmationMessage);}if(confirmationMessage){e.preventDefault();e.returnValue=confirmationMessage;return confirmationMessage;}};var eventHandler={target:findEventTarget(target),eventTypeString,callbackfunc,handlerFunc:beforeUnloadEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_beforeunload_callback_on_thread(userData,callbackfunc,targetThread){userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;if(typeof onbeforeunload=="undefined")return-1;// beforeunload callback can only be registered on the main browser thread, because the page will go away immediately after returning from the handler,
// and there is no time to start proxying it anywhere.
if(targetThread!==1)return-5;return registerBeforeUnloadEventCallback(2,userData,true,callbackfunc,28,"beforeunload");}_emscripten_set_beforeunload_callback_on_thread.sig="ippp";var fillBatteryEventData=(eventStruct,e)=>{HEAPF64[eventStruct>>>3>>>0]=e.chargingTime;HEAPF64[eventStruct+8>>>3>>>0]=e.dischargingTime;HEAPF64[eventStruct+16>>>3>>>0]=e.level;HEAP8[eventStruct+24>>>0]=e.charging;};var battery=()=>navigator.battery||navigator.mozBattery||navigator.webkitBattery;var registerBatteryEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{JSEvents.batteryEvent||=_malloc(32);var batteryEventHandlerFunc=(e=event)=>{var batteryEvent=JSEvents.batteryEvent;fillBatteryEventData(batteryEvent,battery());if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,batteryEvent,userData))e.preventDefault();};var eventHandler={target:findEventTarget(target),eventTypeString,callbackfunc,handlerFunc:batteryEventHandlerFunc,useCapture};return JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_batterychargingchange_callback_on_thread(userData,callbackfunc,targetThread){userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;if(!battery())return-1;return registerBatteryEventCallback(battery(),userData,true,callbackfunc,29,"chargingchange",targetThread);}_emscripten_set_batterychargingchange_callback_on_thread.sig="ippp";function _emscripten_set_batterylevelchange_callback_on_thread(userData,callbackfunc,targetThread){userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;if(!battery())return-1;return registerBatteryEventCallback(battery(),userData,true,callbackfunc,30,"levelchange",targetThread);}_emscripten_set_batterylevelchange_callback_on_thread.sig="ippp";function _emscripten_get_battery_status(batteryState){batteryState>>>=0;if(!battery())return-1;fillBatteryEventData(batteryState,battery());return 0;}_emscripten_get_battery_status.sig="ip";function __emscripten_set_offscreencanvas_size(target,width,height){target>>>=0;return-1;}__emscripten_set_offscreencanvas_size.sig="ipii";function _emscripten_set_element_css_size(target,width,height){target>>>=0;target=findEventTarget(target);if(!target)return-4;target.style.width=width+"px";target.style.height=height+"px";return 0;}_emscripten_set_element_css_size.sig="ipdd";function _emscripten_get_element_css_size(target,width,height){target>>>=0;width>>>=0;height>>>=0;target=findEventTarget(target);if(!target)return-4;var rect=getBoundingClientRect(target);HEAPF64[width>>>3>>>0]=rect.width;HEAPF64[height>>>3>>>0]=rect.height;return 0;}_emscripten_get_element_css_size.sig="ippp";var _emscripten_html5_remove_all_event_listeners=()=>JSEvents.removeAllEventListeners();_emscripten_html5_remove_all_event_listeners.sig="v";var _emscripten_request_animation_frame=function(cb,userData){cb>>>=0;userData>>>=0;return requestAnimationFrame(timeStamp=>((a1,a2)=>{})(/* a dynamic function call to signature idi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */timeStamp,userData));};_emscripten_request_animation_frame.sig="ipp";var _emscripten_cancel_animation_frame=id=>cancelAnimationFrame(id);_emscripten_cancel_animation_frame.sig="vi";var _emscripten_request_animation_frame_loop=function(cb,userData){cb>>>=0;userData>>>=0;function tick(timeStamp){if(((a1,a2)=>{})(/* a dynamic function call to signature idi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */timeStamp,userData)){requestAnimationFrame(tick);}}return requestAnimationFrame(tick);};_emscripten_request_animation_frame_loop.sig="vpp";var _emscripten_performance_now=()=>performance.now();_emscripten_performance_now.sig="d";var _emscripten_get_device_pixel_ratio=()=>devicePixelRatio;_emscripten_get_device_pixel_ratio.sig="d";function _emscripten_get_callstack(flags,str,maxbytes){str>>>=0;var callstack=getCallstack(flags);// User can query the required amount of bytes to hold the callstack.
if(!str||maxbytes<=0){return lengthBytesUTF8(callstack)+1;}// Output callstack string as C string to HEAP.
var bytesWrittenExcludingNull=stringToUTF8(callstack,str,maxbytes);// Return number of bytes written, including null.
return bytesWrittenExcludingNull+1;}_emscripten_get_callstack.sig="iipi";/** @returns {number} */var convertFrameToPC=frame=>{abort("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER");// return 0 if we can't find any
return 0;};function _emscripten_return_address(level){var callstack=jsStackTrace().split("\n");if(callstack[0]=="Error"){callstack.shift();}// skip this function and the caller to get caller's return address
var caller=callstack[level+3];return convertFrameToPC(caller);}_emscripten_return_address.sig="pi";var UNWIND_CACHE={};var saveInUnwindCache=callstack=>{callstack.forEach(frame=>{var pc=convertFrameToPC(frame);if(pc){UNWIND_CACHE[pc]=frame;}});};function _emscripten_stack_snapshot(){var callstack=jsStackTrace().split("\n");if(callstack[0]=="Error"){callstack.shift();}saveInUnwindCache(callstack);// Caches the stack snapshot so that emscripten_stack_unwind_buffer() can
// unwind from this spot.
UNWIND_CACHE.last_addr=convertFrameToPC(callstack[3]);UNWIND_CACHE.last_stack=callstack;return UNWIND_CACHE.last_addr;}_emscripten_stack_snapshot.sig="p";function _emscripten_stack_unwind_buffer(addr,buffer,count){addr>>>=0;buffer>>>=0;var stack;if(UNWIND_CACHE.last_addr==addr){stack=UNWIND_CACHE.last_stack;}else{stack=jsStackTrace().split("\n");if(stack[0]=="Error"){stack.shift();}saveInUnwindCache(stack);}var offset=3;while(stack[offset]&&convertFrameToPC(stack[offset])!=addr){++offset;}for(var i=0;i<count&&stack[i+offset];++i){HEAP32[buffer+i*4>>>2>>>0]=convertFrameToPC(stack[i+offset]);}return i;}_emscripten_stack_unwind_buffer.sig="ippi";function _emscripten_pc_get_function(pc){pc>>>=0;abort("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER");return 0;}_emscripten_pc_get_function.sig="pp";var convertPCtoSourceLocation=pc=>{if(UNWIND_CACHE.last_get_source_pc==pc)return UNWIND_CACHE.last_source;var match;var source;if(!source){var frame=UNWIND_CACHE[pc];if(!frame)return null;// Example: at callMain (a.out.js:6335:22)
if(match=/\((.*):(\d+):(\d+)\)$/.exec(frame)){source={file:match[1],line:match[2],column:match[3]};}else// Example: main@a.out.js:1337:42
if(match=/@(.*):(\d+):(\d+)/.exec(frame)){source={file:match[1],line:match[2],column:match[3]};}}UNWIND_CACHE.last_get_source_pc=pc;UNWIND_CACHE.last_source=source;return source;};function _emscripten_pc_get_file(pc){pc>>>=0;var result=convertPCtoSourceLocation(pc);if(!result)return 0;if(_emscripten_pc_get_file.ret)_free(_emscripten_pc_get_file.ret);_emscripten_pc_get_file.ret=stringToNewUTF8(result.file);return _emscripten_pc_get_file.ret;}_emscripten_pc_get_file.sig="pp";function _emscripten_pc_get_line(pc){pc>>>=0;var result=convertPCtoSourceLocation(pc);return result?result.line:0;}_emscripten_pc_get_line.sig="ip";function _emscripten_pc_get_column(pc){pc>>>=0;var result=convertPCtoSourceLocation(pc);return result?result.column||0:0;}_emscripten_pc_get_column.sig="ip";var _sched_yield=()=>0;Module["_sched_yield"]=_sched_yield;_sched_yield.sig="i";function _random_get(buf,buf_len){buf>>>=0;buf_len>>>=0;try{_getentropy(buf,buf_len);return 0;}catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return e.errno;}}_random_get.sig="ipp";var checkWasiClock=clock_id=>clock_id==0||clock_id==1||clock_id==2||clock_id==3;function _clock_time_get(clk_id,ignored_precision_low,ignored_precision_high,ptime){var ignored_precision=convertI32PairToI53Checked(ignored_precision_low,ignored_precision_high);ptime>>>=0;if(!checkWasiClock(clk_id)){return 28;}var now;// all wasi clocks but realtime are monotonic
if(clk_id===0){now=Date.now();}else if(nowIsMonotonic){now=_emscripten_get_now();}else{return 52;}// "now" is in ms, and wasi times are in ns.
var nsec=Math.round(now*1e3*1e3);HEAP32[ptime>>>2>>>0]=nsec>>>0;HEAP32[ptime+4>>>2>>>0]=nsec/Math.pow(2,32)>>>0;return 0;}_clock_time_get.sig="iiiip";function _clock_res_get(clk_id,pres){pres>>>=0;if(!checkWasiClock(clk_id)){return 28;}var nsec;// all wasi clocks but realtime are monotonic
if(clk_id===0){nsec=1e3*1e3;}else// educated guess that it's milliseconds
if(nowIsMonotonic){nsec=_emscripten_get_now_res();}else{return 52;}HEAP32[pres>>>2>>>0]=nsec>>>0;HEAP32[pres+4>>>2>>>0]=nsec/Math.pow(2,32)>>>0;return 0;}_clock_res_get.sig="iip";var wasiRightsToMuslOFlags=rights=>{if(rights&2&&rights&64){return 2;}if(rights&2){return 0;}if(rights&64){return 1;}throw new FS.ErrnoError(28);};var wasiOFlagsToMuslOFlags=oflags=>{var musl_oflags=0;if(oflags&1){musl_oflags|=64;}if(oflags&8){musl_oflags|=512;}if(oflags&2){musl_oflags|=65536;}if(oflags&4){musl_oflags|=128;}return musl_oflags;};var _emscripten_unwind_to_js_event_loop=()=>{throw"unwind";};_emscripten_unwind_to_js_event_loop.sig="v";var setImmediateWrapped=func=>{setImmediateWrapped.mapping||=[];var id=setImmediateWrapped.mapping.length;setImmediateWrapped.mapping[id]=setImmediate(()=>{setImmediateWrapped.mapping[id]=undefined;func();});return id;};var clearImmediateWrapped=id=>{clearImmediate(setImmediateWrapped.mapping[id]);setImmediateWrapped.mapping[id]=undefined;};var polyfillSetImmediate=()=>{};// nop, used for its postset to ensure setImmediate() polyfill is
// not duplicated between emscripten_set_immediate() and
// emscripten_set_immediate_loop() if application links to both of them.
var _emscripten_set_immediate=function(cb,userData){cb>>>=0;userData>>>=0;runtimeKeepalivePush();return emSetImmediate(()=>{runtimeKeepalivePop();callUserCallback(()=>(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */userData));});};_emscripten_set_immediate.sig="ipp";var _emscripten_clear_immediate=id=>{runtimeKeepalivePop();emClearImmediate(id);};_emscripten_clear_immediate.sig="vi";var _emscripten_set_immediate_loop=function(cb,userData){cb>>>=0;userData>>>=0;function tick(){callUserCallback(()=>{if((a1=>{})(/* a dynamic function call to signature ii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */userData)){emSetImmediate(tick);}else{runtimeKeepalivePop();}});}runtimeKeepalivePush();emSetImmediate(tick);};_emscripten_set_immediate_loop.sig="vpp";var _emscripten_set_timeout=function(cb,msecs,userData){cb>>>=0;userData>>>=0;return safeSetTimeout(()=>(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */userData),msecs);};_emscripten_set_timeout.sig="ipdp";var _emscripten_clear_timeout=clearTimeout;_emscripten_clear_timeout.sig="vi";var _emscripten_set_timeout_loop=function(cb,msecs,userData){cb>>>=0;userData>>>=0;function tick(){var t=_emscripten_get_now();var n=t+msecs;runtimeKeepalivePop();callUserCallback(()=>{if(((a1,a2)=>{})(/* a dynamic function call to signature idi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */t,userData)){// Save a little bit of code space: modern browsers should treat
// negative setTimeout as timeout of 0
// (https://stackoverflow.com/questions/8430966/is-calling-settimeout-with-a-negative-delay-ok)
runtimeKeepalivePush();setTimeout(tick,n-_emscripten_get_now());}});}runtimeKeepalivePush();return setTimeout(tick,0);};_emscripten_set_timeout_loop.sig="vpdp";var _emscripten_set_interval=function(cb,msecs,userData){cb>>>=0;userData>>>=0;runtimeKeepalivePush();return setInterval(()=>{callUserCallback(()=>(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */userData));},msecs);};_emscripten_set_interval.sig="ipdp";var _emscripten_clear_interval=id=>{runtimeKeepalivePop();clearInterval(id);};_emscripten_clear_interval.sig="vi";var idsToPromises=(idBuf,size)=>{var promises=[];for(var i=0;i<size;i++){var id=HEAP32[idBuf+i*4>>>2>>>0];promises[i]=getPromise(id);}return promises;};var makePromiseCallback=(callback,userData)=>value=>{runtimeKeepalivePop();var stack=stackSave();// Allocate space for the result value and initialize it to NULL.
var resultPtr=stackAlloc(POINTER_SIZE);HEAPU32[resultPtr>>>2>>>0]=0;try{var result=((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */resultPtr,userData,value);var resultVal=HEAPU32[resultPtr>>>2>>>0];}catch(e){// If the thrown value is potentially a valid pointer, use it as the
// rejection reason. Otherwise use a null pointer as the reason. If we
// allow arbitrary objects to be thrown here, we will get a TypeError in
// MEMORY64 mode when they are later converted to void* rejection
// values.
if(typeof e!="number"){throw 0;}throw e;}finally{// Thrown errors will reject the promise, but at least we will restore
// the stack first.
stackRestore(stack);}switch(result){case 0:return resultVal;case 1:return getPromise(resultVal);case 2:var ret=getPromise(resultVal);_emscripten_promise_destroy(resultVal);return ret;case 3:throw resultVal;}};function _emscripten_promise_then(id,onFulfilled,onRejected,userData){id>>>=0;onFulfilled>>>=0;onRejected>>>=0;userData>>>=0;runtimeKeepalivePush();var promise=getPromise(id);var newId=promiseMap.allocate({promise:promise.then(makePromiseCallback(onFulfilled,userData),makePromiseCallback(onRejected,userData))});return newId;}_emscripten_promise_then.sig="ppppp";var _emscripten_promise_all=function(idBuf,resultBuf,size){idBuf>>>=0;resultBuf>>>=0;size>>>=0;var promises=idsToPromises(idBuf,size);var id=promiseMap.allocate({promise:Promise.all(promises).then(results=>{if(resultBuf){for(var i=0;i<size;i++){var result=results[i];HEAPU32[resultBuf+i*4>>>2>>>0]=result;}}return resultBuf;})});return id;};_emscripten_promise_all.sig="pppp";var setPromiseResult=(ptr,fulfill,value)=>{var result=fulfill?0:3;HEAP32[ptr>>>2>>>0]=result;HEAPU32[ptr+4>>>2>>>0]=value;};var _emscripten_promise_all_settled=function(idBuf,resultBuf,size){idBuf>>>=0;resultBuf>>>=0;size>>>=0;var promises=idsToPromises(idBuf,size);var id=promiseMap.allocate({promise:Promise.allSettled(promises).then(results=>{if(resultBuf){var offset=resultBuf;for(var i=0;i<size;i++,offset+=8){if(results[i].status==="fulfilled"){setPromiseResult(offset,true,results[i].value);}else{setPromiseResult(offset,false,results[i].reason);}}}return resultBuf;})});return id;};_emscripten_promise_all_settled.sig="pppp";var _emscripten_promise_any=function(idBuf,errorBuf,size){idBuf>>>=0;errorBuf>>>=0;size>>>=0;var promises=idsToPromises(idBuf,size);var id=promiseMap.allocate({promise:Promise.any(promises).catch(err=>{if(errorBuf){for(var i=0;i<size;i++){HEAPU32[errorBuf+i*4>>>2>>>0]=err.errors[i];}}throw errorBuf;})});return id;};_emscripten_promise_any.sig="pppp";function _emscripten_promise_race(idBuf,size){idBuf>>>=0;size>>>=0;var promises=idsToPromises(idBuf,size);var id=promiseMap.allocate({promise:Promise.race(promises)});return id;}_emscripten_promise_race.sig="ppp";var _emscripten_promise_await=function(returnValuePtr,id){returnValuePtr>>>=0;id>>>=0;return Asyncify.handleSleep(wakeUp=>{getPromise(id).then(value=>{setPromiseResult(returnValuePtr,true,value);wakeUp();},value=>{setPromiseResult(returnValuePtr,false,value);wakeUp();});});};_emscripten_promise_await.sig="vpp";_emscripten_promise_await.isAsync=true;function ___resumeException(ptr){ptr>>>=0;if(!exceptionLast){exceptionLast=ptr;}throw exceptionLast;}___resumeException.sig="vp";var findMatchingCatch=args=>{var thrown=exceptionLast;if(!thrown){// just pass through the null ptr
setTempRet0(0);return 0;}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){// just pass through the thrown ptr
setTempRet0(0);return thrown;}// can_catch receives a **, add indirection
// The different catch blocks are denoted by different types.
// Due to inheritance, those types may not precisely match the
// type of the thrown object. Find one which matches, and
// return the type of the catch block which should be called.
for(var caughtType of args){if(caughtType===0||caughtType===thrownType){// Catch all clause matched or exactly the same type is caught
break;}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown;}}setTempRet0(thrownType);return thrown;};function ___cxa_find_matching_catch_2(){return findMatchingCatch([]);}___cxa_find_matching_catch_2.sig="p";function ___cxa_find_matching_catch_3(arg0){arg0>>>=0;return findMatchingCatch([arg0]);}___cxa_find_matching_catch_3.sig="pp";function ___cxa_find_matching_catch_4(arg0,arg1){arg0>>>=0;arg1>>>=0;return findMatchingCatch([arg0,arg1]);}___cxa_find_matching_catch_4.sig="ppp";var exceptionCaught=[];var ___cxa_rethrow=()=>{var info=exceptionCaught.pop();if(!info){abort("no exception to throw");}var ptr=info.excPtr;if(!info.get_rethrown()){// Only pop if the corresponding push was through rethrow_primary_exception
exceptionCaught.push(info);info.set_rethrown(true);info.set_caught(false);uncaughtExceptionCount++;}exceptionLast=ptr;throw exceptionLast;};___cxa_rethrow.sig="v";function _llvm_eh_typeid_for(type){type>>>=0;return type;}_llvm_eh_typeid_for.sig="vp";function ___cxa_begin_catch(ptr){ptr>>>=0;var info=new ExceptionInfo(ptr);if(!info.get_caught()){info.set_caught(true);uncaughtExceptionCount--;}info.set_rethrown(false);exceptionCaught.push(info);___cxa_increment_exception_refcount(ptr);return ___cxa_get_exception_ptr(ptr);}___cxa_begin_catch.sig="pp";var ___cxa_end_catch=()=>{// Clear state flag.
_setThrew(0,0);// Call destructor if one is registered then clear it.
var info=exceptionCaught.pop();___cxa_decrement_exception_refcount(info.excPtr);exceptionLast=0;};// XXX in decRef?
___cxa_end_catch.sig="v";var ___cxa_uncaught_exceptions=()=>uncaughtExceptionCount;Module["___cxa_uncaught_exceptions"]=___cxa_uncaught_exceptions;___cxa_uncaught_exceptions.sig="i";function ___cxa_call_unexpected(exception){exception>>>=0;return abort("Unexpected exception thrown, this is not properly supported - aborting");}___cxa_call_unexpected.sig="vp";function ___cxa_current_primary_exception(){if(!exceptionCaught.length){return 0;}var info=exceptionCaught[exceptionCaught.length-1];___cxa_increment_exception_refcount(info.excPtr);return info.excPtr;}Module["___cxa_current_primary_exception"]=___cxa_current_primary_exception;___cxa_current_primary_exception.sig="p";function ___cxa_rethrow_primary_exception(ptr){ptr>>>=0;if(!ptr)return;var info=new ExceptionInfo(ptr);exceptionCaught.push(info);info.set_rethrown(true);___cxa_rethrow();}Module["___cxa_rethrow_primary_exception"]=___cxa_rethrow_primary_exception;___cxa_rethrow_primary_exception.sig="vp";var _emscripten_run_preload_plugins=function(file,onload,onerror){file>>>=0;onload>>>=0;onerror>>>=0;runtimeKeepalivePush();var _file=UTF8ToString(file);var data=FS.analyzePath(_file);if(!data.exists)return-1;FS.createPreloadedFile(PATH.dirname(_file),PATH.basename(_file),// TODO: This copy is not needed if the contents are already a Uint8Array,
//       which they often are (and always are in WasmFS).
new Uint8Array(data.object.contents),true,true,()=>{runtimeKeepalivePop();if(onload)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */file);},()=>{runtimeKeepalivePop();if(onerror)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */file);},true);// don'tCreateFile - it's already there
return 0;};_emscripten_run_preload_plugins.sig="ippp";var Browser_asyncPrepareDataCounter=0;var _emscripten_run_preload_plugins_data=function(data,size,suffix,arg,onload,onerror){data>>>=0;suffix>>>=0;arg>>>=0;onload>>>=0;onerror>>>=0;runtimeKeepalivePush();var _suffix=UTF8ToString(suffix);var name="prepare_data_"+Browser_asyncPrepareDataCounter++ +"."+_suffix;var cname=stringToNewUTF8(name);FS.createPreloadedFile("/",name,HEAPU8.subarray(data>>>0,data+size>>>0),true,true,()=>{runtimeKeepalivePop();if(onload)((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg,cname);},()=>{runtimeKeepalivePop();if(onerror)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);},true);};_emscripten_run_preload_plugins_data.sig="vpipppp";var _emscripten_async_run_script=function(script,millis){script>>>=0;// TODO: cache these to avoid generating garbage
safeSetTimeout(()=>_emscripten_run_script(script),millis);};_emscripten_async_run_script.sig="vpi";var _emscripten_async_load_script=function(url,onload,onerror){url>>>=0;onload>>>=0;onerror>>>=0;url=UTF8ToString(url);runtimeKeepalivePush();var loadDone=()=>{runtimeKeepalivePop();if(onload){var onloadCallback=()=>callUserCallback(()=>{});/* a dynamic function call to signature v, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */if(runDependencies>0){dependenciesFulfilled=onloadCallback;}else{onloadCallback();}}};var loadError=()=>{runtimeKeepalivePop();if(onerror){callUserCallback(()=>{});}};var script=document.createElement("script");script.onload=loadDone;script.onerror=loadError;script.src=url;document.body.appendChild(script);};_emscripten_async_load_script.sig="vppp";function _emscripten_get_main_loop_timing(mode,value){mode>>>=0;value>>>=0;if(mode)HEAP32[mode>>>2>>>0]=Browser.mainLoop.timingMode;if(value)HEAP32[value>>>2>>>0]=Browser.mainLoop.timingValue;}_emscripten_get_main_loop_timing.sig="vpp";var _emscripten_set_main_loop=function(func,fps,simulateInfiniteLoop){func>>>=0;var browserIterationFunc=()=>{};/* a dynamic function call to signature v, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */setMainLoop(browserIterationFunc,fps,simulateInfiniteLoop);};_emscripten_set_main_loop.sig="vpii";var _emscripten_set_main_loop_arg=function(func,arg,fps,simulateInfiniteLoop){func>>>=0;arg>>>=0;var browserIterationFunc=()=>(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);setMainLoop(browserIterationFunc,fps,simulateInfiniteLoop,arg);};_emscripten_set_main_loop_arg.sig="vppii";var _emscripten_cancel_main_loop=()=>{Browser.mainLoop.pause();Browser.mainLoop.func=null;};_emscripten_cancel_main_loop.sig="v";var _emscripten_pause_main_loop=()=>{Browser.mainLoop.pause();};_emscripten_pause_main_loop.sig="v";var _emscripten_resume_main_loop=()=>{Browser.mainLoop.resume();};_emscripten_resume_main_loop.sig="v";var __emscripten_push_main_loop_blocker=function(func,arg,name){func>>>=0;arg>>>=0;name>>>=0;Browser.mainLoop.queue.push({func:()=>{(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);},name:UTF8ToString(name),counted:true});Browser.mainLoop.updateStatus();};__emscripten_push_main_loop_blocker.sig="vppp";var __emscripten_push_uncounted_main_loop_blocker=function(func,arg,name){func>>>=0;arg>>>=0;name>>>=0;Browser.mainLoop.queue.push({func:()=>{(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);},name:UTF8ToString(name),counted:false});Browser.mainLoop.updateStatus();};__emscripten_push_uncounted_main_loop_blocker.sig="vppp";var _emscripten_set_main_loop_expected_blockers=num=>{Browser.mainLoop.expectedBlockers=num;Browser.mainLoop.remainingBlockers=num;Browser.mainLoop.updateStatus();};_emscripten_set_main_loop_expected_blockers.sig="vi";var _emscripten_async_call=function(func,arg,millis){func>>>=0;arg>>>=0;function wrapper(){(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);}if(millis>=0){safeSetTimeout(wrapper,millis);}else{Browser.safeRequestAnimationFrame(wrapper);}};_emscripten_async_call.sig="vppi";function _emscripten_get_window_title(){var buflen=256;if(!_emscripten_get_window_title.buffer){_emscripten_get_window_title.buffer=_malloc(buflen);}stringToUTF8(document.title,_emscripten_get_window_title.buffer,buflen);return _emscripten_get_window_title.buffer;}_emscripten_get_window_title.sig="p";function _emscripten_set_window_title(title){title>>>=0;return document.title=UTF8ToString(title);}_emscripten_set_window_title.sig="vp";function _emscripten_get_screen_size(width,height){width>>>=0;height>>>=0;HEAP32[width>>>2>>>0]=screen.width;HEAP32[height>>>2>>>0]=screen.height;}_emscripten_get_screen_size.sig="vpp";var _emscripten_hide_mouse=()=>{var styleSheet=document.styleSheets[0];var rules=styleSheet.cssRules;for(var i=0;i<rules.length;i++){if(rules[i].cssText.substr(0,6)=="canvas"){styleSheet.deleteRule(i);i--;}}styleSheet.insertRule("canvas.emscripten { border: 1px solid black; cursor: none; }",0);};_emscripten_hide_mouse.sig="v";var _emscripten_set_canvas_size=(width,height)=>{Browser.setCanvasSize(width,height);};_emscripten_set_canvas_size.sig="vii";function _emscripten_get_canvas_size(width,height,isFullscreen){width>>>=0;height>>>=0;isFullscreen>>>=0;var canvas=Module["canvas"];HEAP32[width>>>2>>>0]=canvas.width;HEAP32[height>>>2>>>0]=canvas.height;HEAP32[isFullscreen>>>2>>>0]=Browser.isFullscreen?1:0;}_emscripten_get_canvas_size.sig="vppp";function _emscripten_create_worker(url){url>>>=0;url=UTF8ToString(url);var id=Browser.workers.length;var info={worker:new Worker(url),callbacks:[],awaited:0,buffer:0,bufferSize:0};info.worker.onmessage=function info_worker_onmessage(msg){if(ABORT)return;var info=Browser.workers[id];if(!info)return;// worker was destroyed meanwhile
var callbackId=msg.data["callbackId"];var callbackInfo=info.callbacks[callbackId];if(!callbackInfo)return;// no callback or callback removed meanwhile
// Don't trash our callback state if we expect additional calls.
if(msg.data["finalResponse"]){info.awaited--;info.callbacks[callbackId]=null;// TODO: reuse callbackIds, compress this
runtimeKeepalivePop();}var data=msg.data["data"];if(data){if(!data.byteLength)data=new Uint8Array(data);if(!info.buffer||info.bufferSize<data.length){if(info.buffer)_free(info.buffer);info.bufferSize=data.length;info.buffer=_malloc(data.length);}HEAPU8.set(data,info.buffer>>>0);callbackInfo.func(info.buffer,data.length,callbackInfo.arg);}else{callbackInfo.func(0,0,callbackInfo.arg);}};Browser.workers.push(info);return id;}_emscripten_create_worker.sig="ip";var _emscripten_destroy_worker=id=>{var info=Browser.workers[id];info.worker.terminate();if(info.buffer)_free(info.buffer);Browser.workers[id]=null;};_emscripten_destroy_worker.sig="vi";var _emscripten_call_worker=function(id,funcName,data,size,callback,arg){funcName>>>=0;data>>>=0;callback>>>=0;arg>>>=0;funcName=UTF8ToString(funcName);var info=Browser.workers[id];var callbackId=-1;if(callback){// If we are waiting for a response from the worker we need to keep
// the runtime alive at least long enough to receive it.
// The corresponding runtimeKeepalivePop is in the `finalResponse`
// handler above.
runtimeKeepalivePush();callbackId=info.callbacks.length;info.callbacks.push({func:(a1,a2,a3)=>{},/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg});info.awaited++;}var transferObject={"funcName":funcName,"callbackId":callbackId,"data":data?new Uint8Array(HEAPU8.subarray(data>>>0,data+size>>>0)):0};if(data){info.worker.postMessage(transferObject,[transferObject.data.buffer]);}else{info.worker.postMessage(transferObject);}};_emscripten_call_worker.sig="vippipp";var _emscripten_get_worker_queue_size=id=>{var info=Browser.workers[id];if(!info)return-1;return info.awaited;};_emscripten_get_worker_queue_size.sig="ii";var getPreloadedImageData=(path,w,h)=>{path=PATH_FS.resolve(path);var canvas=/** @type {HTMLCanvasElement} */preloadedImages[path];if(!canvas)return 0;var ctx=canvas.getContext("2d");var image=ctx.getImageData(0,0,canvas.width,canvas.height);var buf=_malloc(canvas.width*canvas.height*4);HEAPU8.set(image.data,buf>>>0);HEAP32[w>>>2>>>0]=canvas.width;HEAP32[h>>>2>>>0]=canvas.height;return buf;};function _emscripten_get_preloaded_image_data(path,w,h){path>>>=0;w>>>=0;h>>>=0;return getPreloadedImageData(UTF8ToString(path),w,h);}_emscripten_get_preloaded_image_data.sig="pppp";var getPreloadedImageData__data=["$PATH_FS","malloc"];function _emscripten_get_preloaded_image_data_from_FILE(file,w,h){file>>>=0;w>>>=0;h>>>=0;var fd=_fileno(file);var stream=FS.getStream(fd);if(stream){return getPreloadedImageData(stream.path,w,h);}return 0;}_emscripten_get_preloaded_image_data_from_FILE.sig="pppp";var wget={wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle(){var handle=wget.nextWgetRequestHandle;wget.nextWgetRequestHandle++;return handle;}};/**
     * @param {number=} mode Optionally, the mode to create in. Uses mkdir's
     *                       default if not set.
     */var FS_mkdirTree=(path,mode)=>FS.mkdirTree(path,mode);var _emscripten_async_wget=function(url,file,onload,onerror){url>>>=0;file>>>=0;onload>>>=0;onerror>>>=0;runtimeKeepalivePush();var _url=UTF8ToString(url);var _file=UTF8ToString(file);_file=PATH_FS.resolve(_file);function doCallback(callback){if(callback){runtimeKeepalivePop();callUserCallback(()=>{var sp=stackSave();(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */stringToUTF8OnStack(_file));stackRestore(sp);});}}var destinationDirectory=PATH.dirname(_file);FS_createPreloadedFile(destinationDirectory,PATH.basename(_file),_url,true,true,()=>doCallback(onload),()=>doCallback(onerror),false,// dontCreateFile
false,// canOwn
()=>{// preFinish
// if a file exists there, we overwrite it
try{FS_unlink(_file);}catch(e){}// if the destination directory does not yet exist, create it
FS_mkdirTree(destinationDirectory);});};_emscripten_async_wget.sig="vpppp";var _emscripten_async_wget_data=function(url,userdata,onload,onerror){url>>>=0;userdata>>>=0;onload>>>=0;onerror>>>=0;runtimeKeepalivePush();asyncLoad(UTF8ToString(url),byteArray=>{runtimeKeepalivePop();callUserCallback(()=>{var buffer=_malloc(byteArray.length);HEAPU8.set(byteArray,buffer>>>0);((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */userdata,buffer,byteArray.length);_free(buffer);});},()=>{if(onerror){runtimeKeepalivePop();callUserCallback(()=>{(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */userdata);});}},true);};_emscripten_async_wget_data.sig="vpppp";var _emscripten_async_wget2=function(url,file,request,param,userdata,onload,onerror,onprogress){url>>>=0;file>>>=0;request>>>=0;param>>>=0;userdata>>>=0;onload>>>=0;onerror>>>=0;onprogress>>>=0;runtimeKeepalivePush();var _url=UTF8ToString(url);var _file=UTF8ToString(file);_file=PATH_FS.resolve(_file);var _request=UTF8ToString(request);var _param=UTF8ToString(param);var index=_file.lastIndexOf("/");var http=new XMLHttpRequest();http.open(_request,_url,true);http.responseType="arraybuffer";var handle=wget.getNextWgetRequestHandle();var destinationDirectory=PATH.dirname(_file);// LOAD
http.onload=e=>{runtimeKeepalivePop();if(http.status>=200&&http.status<300){// if a file exists there, we overwrite it
try{FS.unlink(_file);}catch(e){}// if the destination directory does not yet exist, create it
FS.mkdirTree(destinationDirectory);FS.createDataFile(_file.substr(0,index),_file.substr(index+1),new Uint8Array(/** @type{ArrayBuffer}*/http.response),true,true,false);if(onload){var sp=stackSave();((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */handle,userdata,stringToUTF8OnStack(_file));stackRestore(sp);}}else{if(onerror)((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */handle,userdata,http.status);}delete wget.wgetRequests[handle];};// ERROR
http.onerror=e=>{runtimeKeepalivePop();if(onerror)((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */handle,userdata,http.status);delete wget.wgetRequests[handle];};// PROGRESS
http.onprogress=e=>{if(e.lengthComputable||e.lengthComputable===undefined&&e.total!=0){var percentComplete=e.loaded/e.total*100;if(onprogress)((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */handle,userdata,percentComplete);}};// ABORT
http.onabort=e=>{runtimeKeepalivePop();delete wget.wgetRequests[handle];};if(_request=="POST"){//Send the proper header information along with the request
http.setRequestHeader("Content-type","application/x-www-form-urlencoded");http.send(_param);}else{http.send(null);}wget.wgetRequests[handle]=http;return handle;};_emscripten_async_wget2.sig="ipppppppp";function _emscripten_async_wget2_data(url,request,param,userdata,free,onload,onerror,onprogress){url>>>=0;request>>>=0;param>>>=0;userdata>>>=0;onload>>>=0;onerror>>>=0;onprogress>>>=0;var _url=UTF8ToString(url);var _request=UTF8ToString(request);var _param=UTF8ToString(param);var http=new XMLHttpRequest();http.open(_request,_url,true);http.responseType="arraybuffer";var handle=wget.getNextWgetRequestHandle();function onerrorjs(){if(onerror){var sp=stackSave();var statusText=0;if(http.statusText){statusText=stringToUTF8OnStack(http.statusText);}((a1,a2,a3,a4)=>{})(/* a dynamic function call to signature viiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */handle,userdata,http.status,statusText);stackRestore(sp);}}// LOAD
http.onload=e=>{if(http.status>=200&&http.status<300||http.status===0&&_url.substr(0,4).toLowerCase()!="http"){var byteArray=new Uint8Array(/** @type{ArrayBuffer} */http.response);var buffer=_malloc(byteArray.length);HEAPU8.set(byteArray,buffer>>>0);if(onload)((a1,a2,a3,a4)=>{})(/* a dynamic function call to signature viiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */handle,userdata,buffer,byteArray.length);if(free)_free(buffer);}else{onerrorjs();}delete wget.wgetRequests[handle];};// ERROR
http.onerror=e=>{onerrorjs();delete wget.wgetRequests[handle];};// PROGRESS
http.onprogress=e=>{if(onprogress)((a1,a2,a3,a4)=>{})(/* a dynamic function call to signature viiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */handle,userdata,e.loaded,e.lengthComputable||e.lengthComputable===undefined?e.total:0);};// ABORT
http.onabort=e=>{delete wget.wgetRequests[handle];};if(_request=="POST"){//Send the proper header information along with the request
http.setRequestHeader("Content-type","application/x-www-form-urlencoded");http.send(_param);}else{http.send(null);}wget.wgetRequests[handle]=http;return handle;}_emscripten_async_wget2_data.sig="ippppippp";var _emscripten_async_wget2_abort=handle=>{var http=wget.wgetRequests[handle];http?.abort();};_emscripten_async_wget2_abort.sig="vi";function ___asctime_r(tmPtr,buf){tmPtr>>>=0;buf>>>=0;var date={tm_sec:HEAP32[tmPtr>>>2>>>0],tm_min:HEAP32[tmPtr+4>>>2>>>0],tm_hour:HEAP32[tmPtr+8>>>2>>>0],tm_mday:HEAP32[tmPtr+12>>>2>>>0],tm_mon:HEAP32[tmPtr+16>>>2>>>0],tm_year:HEAP32[tmPtr+20>>>2>>>0],tm_wday:HEAP32[tmPtr+24>>>2>>>0]};var days=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];var s=days[date.tm_wday]+" "+months[date.tm_mon]+(date.tm_mday<10?"  ":" ")+date.tm_mday+(date.tm_hour<10?" 0":" ")+date.tm_hour+(date.tm_min<10?":0":":")+date.tm_min+(date.tm_sec<10?":0":":")+date.tm_sec+" "+(1900+date.tm_year)+"\n";// asctime_r is specced to behave in an undefined manner if the algorithm would attempt
// to write out more than 26 bytes (including the null terminator).
// See http://pubs.opengroup.org/onlinepubs/9699919799/functions/asctime.html
// Our undefined behavior is to truncate the write to at most 26 bytes, including null terminator.
stringToUTF8(s,buf,26);return buf;}___asctime_r.sig="ppp";function _strptime_l(buf,format,tm,locale){buf>>>=0;format>>>=0;tm>>>=0;locale>>>=0;return _strptime(buf,format,tm);}_strptime_l.sig="ppppp";function ___syscall_shutdown(fd,how){try{getSocketFromFD(fd);return-52;}// unsupported feature
catch(e){if(typeof FS=="undefined"||!(e.name==="ErrnoError"))throw e;return-e.errno;}}Module["___syscall_shutdown"]=___syscall_shutdown;___syscall_shutdown.sig="iiiiiii";function __dlsym_catchup_js(handle,symbolIndex){handle>>>=0;var lib=LDSO.loadedLibsByHandle[handle];var symDict=lib.exports;var symName=Object.keys(symDict)[symbolIndex];var sym=symDict[symName];var result=addFunction(sym,sym.sig);return result;}__dlsym_catchup_js.sig="ppi";var FS_readFile=FS.readFile;var _setNetworkCallback=(event,userData,callback)=>{function _callback(data){try{if(event==="error"){var sp=stackSave();var msg=stringToUTF8OnStack(data[2]);((a1,a2,a3,a4)=>{})(/* a dynamic function call to signature viiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */data[0],data[1],msg,userData);stackRestore(sp);}else{((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */data,userData);}}catch(e){if(!(e instanceof ExitStatus)){if(e&&typeof e=="object"&&e.stack)err("exception thrown: "+[e,e.stack]);throw e;}}}// FIXME(sbc): This has no corresponding Pop so will currently keep the
// runtime alive indefinitely.
runtimeKeepalivePush();Module["websocket"]["on"](event,callback?_callback:null);};function _emscripten_set_socket_error_callback(userData,callback){userData>>>=0;callback>>>=0;_setNetworkCallback("error",userData,callback);}_emscripten_set_socket_error_callback.sig="vpp";function _emscripten_set_socket_open_callback(userData,callback){userData>>>=0;callback>>>=0;_setNetworkCallback("open",userData,callback);}_emscripten_set_socket_open_callback.sig="vpp";function _emscripten_set_socket_listen_callback(userData,callback){userData>>>=0;callback>>>=0;_setNetworkCallback("listen",userData,callback);}_emscripten_set_socket_listen_callback.sig="vpp";function _emscripten_set_socket_connection_callback(userData,callback){userData>>>=0;callback>>>=0;_setNetworkCallback("connection",userData,callback);}_emscripten_set_socket_connection_callback.sig="vpp";function _emscripten_set_socket_message_callback(userData,callback){userData>>>=0;callback>>>=0;_setNetworkCallback("message",userData,callback);}_emscripten_set_socket_message_callback.sig="vpp";function _emscripten_set_socket_close_callback(userData,callback){userData>>>=0;callback>>>=0;_setNetworkCallback("close",userData,callback);}_emscripten_set_socket_close_callback.sig="vpp";function _emscripten_webgl_enable_ANGLE_instanced_arrays(ctx){ctx>>>=0;return webgl_enable_ANGLE_instanced_arrays(GL.contexts[ctx].GLctx);}_emscripten_webgl_enable_ANGLE_instanced_arrays.sig="ip";function _emscripten_webgl_enable_OES_vertex_array_object(ctx){ctx>>>=0;return webgl_enable_OES_vertex_array_object(GL.contexts[ctx].GLctx);}_emscripten_webgl_enable_OES_vertex_array_object.sig="ip";function _emscripten_webgl_enable_WEBGL_draw_buffers(ctx){ctx>>>=0;return webgl_enable_WEBGL_draw_buffers(GL.contexts[ctx].GLctx);}_emscripten_webgl_enable_WEBGL_draw_buffers.sig="ip";function _emscripten_webgl_enable_WEBGL_multi_draw(ctx){ctx>>>=0;return webgl_enable_WEBGL_multi_draw(GL.contexts[ctx].GLctx);}_emscripten_webgl_enable_WEBGL_multi_draw.sig="ip";function _emscripten_webgl_enable_EXT_polygon_offset_clamp(ctx){ctx>>>=0;return webgl_enable_EXT_polygon_offset_clamp(GL.contexts[ctx].GLctx);}_emscripten_webgl_enable_EXT_polygon_offset_clamp.sig="ip";function _emscripten_webgl_enable_EXT_clip_control(ctx){ctx>>>=0;return webgl_enable_EXT_clip_control(GL.contexts[ctx].GLctx);}_emscripten_webgl_enable_EXT_clip_control.sig="ip";function _emscripten_webgl_enable_WEBGL_polygon_mode(ctx){ctx>>>=0;return webgl_enable_WEBGL_polygon_mode(GL.contexts[ctx].GLctx);}_emscripten_webgl_enable_WEBGL_polygon_mode.sig="ip";function _glVertexPointer(size,type,stride,ptr){ptr>>>=0;throw"Legacy GL function (glVertexPointer) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";}_glVertexPointer.sig="viiip";var _glMatrixMode=()=>{throw"Legacy GL function (glMatrixMode) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";};_glMatrixMode.sig="vi";var _glBegin=()=>{throw"Legacy GL function (glBegin) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";};_glBegin.sig="vi";var _glLoadIdentity=()=>{throw"Legacy GL function (glLoadIdentity) called. If you want legacy GL emulation, you need to compile with -sLEGACY_GL_EMULATION to enable legacy GL emulation.";};_glLoadIdentity.sig="v";var _glVertexAttribDivisorNV=_glVertexAttribDivisor;var _glDrawArraysInstancedNV=_glDrawArraysInstanced;var _glDrawElementsInstancedNV=_glDrawElementsInstanced;var _glVertexAttribDivisorEXT=_glVertexAttribDivisor;var _glDrawArraysInstancedEXT=_glDrawArraysInstanced;var _glDrawElementsInstancedEXT=_glDrawElementsInstanced;var _glVertexAttribDivisorARB=_glVertexAttribDivisor;var _glDrawArraysInstancedARB=_glDrawArraysInstanced;var _glDrawElementsInstancedARB=_glDrawElementsInstanced;var _glDrawBuffersEXT=_glDrawBuffers;/** @suppress {duplicate } */function _glMultiDrawArraysWEBGL(mode,firsts,counts,drawcount){firsts>>>=0;counts>>>=0;GLctx.multiDrawWebgl["multiDrawArraysWEBGL"](mode,HEAP32,firsts>>>2,HEAP32,counts>>>2,drawcount);}_glMultiDrawArraysWEBGL.sig="vippi";var _glMultiDrawArrays=_glMultiDrawArraysWEBGL;_glMultiDrawArrays.sig="vippi";var _glMultiDrawArraysANGLE=_glMultiDrawArraysWEBGL;/** @suppress {duplicate } */function _glMultiDrawArraysInstancedWEBGL(mode,firsts,counts,instanceCounts,drawcount){firsts>>>=0;counts>>>=0;instanceCounts>>>=0;GLctx.multiDrawWebgl["multiDrawArraysInstancedWEBGL"](mode,HEAP32,firsts>>>2,HEAP32,counts>>>2,HEAP32,instanceCounts>>>2,drawcount);}_glMultiDrawArraysInstancedWEBGL.sig="vipppi";var _glMultiDrawArraysInstancedANGLE=_glMultiDrawArraysInstancedWEBGL;/** @suppress {duplicate } */function _glMultiDrawElementsWEBGL(mode,counts,type,offsets,drawcount){counts>>>=0;offsets>>>=0;GLctx.multiDrawWebgl["multiDrawElementsWEBGL"](mode,HEAP32,counts>>>2,type,HEAP32,offsets>>>2,drawcount);}_glMultiDrawElementsWEBGL.sig="vipipi";var _glMultiDrawElements=_glMultiDrawElementsWEBGL;_glMultiDrawElements.sig="vipipi";var _glMultiDrawElementsANGLE=_glMultiDrawElementsWEBGL;/** @suppress {duplicate } */function _glMultiDrawElementsInstancedWEBGL(mode,counts,type,offsets,instanceCounts,drawcount){counts>>>=0;offsets>>>=0;instanceCounts>>>=0;GLctx.multiDrawWebgl["multiDrawElementsInstancedWEBGL"](mode,HEAP32,counts>>>2,type,HEAP32,offsets>>>2,HEAP32,instanceCounts>>>2,drawcount);}_glMultiDrawElementsInstancedWEBGL.sig="vipippi";var _glMultiDrawElementsInstancedANGLE=_glMultiDrawElementsInstancedWEBGL;var _glClearDepth=x0=>GLctx.clearDepth(x0);_glClearDepth.sig="vd";var _glDepthRange=(x0,x1)=>GLctx.depthRange(x0,x1);_glDepthRange.sig="vdd";var _emscripten_glGenVertexArrays=_glGenVertexArrays;_emscripten_glGenVertexArrays.sig="vip";var _emscripten_glDeleteVertexArrays=_glDeleteVertexArrays;_emscripten_glDeleteVertexArrays.sig="vip";var _emscripten_glBindVertexArray=_glBindVertexArray;_emscripten_glBindVertexArray.sig="vi";var _emscripten_glIsVertexArray=_glIsVertexArray;_emscripten_glIsVertexArray.sig="ii";var _emscripten_glVertexPointer=_glVertexPointer;_emscripten_glVertexPointer.sig="viiip";var _emscripten_glMatrixMode=_glMatrixMode;_emscripten_glMatrixMode.sig="vi";var _emscripten_glBegin=_glBegin;_emscripten_glBegin.sig="vi";var _emscripten_glLoadIdentity=_glLoadIdentity;_emscripten_glLoadIdentity.sig="v";var _emscripten_glVertexAttribDivisor=_glVertexAttribDivisor;_emscripten_glVertexAttribDivisor.sig="vii";var _emscripten_glDrawArraysInstanced=_glDrawArraysInstanced;_emscripten_glDrawArraysInstanced.sig="viiii";var _emscripten_glDrawElementsInstanced=_glDrawElementsInstanced;_emscripten_glDrawElementsInstanced.sig="viiipi";var _emscripten_glVertexAttribDivisorNV=_glVertexAttribDivisorNV;var _emscripten_glDrawArraysInstancedNV=_glDrawArraysInstancedNV;var _emscripten_glDrawElementsInstancedNV=_glDrawElementsInstancedNV;var _emscripten_glVertexAttribDivisorEXT=_glVertexAttribDivisorEXT;var _emscripten_glDrawArraysInstancedEXT=_glDrawArraysInstancedEXT;var _emscripten_glDrawElementsInstancedEXT=_glDrawElementsInstancedEXT;var _emscripten_glVertexAttribDivisorARB=_glVertexAttribDivisorARB;var _emscripten_glDrawArraysInstancedARB=_glDrawArraysInstancedARB;var _emscripten_glDrawElementsInstancedARB=_glDrawElementsInstancedARB;var _emscripten_glDrawBuffers=_glDrawBuffers;_emscripten_glDrawBuffers.sig="vip";var _emscripten_glDrawBuffersEXT=_glDrawBuffersEXT;var _emscripten_glMultiDrawArrays=_glMultiDrawArrays;_emscripten_glMultiDrawArrays.sig="vippi";var _emscripten_glMultiDrawArraysANGLE=_glMultiDrawArraysANGLE;var _emscripten_glMultiDrawArraysWEBGL=_glMultiDrawArraysWEBGL;var _emscripten_glMultiDrawArraysInstancedANGLE=_glMultiDrawArraysInstancedANGLE;var _emscripten_glMultiDrawArraysInstancedWEBGL=_glMultiDrawArraysInstancedWEBGL;var _emscripten_glMultiDrawElements=_glMultiDrawElements;_emscripten_glMultiDrawElements.sig="vipipi";var _emscripten_glMultiDrawElementsANGLE=_glMultiDrawElementsANGLE;var _emscripten_glMultiDrawElementsWEBGL=_glMultiDrawElementsWEBGL;var _emscripten_glMultiDrawElementsInstancedANGLE=_glMultiDrawElementsInstancedANGLE;var _emscripten_glMultiDrawElementsInstancedWEBGL=_glMultiDrawElementsInstancedWEBGL;var _emscripten_glClearDepth=_glClearDepth;_emscripten_glClearDepth.sig="vd";var _emscripten_glDepthRange=_glDepthRange;_emscripten_glDepthRange.sig="vdd";var writeGLArray=(arr,dst,dstLength,heapType)=>{var len=arr.length;var writeLength=dstLength<len?dstLength:len;var heap=heapType?HEAPF32:HEAP32;// Works because HEAPF32 and HEAP32 have the same bytes-per-element
dst=dst>>>2;for(var i=0;i<writeLength;++i){heap[dst+i>>>0]=arr[i];}return len;};var webglPowerPreferences=["default","low-power","high-performance"];/** @suppress {duplicate } */function _emscripten_webgl_do_create_context(target,attributes){target>>>=0;attributes>>>=0;var attr32=attributes>>>2;var powerPreference=HEAP32[attr32+(8>>2)>>>0];var contextAttributes={"alpha":!!HEAP8[attributes+0>>>0],"depth":!!HEAP8[attributes+1>>>0],"stencil":!!HEAP8[attributes+2>>>0],"antialias":!!HEAP8[attributes+3>>>0],"premultipliedAlpha":!!HEAP8[attributes+4>>>0],"preserveDrawingBuffer":!!HEAP8[attributes+5>>>0],"powerPreference":webglPowerPreferences[powerPreference],"failIfMajorPerformanceCaveat":!!HEAP8[attributes+12>>>0],// The following are not predefined WebGL context attributes in the WebGL specification, so the property names can be minified by Closure.
majorVersion:HEAP32[attr32+(16>>2)>>>0],minorVersion:HEAP32[attr32+(20>>2)>>>0],enableExtensionsByDefault:HEAP8[attributes+24>>>0],explicitSwapControl:HEAP8[attributes+25>>>0],proxyContextToMainThread:HEAP32[attr32+(28>>2)>>>0],renderViaOffscreenBackBuffer:HEAP8[attributes+32>>>0]};var canvas=findCanvasEventTarget(target);if(!canvas){return 0;}if(contextAttributes.explicitSwapControl){return 0;}var contextHandle=GL.createContext(canvas,contextAttributes);return contextHandle;}_emscripten_webgl_do_create_context.sig="ppp";var _emscripten_webgl_create_context=_emscripten_webgl_do_create_context;_emscripten_webgl_create_context.sig="ppp";/** @suppress {duplicate } */function _emscripten_webgl_do_get_current_context(){return GL.currentContext?GL.currentContext.handle:0;}_emscripten_webgl_do_get_current_context.sig="p";var _emscripten_webgl_get_current_context=_emscripten_webgl_do_get_current_context;_emscripten_webgl_get_current_context.sig="p";/** @suppress {duplicate } */var _emscripten_webgl_do_commit_frame=()=>{if(!GL.currentContext||!GL.currentContext.GLctx){return-3;}if(!GL.currentContext.attributes.explicitSwapControl){return-3;}// We would do GL.currentContext.GLctx.commit(); here, but the current implementation
// in browsers has removed it - swap is implicit, so this function is a no-op for now
// (until/unless the spec changes).
return 0;};_emscripten_webgl_do_commit_frame.sig="i";var _emscripten_webgl_commit_frame=_emscripten_webgl_do_commit_frame;_emscripten_webgl_commit_frame.sig="i";function _emscripten_webgl_make_context_current(contextHandle){contextHandle>>>=0;var success=GL.makeContextCurrent(contextHandle);return success?0:-5;}_emscripten_webgl_make_context_current.sig="ip";function _emscripten_webgl_get_drawing_buffer_size(contextHandle,width,height){contextHandle>>>=0;width>>>=0;height>>>=0;var GLContext=GL.getContext(contextHandle);if(!GLContext||!GLContext.GLctx||!width||!height){return-5;}HEAP32[width>>>2>>>0]=GLContext.GLctx.drawingBufferWidth;HEAP32[height>>>2>>>0]=GLContext.GLctx.drawingBufferHeight;return 0;}_emscripten_webgl_get_drawing_buffer_size.sig="ippp";function _emscripten_webgl_get_context_attributes(c,a){c>>>=0;a>>>=0;if(!a)return-5;c=GL.contexts[c];if(!c)return-3;var t=c.GLctx;if(!t)return-3;t=t.getContextAttributes();HEAP8[a>>>0]=t.alpha;HEAP8[a+1>>>0]=t.depth;HEAP8[a+2>>>0]=t.stencil;HEAP8[a+3>>>0]=t.antialias;HEAP8[a+4>>>0]=t.premultipliedAlpha;HEAP8[a+5>>>0]=t.preserveDrawingBuffer;var power=t["powerPreference"]&&webglPowerPreferences.indexOf(t["powerPreference"]);HEAP32[a+8>>>2>>>0]=power;HEAP8[a+12>>>0]=t.failIfMajorPerformanceCaveat;HEAP32[a+16>>>2>>>0]=c.version;HEAP32[a+20>>>2>>>0]=0;HEAP8[a+24>>>0]=c.attributes.enableExtensionsByDefault;return 0;}_emscripten_webgl_get_context_attributes.sig="ipp";function _emscripten_webgl_destroy_context(contextHandle){contextHandle>>>=0;if(GL.currentContext==contextHandle)GL.currentContext=0;GL.deleteContext(contextHandle);}_emscripten_webgl_destroy_context.sig="ip";function _emscripten_webgl_enable_extension(contextHandle,extension){contextHandle>>>=0;extension>>>=0;var context=GL.getContext(contextHandle);var extString=UTF8ToString(extension);if(extString.startsWith("GL_"))extString=extString.substr(3);// Allow enabling extensions both with "GL_" prefix and without.
// Switch-board that pulls in code for all GL extensions, even if those are not used :/
// Build with -sGL_SUPPORT_SIMPLE_ENABLE_EXTENSIONS=0 to avoid this.
// Obtain function entry points to WebGL 1 extension related functions.
if(extString=="ANGLE_instanced_arrays")webgl_enable_ANGLE_instanced_arrays(GLctx);if(extString=="OES_vertex_array_object")webgl_enable_OES_vertex_array_object(GLctx);if(extString=="WEBGL_draw_buffers")webgl_enable_WEBGL_draw_buffers(GLctx);if(extString=="WEBGL_multi_draw")webgl_enable_WEBGL_multi_draw(GLctx);if(extString=="EXT_polygon_offset_clamp")webgl_enable_EXT_polygon_offset_clamp(GLctx);if(extString=="EXT_clip_control")webgl_enable_EXT_clip_control(GLctx);if(extString=="WEBGL_polygon_mode")webgl_enable_WEBGL_polygon_mode(GLctx);var ext=context.GLctx.getExtension(extString);return!!ext;}_emscripten_webgl_enable_extension.sig="ipp";var _emscripten_supports_offscreencanvas=()=>// TODO: Add a new build mode, e.g. OFFSCREENCANVAS_SUPPORT=2, which
// necessitates OffscreenCanvas support at build time, and "return 1;" here in that build mode.
0;_emscripten_supports_offscreencanvas.sig="i";var registerWebGlEventCallback=(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread)=>{var webGlEventHandlerFunc=(e=event)=>{if(((a1,a2,a3)=>{})(/* a dynamic function call to signature iiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */eventTypeId,0,userData))e.preventDefault();};var eventHandler={target:findEventTarget(target),eventTypeString,callbackfunc,handlerFunc:webGlEventHandlerFunc,useCapture};JSEvents.registerOrRemoveHandler(eventHandler);};function _emscripten_set_webglcontextlost_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;registerWebGlEventCallback(target,userData,useCapture,callbackfunc,31,"webglcontextlost",targetThread);return 0;}_emscripten_set_webglcontextlost_callback_on_thread.sig="ippipp";function _emscripten_set_webglcontextrestored_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target>>>=0;userData>>>=0;callbackfunc>>>=0;targetThread>>>=0;registerWebGlEventCallback(target,userData,useCapture,callbackfunc,32,"webglcontextrestored",targetThread);return 0;}_emscripten_set_webglcontextrestored_callback_on_thread.sig="ippipp";function _emscripten_is_webgl_context_lost(contextHandle){contextHandle>>>=0;return!GL.contexts[contextHandle]||GL.contexts[contextHandle].GLctx.isContextLost();}_emscripten_is_webgl_context_lost.sig="ip";function _emscripten_webgl_get_supported_extensions(){return stringToNewUTF8(GLctx.getSupportedExtensions().join(" "));}_emscripten_webgl_get_supported_extensions.sig="p";var _emscripten_webgl_get_program_parameter_d=(program,param)=>GLctx.getProgramParameter(GL.programs[program],param);_emscripten_webgl_get_program_parameter_d.sig="dii";function _emscripten_webgl_get_program_info_log_utf8(program){return stringToNewUTF8(GLctx.getProgramInfoLog(GL.programs[program]));}_emscripten_webgl_get_program_info_log_utf8.sig="pi";var _emscripten_webgl_get_shader_parameter_d=(shader,param)=>GLctx.getShaderParameter(GL.shaders[shader],param);_emscripten_webgl_get_shader_parameter_d.sig="dii";function _emscripten_webgl_get_shader_info_log_utf8(shader){return stringToNewUTF8(GLctx.getShaderInfoLog(GL.shaders[shader]));}_emscripten_webgl_get_shader_info_log_utf8.sig="pi";function _emscripten_webgl_get_shader_source_utf8(shader){return stringToNewUTF8(GLctx.getShaderSource(GL.shaders[shader]));}_emscripten_webgl_get_shader_source_utf8.sig="pi";var _emscripten_webgl_get_vertex_attrib_d=(index,param)=>GLctx.getVertexAttrib(index,param);_emscripten_webgl_get_vertex_attrib_d.sig="dii";var _emscripten_webgl_get_vertex_attrib_o=(index,param)=>{var obj=GLctx.getVertexAttrib(index,param);return obj?.name;};_emscripten_webgl_get_vertex_attrib_o.sig="iii";function _emscripten_webgl_get_vertex_attrib_v(index,param,dst,dstLength,dstType){dst>>>=0;return writeGLArray(GLctx.getVertexAttrib(index,param),dst,dstLength,dstType);}_emscripten_webgl_get_vertex_attrib_v.sig="iiipii";var _emscripten_webgl_get_uniform_d=(program,location)=>GLctx.getUniform(GL.programs[program],webglGetUniformLocation(location));_emscripten_webgl_get_uniform_d.sig="dii";function _emscripten_webgl_get_uniform_v(program,location,dst,dstLength,dstType){dst>>>=0;return writeGLArray(GLctx.getUniform(GL.programs[program],webglGetUniformLocation(location)),dst,dstLength,dstType);}_emscripten_webgl_get_uniform_v.sig="iiipii";function _emscripten_webgl_get_parameter_v(param,dst,dstLength,dstType){dst>>>=0;return writeGLArray(GLctx.getParameter(param),dst,dstLength,dstType);}_emscripten_webgl_get_parameter_v.sig="iipii";var _emscripten_webgl_get_parameter_d=param=>GLctx.getParameter(param);_emscripten_webgl_get_parameter_d.sig="di";var _emscripten_webgl_get_parameter_o=param=>{var obj=GLctx.getParameter(param);return obj?.name;};_emscripten_webgl_get_parameter_o.sig="ii";function _emscripten_webgl_get_parameter_utf8(param){return stringToNewUTF8(GLctx.getParameter(param));}_emscripten_webgl_get_parameter_utf8.sig="pi";function _emscripten_webgl_get_parameter_i64v(param,dst){dst>>>=0;return writeI53ToI64(dst,GLctx.getParameter(param));}_emscripten_webgl_get_parameter_i64v.sig="vip";var _glutPostRedisplay=()=>{if(GLUT.displayFunc&&!GLUT.requestedAnimationFrame){GLUT.requestedAnimationFrame=true;Browser.requestAnimationFrame(()=>{GLUT.requestedAnimationFrame=false;Browser.mainLoop.runIter(()=>(()=>{})());});}};_glutPostRedisplay.sig="v";var GLUT={initTime:null,idleFunc:null,displayFunc:null,keyboardFunc:null,keyboardUpFunc:null,specialFunc:null,specialUpFunc:null,reshapeFunc:null,motionFunc:null,passiveMotionFunc:null,mouseFunc:null,buttons:0,modifiers:0,initWindowWidth:256,initWindowHeight:256,initDisplayMode:18,windowX:0,windowY:0,windowWidth:0,windowHeight:0,requestedAnimationFrame:false,saveModifiers:event=>{GLUT.modifiers=0;if(event["shiftKey"])GLUT.modifiers+=1;/* GLUT_ACTIVE_SHIFT */if(event["ctrlKey"])GLUT.modifiers+=2;/* GLUT_ACTIVE_CTRL */if(event["altKey"])GLUT.modifiers+=4;},/* GLUT_ACTIVE_ALT */onMousemove:event=>{/* Send motion event only if the motion changed, prevents
         * spamming our app with uncessary callback call. It does happen in
         * Chrome on Windows.
         */var lastX=Browser.mouseX;var lastY=Browser.mouseY;Browser.calculateMouseEvent(event);var newX=Browser.mouseX;var newY=Browser.mouseY;if(newX==lastX&&newY==lastY)return;if(GLUT.buttons==0&&event.target==Module["canvas"]&&GLUT.passiveMotionFunc){event.preventDefault();GLUT.saveModifiers(event);((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */lastX,lastY);}else if(GLUT.buttons!=0&&GLUT.motionFunc){event.preventDefault();GLUT.saveModifiers(event);((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */lastX,lastY);}},getSpecialKey:keycode=>{var key=null;switch(keycode){case 8:key=120;/* backspace */break;case 46:key=111;/* delete */break;case 112:/*DOM_VK_F1*/key=1;/* GLUT_KEY_F1 */break;case 113:/*DOM_VK_F2*/key=2;/* GLUT_KEY_F2 */break;case 114:/*DOM_VK_F3*/key=3;/* GLUT_KEY_F3 */break;case 115:/*DOM_VK_F4*/key=4;/* GLUT_KEY_F4 */break;case 116:/*DOM_VK_F5*/key=5;/* GLUT_KEY_F5 */break;case 117:/*DOM_VK_F6*/key=6;/* GLUT_KEY_F6 */break;case 118:/*DOM_VK_F7*/key=7;/* GLUT_KEY_F7 */break;case 119:/*DOM_VK_F8*/key=8;/* GLUT_KEY_F8 */break;case 120:/*DOM_VK_F9*/key=9;/* GLUT_KEY_F9 */break;case 121:/*DOM_VK_F10*/key=10;/* GLUT_KEY_F10 */break;case 122:/*DOM_VK_F11*/key=11;/* GLUT_KEY_F11 */break;case 123:/*DOM_VK_F12*/key=12;/* GLUT_KEY_F12 */break;case 37:/*DOM_VK_LEFT*/key=100;/* GLUT_KEY_LEFT */break;case 38:/*DOM_VK_UP*/key=101;/* GLUT_KEY_UP */break;case 39:/*DOM_VK_RIGHT*/key=102;/* GLUT_KEY_RIGHT */break;case 40:/*DOM_VK_DOWN*/key=103;/* GLUT_KEY_DOWN */break;case 33:/*DOM_VK_PAGE_UP*/key=104;/* GLUT_KEY_PAGE_UP */break;case 34:/*DOM_VK_PAGE_DOWN*/key=105;/* GLUT_KEY_PAGE_DOWN */break;case 36:/*DOM_VK_HOME*/key=106;/* GLUT_KEY_HOME */break;case 35:/*DOM_VK_END*/key=107;/* GLUT_KEY_END */break;case 45:/*DOM_VK_INSERT*/key=108;/* GLUT_KEY_INSERT */break;case 16:/*DOM_VK_SHIFT*/case 5:/*DOM_VK_LEFT_SHIFT*/key=112;/* GLUT_KEY_SHIFT_L */break;case 6:/*DOM_VK_RIGHT_SHIFT*/key=113;/* GLUT_KEY_SHIFT_R */break;case 17:/*DOM_VK_CONTROL*/case 3:/*DOM_VK_LEFT_CONTROL*/key=114;/* GLUT_KEY_CONTROL_L */break;case 4:/*DOM_VK_RIGHT_CONTROL*/key=115;/* GLUT_KEY_CONTROL_R */break;case 18:/*DOM_VK_ALT*/case 2:/*DOM_VK_LEFT_ALT*/key=116;/* GLUT_KEY_ALT_L */break;case 1:/*DOM_VK_RIGHT_ALT*/key=117;/* GLUT_KEY_ALT_R */break;}return key;},getASCIIKey:event=>{if(event["ctrlKey"]||event["altKey"]||event["metaKey"])return null;var keycode=event["keyCode"];/* The exact list is soooo hard to find in a canonical place! */if(48<=keycode&&keycode<=57)return keycode;// numeric  TODO handle shift?
if(65<=keycode&&keycode<=90)return event["shiftKey"]?keycode:keycode+32;if(96<=keycode&&keycode<=105)return keycode-48;// numpad numbers
if(106<=keycode&&keycode<=111)return keycode-106+42;// *,+-./  TODO handle shift?
switch(keycode){case 9:// tab key
case 13:// return key
case 27:// escape
case 32:// space
case 61:// equal
return keycode;}var s=event["shiftKey"];switch(keycode){case 186:return s?58:59;// colon / semi-colon
case 187:return s?43:61;// add / equal (these two may be wrong)
case 188:return s?60:44;// less-than / comma
case 189:return s?95:45;// dash
case 190:return s?62:46;// greater-than / period
case 191:return s?63:47;// forward slash
case 219:return s?123:91;// open bracket
case 220:return s?124:47;// back slash
case 221:return s?125:93;// close bracket
case 222:return s?34:39;}// single quote
return null;},onKeydown:event=>{if(GLUT.specialFunc||GLUT.keyboardFunc){var key=GLUT.getSpecialKey(event["keyCode"]);if(key!==null){if(GLUT.specialFunc){event.preventDefault();GLUT.saveModifiers(event);((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */key,Browser.mouseX,Browser.mouseY);}}else{key=GLUT.getASCIIKey(event);if(key!==null&&GLUT.keyboardFunc){event.preventDefault();GLUT.saveModifiers(event);((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */key,Browser.mouseX,Browser.mouseY);}}}},onKeyup:event=>{if(GLUT.specialUpFunc||GLUT.keyboardUpFunc){var key=GLUT.getSpecialKey(event["keyCode"]);if(key!==null){if(GLUT.specialUpFunc){event.preventDefault();GLUT.saveModifiers(event);((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */key,Browser.mouseX,Browser.mouseY);}}else{key=GLUT.getASCIIKey(event);if(key!==null&&GLUT.keyboardUpFunc){event.preventDefault();GLUT.saveModifiers(event);((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */key,Browser.mouseX,Browser.mouseY);}}}},touchHandler:event=>{if(event.target!=Module["canvas"]){return;}var touches=event.changedTouches,main=touches[0],type="";switch(event.type){case"touchstart":type="mousedown";break;case"touchmove":type="mousemove";break;case"touchend":type="mouseup";break;default:return;}var simulatedEvent=document.createEvent("MouseEvent");simulatedEvent.initMouseEvent(type,true,true,window,1,main.screenX,main.screenY,main.clientX,main.clientY,false,false,false,false,0,/*main*/null);main.target.dispatchEvent(simulatedEvent);event.preventDefault();},onMouseButtonDown:event=>{Browser.calculateMouseEvent(event);GLUT.buttons|=1<<event["button"];if(event.target==Module["canvas"]&&GLUT.mouseFunc){try{event.target.setCapture();}catch(e){}event.preventDefault();GLUT.saveModifiers(event);((a1,a2,a3,a4)=>{})(/* a dynamic function call to signature viiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */event["button"],0,/*GLUT_DOWN*/Browser.mouseX,Browser.mouseY);}},onMouseButtonUp:event=>{Browser.calculateMouseEvent(event);GLUT.buttons&=~(1<<event["button"]);if(GLUT.mouseFunc){event.preventDefault();GLUT.saveModifiers(event);((a1,a2,a3,a4)=>{})(/* a dynamic function call to signature viiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */event["button"],1,/*GLUT_UP*/Browser.mouseX,Browser.mouseY);}},onMouseWheel:event=>{Browser.calculateMouseEvent(event);// cross-browser wheel delta
var e=window.event||event;// old IE support
// Note the minus sign that flips browser wheel direction (positive direction scrolls page down) to native wheel direction (positive direction is mouse wheel up)
var delta=-Browser.getMouseWheelDelta(event);delta=delta==0?0:delta>0?Math.max(delta,1):Math.min(delta,-1);// Quantize to integer so that minimum scroll is at least +/- 1.
var button=3;// wheel up
if(delta<0){button=4;}// wheel down
if(GLUT.mouseFunc){event.preventDefault();GLUT.saveModifiers(event);((a1,a2,a3,a4)=>{})(/* a dynamic function call to signature viiii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */button,0,/*GLUT_DOWN*/Browser.mouseX,Browser.mouseY);}},onFullscreenEventChange:event=>{var width;var height;if(document["fullscreen"]||document["fullScreen"]||document["mozFullScreen"]||document["webkitIsFullScreen"]){width=screen["width"];height=screen["height"];}else{width=GLUT.windowWidth;height=GLUT.windowHeight;// TODO set position
document.removeEventListener("fullscreenchange",GLUT.onFullscreenEventChange,true);document.removeEventListener("mozfullscreenchange",GLUT.onFullscreenEventChange,true);document.removeEventListener("webkitfullscreenchange",GLUT.onFullscreenEventChange,true);}Browser.setCanvasSize(width,height,true);// N.B. GLUT.reshapeFunc is also registered as a canvas resize callback.
// Just call it once here.
/* Can't call _glutReshapeWindow as that requests cancelling fullscreen. */if(GLUT.reshapeFunc){// out("GLUT.reshapeFunc (from FS): " + width + ", " + height);
((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */width,height);}_glutPostRedisplay();}};var _glutGetModifiers=()=>GLUT.modifiers;_glutGetModifiers.sig="i";function _glutInit(argcp,argv){argcp>>>=0;argv>>>=0;// Ignore arguments
GLUT.initTime=Date.now();var isTouchDevice="ontouchstart"in document.documentElement;if(isTouchDevice){// onMouseButtonDown, onMouseButtonUp and onMousemove handlers
// depend on Browser.mouseX / Browser.mouseY fields. Those fields
// don't get updated by touch events. So register a touchHandler
// function that translates the touch events to mouse events.
// GLUT doesn't support touch, mouse only, so from touch events we
// are only looking at single finger touches to emulate left click,
// so we can use workaround and convert all touch events in mouse
// events. See touchHandler.
window.addEventListener("touchmove",GLUT.touchHandler,true);window.addEventListener("touchstart",GLUT.touchHandler,true);window.addEventListener("touchend",GLUT.touchHandler,true);}window.addEventListener("keydown",GLUT.onKeydown,true);window.addEventListener("keyup",GLUT.onKeyup,true);window.addEventListener("mousemove",GLUT.onMousemove,true);window.addEventListener("mousedown",GLUT.onMouseButtonDown,true);window.addEventListener("mouseup",GLUT.onMouseButtonUp,true);// IE9, Chrome, Safari, Opera
window.addEventListener("mousewheel",GLUT.onMouseWheel,true);// Firefox
window.addEventListener("DOMMouseScroll",GLUT.onMouseWheel,true);Browser.resizeListeners.push((width,height)=>{if(GLUT.reshapeFunc){((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */width,height);}});__ATEXIT__.push(()=>{if(isTouchDevice){window.removeEventListener("touchmove",GLUT.touchHandler,true);window.removeEventListener("touchstart",GLUT.touchHandler,true);window.removeEventListener("touchend",GLUT.touchHandler,true);}window.removeEventListener("keydown",GLUT.onKeydown,true);window.removeEventListener("keyup",GLUT.onKeyup,true);window.removeEventListener("mousemove",GLUT.onMousemove,true);window.removeEventListener("mousedown",GLUT.onMouseButtonDown,true);window.removeEventListener("mouseup",GLUT.onMouseButtonUp,true);// IE9, Chrome, Safari, Opera
window.removeEventListener("mousewheel",GLUT.onMouseWheel,true);// Firefox
window.removeEventListener("DOMMouseScroll",GLUT.onMouseWheel,true);Module["canvas"].width=Module["canvas"].height=1;});}_glutInit.sig="vpp";var _glutInitWindowSize=(width,height)=>{Browser.setCanvasSize(GLUT.initWindowWidth=width,GLUT.initWindowHeight=height);};_glutInitWindowSize.sig="vii";var _glutInitWindowPosition=(x,y)=>{};_glutInitWindowPosition.sig="vii";var _glutGet=type=>{switch(type){case 100:/* GLUT_WINDOW_X */return 0;/* TODO */case 101:/* GLUT_WINDOW_Y */return 0;/* TODO */case 102:/* GLUT_WINDOW_WIDTH */return Module["canvas"].width;case 103:/* GLUT_WINDOW_HEIGHT */return Module["canvas"].height;case 200:/* GLUT_SCREEN_WIDTH */return Module["canvas"].width;case 201:/* GLUT_SCREEN_HEIGHT */return Module["canvas"].height;case 500:/* GLUT_INIT_WINDOW_X */return 0;/* TODO */case 501:/* GLUT_INIT_WINDOW_Y */return 0;/* TODO */case 502:/* GLUT_INIT_WINDOW_WIDTH */return GLUT.initWindowWidth;case 503:/* GLUT_INIT_WINDOW_HEIGHT */return GLUT.initWindowHeight;case 700:/* GLUT_ELAPSED_TIME */var now=Date.now();return now-GLUT.initTime;case 105:/* GLUT_WINDOW_STENCIL_SIZE */return Module.ctx.getContextAttributes().stencil?8:0;case 106:/* GLUT_WINDOW_DEPTH_SIZE */return Module.ctx.getContextAttributes().depth?8:0;case 110:/* GLUT_WINDOW_ALPHA_SIZE */return Module.ctx.getContextAttributes().alpha?8:0;case 120:/* GLUT_WINDOW_NUM_SAMPLES */return Module.ctx.getContextAttributes().antialias?1:0;default:throw"glutGet("+type+") not implemented yet";}};_glutGet.sig="ii";var _glutIdleFunc=function(func){func>>>=0;function callback(){if(GLUT.idleFunc){(()=>{})();/* a dynamic function call to signature v, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */safeSetTimeout(callback,4);}}// HTML spec specifies a 4ms minimum delay on the main thread; workers might get more, but we standardize here
if(!GLUT.idleFunc){safeSetTimeout(callback,0);}GLUT.idleFunc=func;};_glutIdleFunc.sig="vp";var _glutTimerFunc=function(msec,func,value){func>>>=0;return safeSetTimeout(()=>(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */value),msec);};_glutTimerFunc.sig="vipi";function _glutDisplayFunc(func){func>>>=0;GLUT.displayFunc=func;}_glutDisplayFunc.sig="vp";function _glutKeyboardFunc(func){func>>>=0;GLUT.keyboardFunc=func;}_glutKeyboardFunc.sig="vp";function _glutKeyboardUpFunc(func){func>>>=0;GLUT.keyboardUpFunc=func;}_glutKeyboardUpFunc.sig="vp";function _glutSpecialFunc(func){func>>>=0;GLUT.specialFunc=func;}_glutSpecialFunc.sig="vp";function _glutSpecialUpFunc(func){func>>>=0;GLUT.specialUpFunc=func;}_glutSpecialUpFunc.sig="vp";function _glutReshapeFunc(func){func>>>=0;GLUT.reshapeFunc=func;}_glutReshapeFunc.sig="vp";function _glutMotionFunc(func){func>>>=0;GLUT.motionFunc=func;}_glutMotionFunc.sig="vp";function _glutPassiveMotionFunc(func){func>>>=0;GLUT.passiveMotionFunc=func;}_glutPassiveMotionFunc.sig="vp";function _glutMouseFunc(func){func>>>=0;GLUT.mouseFunc=func;}_glutMouseFunc.sig="vp";var _glutSetCursor=cursor=>{var cursorStyle="auto";switch(cursor){case 0:/* GLUT_CURSOR_RIGHT_ARROW */// No equivalent css cursor style, fallback to 'auto'
break;case 1:/* GLUT_CURSOR_LEFT_ARROW */// No equivalent css cursor style, fallback to 'auto'
break;case 2:/* GLUT_CURSOR_INFO */cursorStyle="pointer";break;case 3:/* GLUT_CURSOR_DESTROY */// No equivalent css cursor style, fallback to 'auto'
break;case 4:/* GLUT_CURSOR_HELP */cursorStyle="help";break;case 5:/* GLUT_CURSOR_CYCLE */// No equivalent css cursor style, fallback to 'auto'
break;case 6:/* GLUT_CURSOR_SPRAY */// No equivalent css cursor style, fallback to 'auto'
break;case 7:/* GLUT_CURSOR_WAIT */cursorStyle="wait";break;case 8:/* GLUT_CURSOR_TEXT */cursorStyle="text";break;case 9:/* GLUT_CURSOR_CROSSHAIR */case 102:/* GLUT_CURSOR_FULL_CROSSHAIR */cursorStyle="crosshair";break;case 10:/* GLUT_CURSOR_UP_DOWN */cursorStyle="ns-resize";break;case 11:/* GLUT_CURSOR_LEFT_RIGHT */cursorStyle="ew-resize";break;case 12:/* GLUT_CURSOR_TOP_SIDE */cursorStyle="n-resize";break;case 13:/* GLUT_CURSOR_BOTTOM_SIDE */cursorStyle="s-resize";break;case 14:/* GLUT_CURSOR_LEFT_SIDE */cursorStyle="w-resize";break;case 15:/* GLUT_CURSOR_RIGHT_SIDE */cursorStyle="e-resize";break;case 16:/* GLUT_CURSOR_TOP_LEFT_CORNER */cursorStyle="nw-resize";break;case 17:/* GLUT_CURSOR_TOP_RIGHT_CORNER */cursorStyle="ne-resize";break;case 18:/* GLUT_CURSOR_BOTTOM_RIGHT_CORNER */cursorStyle="se-resize";break;case 19:/* GLUT_CURSOR_BOTTOM_LEFT_CORNER */cursorStyle="sw-resize";break;case 100:/* GLUT_CURSOR_INHERIT */break;case 101:/* GLUT_CURSOR_NONE */cursorStyle="none";break;default:throw"glutSetCursor: Unknown cursor type: "+cursor;}Module["canvas"].style.cursor=cursorStyle;};_glutSetCursor.sig="vi";function _glutCreateWindow(name){name>>>=0;var contextAttributes={antialias:(GLUT.initDisplayMode&128)!=/*GLUT_MULTISAMPLE*/0,depth:(GLUT.initDisplayMode&16)!=/*GLUT_DEPTH*/0,stencil:(GLUT.initDisplayMode&32)!=/*GLUT_STENCIL*/0,alpha:(GLUT.initDisplayMode&8)!=/*GLUT_ALPHA*/0};Module.ctx=Browser.createContext(Module["canvas"],true,true,contextAttributes);return Module.ctx?1:/* a new GLUT window ID for the created context */0;}_glutCreateWindow.sig="ip";var _glutDestroyWindow=name=>{delete Module.ctx;return 1;};_glutDestroyWindow.sig="vi";var _glutReshapeWindow=(width,height)=>{Browser.exitFullscreen();Browser.setCanvasSize(width,height,true);// N.B. GLUT.reshapeFunc is also registered as a canvas resize callback.
// Just call it once here.
if(GLUT.reshapeFunc){((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */width,height);}_glutPostRedisplay();};_glutReshapeWindow.sig="vii";var _glutPositionWindow=(x,y)=>{Browser.exitFullscreen();/* TODO */_glutPostRedisplay();};_glutPositionWindow.sig="vii";var _glutFullScreen=()=>{GLUT.windowX=0;// TODO
GLUT.windowY=0;// TODO
GLUT.windowWidth=Module["canvas"].width;GLUT.windowHeight=Module["canvas"].height;document.addEventListener("fullscreenchange",GLUT.onFullscreenEventChange,true);document.addEventListener("mozfullscreenchange",GLUT.onFullscreenEventChange,true);document.addEventListener("webkitfullscreenchange",GLUT.onFullscreenEventChange,true);Browser.requestFullscreen(/*lockPointer=*/false,/*resizeCanvas=*/false);};_glutFullScreen.sig="v";var _glutInitDisplayMode=mode=>GLUT.initDisplayMode=mode;_glutInitDisplayMode.sig="vi";var _glutSwapBuffers=()=>{};_glutSwapBuffers.sig="v";var _glutMainLoop=()=>{_glutReshapeWindow(Module["canvas"].width,Module["canvas"].height);_glutPostRedisplay();throw"unwind";};_glutMainLoop.sig="v";function _XOpenDisplay(name){name>>>=0;return 1;}_XOpenDisplay.sig="pp";function _XCreateWindow(display,parent,x,y,width,height,border_width,depth,class_,visual,valuemask,attributes){display>>>=0;parent>>>=0;visual>>>=0;valuemask>>>=0;attributes>>>=0;// All we can do is set the width and height
Browser.setCanvasSize(width,height);return 2;}_XCreateWindow.sig="pppiiiiiiippp";function _XChangeWindowAttributes(display,window,valuemask,attributes){display>>>=0;window>>>=0;valuemask>>>=0;attributes>>>=0;}_XChangeWindowAttributes.sig="ipppp";function _XSetWMHints(display,win,hints){display>>>=0;win>>>=0;hints>>>=0;}_XSetWMHints.sig="ippp";function _XMapWindow(display,win){display>>>=0;win>>>=0;}_XMapWindow.sig="ipp";function _XStoreName(display,win,name){display>>>=0;win>>>=0;name>>>=0;}_XStoreName.sig="ippp";function _XInternAtom(display,name_,hmm){display>>>=0;name_>>>=0;return 0;}_XInternAtom.sig="pppi";function _XSendEvent(display,win,propagate,event_mask,even_send){display>>>=0;win>>>=0;event_mask>>>=0;even_send>>>=0;}_XSendEvent.sig="ippipp";function _XPending(display){display>>>=0;return 0;}_XPending.sig="ip";var EGL={errorCode:12288,defaultDisplayInitialized:false,currentContext:0,currentReadSurface:0,currentDrawSurface:0,contextAttributes:{alpha:false,depth:false,stencil:false,antialias:false},stringCache:{},setErrorCode(code){EGL.errorCode=code;},chooseConfig(display,attribList,config,config_size,numConfigs){if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}if(attribList){// read attribList if it is non-null
for(;;){var param=HEAP32[attribList>>>2>>>0];if(param==12321)/*EGL_ALPHA_SIZE*/{var alphaSize=HEAP32[attribList+4>>>2>>>0];EGL.contextAttributes.alpha=alphaSize>0;}else if(param==12325)/*EGL_DEPTH_SIZE*/{var depthSize=HEAP32[attribList+4>>>2>>>0];EGL.contextAttributes.depth=depthSize>0;}else if(param==12326)/*EGL_STENCIL_SIZE*/{var stencilSize=HEAP32[attribList+4>>>2>>>0];EGL.contextAttributes.stencil=stencilSize>0;}else if(param==12337)/*EGL_SAMPLES*/{var samples=HEAP32[attribList+4>>>2>>>0];EGL.contextAttributes.antialias=samples>0;}else if(param==12338)/*EGL_SAMPLE_BUFFERS*/{var samples=HEAP32[attribList+4>>>2>>>0];EGL.contextAttributes.antialias=samples==1;}else if(param==12544)/*EGL_CONTEXT_PRIORITY_LEVEL_IMG*/{var requestedPriority=HEAP32[attribList+4>>>2>>>0];EGL.contextAttributes.lowLatency=requestedPriority!=12547;}else if(param==12344)/*EGL_NONE*/{break;}attribList+=8;}}if((!config||!config_size)&&!numConfigs){EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0;}if(numConfigs){HEAP32[numConfigs>>>2>>>0]=1;}// Total number of supported configs: 1.
if(config&&config_size>0){HEAPU32[config>>>2>>>0]=62002;}EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;}};function _eglGetDisplay(nativeDisplayType){nativeDisplayType>>>=0;EGL.setErrorCode(12288);// Emscripten EGL implementation "emulates" X11, and eglGetDisplay is
// expected to accept/receive a pointer to an X11 Display object (or
// EGL_DEFAULT_DISPLAY).
if(nativeDisplayType!=0&&/* EGL_DEFAULT_DISPLAY */nativeDisplayType!=1)/* see library_xlib.js */{return 0;}// EGL_NO_DISPLAY
return 62e3;}_eglGetDisplay.sig="pp";function _eglInitialize(display,majorVersion,minorVersion){display>>>=0;majorVersion>>>=0;minorVersion>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}if(majorVersion){HEAP32[majorVersion>>>2>>>0]=1;}// Advertise EGL Major version: '1'
if(minorVersion){HEAP32[minorVersion>>>2>>>0]=4;}// Advertise EGL Minor version: '4'
EGL.defaultDisplayInitialized=true;EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;}_eglInitialize.sig="ippp";function _eglTerminate(display){display>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}EGL.currentContext=0;EGL.currentReadSurface=0;EGL.currentDrawSurface=0;EGL.defaultDisplayInitialized=false;EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;}_eglTerminate.sig="ip";function _eglGetConfigs(display,configs,config_size,numConfigs){display>>>=0;configs>>>=0;numConfigs>>>=0;return EGL.chooseConfig(display,0,configs,config_size,numConfigs);}_eglGetConfigs.sig="ippip";function _eglChooseConfig(display,attrib_list,configs,config_size,numConfigs){display>>>=0;attrib_list>>>=0;configs>>>=0;numConfigs>>>=0;return EGL.chooseConfig(display,attrib_list,configs,config_size,numConfigs);}_eglChooseConfig.sig="ipppip";function _eglGetConfigAttrib(display,config,attribute,value){display>>>=0;config>>>=0;value>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}if(config!=62002){EGL.setErrorCode(12293);/* EGL_BAD_CONFIG */return 0;}if(!value){EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0;}EGL.setErrorCode(12288);/* EGL_SUCCESS */switch(attribute){case 12320:// EGL_BUFFER_SIZE
HEAP32[value>>>2>>>0]=EGL.contextAttributes.alpha?32:24;return 1;case 12321:// EGL_ALPHA_SIZE
HEAP32[value>>>2>>>0]=EGL.contextAttributes.alpha?8:0;return 1;case 12322:// EGL_BLUE_SIZE
HEAP32[value>>>2>>>0]=8;return 1;case 12323:// EGL_GREEN_SIZE
HEAP32[value>>>2>>>0]=8;return 1;case 12324:// EGL_RED_SIZE
HEAP32[value>>>2>>>0]=8;return 1;case 12325:// EGL_DEPTH_SIZE
HEAP32[value>>>2>>>0]=EGL.contextAttributes.depth?24:0;return 1;case 12326:// EGL_STENCIL_SIZE
HEAP32[value>>>2>>>0]=EGL.contextAttributes.stencil?8:0;return 1;case 12327:// EGL_CONFIG_CAVEAT
// We can return here one of EGL_NONE (0x3038), EGL_SLOW_CONFIG (0x3050) or EGL_NON_CONFORMANT_CONFIG (0x3051).
HEAP32[value>>>2>>>0]=12344;return 1;case 12328:// EGL_CONFIG_ID
HEAP32[value>>>2>>>0]=62002;return 1;case 12329:// EGL_LEVEL
HEAP32[value>>>2>>>0]=0;return 1;case 12330:// EGL_MAX_PBUFFER_HEIGHT
HEAP32[value>>>2>>>0]=4096;return 1;case 12331:// EGL_MAX_PBUFFER_PIXELS
HEAP32[value>>>2>>>0]=16777216;return 1;case 12332:// EGL_MAX_PBUFFER_WIDTH
HEAP32[value>>>2>>>0]=4096;return 1;case 12333:// EGL_NATIVE_RENDERABLE
HEAP32[value>>>2>>>0]=0;return 1;case 12334:// EGL_NATIVE_VISUAL_ID
HEAP32[value>>>2>>>0]=0;return 1;case 12335:// EGL_NATIVE_VISUAL_TYPE
HEAP32[value>>>2>>>0]=12344;return 1;case 12337:// EGL_SAMPLES
HEAP32[value>>>2>>>0]=EGL.contextAttributes.antialias?4:0;return 1;case 12338:// EGL_SAMPLE_BUFFERS
HEAP32[value>>>2>>>0]=EGL.contextAttributes.antialias?1:0;return 1;case 12339:// EGL_SURFACE_TYPE
HEAP32[value>>>2>>>0]=4;return 1;case 12340:// EGL_TRANSPARENT_TYPE
// If this returns EGL_TRANSPARENT_RGB (0x3052), transparency is used through color-keying. No such thing applies to Emscripten canvas.
HEAP32[value>>>2>>>0]=12344;return 1;case 12341:// EGL_TRANSPARENT_BLUE_VALUE
case 12342:// EGL_TRANSPARENT_GREEN_VALUE
case 12343:// EGL_TRANSPARENT_RED_VALUE
// "If EGL_TRANSPARENT_TYPE is EGL_NONE, then the values for EGL_TRANSPARENT_RED_VALUE, EGL_TRANSPARENT_GREEN_VALUE, and EGL_TRANSPARENT_BLUE_VALUE are undefined."
HEAP32[value>>>2>>>0]=-1;return 1;case 12345:// EGL_BIND_TO_TEXTURE_RGB
case 12346:// EGL_BIND_TO_TEXTURE_RGBA
HEAP32[value>>>2>>>0]=0;return 1;case 12347:// EGL_MIN_SWAP_INTERVAL
HEAP32[value>>>2>>>0]=0;return 1;case 12348:// EGL_MAX_SWAP_INTERVAL
HEAP32[value>>>2>>>0]=1;return 1;case 12349:// EGL_LUMINANCE_SIZE
case 12350:// EGL_ALPHA_MASK_SIZE
HEAP32[value>>>2>>>0]=0;return 1;case 12351:// EGL_COLOR_BUFFER_TYPE
// EGL has two types of buffers: EGL_RGB_BUFFER and EGL_LUMINANCE_BUFFER.
HEAP32[value>>>2>>>0]=12430;return 1;case 12352:// EGL_RENDERABLE_TYPE
// A bit combination of EGL_OPENGL_ES_BIT,EGL_OPENVG_BIT,EGL_OPENGL_ES2_BIT and EGL_OPENGL_BIT.
HEAP32[value>>>2>>>0]=4;return 1;case 12354:// EGL_CONFORMANT
// "EGL_CONFORMANT is a mask indicating if a client API context created with respect to the corresponding EGLConfig will pass the required conformance tests for that API."
HEAP32[value>>>2>>>0]=0;return 1;default:EGL.setErrorCode(12292);/* EGL_BAD_ATTRIBUTE */return 0;}}_eglGetConfigAttrib.sig="ippip";function _eglCreateWindowSurface(display,config,win,attrib_list){display>>>=0;config>>>=0;attrib_list>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}if(config!=62002){EGL.setErrorCode(12293);/* EGL_BAD_CONFIG */return 0;}// TODO: Examine attrib_list! Parameters that can be present there are:
// - EGL_RENDER_BUFFER (must be EGL_BACK_BUFFER)
// - EGL_VG_COLORSPACE (can't be set)
// - EGL_VG_ALPHA_FORMAT (can't be set)
EGL.setErrorCode(12288);/* EGL_SUCCESS */return 62006;}_eglCreateWindowSurface.sig="pppip";function _eglDestroySurface(display,surface){display>>>=0;surface>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}if(surface!=62006)/* Magic ID for the only EGLSurface supported by Emscripten */{EGL.setErrorCode(12301);/* EGL_BAD_SURFACE */return 1;}if(EGL.currentReadSurface==surface){EGL.currentReadSurface=0;}if(EGL.currentDrawSurface==surface){EGL.currentDrawSurface=0;}EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;}_eglDestroySurface.sig="ipp";function _eglCreateContext(display,config,hmm,contextAttribs){display>>>=0;config>>>=0;hmm>>>=0;contextAttribs>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}// EGL 1.4 spec says default EGL_CONTEXT_CLIENT_VERSION is GLES1, but this is not supported by Emscripten.
// So user must pass EGL_CONTEXT_CLIENT_VERSION == 2 to initialize EGL.
var glesContextVersion=1;for(;;){var param=HEAP32[contextAttribs>>>2>>>0];if(param==12440)/*EGL_CONTEXT_CLIENT_VERSION*/{glesContextVersion=HEAP32[contextAttribs+4>>>2>>>0];}else if(param==12344)/*EGL_NONE*/{break;}else{/* EGL1.4 specifies only EGL_CONTEXT_CLIENT_VERSION as supported attribute */EGL.setErrorCode(12292);/*EGL_BAD_ATTRIBUTE*/return 0;}contextAttribs+=8;}if(glesContextVersion!=2){EGL.setErrorCode(12293);/* EGL_BAD_CONFIG */return 0;}/* EGL_NO_CONTEXT */EGL.contextAttributes.majorVersion=glesContextVersion-1;// WebGL 1 is GLES 2, WebGL2 is GLES3
EGL.contextAttributes.minorVersion=0;EGL.context=GL.createContext(Module["canvas"],EGL.contextAttributes);if(EGL.context!=0){EGL.setErrorCode(12288);// Run callbacks so that GL emulation works
GL.makeContextCurrent(EGL.context);Browser.useWebGL=true;Browser.moduleContextCreatedCallbacks.forEach(callback=>callback());// Note: This function only creates a context, but it shall not make it active.
GL.makeContextCurrent(null);return 62004;}else{EGL.setErrorCode(12297);// By the EGL 1.4 spec, an implementation that does not support GLES2 (WebGL in this case), this error code is set.
return 0;}}_eglCreateContext.sig="ppppp";function _eglDestroyContext(display,context){display>>>=0;context>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}if(context!=62004){EGL.setErrorCode(12294);/* EGL_BAD_CONTEXT */return 0;}GL.deleteContext(EGL.context);EGL.setErrorCode(12288);/* EGL_SUCCESS */if(EGL.currentContext==context){EGL.currentContext=0;}return 1;}_eglDestroyContext.sig="ipp";function _eglQuerySurface(display,surface,attribute,value){display>>>=0;surface>>>=0;value>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}if(surface!=62006)/* Magic ID for Emscripten 'default surface' */{EGL.setErrorCode(12301);/* EGL_BAD_SURFACE */return 0;}if(!value){EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0;}EGL.setErrorCode(12288);/* EGL_SUCCESS */switch(attribute){case 12328:// EGL_CONFIG_ID
HEAP32[value>>>2>>>0]=62002;return 1;case 12376:// EGL_LARGEST_PBUFFER
// Odd EGL API: If surface is not a pbuffer surface, 'value' should not be written to. It's not specified as an error, so true should(?) be returned.
// Existing Android implementation seems to do so at least.
return 1;case 12375:// EGL_WIDTH
HEAP32[value>>>2>>>0]=Module["canvas"].width;return 1;case 12374:// EGL_HEIGHT
HEAP32[value>>>2>>>0]=Module["canvas"].height;return 1;case 12432:// EGL_HORIZONTAL_RESOLUTION
HEAP32[value>>>2>>>0]=-1;return 1;case 12433:// EGL_VERTICAL_RESOLUTION
HEAP32[value>>>2>>>0]=-1;return 1;case 12434:// EGL_PIXEL_ASPECT_RATIO
HEAP32[value>>>2>>>0]=-1;return 1;case 12422:// EGL_RENDER_BUFFER
// The main surface is bound to the visible canvas window - it's always backbuffered.
// Alternative to EGL_BACK_BUFFER would be EGL_SINGLE_BUFFER.
HEAP32[value>>>2>>>0]=12420;return 1;case 12441:// EGL_MULTISAMPLE_RESOLVE
HEAP32[value>>>2>>>0]=12442;return 1;case 12435:// EGL_SWAP_BEHAVIOR
// The two possibilities are EGL_BUFFER_PRESERVED and EGL_BUFFER_DESTROYED. Slightly unsure which is the
// case for browser environment, but advertise the 'weaker' behavior to be sure.
HEAP32[value>>>2>>>0]=12437;return 1;case 12416:// EGL_TEXTURE_FORMAT
case 12417:// EGL_TEXTURE_TARGET
case 12418:// EGL_MIPMAP_TEXTURE
case 12419:// EGL_MIPMAP_LEVEL
// This is a window surface, not a pbuffer surface. Spec:
// "Querying EGL_TEXTURE_FORMAT, EGL_TEXTURE_TARGET, EGL_MIPMAP_TEXTURE, or EGL_MIPMAP_LEVEL for a non-pbuffer surface is not an error, but value is not modified."
// So pass-through.
return 1;default:EGL.setErrorCode(12292);/* EGL_BAD_ATTRIBUTE */return 0;}}_eglQuerySurface.sig="ippip";function _eglQueryContext(display,context,attribute,value){display>>>=0;context>>>=0;value>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}//\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
if(context!=62004){EGL.setErrorCode(12294);/* EGL_BAD_CONTEXT */return 0;}if(!value){EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0;}EGL.setErrorCode(12288);/* EGL_SUCCESS */switch(attribute){case 12328:// EGL_CONFIG_ID
HEAP32[value>>>2>>>0]=62002;return 1;case 12439:// EGL_CONTEXT_CLIENT_TYPE
HEAP32[value>>>2>>>0]=12448;return 1;case 12440:// EGL_CONTEXT_CLIENT_VERSION
HEAP32[value>>>2>>>0]=EGL.contextAttributes.majorVersion+1;return 1;case 12422:// EGL_RENDER_BUFFER
// The context is bound to the visible canvas window - it's always backbuffered.
// Alternative to EGL_BACK_BUFFER would be EGL_SINGLE_BUFFER.
HEAP32[value>>>2>>>0]=12420;return 1;default:EGL.setErrorCode(12292);/* EGL_BAD_ATTRIBUTE */return 0;}}_eglQueryContext.sig="ippip";var _eglGetError=()=>EGL.errorCode;_eglGetError.sig="i";function _eglQueryString(display,name){display>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}//\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
EGL.setErrorCode(12288);/* EGL_SUCCESS */if(EGL.stringCache[name])return EGL.stringCache[name];var ret;switch(name){case 12371:/* EGL_VENDOR */ret=stringToNewUTF8("Emscripten");break;case 12372:/* EGL_VERSION */ret=stringToNewUTF8("1.4 Emscripten EGL");break;case 12373:/* EGL_EXTENSIONS */ret=stringToNewUTF8("");break;// Currently not supporting any EGL extensions.
case 12429:/* EGL_CLIENT_APIS */ret=stringToNewUTF8("OpenGL_ES");break;default:EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0;}EGL.stringCache[name]=ret;return ret;}_eglQueryString.sig="ppi";var _eglBindAPI=api=>{if(api==12448)/* EGL_OPENGL_ES_API */{EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;}// if (api == 0x30A1 /* EGL_OPENVG_API */ || api == 0x30A2 /* EGL_OPENGL_API */) {
EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0;};_eglBindAPI.sig="ii";var _eglQueryAPI=()=>{EGL.setErrorCode(12288);/* EGL_SUCCESS */return 12448;};// EGL_OPENGL_ES_API
_eglQueryAPI.sig="i";var _eglWaitClient=()=>{EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;};_eglWaitClient.sig="i";var _eglWaitNative=nativeEngineId=>{EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;};_eglWaitNative.sig="ii";var _eglWaitGL=_eglWaitClient;_eglWaitGL.sig="i";function _eglSwapInterval(display,interval){display>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}if(interval==0)_emscripten_set_main_loop_timing(0,0);else _emscripten_set_main_loop_timing(1,interval);EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;}_eglSwapInterval.sig="ipi";function _eglMakeCurrent(display,draw,read,context){display>>>=0;draw>>>=0;read>>>=0;context>>>=0;if(display!=62e3){EGL.setErrorCode(12296);/* EGL_BAD_DISPLAY */return 0;}//\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
if(context!=0&&context!=62004){EGL.setErrorCode(12294);/* EGL_BAD_CONTEXT */return 0;}if(read!=0&&read!=62006||draw!=0&&draw!=62006)/* Magic ID for Emscripten 'default surface' */{EGL.setErrorCode(12301);/* EGL_BAD_SURFACE */return 0;}GL.makeContextCurrent(context?EGL.context:null);EGL.currentContext=context;EGL.currentDrawSurface=draw;EGL.currentReadSurface=read;EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;}_eglMakeCurrent.sig="ipppp";function _eglGetCurrentContext(){return EGL.currentContext;}_eglGetCurrentContext.sig="p";function _eglGetCurrentSurface(readdraw){if(readdraw==12378)/* EGL_READ */{return EGL.currentReadSurface;}else if(readdraw==12377)/* EGL_DRAW */{return EGL.currentDrawSurface;}else{EGL.setErrorCode(12300);/* EGL_BAD_PARAMETER */return 0;}}_eglGetCurrentSurface.sig="pi";function _eglGetCurrentDisplay(){return EGL.currentContext?62e3:0;}_eglGetCurrentDisplay.sig="p";function _eglSwapBuffers(dpy,surface){dpy>>>=0;surface>>>=0;if(!EGL.defaultDisplayInitialized){EGL.setErrorCode(12289);}else/* EGL_NOT_INITIALIZED */if(!Module.ctx){EGL.setErrorCode(12290);}else/* EGL_BAD_ACCESS */if(Module.ctx.isContextLost()){EGL.setErrorCode(12302);}else/* EGL_CONTEXT_LOST */{// According to documentation this does an implicit flush.
// Due to discussion at https://github.com/emscripten-core/emscripten/pull/1871
// the flush was removed since this _may_ result in slowing code down.
//_glFlush();
EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;}/* EGL_TRUE */return 0;}_eglSwapBuffers.sig="ipp";var _eglReleaseThread=()=>{// Equivalent to eglMakeCurrent with EGL_NO_CONTEXT and EGL_NO_SURFACE.
EGL.currentContext=0;EGL.currentReadSurface=0;EGL.currentDrawSurface=0;// EGL spec v1.4 p.55:
// "calling eglGetError immediately following a successful call to eglReleaseThread should not be done.
//  Such a call will return EGL_SUCCESS - but will also result in reallocating per-thread state."
EGL.setErrorCode(12288);/* EGL_SUCCESS */return 1;};/* EGL_TRUE */_eglReleaseThread.sig="i";function _uuid_clear(uu){uu>>>=0;return zeroMemory(uu,16);}_uuid_clear.sig="vp";function _uuid_compare(uu1,uu2){uu1>>>=0;uu2>>>=0;return _memcmp(uu1,uu2,16);}_uuid_compare.sig="ipp";function _uuid_copy(dst,src){dst>>>=0;src>>>=0;return _memcpy(dst,src,16);}_uuid_copy.sig="vpp";function _uuid_generate(out){out>>>=0;// void uuid_generate(uuid_t out);
var uuid=null;if(ENVIRONMENT_IS_NODE){}else if(ENVIRONMENT_IS_WEB&&typeof window.crypto!="undefined"&&typeof window.crypto.getRandomValues!="undefined"){// If crypto.getRandomValues is available try to use it.
uuid=new Uint8Array(16);window.crypto.getRandomValues(uuid);}// Fall back to Math.random if a higher quality random number generator is not available.
if(!uuid){uuid=new Array(16);var d=new Date().getTime();for(var i=0;i<16;i++){var r=(d+Math.random()*256)%256|0;d=d/256|0;uuid[i]=r;}}// Makes uuid compliant to RFC-4122
uuid[6]=uuid[6]&15|64;// uuid version
uuid[8]=uuid[8]&63|128;// uuid variant
writeArrayToMemory(uuid,out);}_uuid_generate.sig="vp";function _uuid_is_null(uu){uu>>>=0;// int uuid_is_null(const uuid_t uu);
for(var i=0;i<4;i++,uu=uu+4|0){var val=HEAP32[uu>>>2>>>0];if(val){return 0;}}return 1;}_uuid_is_null.sig="ip";function _uuid_parse(inp,uu){inp>>>=0;uu>>>=0;// int uuid_parse(const char *in, uuid_t uu);
inp=UTF8ToString(inp);if(inp.length===36){var i=0;var uuid=new Array(16);inp.toLowerCase().replace(/[0-9a-f]{2}/g,function(byte){if(i<16){uuid[i++]=parseInt(byte,16);}});if(i<16){return-1;}writeArrayToMemory(uuid,uu);return 0;}return-1;}_uuid_parse.sig="ipp";/** @param {number|boolean=} upper */function _uuid_unparse(uu,out,upper){uu>>>=0;out>>>=0;// void uuid_unparse(const uuid_t uu, char *out);
var i=0;var uuid="xxxx-xx-xx-xx-xxxxxx".replace(/[x]/g,function(c){var r=upper?HEAPU8[uu+i>>>0].toString(16).toUpperCase():HEAPU8[uu+i>>>0].toString(16);r=r.length===1?"0"+r:r;// Zero pad single digit hex values
i++;return r;});stringToUTF8(uuid,out,37);}_uuid_unparse.sig="vpp";function _uuid_unparse_lower(uu,out){uu>>>=0;out>>>=0;// void uuid_unparse_lower(const uuid_t uu, char *out);
_uuid_unparse(uu,out);}_uuid_unparse_lower.sig="vpp";function _uuid_unparse_upper(uu,out){uu>>>=0;out>>>=0;// void uuid_unparse_upper(const uuid_t uu, char *out);
_uuid_unparse(uu,out,true);}_uuid_unparse_upper.sig="vpp";function _uuid_type(uu){uu>>>=0;return 4;}_uuid_type.sig="ip";function _uuid_variant(uu){uu>>>=0;return 1;}_uuid_variant.sig="ip";var GLEW={isLinaroFork:1,extensions:null,error:{0:null,1:null,2:null,3:null,4:null,5:null,6:null,7:null,8:null},version:{1:null,2:null,3:null,4:null},errorStringConstantFromCode(error){if(GLEW.isLinaroFork){switch(error){case 4:return"OpenGL ES lib expected, found OpenGL lib";// GLEW_ERROR_NOT_GLES_VERSION
case 5:return"OpenGL lib expected, found OpenGL ES lib";// GLEW_ERROR_GLES_VERSION
case 6:return"Missing EGL version";// GLEW_ERROR_NO_EGL_VERSION
case 7:return"EGL 1.1 and up are supported";// GLEW_ERROR_EGL_VERSION_10_ONLY
default:break;}}switch(error){case 0:return"No error";// GLEW_OK || GLEW_NO_ERROR
case 1:return"Missing GL version";// GLEW_ERROR_NO_GL_VERSION
case 2:return"GL 1.1 and up are supported";// GLEW_ERROR_GL_VERSION_10_ONLY
case 3:return"GLX 1.2 and up are supported";// GLEW_ERROR_GLX_VERSION_11_ONLY
default:return null;}},errorString(error){if(!GLEW.error[error]){var string=GLEW.errorStringConstantFromCode(error);if(!string){string="Unknown error";error=8;}// prevent array from growing more than this
GLEW.error[error]=stringToNewUTF8(string);}return GLEW.error[error];},versionStringConstantFromCode(name){switch(name){case 1:return"1.10.0";// GLEW_VERSION
case 2:return"1";// GLEW_VERSION_MAJOR
case 3:return"10";// GLEW_VERSION_MINOR
case 4:return"0";// GLEW_VERSION_MICRO
default:return null;}},versionString(name){if(!GLEW.version[name]){var string=GLEW.versionStringConstantFromCode(name);if(!string)return 0;GLEW.version[name]=stringToNewUTF8(string);}return GLEW.version[name];},extensionIsSupported(name){GLEW.extensions||=webglGetExtensions();if(GLEW.extensions.includes(name))return 1;// extensions from GLEmulations do not come unprefixed
// so, try with prefix
return GLEW.extensions.includes("GL_"+name);}};var _glewInit=()=>0;_glewInit.sig="i";function _glewIsSupported(name){name>>>=0;var exts=UTF8ToString(name).split(" ");for(var i=0;i<exts.length;++i){if(!GLEW.extensionIsSupported(exts[i]))return 0;}return 1;}_glewIsSupported.sig="ip";function _glewGetExtension(name){name>>>=0;return GLEW.extensionIsSupported(UTF8ToString(name));}_glewGetExtension.sig="ip";function _glewGetErrorString(error){return GLEW.errorString(error);}_glewGetErrorString.sig="pi";function _glewGetString(name){return GLEW.versionString(name);}_glewGetString.sig="pi";var IDBStore={indexedDB(){if(typeof indexedDB!="undefined")return indexedDB;var ret=null;if(typeof window=="object")ret=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB;assert(ret,"IDBStore used, but indexedDB not supported");return ret;},DB_VERSION:22,DB_STORE_NAME:"FILE_DATA",dbs:{},blobs:[0],getDB(name,callback){// check the cache first
var db=IDBStore.dbs[name];if(db){return callback(null,db);}var req;try{req=IDBStore.indexedDB().open(name,IDBStore.DB_VERSION);}catch(e){return callback(e);}req.onupgradeneeded=e=>{var db=/** @type {IDBDatabase} */e.target.result;var transaction=e.target.transaction;var fileStore;if(db.objectStoreNames.contains(IDBStore.DB_STORE_NAME)){fileStore=transaction.objectStore(IDBStore.DB_STORE_NAME);}else{fileStore=db.createObjectStore(IDBStore.DB_STORE_NAME);}};req.onsuccess=()=>{db=/** @type {IDBDatabase} */req.result;// add to the cache
IDBStore.dbs[name]=db;callback(null,db);};req.onerror=function(event){callback(event.target.error||"unknown error");event.preventDefault();};},getStore(dbName,type,callback){IDBStore.getDB(dbName,(error,db)=>{if(error)return callback(error);var transaction=db.transaction([IDBStore.DB_STORE_NAME],type);transaction.onerror=event=>{callback(event.target.error||"unknown error");event.preventDefault();};var store=transaction.objectStore(IDBStore.DB_STORE_NAME);callback(null,store);});},getFile(dbName,id,callback){IDBStore.getStore(dbName,"readonly",(err,store)=>{if(err)return callback(err);var req=store.get(id);req.onsuccess=event=>{var result=event.target.result;if(!result){return callback(`file ${id} not found`);}return callback(null,result);};req.onerror=callback;});},setFile(dbName,id,data,callback){IDBStore.getStore(dbName,"readwrite",(err,store)=>{if(err)return callback(err);var req=store.put(data,id);req.onsuccess=event=>callback();req.onerror=callback;});},deleteFile(dbName,id,callback){IDBStore.getStore(dbName,"readwrite",(err,store)=>{if(err)return callback(err);var req=store.delete(id);req.onsuccess=event=>callback();req.onerror=callback;});},existsFile(dbName,id,callback){IDBStore.getStore(dbName,"readonly",(err,store)=>{if(err)return callback(err);var req=store.count(id);req.onsuccess=event=>callback(null,event.target.result>0);req.onerror=callback;});},clearStore(dbName,callback){IDBStore.getStore(dbName,"readwrite",(err,store)=>{if(err)return callback(err);var req=store.clear();req.onsuccess=event=>callback();req.onerror=callback;});}};var _emscripten_idb_async_load=function(db,id,arg,onload,onerror){db>>>=0;id>>>=0;arg>>>=0;onload>>>=0;onerror>>>=0;runtimeKeepalivePush();IDBStore.getFile(UTF8ToString(db),UTF8ToString(id),(error,byteArray)=>{runtimeKeepalivePop();callUserCallback(()=>{if(error){if(onerror)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);return;}var buffer=_malloc(byteArray.length);HEAPU8.set(byteArray,buffer>>>0);((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg,buffer,byteArray.length);_free(buffer);});});};_emscripten_idb_async_load.sig="vppppp";var _emscripten_idb_async_store=function(db,id,ptr,num,arg,onstore,onerror){db>>>=0;id>>>=0;ptr>>>=0;arg>>>=0;onstore>>>=0;onerror>>>=0;// note that we copy the data here, as these are async operatins - changes
// to HEAPU8 meanwhile should not affect us!
runtimeKeepalivePush();IDBStore.setFile(UTF8ToString(db),UTF8ToString(id),new Uint8Array(HEAPU8.subarray(ptr>>>0,ptr+num>>>0)),error=>{runtimeKeepalivePop();callUserCallback(()=>{if(error){if(onerror)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);return;}if(onstore)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);});});};_emscripten_idb_async_store.sig="vpppippp";var _emscripten_idb_async_delete=function(db,id,arg,ondelete,onerror){db>>>=0;id>>>=0;arg>>>=0;ondelete>>>=0;onerror>>>=0;runtimeKeepalivePush();IDBStore.deleteFile(UTF8ToString(db),UTF8ToString(id),error=>{runtimeKeepalivePop();callUserCallback(()=>{if(error){if(onerror)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);return;}if(ondelete)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);});});};_emscripten_idb_async_delete.sig="vppppp";var _emscripten_idb_async_exists=function(db,id,arg,oncheck,onerror){db>>>=0;id>>>=0;arg>>>=0;oncheck>>>=0;onerror>>>=0;runtimeKeepalivePush();IDBStore.existsFile(UTF8ToString(db),UTF8ToString(id),(error,exists)=>{runtimeKeepalivePop();callUserCallback(()=>{if(error){if(onerror)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);return;}if(oncheck)((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg,exists);});});};_emscripten_idb_async_exists.sig="vppppp";var _emscripten_idb_async_clear=function(db,arg,onclear,onerror){db>>>=0;arg>>>=0;onclear>>>=0;onerror>>>=0;runtimeKeepalivePush();IDBStore.clearStore(UTF8ToString(db),error=>{runtimeKeepalivePop();callUserCallback(()=>{if(error){if(onerror)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);return;}if(onclear)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */arg);});});};_emscripten_idb_async_clear.sig="vpppp";var _emscripten_idb_load=function(db,id,pbuffer,pnum,perror){db>>>=0;id>>>=0;pbuffer>>>=0;pnum>>>=0;perror>>>=0;return Asyncify.handleSleep(wakeUp=>{IDBStore.getFile(UTF8ToString(db),UTF8ToString(id),(error,byteArray)=>{if(error){HEAP32[perror>>>2>>>0]=1;wakeUp();return;}var buffer=_malloc(byteArray.length);// must be freed by the caller!
HEAPU8.set(byteArray,buffer>>>0);HEAPU32[pbuffer>>>2>>>0]=buffer;HEAP32[pnum>>>2>>>0]=byteArray.length;HEAP32[perror>>>2>>>0]=0;wakeUp();});});};_emscripten_idb_load.sig="vppppp";_emscripten_idb_load.isAsync=true;var _emscripten_idb_store=function(db,id,ptr,num,perror){db>>>=0;id>>>=0;ptr>>>=0;perror>>>=0;return Asyncify.handleSleep(wakeUp=>{IDBStore.setFile(UTF8ToString(db),UTF8ToString(id),new Uint8Array(HEAPU8.subarray(ptr>>>0,ptr+num>>>0)),error=>{HEAP32[perror>>>2>>>0]=!!error;wakeUp();});});};_emscripten_idb_store.sig="vpppip";_emscripten_idb_store.isAsync=true;var _emscripten_idb_delete=function(db,id,perror){db>>>=0;id>>>=0;perror>>>=0;return Asyncify.handleSleep(wakeUp=>{IDBStore.deleteFile(UTF8ToString(db),UTF8ToString(id),error=>{HEAP32[perror>>>2>>>0]=!!error;wakeUp();});});};_emscripten_idb_delete.sig="vppp";_emscripten_idb_delete.isAsync=true;var _emscripten_idb_exists=function(db,id,pexists,perror){db>>>=0;id>>>=0;pexists>>>=0;perror>>>=0;return Asyncify.handleSleep(wakeUp=>{IDBStore.existsFile(UTF8ToString(db),UTF8ToString(id),(error,exists)=>{HEAP32[pexists>>>2>>>0]=!!exists;HEAP32[perror>>>2>>>0]=!!error;wakeUp();});});};_emscripten_idb_exists.sig="vpppp";_emscripten_idb_exists.isAsync=true;var _emscripten_idb_clear=function(db,perror){db>>>=0;perror>>>=0;return Asyncify.handleSleep(wakeUp=>{IDBStore.clearStore(UTF8ToString(db),error=>{HEAP32[perror>>>2>>>0]=!!error;wakeUp();});});};_emscripten_idb_clear.sig="vpp";_emscripten_idb_clear.isAsync=true;var _emscripten_idb_load_blob=function(db,id,pblob,perror){db>>>=0;id>>>=0;pblob>>>=0;perror>>>=0;return Asyncify.handleSleep(wakeUp=>{assert(!IDBStore.pending);IDBStore.pending=msg=>{IDBStore.pending=null;var blob=msg.blob;if(!blob){HEAP32[perror>>>2>>>0]=1;wakeUp();return;}assert(blob instanceof Blob);var blobId=IDBStore.blobs.length;IDBStore.blobs.push(blob);HEAP32[pblob>>>2>>>0]=blobId;wakeUp();};postMessage({target:"IDBStore",method:"loadBlob",db:UTF8ToString(db),id:UTF8ToString(id)});});};_emscripten_idb_load_blob.sig="vpppp";_emscripten_idb_load_blob.isAsync=true;var _emscripten_idb_store_blob=function(db,id,ptr,num,perror){db>>>=0;id>>>=0;ptr>>>=0;perror>>>=0;return Asyncify.handleSleep(wakeUp=>{assert(!IDBStore.pending);IDBStore.pending=msg=>{IDBStore.pending=null;HEAP32[perror>>>2>>>0]=!!msg.error;wakeUp();};postMessage({target:"IDBStore",method:"storeBlob",db:UTF8ToString(db),id:UTF8ToString(id),blob:new Blob([new Uint8Array(HEAPU8.subarray(ptr>>>0,ptr+num>>>0))])});});};_emscripten_idb_store_blob.sig="vpppip";_emscripten_idb_store_blob.isAsync=true;function _emscripten_idb_read_from_blob(blobId,start,num,buffer){buffer>>>=0;var blob=IDBStore.blobs[blobId];if(!blob)return 1;if(start+num>blob.size)return 2;var byteArray=new FileReaderSync().readAsArrayBuffer(blob.slice(start,start+num));HEAPU8.set(new Uint8Array(byteArray),buffer>>>0);return 0;}_emscripten_idb_read_from_blob.sig="viiip";var _emscripten_idb_free_blob=blobId=>{assert(IDBStore.blobs[blobId]);IDBStore.blobs[blobId]=null;};_emscripten_idb_free_blob.sig="vi";var _emscripten_sleep=ms=>Asyncify.handleSleep(wakeUp=>safeSetTimeout(wakeUp,ms));_emscripten_sleep.sig="vi";_emscripten_sleep.isAsync=true;var _emscripten_scan_registers=function(func){func>>>=0;return Asyncify.handleSleep(wakeUp=>{// We must first unwind, so things are spilled to the stack. Then while
// we are pausing we do the actual scan. After that we can resume. Note
// how using a timeout here avoids unbounded call stack growth, which
// could happen if we tried to scan the stack immediately after unwinding.
safeSetTimeout(()=>{var stackBegin=Asyncify.currData+12;var stackEnd=HEAPU32[Asyncify.currData>>>2>>>0];((a1,a2)=>{})(/* a dynamic function call to signature vii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */stackBegin,stackEnd);wakeUp();},0);});};_emscripten_scan_registers.sig="vp";_emscripten_scan_registers.isAsync=true;var _emscripten_lazy_load_code=()=>Asyncify.handleSleep(wakeUp=>{// Update the expected wasm binary file to be the lazy one.
wasmBinaryFile+=".lazy.wasm";// Add a callback for when all run dependencies are fulfilled, which happens when async wasm loading is done.
dependenciesFulfilled=wakeUp;// Load the new wasm.
createWasm();});_emscripten_lazy_load_code.sig="v";_emscripten_lazy_load_code.isAsync=true;async function __load_secondary_module(){// Mark the module as loading for the wasm module (so it doesn't try to load it again).
wasmExports["load_secondary_module_status"].value=1;var imports={"primary":wasmExports};// Replace '.wasm' suffix with '.deferred.wasm'.
var deferred=wasmBinaryFile.slice(0,-5)+".deferred.wasm";await new Promise(resolve=>{instantiateAsync(null,deferred,imports,resolve);});}__load_secondary_module.sig="v";__load_secondary_module.isAsync=true;var Fibers={nextFiber:0,trampolineRunning:false,trampoline(){if(!Fibers.trampolineRunning&&Fibers.nextFiber){Fibers.trampolineRunning=true;do{var fiber=Fibers.nextFiber;Fibers.nextFiber=0;Fibers.finishContextSwitch(fiber);}while(Fibers.nextFiber);Fibers.trampolineRunning=false;}},finishContextSwitch(newFiber){var stack_base=HEAPU32[newFiber>>>2>>>0];var stack_max=HEAPU32[newFiber+4>>>2>>>0];_emscripten_stack_set_limits(stack_base,stack_max);stackRestore(HEAPU32[newFiber+8>>>2>>>0]);var entryPoint=HEAPU32[newFiber+12>>>2>>>0];if(entryPoint!==0){Asyncify.currData=null;HEAPU32[newFiber+12>>>2>>>0]=0;var userData=HEAPU32[newFiber+16>>>2>>>0];(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */userData);}else{var asyncifyData=newFiber+20;Asyncify.currData=asyncifyData;Asyncify.state=Asyncify.State.Rewinding;_asyncify_start_rewind(asyncifyData);Asyncify.doRewind(asyncifyData);}}};function _emscripten_fiber_swap(oldFiber,newFiber){oldFiber>>>=0;newFiber>>>=0;if(ABORT)return;if(Asyncify.state===Asyncify.State.Normal){Asyncify.state=Asyncify.State.Unwinding;var asyncifyData=oldFiber+20;Asyncify.setDataRewindFunc(asyncifyData);Asyncify.currData=asyncifyData;_asyncify_start_unwind(asyncifyData);var stackTop=stackSave();HEAPU32[oldFiber+8>>>2>>>0]=stackTop;Fibers.nextFiber=newFiber;}else{Asyncify.state=Asyncify.State.Normal;_asyncify_stop_rewind();Asyncify.currData=null;}}_emscripten_fiber_swap.sig="vpp";_emscripten_fiber_swap.isAsync=true;var _SDL_GetTicks=()=>Date.now()-SDL.startTime|0;_SDL_GetTicks.sig="i";function _SDL_LockSurface(surf){surf>>>=0;var surfData=SDL.surfaces[surf];surfData.locked++;if(surfData.locked>1)return 0;if(!surfData.buffer){surfData.buffer=_malloc(surfData.width*surfData.height*4);HEAPU32[surf+20>>>2>>>0]=surfData.buffer;}// Mark in C/C++-accessible SDL structure
// SDL_Surface has the following fields: Uint32 flags, SDL_PixelFormat *format; int w, h; Uint16 pitch; void *pixels; ...
// So we have fields all of the same size, and 5 of them before us.
// TODO: Use macros like in library.js
HEAPU32[surf+20>>>2>>>0]=surfData.buffer;if(surf==SDL.screen&&Module.screenIsReadOnly&&surfData.image)return 0;if(SDL.defaults.discardOnLock){if(!surfData.image){surfData.image=surfData.ctx.createImageData(surfData.width,surfData.height);}if(!SDL.defaults.opaqueFrontBuffer)return;}else{surfData.image=surfData.ctx.getImageData(0,0,surfData.width,surfData.height);}// Emulate desktop behavior and kill alpha values on the locked surface. (very costly!) Set SDL.defaults.opaqueFrontBuffer = false
// if you don't want this.
if(surf==SDL.screen&&SDL.defaults.opaqueFrontBuffer){var data=surfData.image.data;var num=data.length;for(var i=0;i<num/4;i++){data[i*4+3]=255;}}// opacity, as canvases blend alpha
if(SDL.defaults.copyOnLock&&!SDL.defaults.discardOnLock){// Copy pixel data to somewhere accessible to 'C/C++'
if(surfData.isFlagSet(2097152))/* SDL_HWPALETTE */{// If this is needed then
// we should compact the data from 32bpp to 8bpp index.
// I think best way to implement this is use
// additional colorMap hash (color->index).
// Something like this:
// var size = surfData.width * surfData.height;
// var data = '';
// for (var i = 0; i<size; i++) {
//   var color = SDL.translateRGBAToColor(
//     surfData.image.data[i*4   ],
//     surfData.image.data[i*4 +1],
//     surfData.image.data[i*4 +2],
//     255);
//   var index = surfData.colorMap[color];
//   HEAP8[(surfData.buffer)+(i)] = index;
// }
throw"CopyOnLock is not supported for SDL_LockSurface with SDL_HWPALETTE flag set"+new Error().stack;}else{HEAPU8.set(surfData.image.data,surfData.buffer>>>0);}}return 0;}_SDL_LockSurface.sig="ip";var SDL={defaults:{width:320,height:200,copyOnLock:true,discardOnLock:false,opaqueFrontBuffer:true},version:null,surfaces:{},canvasPool:[],events:[],fonts:[null],audios:[null],rwops:[null],music:{audio:null,volume:1},mixerFrequency:22050,mixerFormat:32784,mixerNumChannels:2,mixerChunkSize:1024,channelMinimumNumber:0,GL:false,glAttributes:{0:3,1:3,2:2,3:0,4:0,5:1,6:16,7:0,8:0,9:0,10:0,11:0,12:0,13:0,14:0,15:1,16:0,17:0,18:0},keyboardState:null,keyboardMap:{},canRequestFullscreen:false,isRequestingFullscreen:false,textInput:false,unicode:false,ttfContext:null,audio:null,startTime:null,initFlags:0,buttonState:0,modState:0,DOMButtons:[0,0,0],DOMEventToSDLEvent:{},TOUCH_DEFAULT_ID:0,eventHandler:null,eventHandlerContext:null,eventHandlerTemp:0,keyCodes:{16:1249,17:1248,18:1250,20:1081,33:1099,34:1102,35:1101,36:1098,37:1104,38:1106,39:1103,40:1105,44:316,45:1097,46:127,91:1251,93:1125,96:1122,97:1113,98:1114,99:1115,100:1116,101:1117,102:1118,103:1119,104:1120,105:1121,106:1109,107:1111,109:1110,110:1123,111:1108,112:1082,113:1083,114:1084,115:1085,116:1086,117:1087,118:1088,119:1089,120:1090,121:1091,122:1092,123:1093,124:1128,125:1129,126:1130,127:1131,128:1132,129:1133,130:1134,131:1135,132:1136,133:1137,134:1138,135:1139,144:1107,160:94,161:33,162:34,163:35,164:36,165:37,166:38,167:95,168:40,169:41,170:42,171:43,172:124,173:45,174:123,175:125,176:126,181:127,182:129,183:128,188:44,190:46,191:47,192:96,219:91,220:92,221:93,222:39,224:1251},scanCodes:{8:42,9:43,13:40,27:41,32:44,35:204,39:53,44:54,46:55,47:56,48:39,49:30,50:31,51:32,52:33,53:34,54:35,55:36,56:37,57:38,58:203,59:51,61:46,91:47,92:49,93:48,96:52,97:4,98:5,99:6,100:7,101:8,102:9,103:10,104:11,105:12,106:13,107:14,108:15,109:16,110:17,111:18,112:19,113:20,114:21,115:22,116:23,117:24,118:25,119:26,120:27,121:28,122:29,127:76,305:224,308:226,316:70},loadRect(rect){return{x:HEAP32[rect+0>>>2>>>0],y:HEAP32[rect+4>>>2>>>0],w:HEAP32[rect+8>>>2>>>0],h:HEAP32[rect+12>>>2>>>0]};},updateRect(rect,r){HEAP32[rect>>>2>>>0]=r.x;HEAP32[rect+4>>>2>>>0]=r.y;HEAP32[rect+8>>>2>>>0]=r.w;HEAP32[rect+12>>>2>>>0]=r.h;},intersectionOfRects(first,second){var leftX=Math.max(first.x,second.x);var leftY=Math.max(first.y,second.y);var rightX=Math.min(first.x+first.w,second.x+second.w);var rightY=Math.min(first.y+first.h,second.y+second.h);return{x:leftX,y:leftY,w:Math.max(leftX,rightX)-leftX,h:Math.max(leftY,rightY)-leftY};},checkPixelFormat(fmt){},loadColorToCSSRGB(color){var rgba=HEAP32[color>>>2>>>0];return"rgb("+(rgba&255)+","+(rgba>>8&255)+","+(rgba>>16&255)+")";},loadColorToCSSRGBA(color){var rgba=HEAP32[color>>>2>>>0];return"rgba("+(rgba&255)+","+(rgba>>8&255)+","+(rgba>>16&255)+","+(rgba>>24&255)/255+")";},translateColorToCSSRGBA:rgba=>"rgba("+(rgba&255)+","+(rgba>>8&255)+","+(rgba>>16&255)+","+(rgba>>>24)/255+")",translateRGBAToCSSRGBA:(r,g,b,a)=>"rgba("+(r&255)+","+(g&255)+","+(b&255)+","+(a&255)/255+")",translateRGBAToColor:(r,g,b,a)=>r|g<<8|b<<16|a<<24,makeSurface(width,height,flags,usePageCanvas,source,rmask,gmask,bmask,amask){var is_SDL_HWSURFACE=flags&1;var is_SDL_HWPALETTE=flags&2097152;var is_SDL_OPENGL=flags&67108864;var surf=_malloc(60);var pixelFormat=_malloc(44);//surface with SDL_HWPALETTE flag is 8bpp surface (1 byte)
var bpp=is_SDL_HWPALETTE?1:4;var buffer=0;// preemptively initialize this for software surfaces,
// otherwise it will be lazily initialized inside of SDL_LockSurface
if(!is_SDL_HWSURFACE&&!is_SDL_OPENGL){buffer=_malloc(width*height*4);}HEAP32[surf>>>2>>>0]=flags;HEAPU32[surf+4>>>2>>>0]=pixelFormat;HEAP32[surf+8>>>2>>>0]=width;HEAP32[surf+12>>>2>>>0]=height;HEAP32[surf+16>>>2>>>0]=width*bpp;// assuming RGBA or indexed for now,
// since that is what ImageData gives us in browsers
HEAPU32[surf+20>>>2>>>0]=buffer;HEAP32[surf+36>>>2>>>0]=0;HEAP32[surf+40>>>2>>>0]=0;HEAP32[surf+44>>>2>>>0]=Module["canvas"].width;HEAP32[surf+48>>>2>>>0]=Module["canvas"].height;HEAP32[surf+56>>>2>>>0]=1;HEAP32[pixelFormat>>>2>>>0]=-2042224636;HEAP32[pixelFormat+4>>>2>>>0]=0;// TODO
HEAP8[pixelFormat+8>>>0]=bpp*8;HEAP8[pixelFormat+9>>>0]=bpp;HEAP32[pixelFormat+12>>>2>>>0]=rmask||255;HEAP32[pixelFormat+16>>>2>>>0]=gmask||65280;HEAP32[pixelFormat+20>>>2>>>0]=bmask||16711680;HEAP32[pixelFormat+24>>>2>>>0]=amask||4278190080;// Decide if we want to use WebGL or not
SDL.GL=SDL.GL||is_SDL_OPENGL;var canvas;if(!usePageCanvas){if(SDL.canvasPool.length>0){canvas=SDL.canvasPool.pop();}else{canvas=document.createElement("canvas");}canvas.width=width;canvas.height=height;}else{canvas=Module["canvas"];}var webGLContextAttributes={antialias:SDL.glAttributes[13]!=/*SDL_GL_MULTISAMPLEBUFFERS*/0&&SDL.glAttributes[14]>/*SDL_GL_MULTISAMPLESAMPLES*/1,depth:SDL.glAttributes[6]>/*SDL_GL_DEPTH_SIZE*/0,stencil:SDL.glAttributes[7]>/*SDL_GL_STENCIL_SIZE*/0,alpha:SDL.glAttributes[3]>/*SDL_GL_ALPHA_SIZE*/0};var ctx=Browser.createContext(canvas,is_SDL_OPENGL,usePageCanvas,webGLContextAttributes);SDL.surfaces[surf]={width,height,canvas,ctx,surf,buffer,pixelFormat,alpha:255,flags,locked:0,usePageCanvas,source,isFlagSet:flag=>flags&flag};return surf;},copyIndexedColorData(surfData,rX,rY,rW,rH){// HWPALETTE works with palette
// set by SDL_SetColors
if(!surfData.colors){return;}var fullWidth=Module["canvas"].width;var fullHeight=Module["canvas"].height;var startX=rX||0;var startY=rY||0;var endX=(rW||fullWidth-startX)+startX;var endY=(rH||fullHeight-startY)+startY;var buffer=surfData.buffer;if(!surfData.image.data32){surfData.image.data32=new Uint32Array(surfData.image.data.buffer);}var data32=surfData.image.data32;var colors32=surfData.colors32;for(var y=startY;y<endY;++y){var base=y*fullWidth;for(var x=startX;x<endX;++x){data32[base+x]=colors32[HEAPU8[buffer+base+x>>>0]];}}},freeSurface(surf){var refcountPointer=surf+56;var refcount=HEAP32[refcountPointer>>>2>>>0];if(refcount>1){HEAP32[refcountPointer>>>2>>>0]=refcount-1;return;}var info=SDL.surfaces[surf];if(!info.usePageCanvas&&info.canvas)SDL.canvasPool.push(info.canvas);if(info.buffer)_free(info.buffer);_free(info.pixelFormat);_free(surf);SDL.surfaces[surf]=null;if(surf===SDL.screen){SDL.screen=null;}},blitSurface(src,srcrect,dst,dstrect,scale){var srcData=SDL.surfaces[src];var dstData=SDL.surfaces[dst];var sr,dr;if(srcrect){sr=SDL.loadRect(srcrect);}else{sr={x:0,y:0,w:srcData.width,h:srcData.height};}if(dstrect){dr=SDL.loadRect(dstrect);}else{dr={x:0,y:0,w:srcData.width,h:srcData.height};}if(dstData.clipRect){var widthScale=!scale||sr.w===0?1:sr.w/dr.w;var heightScale=!scale||sr.h===0?1:sr.h/dr.h;dr=SDL.intersectionOfRects(dstData.clipRect,dr);sr.w=dr.w*widthScale;sr.h=dr.h*heightScale;if(dstrect){SDL.updateRect(dstrect,dr);}}var blitw,blith;if(scale){blitw=dr.w;blith=dr.h;}else{blitw=sr.w;blith=sr.h;}if(sr.w===0||sr.h===0||blitw===0||blith===0){return 0;}var oldAlpha=dstData.ctx.globalAlpha;dstData.ctx.globalAlpha=srcData.alpha/255;dstData.ctx.drawImage(srcData.canvas,sr.x,sr.y,sr.w,sr.h,dr.x,dr.y,blitw,blith);dstData.ctx.globalAlpha=oldAlpha;if(dst!=SDL.screen){// XXX As in IMG_Load, for compatibility we write out |pixels|
warnOnce("WARNING: copying canvas data to memory for compatibility");_SDL_LockSurface(dst);dstData.locked--;}// The surface is not actually locked in this hack
return 0;},downFingers:{},savedKeydown:null,receiveEvent(event){function unpressAllPressedKeys(){// Un-press all pressed keys: TODO
for(var code in SDL.keyboardMap){SDL.events.push({type:"keyup",keyCode:SDL.keyboardMap[code]});}}switch(event.type){case"touchstart":case"touchmove":{event.preventDefault();var touches=[];// Clear out any touchstart events that we've already processed
if(event.type==="touchstart"){for(var i=0;i<event.touches.length;i++){var touch=event.touches[i];if(SDL.downFingers[touch.identifier]!=true){SDL.downFingers[touch.identifier]=true;touches.push(touch);}}}else{touches=event.touches;}var firstTouch=touches[0];if(firstTouch){if(event.type=="touchstart"){SDL.DOMButtons[0]=1;}var mouseEventType;switch(event.type){case"touchstart":mouseEventType="mousedown";break;case"touchmove":mouseEventType="mousemove";break;}var mouseEvent={type:mouseEventType,button:0,pageX:firstTouch.clientX,pageY:firstTouch.clientY};SDL.events.push(mouseEvent);}for(var i=0;i<touches.length;i++){var touch=touches[i];SDL.events.push({type:event.type,touch});}break;}case"touchend":{event.preventDefault();// Remove the entry in the SDL.downFingers hash
// because the finger is no longer down.
for(var i=0;i<event.changedTouches.length;i++){var touch=event.changedTouches[i];if(SDL.downFingers[touch.identifier]===true){delete SDL.downFingers[touch.identifier];}}var mouseEvent={type:"mouseup",button:0,pageX:event.changedTouches[0].clientX,pageY:event.changedTouches[0].clientY};SDL.DOMButtons[0]=0;SDL.events.push(mouseEvent);for(var i=0;i<event.changedTouches.length;i++){var touch=event.changedTouches[i];SDL.events.push({type:"touchend",touch});}break;}case"DOMMouseScroll":case"mousewheel":case"wheel":// Flip the wheel direction to translate from browser wheel direction
// (+:down) to SDL direction (+:up)
var delta=-Browser.getMouseWheelDelta(event);// Quantize to integer so that minimum scroll is at least +/- 1.
delta=delta==0?0:delta>0?Math.max(delta,1):Math.min(delta,-1);// Simulate old-style SDL events representing mouse wheel input as buttons
// Subtract one since JS->C marshalling is defined to add one back.
var button=delta>0?3:/*SDL_BUTTON_WHEELUP-1*/4;/*SDL_BUTTON_WHEELDOWN-1*/SDL.events.push({type:"mousedown",button,pageX:event.pageX,pageY:event.pageY});SDL.events.push({type:"mouseup",button,pageX:event.pageX,pageY:event.pageY});// Pass a delta motion event.
SDL.events.push({type:"wheel",deltaX:0,deltaY:delta});// If we don't prevent this, then 'wheel' event will be sent again by
// the browser as 'DOMMouseScroll' and we will receive this same event
// the second time.
event.preventDefault();break;case"mousemove":if(SDL.DOMButtons[0]===1){SDL.events.push({type:"touchmove",touch:{identifier:0,deviceID:-1,pageX:event.pageX,pageY:event.pageY}});}if(Browser.pointerLock){// workaround for firefox bug 750111
if("mozMovementX"in event){event["movementX"]=event["mozMovementX"];event["movementY"]=event["mozMovementY"];}// workaround for Firefox bug 782777
if(event["movementX"]==0&&event["movementY"]==0){// ignore a mousemove event if it doesn't contain any movement info
// (without pointer lock, we infer movement from pageX/pageY, so this check is unnecessary)
event.preventDefault();return;}}// fall through
case"keydown":case"keyup":case"keypress":case"mousedown":case"mouseup":// If we preventDefault on keydown events, the subsequent keypress events
// won't fire. However, it's fine (and in some cases necessary) to
// preventDefault for keys that don't generate a character. Otherwise,
// preventDefault is the right thing to do in general.
if(event.type!=="keydown"||!SDL.unicode&&!SDL.textInput||event.keyCode===8||/* backspace */event.keyCode===9)/* tab */{event.preventDefault();}if(event.type=="mousedown"){SDL.DOMButtons[event.button]=1;SDL.events.push({type:"touchstart",touch:{identifier:0,deviceID:-1,pageX:event.pageX,pageY:event.pageY}});}else if(event.type=="mouseup"){// ignore extra ups, can happen if we leave the canvas while pressing down, then return,
// since we add a mouseup in that case
if(!SDL.DOMButtons[event.button]){return;}SDL.events.push({type:"touchend",touch:{identifier:0,deviceID:-1,pageX:event.pageX,pageY:event.pageY}});SDL.DOMButtons[event.button]=0;}// We can only request fullscreen as the result of user input.
// Due to this limitation, we toggle a boolean on keydown which
// SDL_WM_ToggleFullScreen will check and subsequently set another
// flag indicating for us to request fullscreen on the following
// keyup. This isn't perfect, but it enables SDL_WM_ToggleFullScreen
// to work as the result of a keypress (which is an extremely
// common use case).
if(event.type==="keydown"||event.type==="mousedown"){SDL.canRequestFullscreen=true;}else if(event.type==="keyup"||event.type==="mouseup"){if(SDL.isRequestingFullscreen){Module["requestFullscreen"](/*lockPointer=*/true,/*resizeCanvas=*/true);SDL.isRequestingFullscreen=false;}SDL.canRequestFullscreen=false;}// SDL expects a unicode character to be passed to its keydown events.
// Unfortunately, the browser APIs only provide a charCode property on
// keypress events, so we must backfill in keydown events with their
// subsequent keypress event's charCode.
if(event.type==="keypress"&&SDL.savedKeydown){// charCode is read-only
SDL.savedKeydown.keypressCharCode=event.charCode;SDL.savedKeydown=null;}else if(event.type==="keydown"){SDL.savedKeydown=event;}// Don't push keypress events unless SDL_StartTextInput has been called.
if(event.type!=="keypress"||SDL.textInput){SDL.events.push(event);}break;case"mouseout":// Un-press all pressed mouse buttons, because we might miss the release outside of the canvas
for(var i=0;i<3;i++){if(SDL.DOMButtons[i]){SDL.events.push({type:"mouseup",button:i,pageX:event.pageX,pageY:event.pageY});SDL.DOMButtons[i]=0;}}event.preventDefault();break;case"focus":SDL.events.push(event);event.preventDefault();break;case"blur":SDL.events.push(event);unpressAllPressedKeys();event.preventDefault();break;case"visibilitychange":SDL.events.push({type:"visibilitychange",visible:!document.hidden});unpressAllPressedKeys();event.preventDefault();break;case"unload":if(Browser.mainLoop.runner){SDL.events.push(event);// Force-run a main event loop, since otherwise this event will never be caught!
Browser.mainLoop.runner();}return;case"resize":SDL.events.push(event);// manually triggered resize event doesn't have a preventDefault member
if(event.preventDefault){event.preventDefault();}break;}if(SDL.events.length>=1e4){err("SDL event queue full, dropping events");SDL.events=SDL.events.slice(0,1e4);}// If we have a handler installed, this will push the events to the app
// instead of the app polling for them.
SDL.flushEventsToHandler();return;},lookupKeyCodeForEvent(event){var code=event.keyCode;if(code>=65&&code<=90){code+=32;}else// make lowercase for SDL
{code=SDL.keyCodes[event.keyCode]||event.keyCode;// If this is one of the modifier keys (224 | 1<<10 - 227 | 1<<10), and the event specifies that it is
// a right key, add 4 to get the right key SDL key code.
if(event.location===2&&/*KeyboardEvent.DOM_KEY_LOCATION_RIGHT*/code>=(224|1<<10)&&code<=(227|1<<10)){code+=4;}}return code;},handleEvent(event){if(event.handled)return;event.handled=true;switch(event.type){case"touchstart":case"touchend":case"touchmove":{Browser.calculateMouseEvent(event);break;}case"keydown":case"keyup":{var down=event.type==="keydown";var code=SDL.lookupKeyCodeForEvent(event);// Assigning a boolean to HEAP8, that's alright but Closure would like to warn about it.
// TODO(https://github.com/emscripten-core/emscripten/issues/16311):
// This is kind of ugly hack.  Perhaps we can find a better way?
/** @suppress{checkTypes} */HEAP8[SDL.keyboardState+code>>>0]=down;// TODO: lmeta, rmeta, numlock, capslock, KMOD_MODE, KMOD_RESERVED
SDL.modState=(HEAP8[SDL.keyboardState+1248>>>0]?64:0)|(// KMOD_LCTRL
HEAP8[SDL.keyboardState+1249>>>0]?1:0)|(// KMOD_LSHIFT
HEAP8[SDL.keyboardState+1250>>>0]?256:0)|(// KMOD_LALT
HEAP8[SDL.keyboardState+1252>>>0]?128:0)|(// KMOD_RCTRL
HEAP8[SDL.keyboardState+1253>>>0]?2:0)|(// KMOD_RSHIFT
HEAP8[SDL.keyboardState+1254>>>0]?512:0);//  KMOD_RALT
if(down){SDL.keyboardMap[code]=event.keyCode;}else// save the DOM input, which we can use to unpress it during blur
{delete SDL.keyboardMap[code];}break;}case"mousedown":case"mouseup":if(event.type=="mousedown"){// SDL_BUTTON(x) is defined as (1 << ((x)-1)).  SDL buttons are 1-3,
// and DOM buttons are 0-2, so this means that the below formula is
// correct.
SDL.buttonState|=1<<event.button;}else if(event.type=="mouseup"){SDL.buttonState&=~(1<<event.button);}// fall through
case"mousemove":{Browser.calculateMouseEvent(event);break;}}},flushEventsToHandler(){if(!SDL.eventHandler)return;while(SDL.pollEvent(SDL.eventHandlerTemp)){((a1,a2)=>{})(/* a dynamic function call to signature iii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */SDL.eventHandlerContext,SDL.eventHandlerTemp);}},pollEvent(ptr){if(SDL.initFlags&512&&SDL.joystickEventState){// If SDL_INIT_JOYSTICK was supplied AND the joystick system is configured
// to automatically query for events, query for joystick events.
SDL.queryJoysticks();}if(ptr){while(SDL.events.length>0){if(SDL.makeCEvent(SDL.events.shift(),ptr)!==false)return 1;}return 0;}// XXX: somewhat risky in that we do not check if the event is real or not
// (makeCEvent returns false) if no pointer supplied
return SDL.events.length>0;},makeCEvent(event,ptr){if(typeof event=="number"){// This is a pointer to a copy of a native C event that was SDL_PushEvent'ed
_memcpy(ptr,event,28);_free(event);// the copy is no longer needed
return;}SDL.handleEvent(event);switch(event.type){case"keydown":case"keyup":{var down=event.type==="keydown";//dbg('Received key event: ' + event.keyCode);
var key=SDL.lookupKeyCodeForEvent(event);var scan;if(key>=1024){scan=key-1024;}else{scan=SDL.scanCodes[key]||key;}HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP8[ptr+8>>>0]=down?1:0;HEAP8[ptr+9>>>0]=0;// TODO
HEAP32[ptr+12>>>2>>>0]=scan;HEAP32[ptr+16>>>2>>>0]=key;HEAP16[ptr+20>>>1>>>0]=SDL.modState;// some non-character keys (e.g. backspace and tab) won't have keypressCharCode set, fill in with the keyCode.
HEAP32[ptr+24>>>2>>>0]=event.keypressCharCode||key;break;}case"keypress":{HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];// Not filling in windowID for now
var cStr=intArrayFromString(String.fromCharCode(event.charCode));for(var i=0;i<cStr.length;++i){HEAP8[ptr+(8+i)>>>0]=cStr[i];}break;}case"mousedown":case"mouseup":case"mousemove":{if(event.type!="mousemove"){var down=event.type==="mousedown";HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP32[ptr+4>>>2>>>0]=0;HEAP32[ptr+8>>>2>>>0]=0;HEAP32[ptr+12>>>2>>>0]=0;HEAP8[ptr+16>>>0]=event.button+1;// DOM buttons are 0-2, SDL 1-3
HEAP8[ptr+17>>>0]=down?1:0;HEAP32[ptr+20>>>2>>>0]=Browser.mouseX;HEAP32[ptr+24>>>2>>>0]=Browser.mouseY;}else{HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP32[ptr+4>>>2>>>0]=0;HEAP32[ptr+8>>>2>>>0]=0;HEAP32[ptr+12>>>2>>>0]=0;HEAP32[ptr+16>>>2>>>0]=SDL.buttonState;HEAP32[ptr+20>>>2>>>0]=Browser.mouseX;HEAP32[ptr+24>>>2>>>0]=Browser.mouseY;HEAP32[ptr+28>>>2>>>0]=Browser.mouseMovementX;HEAP32[ptr+32>>>2>>>0]=Browser.mouseMovementY;}break;}case"wheel":{HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP32[ptr+16>>>2>>>0]=event.deltaX;HEAP32[ptr+20>>>2>>>0]=event.deltaY;break;}case"touchstart":case"touchend":case"touchmove":{var touch=event.touch;if(!Browser.touches[touch.identifier])break;var w=Module["canvas"].width;var h=Module["canvas"].height;var x=Browser.touches[touch.identifier].x/w;var y=Browser.touches[touch.identifier].y/h;var lx=Browser.lastTouches[touch.identifier].x/w;var ly=Browser.lastTouches[touch.identifier].y/h;var dx=x-lx;var dy=y-ly;if(touch["deviceID"]===undefined)touch.deviceID=SDL.TOUCH_DEFAULT_ID;if(dx===0&&dy===0&&event.type==="touchmove")return false;// don't send these if nothing happened
HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP32[ptr+4>>>2>>>0]=_SDL_GetTicks();tempI64=[touch.deviceID>>>0,(tempDouble=touch.deviceID,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[ptr+8>>>2>>>0]=tempI64[0],HEAP32[ptr+12>>>2>>>0]=tempI64[1];tempI64=[touch.identifier>>>0,(tempDouble=touch.identifier,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[ptr+16>>>2>>>0]=tempI64[0],HEAP32[ptr+20>>>2>>>0]=tempI64[1];HEAPF32[ptr+24>>>2>>>0]=x;HEAPF32[ptr+28>>>2>>>0]=y;HEAPF32[ptr+32>>>2>>>0]=dx;HEAPF32[ptr+36>>>2>>>0]=dy;if(touch.force!==undefined){HEAPF32[ptr+40>>>2>>>0]=touch.force;}else{// No pressure data, send a digital 0/1 pressure.
HEAPF32[ptr+40>>>2>>>0]=event.type=="touchend"?0:1;}break;}case"unload":{HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];break;}case"resize":{HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP32[ptr+4>>>2>>>0]=event.w;HEAP32[ptr+8>>>2>>>0]=event.h;break;}case"joystick_button_up":case"joystick_button_down":{var state=event.type==="joystick_button_up"?0:1;HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP8[ptr+4>>>0]=event.index;HEAP8[ptr+5>>>0]=event.button;HEAP8[ptr+6>>>0]=state;break;}case"joystick_axis_motion":{HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP8[ptr+4>>>0]=event.index;HEAP8[ptr+5>>>0]=event.axis;HEAP32[ptr+8>>>2>>>0]=SDL.joystickAxisValueConversion(event.value);break;}case"focus":{var SDL_WINDOWEVENT_FOCUS_GAINED=12;/* SDL_WINDOWEVENT_FOCUS_GAINED */HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP32[ptr+4>>>2>>>0]=0;HEAP8[ptr+8>>>0]=SDL_WINDOWEVENT_FOCUS_GAINED;break;}case"blur":{var SDL_WINDOWEVENT_FOCUS_LOST=13;/* SDL_WINDOWEVENT_FOCUS_LOST */HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP32[ptr+4>>>2>>>0]=0;HEAP8[ptr+8>>>0]=SDL_WINDOWEVENT_FOCUS_LOST;break;}case"visibilitychange":{var SDL_WINDOWEVENT_SHOWN=1;/* SDL_WINDOWEVENT_SHOWN */var SDL_WINDOWEVENT_HIDDEN=2;/* SDL_WINDOWEVENT_HIDDEN */var visibilityEventID=event.visible?SDL_WINDOWEVENT_SHOWN:SDL_WINDOWEVENT_HIDDEN;HEAP32[ptr>>>2>>>0]=SDL.DOMEventToSDLEvent[event.type];HEAP32[ptr+4>>>2>>>0]=0;HEAP8[ptr+8>>>0]=visibilityEventID;break;}default:throw"Unhandled SDL event: "+event.type;}},makeFontString(height,fontName){if(fontName.charAt(0)!="'"&&fontName.charAt(0)!='"'){// https://developer.mozilla.org/ru/docs/Web/CSS/font-family
// Font family names containing whitespace should be quoted.
// BTW, quote all font names is easier than searching spaces
fontName='"'+fontName+'"';}return height+"px "+fontName+", serif";},estimateTextWidth(fontData,text){var h=fontData.size;var fontString=SDL.makeFontString(h,fontData.name);var tempCtx=SDL.ttfContext;tempCtx.font=fontString;var ret=tempCtx.measureText(text).width|0;return ret;},allocateChannels(num){// called from Mix_AllocateChannels and init
if(SDL.numChannels&&SDL.numChannels>=num&&num!=0)return;SDL.numChannels=num;SDL.channels=[];for(var i=0;i<num;i++){SDL.channels[i]={audio:null,volume:1};}},setGetVolume(info,volume){if(!info)return 0;var ret=info.volume*128;// MIX_MAX_VOLUME
if(volume!=-1){info.volume=Math.min(Math.max(volume,0),128)/128;if(info.audio){try{info.audio.volume=info.volume;// For <audio> element
if(info.audio.webAudioGainNode)info.audio.webAudioGainNode["gain"]["value"]=info.volume;}// For WebAudio playback
catch(e){err(`setGetVolume failed to set audio volume: ${e}`);}}}return ret;},setPannerPosition(info,x,y,z){if(!info)return;if(info.audio){if(info.audio.webAudioPannerNode){info.audio.webAudioPannerNode["setPosition"](x,y,z);}}},playWebAudio(audio){if(!audio)return;if(audio.webAudioNode)return;// This instance is already playing, don't start again.
if(!SDL.webAudioAvailable())return;try{var webAudio=audio.resource.webAudio;audio.paused=false;if(!webAudio.decodedBuffer){if(webAudio.onDecodeComplete===undefined)abort("Cannot play back audio object that was not loaded");webAudio.onDecodeComplete.push(()=>{if(!audio.paused)SDL.playWebAudio(audio);});return;}audio.webAudioNode=SDL.audioContext["createBufferSource"]();audio.webAudioNode["buffer"]=webAudio.decodedBuffer;audio.webAudioNode["loop"]=audio.loop;audio.webAudioNode["onended"]=audio["onended"];// For <media> element compatibility, route the onended signal to the instance.
audio.webAudioPannerNode=SDL.audioContext["createPanner"]();// avoid Chrome bug
// If posz = 0, the sound will come from only the right.
// By posz = -0.5 (slightly ahead), the sound will come from right and left correctly.
audio.webAudioPannerNode["setPosition"](0,0,-.5);audio.webAudioPannerNode["panningModel"]="equalpower";// Add an intermediate gain node to control volume.
audio.webAudioGainNode=SDL.audioContext["createGain"]();audio.webAudioGainNode["gain"]["value"]=audio.volume;audio.webAudioNode["connect"](audio.webAudioPannerNode);audio.webAudioPannerNode["connect"](audio.webAudioGainNode);audio.webAudioGainNode["connect"](SDL.audioContext["destination"]);audio.webAudioNode["start"](0,audio.currentPosition);audio.startTime=SDL.audioContext["currentTime"]-audio.currentPosition;}catch(e){err(`playWebAudio failed: ${e}`);}},pauseWebAudio(audio){if(!audio)return;if(audio.webAudioNode){try{// Remember where we left off, so that if/when we resume, we can restart the playback at a proper place.
audio.currentPosition=(SDL.audioContext["currentTime"]-audio.startTime)%audio.resource.webAudio.decodedBuffer.duration;// Important: When we reach here, the audio playback is stopped by the user. But when calling .stop() below, the Web Audio
// graph will send the onended signal, but we don't want to process that, since pausing should not clear/destroy the audio
// channel.
audio.webAudioNode["onended"]=undefined;audio.webAudioNode.stop(0);// 0 is a default parameter, but WebKit is confused by it #3861
audio.webAudioNode=undefined;}catch(e){err(`pauseWebAudio failed: ${e}`);}}audio.paused=true;},openAudioContext(){// Initialize Web Audio API if we haven't done so yet. Note: Only initialize Web Audio context ever once on the web page,
// since initializing multiple times fails on Chrome saying 'audio resources have been exhausted'.
if(!SDL.audioContext){if(typeof AudioContext!="undefined")SDL.audioContext=new AudioContext();else if(typeof webkitAudioContext!="undefined")SDL.audioContext=new webkitAudioContext();}},webAudioAvailable:()=>!!SDL.audioContext,fillWebAudioBufferFromHeap(heapPtr,sizeSamplesPerChannel,dstAudioBuffer){// The input audio data is interleaved across the channels, i.e. [L, R, L, R, L, R, ...] and is either 8-bit, 16-bit or float as
// supported by the SDL API. The output audio wave data for Web Audio API must be in planar buffers of [-1,1]-normalized Float32 data,
// so perform a buffer conversion for the data.
var audio=SDL.audio;var numChannels=audio.channels;for(var c=0;c<numChannels;++c){var channelData=dstAudioBuffer["getChannelData"](c);if(channelData.length!=sizeSamplesPerChannel){throw"Web Audio output buffer length mismatch! Destination size: "+channelData.length+" samples vs expected "+sizeSamplesPerChannel+" samples!";}if(audio.format==32784){for(var j=0;j<sizeSamplesPerChannel;++j){channelData[j]=HEAP16[heapPtr+(j*numChannels+c)*2>>>1>>>0]/32768;}}else if(audio.format==8){for(var j=0;j<sizeSamplesPerChannel;++j){var v=HEAP8[heapPtr+(j*numChannels+c)>>>0];channelData[j]=(v>=0?v-128:v+128)/128;}}else if(audio.format==33056){for(var j=0;j<sizeSamplesPerChannel;++j){channelData[j]=HEAPF32[heapPtr+(j*numChannels+c)*4>>>2>>>0];}}else{throw"Invalid SDL audio format "+audio.format+"!";}}},joystickEventState:1,lastJoystickState:{},joystickNamePool:{},recordJoystickState(joystick,state){// Standardize button state.
var buttons=new Array(state.buttons.length);for(var i=0;i<state.buttons.length;i++){buttons[i]=SDL.getJoystickButtonState(state.buttons[i]);}SDL.lastJoystickState[joystick]={buttons,axes:state.axes.slice(0),timestamp:state.timestamp,index:state.index,id:state.id};},getJoystickButtonState(button){if(typeof button=="object"){// Current gamepad API editor's draft (Firefox Nightly)
// https://dvcs.w3.org/hg/gamepad/raw-file/default/gamepad.html#idl-def-GamepadButton
return button["pressed"];}// Current gamepad API working draft (Firefox / Chrome Stable)
// http://www.w3.org/TR/2012/WD-gamepad-20120529/#gamepad-interface
return button>0;},queryJoysticks(){for(var joystick in SDL.lastJoystickState){var state=SDL.getGamepad(joystick-1);var prevState=SDL.lastJoystickState[joystick];// If joystick was removed, state returns null.
if(typeof state=="undefined")return;if(state===null)return;// Check only if the timestamp has differed.
// NOTE: Timestamp is not available in Firefox.
// NOTE: Timestamp is currently not properly set for the GearVR controller
//       on Samsung Internet: it is always zero.
if(typeof state.timestamp!="number"||state.timestamp!=prevState.timestamp||!state.timestamp){var i;for(i=0;i<state.buttons.length;i++){var buttonState=SDL.getJoystickButtonState(state.buttons[i]);// NOTE: The previous state already has a boolean representation of
//       its button, so no need to standardize its button state here.
if(buttonState!==prevState.buttons[i]){// Insert button-press event.
SDL.events.push({type:buttonState?"joystick_button_down":"joystick_button_up",joystick,index:joystick-1,button:i});}}for(i=0;i<state.axes.length;i++){if(state.axes[i]!==prevState.axes[i]){// Insert axes-change event.
SDL.events.push({type:"joystick_axis_motion",joystick,index:joystick-1,axis:i,value:state.axes[i]});}}SDL.recordJoystickState(joystick,state);}}},joystickAxisValueConversion(value){// Make sure value is properly clamped
value=Math.min(1,Math.max(value,-1));// Ensures that 0 is 0, 1 is 32767, and -1 is 32768.
return Math.ceil((value+1)*32767.5-32768);},getGamepads(){var fcn=navigator.getGamepads||navigator.webkitGamepads||navigator.mozGamepads||navigator.gamepads||navigator.webkitGetGamepads;if(fcn!==undefined){// The function must be applied on the navigator object.
return fcn.apply(navigator);}return[];},getGamepad(deviceIndex){var gamepads=SDL.getGamepads();if(gamepads.length>deviceIndex&&deviceIndex>=0){return gamepads[deviceIndex];}return null;}};function _SDL_Linked_Version(){if(SDL.version===null){SDL.version=_malloc(3);HEAP8[SDL.version+0>>>0]=1;HEAP8[SDL.version+1>>>0]=3;HEAP8[SDL.version+2>>>0]=0;}return SDL.version;}_SDL_Linked_Version.sig="p";/** @param{number} initFlags */var _SDL_Init=initFlags=>{SDL.startTime=Date.now();SDL.initFlags=initFlags;// capture all key events. we just keep down and up, but also capture press to prevent default actions
if(!Module["doNotCaptureKeyboard"]){var keyboardListeningElement=Module["keyboardListeningElement"]||document;keyboardListeningElement.addEventListener("keydown",SDL.receiveEvent);keyboardListeningElement.addEventListener("keyup",SDL.receiveEvent);keyboardListeningElement.addEventListener("keypress",SDL.receiveEvent);window.addEventListener("focus",SDL.receiveEvent);window.addEventListener("blur",SDL.receiveEvent);document.addEventListener("visibilitychange",SDL.receiveEvent);}window.addEventListener("unload",SDL.receiveEvent);SDL.keyboardState=_calloc(65536,1);// Our SDL needs 512, but 64K is safe for older SDLs
// Initialize this structure carefully for closure
SDL.DOMEventToSDLEvent["keydown"]=768;/* SDL_KEYDOWN */SDL.DOMEventToSDLEvent["keyup"]=769;/* SDL_KEYUP */SDL.DOMEventToSDLEvent["keypress"]=771;/* SDL_TEXTINPUT */SDL.DOMEventToSDLEvent["mousedown"]=1025;/* SDL_MOUSEBUTTONDOWN */SDL.DOMEventToSDLEvent["mouseup"]=1026;/* SDL_MOUSEBUTTONUP */SDL.DOMEventToSDLEvent["mousemove"]=1024;/* SDL_MOUSEMOTION */SDL.DOMEventToSDLEvent["wheel"]=1027;/* SDL_MOUSEWHEEL */SDL.DOMEventToSDLEvent["touchstart"]=1792;/* SDL_FINGERDOWN */SDL.DOMEventToSDLEvent["touchend"]=1793;/* SDL_FINGERUP */SDL.DOMEventToSDLEvent["touchmove"]=1794;/* SDL_FINGERMOTION */SDL.DOMEventToSDLEvent["unload"]=256;/* SDL_QUIT */SDL.DOMEventToSDLEvent["resize"]=28673;/* SDL_VIDEORESIZE/SDL_EVENT_COMPAT2 */SDL.DOMEventToSDLEvent["visibilitychange"]=512;/* SDL_WINDOWEVENT */SDL.DOMEventToSDLEvent["focus"]=512;/* SDL_WINDOWEVENT */SDL.DOMEventToSDLEvent["blur"]=512;// These are not technically DOM events; the HTML gamepad API is poll-based.
// However, we define them here, as the rest of the SDL code assumes that
// all SDL events originate as DOM events.
SDL.DOMEventToSDLEvent["joystick_axis_motion"]=1536;/* SDL_JOYAXISMOTION */SDL.DOMEventToSDLEvent["joystick_button_down"]=1539;/* SDL_JOYBUTTONDOWN */SDL.DOMEventToSDLEvent["joystick_button_up"]=1540;/* SDL_JOYBUTTONUP */return 0;};// success
_SDL_Init.sig="ii";var _SDL_WasInit=flags=>{if(SDL.startTime===null){_SDL_Init(0);}return 1;};_SDL_WasInit.sig="ii";function _SDL_GetVideoInfo(){var ret=_calloc(20,1);HEAP32[ret+12>>>2>>>0]=Module["canvas"].width;HEAP32[ret+16>>>2>>>0]=Module["canvas"].height;return ret;}_SDL_GetVideoInfo.sig="p";function _SDL_ListModes(format,flags){format>>>=0;return-1;}_SDL_ListModes.sig="ppi";var _SDL_VideoModeOK=(width,height,depth,flags)=>depth;_SDL_VideoModeOK.sig="iiiii";/** @suppress {duplicate } */function _SDL_VideoDriverName(buf,max_size){buf>>>=0;if(SDL.startTime===null){return 0;}//driverName - emscripten_sdl_driver
var driverName=[101,109,115,99,114,105,112,116,101,110,95,115,100,108,95,100,114,105,118,101,114];var index=0;var size=driverName.length;if(max_size<=size){size=max_size-1;}//-1 cause null-terminator
while(index<size){var value=driverName[index];HEAP8[buf+index>>>0]=value;index++;}HEAP8[buf+index>>>0]=0;return buf;}_SDL_VideoDriverName.sig="ppi";var _SDL_AudioDriverName=_SDL_VideoDriverName;_SDL_AudioDriverName.sig="ppi";var _SDL_SetVideoMode=function(width,height,depth,flags){["touchstart","touchend","touchmove","mousedown","mouseup","mousemove","mousewheel","wheel","mouseout","DOMMouseScroll"].forEach(e=>Module["canvas"].addEventListener(e,SDL.receiveEvent,true));var canvas=Module["canvas"];// (0,0) means 'use fullscreen' in native; in Emscripten, use the current canvas size.
if(width==0&&height==0){width=canvas.width;height=canvas.height;}if(!SDL.addedResizeListener){SDL.addedResizeListener=true;Browser.resizeListeners.push((w,h)=>{if(!SDL.settingVideoMode){SDL.receiveEvent({type:"resize",w,h});}});}SDL.settingVideoMode=true;// SetVideoMode itself should not trigger resize events
Browser.setCanvasSize(width,height);SDL.settingVideoMode=false;// Free the old surface first if there is one
if(SDL.screen){SDL.freeSurface(SDL.screen);assert(!SDL.screen);}if(SDL.GL)flags=flags|67108864;// SDL_OPENGL - if we are using GL, then later calls to SetVideoMode may not mention GL, but we do need it. Once in GL mode, we never leave it.
SDL.screen=SDL.makeSurface(width,height,flags,true,"screen");return SDL.screen;};_SDL_SetVideoMode.sig="piiii";function _SDL_GetVideoSurface(){return SDL.screen;}_SDL_GetVideoSurface.sig="p";var _SDL_AudioQuit=()=>{for(var i=0;i<SDL.numChannels;++i){var chan=/** @type {{ audio: (HTMLMediaElement|undefined) }} */SDL.channels[i];if(chan.audio){chan.audio.pause();chan.audio=undefined;}}var audio=/** @type {HTMLMediaElement} */SDL.music.audio;audio?.pause();SDL.music.audio=undefined;};_SDL_AudioQuit.sig="v";var _SDL_VideoQuit=()=>out("SDL_VideoQuit called (and ignored)");_SDL_VideoQuit.sig="v";var _SDL_QuitSubSystem=flags=>out("SDL_QuitSubSystem called (and ignored)");_SDL_QuitSubSystem.sig="vi";var _SDL_Quit=()=>{_SDL_AudioQuit();out("SDL_Quit called (and ignored)");};_SDL_Quit.sig="v";function _SDL_UnlockSurface(surf){surf>>>=0;assert(!SDL.GL);// in GL mode we do not keep around 2D canvases and contexts
var surfData=SDL.surfaces[surf];if(!surfData.locked||--surfData.locked>0){return;}// Copy pixel data to image
if(surfData.isFlagSet(2097152))/* SDL_HWPALETTE */{SDL.copyIndexedColorData(surfData);}else if(!surfData.colors){var data=surfData.image.data;var buffer=surfData.buffer;assert(buffer%4==0,"Invalid buffer offset: "+buffer);var src=buffer>>>2;var dst=0;var isScreen=surf==SDL.screen;var num;if(typeof CanvasPixelArray!="undefined"&&data instanceof CanvasPixelArray){// IE10/IE11: ImageData objects are backed by the deprecated CanvasPixelArray,
// not UInt8ClampedArray. These don't have buffers, so we need to revert
// to copying a byte at a time. We do the undefined check because modern
// browsers do not define CanvasPixelArray anymore.
num=data.length;while(dst<num){var val=HEAP32[src>>>0];// This is optimized. Instead, we could do HEAP32[(((buffer)+(dst))>>>2)];
data[dst]=val&255;data[dst+1]=val>>8&255;data[dst+2]=val>>16&255;data[dst+3]=isScreen?255:val>>24&255;src++;dst+=4;}}else{var data32=new Uint32Array(data.buffer);if(isScreen&&SDL.defaults.opaqueFrontBuffer){num=data32.length;// logically we need to do
//      while (dst < num) {
//          data32[dst++] = HEAP32[src++] | 0xff000000
//      }
// the following code is faster though, because
// .set() is almost free - easily 10x faster due to
// native memcpy efficiencies, and the remaining loop
// just stores, not load + store, so it is faster
data32.set(HEAP32.subarray(src>>>0,src+num>>>0));var data8=new Uint8Array(data.buffer);var i=3;var j=i+4*num;if(num%8==0){// unrolling gives big speedups
while(i<j){data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;data8[i]=255;i=i+4|0;}}else{while(i<j){data8[i]=255;i=i+4|0;}}}else{data32.set(HEAP32.subarray(src>>>0,src+data32.length>>>0));}}}else{var width=Module["canvas"].width;var height=Module["canvas"].height;var s=surfData.buffer;var data=surfData.image.data;var colors=surfData.colors;// TODO: optimize using colors32
for(var y=0;y<height;y++){var base=y*width*4;for(var x=0;x<width;x++){// See comment above about signs
var val=HEAPU8[s++>>>0]*4;var start=base+x*4;data[start]=colors[val];data[start+1]=colors[val+1];data[start+2]=colors[val+2];}s+=width*3;}}// Copy to canvas
surfData.ctx.putImageData(surfData.image,0,0);}_SDL_UnlockSurface.sig="vp";function _SDL_Flip(surf){surf>>>=0;}_SDL_Flip.sig="ip";function _SDL_UpdateRect(surf,x,y,w,h){surf>>>=0;}_SDL_UpdateRect.sig="vpiiii";function _SDL_UpdateRects(surf,numrects,rects){surf>>>=0;rects>>>=0;}_SDL_UpdateRects.sig="vpip";var _SDL_Delay=delay=>_emscripten_sleep(delay);_SDL_Delay.sig="vi";_SDL_Delay.isAsync=true;function _SDL_WM_SetCaption(title,icon){title>>>=0;icon>>>=0;if(title){_emscripten_set_window_title(title);}icon&&=UTF8ToString(icon);}_SDL_WM_SetCaption.sig="vpp";var _SDL_EnableKeyRepeat=(delay,interval)=>{};_SDL_EnableKeyRepeat.sig="iii";/** @param {number} numKeys */function _SDL_GetKeyboardState(numKeys){numKeys>>>=0;if(numKeys){HEAP32[numKeys>>>2>>>0]=65536;}return SDL.keyboardState;}_SDL_GetKeyboardState.sig="pp";var _SDL_GetKeyState=()=>_SDL_GetKeyboardState(0);function _SDL_GetKeyName(key){SDL.keyName||=stringToNewUTF8("unknown key");return SDL.keyName;}_SDL_GetKeyName.sig="pi";var _SDL_GetModState=()=>SDL.modState;_SDL_GetModState.sig="i";function _SDL_GetMouseState(x,y){x>>>=0;y>>>=0;if(x)HEAP32[x>>>2>>>0]=Browser.mouseX;if(y)HEAP32[y>>>2>>>0]=Browser.mouseY;return SDL.buttonState;}_SDL_GetMouseState.sig="ipp";var _SDL_WarpMouse=(x,y)=>{};// TODO: implement this in a non-buggy way. Need to keep relative mouse movements correct after calling this
/*
      var rect = Module["canvas"].getBoundingClientRect();
      SDL.events.push({
        type: 'mousemove',
        pageX: x + (window.scrollX + rect.left),
        pageY: y + (window.scrollY + rect.top)
      });
      */_SDL_WarpMouse.sig="vii";var _SDL_ShowCursor=toggle=>{switch(toggle){case 0:// SDL_DISABLE
if(Browser.isFullscreen){// only try to lock the pointer when in full screen mode
Module["canvas"].requestPointerLock();return 0;}// else return SDL_ENABLE to indicate the failure
return 1;case 1:// SDL_ENABLE
Module["canvas"].exitPointerLock();return 1;case-1:// SDL_QUERY
return!Browser.pointerLock;default:err(`SDL_ShowCursor called with unknown toggle parameter value: ${toggle}`);break;}};_SDL_ShowCursor.sig="ii";function _SDL_GetError(){SDL.errorMessage||=stringToNewUTF8("unknown SDL-emscripten error");return SDL.errorMessage;}_SDL_GetError.sig="p";function _SDL_SetError(fmt,varargs){fmt>>>=0;varargs>>>=0;}_SDL_SetError.sig="vpp";function _SDL_CreateRGBSurface(flags,width,height,depth,rmask,gmask,bmask,amask){return SDL.makeSurface(width,height,flags,false,"CreateRGBSurface",rmask,gmask,bmask,amask);}_SDL_CreateRGBSurface.sig="piiiiiiii";function _SDL_CreateRGBSurfaceFrom(pixels,width,height,depth,pitch,rmask,gmask,bmask,amask){pixels>>>=0;var surf=SDL.makeSurface(width,height,0,false,"CreateRGBSurfaceFrom",rmask,gmask,bmask,amask);if(depth!==32){// TODO: Actually fill pixel data to created surface.
// TODO: Take into account depth and pitch parameters.
err("TODO: Partially unimplemented SDL_CreateRGBSurfaceFrom called!");return surf;}var data=SDL.surfaces[surf];var image=data.ctx.createImageData(width,height);var pitchOfDst=width*4;for(var row=0;row<height;++row){var baseOfSrc=row*pitch;var baseOfDst=row*pitchOfDst;for(var col=0;col<width*4;++col){image.data[baseOfDst+col]=HEAPU8[pixels+(baseOfDst+col)>>>0];}}data.ctx.putImageData(image,0,0);return surf;}_SDL_CreateRGBSurfaceFrom.sig="ppiiiiiiii";/** @param {number} format @param {number} flags */function _SDL_ConvertSurface(surf,format,flags){surf>>>=0;format>>>=0;if(format){SDL.checkPixelFormat(format);}var oldData=SDL.surfaces[surf];var ret=SDL.makeSurface(oldData.width,oldData.height,oldData.flags,false,"copy:"+oldData.source);var newData=SDL.surfaces[ret];newData.ctx.globalCompositeOperation="copy";newData.ctx.drawImage(oldData.canvas,0,0);newData.ctx.globalCompositeOperation=oldData.ctx.globalCompositeOperation;return ret;}_SDL_ConvertSurface.sig="pppi";function _SDL_DisplayFormatAlpha(surf){surf>>>=0;return _SDL_ConvertSurface(surf,0,0);}_SDL_DisplayFormatAlpha.sig="pp";function _SDL_FreeSurface(surf){surf>>>=0;if(surf)SDL.freeSurface(surf);}_SDL_FreeSurface.sig="vp";function _SDL_UpperBlit(src,srcrect,dst,dstrect){src>>>=0;srcrect>>>=0;dst>>>=0;dstrect>>>=0;return SDL.blitSurface(src,srcrect,dst,dstrect,false);}_SDL_UpperBlit.sig="ipppp";function _SDL_UpperBlitScaled(src,srcrect,dst,dstrect){src>>>=0;srcrect>>>=0;dst>>>=0;dstrect>>>=0;return SDL.blitSurface(src,srcrect,dst,dstrect,true);}_SDL_UpperBlitScaled.sig="ipppp";var _SDL_LowerBlit=_SDL_UpperBlit;_SDL_LowerBlit.sig="ipppp";var _SDL_LowerBlitScaled=_SDL_UpperBlitScaled;_SDL_LowerBlitScaled.sig="ipppp";function _SDL_GetClipRect(surf,rect){surf>>>=0;rect>>>=0;assert(rect);var surfData=SDL.surfaces[surf];var r=surfData.clipRect||{x:0,y:0,w:surfData.width,h:surfData.height};SDL.updateRect(rect,r);}_SDL_GetClipRect.sig="vpp";function _SDL_SetClipRect(surf,rect){surf>>>=0;rect>>>=0;var surfData=SDL.surfaces[surf];if(rect){surfData.clipRect=SDL.intersectionOfRects({x:0,y:0,w:surfData.width,h:surfData.height},SDL.loadRect(rect));}else{delete surfData.clipRect;}}_SDL_SetClipRect.sig="ipp";function _SDL_FillRect(surf,rect,color){surf>>>=0;rect>>>=0;var surfData=SDL.surfaces[surf];assert(!surfData.locked);// but we could unlock and re-lock if we must..
if(surfData.isFlagSet(2097152))/* SDL_HWPALETTE */{//in SDL_HWPALETTE color is index (0..255)
//so we should translate 1 byte value to
//32 bit canvas
color=surfData.colors32[color];}var r=rect?SDL.loadRect(rect):{x:0,y:0,w:surfData.width,h:surfData.height};if(surfData.clipRect){r=SDL.intersectionOfRects(surfData.clipRect,r);if(rect){SDL.updateRect(rect,r);}}surfData.ctx.save();surfData.ctx.fillStyle=SDL.translateColorToCSSRGBA(color);surfData.ctx.fillRect(r.x,r.y,r.w,r.h);surfData.ctx.restore();return 0;}_SDL_FillRect.sig="ippi";function _zoomSurface(src,x,y,smooth){src>>>=0;var srcData=SDL.surfaces[src];var w=srcData.width*x;var h=srcData.height*y;var ret=SDL.makeSurface(Math.abs(w),Math.abs(h),srcData.flags,false,"zoomSurface");var dstData=SDL.surfaces[ret];if(x>=0&&y>=0)dstData.ctx.drawImage(srcData.canvas,0,0,w,h);else{dstData.ctx.save();dstData.ctx.scale(x<0?-1:1,y<0?-1:1);dstData.ctx.drawImage(srcData.canvas,w<0?w:0,h<0?h:0,Math.abs(w),Math.abs(h));// XXX I think this should work according to the spec, but currently
// fails on FF: dstData.ctx.drawImage(srcData.canvas, 0, 0, w, h);
dstData.ctx.restore();}return ret;}_zoomSurface.sig="ppddi";function _rotozoomSurface(src,angle,zoom,smooth){src>>>=0;if(angle%360===0){return _zoomSurface(src,zoom,zoom,smooth);}var srcData=SDL.surfaces[src];var w=srcData.width*zoom;var h=srcData.height*zoom;var diagonal=Math.ceil(Math.sqrt(Math.pow(w,2)+Math.pow(h,2)));var ret=SDL.makeSurface(diagonal,diagonal,srcData.flags,false,"rotozoomSurface");var dstData=SDL.surfaces[ret];dstData.ctx.translate(diagonal/2,diagonal/2);dstData.ctx.rotate(-angle*Math.PI/180);dstData.ctx.drawImage(srcData.canvas,-w/2,-h/2,w,h);return ret;}_rotozoomSurface.sig="ppddi";function _SDL_SetAlpha(surf,flag,alpha){surf>>>=0;var surfData=SDL.surfaces[surf];surfData.alpha=alpha;if(!(flag&65536)){// !SDL_SRCALPHA
surfData.alpha=255;}}_SDL_SetAlpha.sig="ipii";function _SDL_SetColorKey(surf,flag,key){surf>>>=0;// SetColorKey assigns one color to be rendered as transparent. I don't
// think the canvas API allows for anything like this, and iterating through
// each pixel to replace that color seems prohibitively expensive.
warnOnce("SDL_SetColorKey is a no-op for performance reasons");return 0;}_SDL_SetColorKey.sig="ipii";function _SDL_PollEvent(ptr){ptr>>>=0;return SDL.pollEvent(ptr);}_SDL_PollEvent.sig="ip";function _SDL_PushEvent(ptr){ptr>>>=0;var copy=_malloc(28);_memcpy(copy,ptr,28);SDL.events.push(copy);return 0;}_SDL_PushEvent.sig="ip";function _SDL_PeepEvents(events,requestedEventCount,action,from,to){events>>>=0;switch(action){case 2:{// SDL_GETEVENT
// We only handle 1 event right now
assert(requestedEventCount==1);var index=0;var retrievedEventCount=0;// this should look through the entire queue until it has filled up the events
// array
while(index<SDL.events.length&&retrievedEventCount<requestedEventCount){var event=SDL.events[index];var type=SDL.DOMEventToSDLEvent[event.type];if(from<=type&&type<=to){if(SDL.makeCEvent(event,events)===false){index++;}else{SDL.events.splice(index,1);retrievedEventCount++;}}else{index++;}}return retrievedEventCount;}default:throw"SDL_PeepEvents does not yet support that action: "+action;}}_SDL_PeepEvents.sig="ipiiii";var _SDL_PumpEvents=()=>SDL.events.forEach(SDL.handleEvent);_SDL_PumpEvents.sig="v";function _emscripten_SDL_SetEventHandler(handler,userdata){handler>>>=0;userdata>>>=0;SDL.eventHandler=handler;SDL.eventHandlerContext=userdata;// All SDLEvents take the same amount of memory
SDL.eventHandlerTemp||=_malloc(28);}_emscripten_SDL_SetEventHandler.sig="vpp";function _SDL_SetColors(surf,colors,firstColor,nColors){surf>>>=0;colors>>>=0;var surfData=SDL.surfaces[surf];// we should create colors array
// only once cause client code
// often wants to change portion
// of palette not all palette.
if(!surfData.colors){var buffer=new ArrayBuffer(256*4);// RGBA, A is unused, but faster this way
surfData.colors=new Uint8Array(buffer);surfData.colors32=new Uint32Array(buffer);}for(var i=0;i<nColors;++i){var index=(firstColor+i)*4;surfData.colors[index]=HEAPU8[colors+i*4>>>0];surfData.colors[index+1]=HEAPU8[colors+(i*4+1)>>>0];surfData.colors[index+2]=HEAPU8[colors+(i*4+2)>>>0];surfData.colors[index+3]=255;}// opaque
return 1;}_SDL_SetColors.sig="ippii";function _SDL_SetPalette(surf,flags,colors,firstColor,nColors){surf>>>=0;colors>>>=0;return _SDL_SetColors(surf,colors,firstColor,nColors);}_SDL_SetPalette.sig="ipipii";function _SDL_MapRGB(fmt,r,g,b){fmt>>>=0;SDL.checkPixelFormat(fmt);// We assume the machine is little-endian.
return r&255|(g&255)<<8|(b&255)<<16|4278190080;}_SDL_MapRGB.sig="ipiii";function _SDL_MapRGBA(fmt,r,g,b,a){fmt>>>=0;SDL.checkPixelFormat(fmt);// We assume the machine is little-endian.
return r&255|(g&255)<<8|(b&255)<<16|(a&255)<<24;}_SDL_MapRGBA.sig="ipiiii";function _SDL_GetRGB(pixel,fmt,r,g,b){fmt>>>=0;r>>>=0;g>>>=0;b>>>=0;SDL.checkPixelFormat(fmt);// We assume the machine is little-endian.
if(r){HEAP8[r>>>0]=pixel&255;}if(g){HEAP8[g>>>0]=pixel>>8&255;}if(b){HEAP8[b>>>0]=pixel>>16&255;}}_SDL_GetRGB.sig="vipppp";function _SDL_GetRGBA(pixel,fmt,r,g,b,a){fmt>>>=0;r>>>=0;g>>>=0;b>>>=0;a>>>=0;SDL.checkPixelFormat(fmt);// We assume the machine is little-endian.
if(r){HEAP8[r>>>0]=pixel&255;}if(g){HEAP8[g>>>0]=pixel>>8&255;}if(b){HEAP8[b>>>0]=pixel>>16&255;}if(a){HEAP8[a>>>0]=pixel>>24&255;}}_SDL_GetRGBA.sig="vippppp";var _SDL_GetAppState=()=>{var state=0;if(Browser.pointerLock){state|=1;}// SDL_APPMOUSEFOCUS
if(document.hasFocus()){state|=2;}// SDL_APPINPUTFOCUS
state|=4;// SDL_APPACTIVE
return state;};_SDL_GetAppState.sig="i";var _SDL_WM_GrabInput=()=>{};_SDL_WM_GrabInput.sig="ii";function _SDL_WM_ToggleFullScreen(surf){surf>>>=0;if(Browser.exitFullscreen()){return 1;}if(!SDL.canRequestFullscreen){return 0;}SDL.isRequestingFullscreen=true;return 1;}_SDL_WM_ToggleFullScreen.sig="ip";var _IMG_Init=flags=>flags;_IMG_Init.sig="ii";function _SDL_FreeRW(rwopsID){rwopsID>>>=0;SDL.rwops[rwopsID]=null;while(SDL.rwops.length>0&&SDL.rwops[SDL.rwops.length-1]===null){SDL.rwops.pop();}}_SDL_FreeRW.sig="vp";var _IMG_Load_RW=function(rwopsID,freeSrc){rwopsID>>>=0;var sp=stackSave();try{// stb_image integration support
var cleanup=()=>{stackRestore(sp);if(rwops&&freeSrc)_SDL_FreeRW(rwopsID);};var addCleanup=func=>{var old=cleanup;cleanup=()=>{old();func();};};var callStbImage=(func,params)=>{var x=stackAlloc(4);var y=stackAlloc(4);var comp=stackAlloc(4);var data=Module["_"+func](...params,x,y,comp,0);if(!data)return null;addCleanup(()=>Module["_stbi_image_free"](data));return{rawData:true,data,width:HEAP32[x>>>2>>>0],height:HEAP32[y>>>2>>>0],size:HEAP32[x>>>2>>>0]*HEAP32[y>>>2>>>0]*HEAP32[comp>>>2>>>0],bpp:HEAP32[comp>>>2>>>0]};};var rwops=SDL.rwops[rwopsID];if(rwops===undefined){return 0;}var raw;var filename=rwops.filename;if(filename===undefined){warnOnce("Only file names that have been preloaded are supported for IMG_Load_RW. Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins");return 0;}if(!raw){filename=PATH_FS.resolve(filename);raw=preloadedImages[filename];if(!raw){if(raw===null)err("Trying to reuse preloaded image, but freePreloadedMediaOnUse is set!");warnOnce("Cannot find preloaded image "+filename);warnOnce("Cannot find preloaded image "+filename+". Consider using STB_IMAGE=1 if you want synchronous image decoding (see settings.js), or package files with --use-preload-plugins");return 0;}else if(Module["freePreloadedMediaOnUse"]){preloadedImages[filename]=null;}}var surf=SDL.makeSurface(raw.width,raw.height,0,false,"load:"+filename);var surfData=SDL.surfaces[surf];surfData.ctx.globalCompositeOperation="copy";if(!raw.rawData){surfData.ctx.drawImage(raw,0,0,raw.width,raw.height,0,0,raw.width,raw.height);}else{var imageData=surfData.ctx.getImageData(0,0,surfData.width,surfData.height);if(raw.bpp==4){// rgba
imageData.data.set(HEAPU8.subarray(raw.data>>>0,raw.data+raw.size>>>0));}else if(raw.bpp==3){// rgb
var pixels=raw.size/3;var data=imageData.data;var sourcePtr=raw.data;var destPtr=0;for(var i=0;i<pixels;i++){data[destPtr++]=HEAPU8[sourcePtr++>>>0];data[destPtr++]=HEAPU8[sourcePtr++>>>0];data[destPtr++]=HEAPU8[sourcePtr++>>>0];data[destPtr++]=255;}}else if(raw.bpp==2){// grayscale + alpha
var pixels=raw.size;var data=imageData.data;var sourcePtr=raw.data;var destPtr=0;for(var i=0;i<pixels;i++){var gray=HEAPU8[sourcePtr++>>>0];var alpha=HEAPU8[sourcePtr++>>>0];data[destPtr++]=gray;data[destPtr++]=gray;data[destPtr++]=gray;data[destPtr++]=alpha;}}else if(raw.bpp==1){// grayscale
var pixels=raw.size;var data=imageData.data;var sourcePtr=raw.data;var destPtr=0;for(var i=0;i<pixels;i++){var value=HEAPU8[sourcePtr++>>>0];data[destPtr++]=value;data[destPtr++]=value;data[destPtr++]=value;data[destPtr++]=255;}}else{err(`cannot handle bpp ${raw.bpp}`);return 0;}surfData.ctx.putImageData(imageData,0,0);}surfData.ctx.globalCompositeOperation="source-over";// XXX SDL does not specify that loaded images must have available pixel data, in fact
//     there are cases where you just want to blit them, so you just need the hardware
//     accelerated version. However, code everywhere seems to assume that the pixels
//     are in fact available, so we retrieve it here. This does add overhead though.
_SDL_LockSurface(surf);surfData.locked--;// The surface is not actually locked in this hack
if(SDL.GL){// After getting the pixel data, we can free the canvas and context if we do not need to do 2D canvas blitting
surfData.canvas=surfData.ctx=null;}return surf;}finally{cleanup();}};_IMG_Load_RW.sig="ppi";var _SDL_LoadBMP_RW=_IMG_Load_RW;_SDL_LoadBMP_RW.sig="ppi";/** @param {number} mode */function _SDL_RWFromFile(_name,mode){_name>>>=0;mode>>>=0;var id=SDL.rwops.length;// TODO: recycle ids when they are null
var filename=UTF8ToString(_name);SDL.rwops.push({filename,mimetype:Browser.getMimetype(filename)});return id;}_SDL_RWFromFile.sig="ppp";function _IMG_Load(filename){filename>>>=0;var rwops=_SDL_RWFromFile(filename,0);var result=_IMG_Load_RW(rwops,1);return result;}_IMG_Load.sig="pp";var _IMG_Quit=()=>out("IMG_Quit called (and ignored)");_IMG_Quit.sig="v";function _SDL_OpenAudio(desired,obtained){desired>>>=0;obtained>>>=0;try{SDL.audio={freq:HEAPU32[desired>>>2>>>0],format:HEAPU16[desired+4>>>1>>>0],channels:HEAPU8[desired+6>>>0],samples:HEAPU16[desired+8>>>1>>>0],// Samples in the CB buffer per single sound channel.
callback:HEAPU32[desired+16>>>2>>>0],userdata:HEAPU32[desired+20>>>2>>>0],paused:true,timer:null};// The .silence field tells the constant sample value that corresponds to the safe un-skewed silence value for the wave data.
if(SDL.audio.format==8){SDL.audio.silence=128;}else// Audio ranges in [0, 255], so silence is half-way in between.
if(SDL.audio.format==32784){SDL.audio.silence=0;}else// Signed data in range [-32768, 32767], silence is 0.
if(SDL.audio.format==33056){SDL.audio.silence=0;}else// Float data in range [-1.0, 1.0], silence is 0.0
{throw"Invalid SDL audio format "+SDL.audio.format+"!";}// Round the desired audio frequency up to the next 'common' frequency value.
// Web Audio API spec states 'An implementation must support sample-rates in at least the range 22050 to 96000.'
if(SDL.audio.freq<=0){throw"Unsupported sound frequency "+SDL.audio.freq+"!";}else if(SDL.audio.freq<=22050){SDL.audio.freq=22050;}else// Take it safe and clamp everything lower than 22kHz to that.
if(SDL.audio.freq<=32e3){SDL.audio.freq=32e3;}else if(SDL.audio.freq<=44100){SDL.audio.freq=44100;}else if(SDL.audio.freq<=48e3){SDL.audio.freq=48e3;}else if(SDL.audio.freq<=96e3){SDL.audio.freq=96e3;}else{throw`Unsupported sound frequency ${SDL.audio.freq}!`;}if(SDL.audio.channels==0){SDL.audio.channels=1;}else// In SDL both 0 and 1 mean mono.
if(SDL.audio.channels<0||SDL.audio.channels>32){throw`Unsupported number of audio channels for SDL audio: ${SDL.audio.channels}!`;}else if(SDL.audio.channels!=1&&SDL.audio.channels!=2){// Unsure what SDL audio spec supports. Web Audio spec supports up to 32 channels.
out(`Warning: Using untested number of audio channels ${SDL.audio.channels}`);}if(SDL.audio.samples<128||SDL.audio.samples>524288)/* arbitrary cap */{throw`Unsupported audio callback buffer size ${SDL.audio.samples}!`;}else if((SDL.audio.samples&SDL.audio.samples-1)!=0){throw`Audio callback buffer size ${SDL.audio.samples} must be a power-of-two!`;}var totalSamples=SDL.audio.samples*SDL.audio.channels;if(SDL.audio.format==8){SDL.audio.bytesPerSample=1;}else if(SDL.audio.format==32784){SDL.audio.bytesPerSample=2;}else if(SDL.audio.format==33056){SDL.audio.bytesPerSample=4;}else{throw`Invalid SDL audio format ${SDL.audio.format}!`;}SDL.audio.bufferSize=totalSamples*SDL.audio.bytesPerSample;// Duration of a single queued buffer in seconds.
SDL.audio.bufferDurationSecs=SDL.audio.bufferSize/SDL.audio.bytesPerSample/SDL.audio.channels/SDL.audio.freq;// Audio samples are played with a constant delay of this many seconds to account for browser and jitter.
SDL.audio.bufferingDelay=50/1e3;SDL.audio.buffer=_malloc(SDL.audio.bufferSize);// To account for jittering in frametimes, always have multiple audio
// buffers queued up for the audio output device.
// This helps that we won't starve that easily if a frame takes long to complete.
SDL.audio.numSimultaneouslyQueuedBuffers=Module["SDL_numSimultaneouslyQueuedBuffers"]||5;// Pulls and queues new audio data if appropriate. This function gets
// "over-called" in both requestAnimationFrames and setTimeouts to ensure
// that we get the finest granularity possible and as many chances from
// the browser to fill new audio data. This is because setTimeouts alone
// have very poor granularity for audio streaming purposes, but also the
// application might not be using emscripten_set_main_loop to drive the
// main loop, so we cannot rely on that alone.
SDL.audio.queueNewAudioData=()=>{if(!SDL.audio)return;for(var i=0;i<SDL.audio.numSimultaneouslyQueuedBuffers;++i){// Only queue new data if we don't have enough audio data already in queue. Otherwise skip this time slot
// and wait to queue more in the next time the callback is run.
var secsUntilNextPlayStart=SDL.audio.nextPlayTime-SDL.audioContext["currentTime"];if(secsUntilNextPlayStart>=SDL.audio.bufferingDelay+SDL.audio.bufferDurationSecs*SDL.audio.numSimultaneouslyQueuedBuffers)return;// Ask SDL audio data from the user code.
((a1,a2,a3)=>{})(/* a dynamic function call to signature viii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */SDL.audio.userdata,SDL.audio.buffer,SDL.audio.bufferSize);// And queue it to be played after the currently playing audio stream.
SDL.audio.pushAudio(SDL.audio.buffer,SDL.audio.bufferSize);}};var sleepCallback=()=>{SDL.audio?.queueNewAudioData?.();};Asyncify.sleepCallbacks.push(sleepCallback);SDL.audio.callbackRemover=()=>{Asyncify.sleepCallbacks=Asyncify.sleepCallbacks.filter(callback=>callback!==sleepCallback);};// Create a callback function that will be routinely called to ask more audio data from the user application.
SDL.audio.caller=()=>{if(!SDL.audio)return;--SDL.audio.numAudioTimersPending;SDL.audio.queueNewAudioData();// Queue this callback function to be called again later to pull more audio data.
var secsUntilNextPlayStart=SDL.audio.nextPlayTime-SDL.audioContext["currentTime"];// Queue the next audio frame push to be performed half-way when the previously queued buffer has finished playing.
var preemptBufferFeedSecs=SDL.audio.bufferDurationSecs/2;if(SDL.audio.numAudioTimersPending<SDL.audio.numSimultaneouslyQueuedBuffers){++SDL.audio.numAudioTimersPending;SDL.audio.timer=safeSetTimeout(SDL.audio.caller,Math.max(0,1e3*(secsUntilNextPlayStart-preemptBufferFeedSecs)));// If we are risking starving, immediately queue an extra buffer.
if(SDL.audio.numAudioTimersPending<SDL.audio.numSimultaneouslyQueuedBuffers){++SDL.audio.numAudioTimersPending;safeSetTimeout(SDL.audio.caller,1);}}};SDL.audio.audioOutput=new Audio();// Initialize Web Audio API if we haven't done so yet. Note: Only initialize Web Audio context ever once on the web page,
// since initializing multiple times fails on Chrome saying 'audio resources have been exhausted'.
SDL.openAudioContext();if(!SDL.audioContext)throw"Web Audio API is not available!";autoResumeAudioContext(SDL.audioContext);SDL.audio.nextPlayTime=0;// Time in seconds when the next audio block is due to start.
// The pushAudio function with a new audio buffer whenever there is new
// audio data to schedule to be played back on the device.
SDL.audio.pushAudio=(ptr,sizeBytes)=>{try{if(SDL.audio.paused)return;var sizeSamples=sizeBytes/SDL.audio.bytesPerSample;// How many samples fit in the callback buffer?
var sizeSamplesPerChannel=sizeSamples/SDL.audio.channels;// How many samples per a single channel fit in the cb buffer?
if(sizeSamplesPerChannel!=SDL.audio.samples){throw"Received mismatching audio buffer size!";}// Allocate new sound buffer to be played.
var source=SDL.audioContext["createBufferSource"]();var soundBuffer=SDL.audioContext["createBuffer"](SDL.audio.channels,sizeSamplesPerChannel,SDL.audio.freq);source["connect"](SDL.audioContext["destination"]);SDL.fillWebAudioBufferFromHeap(ptr,sizeSamplesPerChannel,soundBuffer);// Workaround https://bugzilla.mozilla.org/show_bug.cgi?id=883675 by setting the buffer only after filling. The order is important here!
source["buffer"]=soundBuffer;// Schedule the generated sample buffer to be played out at the correct time right after the previously scheduled
// sample buffer has finished.
var curtime=SDL.audioContext["currentTime"];// Don't ever start buffer playbacks earlier from current time than a given constant 'SDL.audio.bufferingDelay', since a browser
// may not be able to mix that audio clip in immediately, and there may be subsequent jitter that might cause the stream to starve.
var playtime=Math.max(curtime+SDL.audio.bufferingDelay,SDL.audio.nextPlayTime);if(typeof source["start"]!="undefined"){source["start"](playtime);}else// New Web Audio API: sound sources are started with a .start() call.
if(typeof source["noteOn"]!="undefined"){source["noteOn"](playtime);}/*
            // Uncomment to debug SDL buffer feed starves.
            if (SDL.audio.curBufferEnd) {
              var thisBufferStart = Math.round(playtime * SDL.audio.freq);
              if (thisBufferStart != SDL.audio.curBufferEnd) out('SDL starved ' + (thisBufferStart - SDL.audio.curBufferEnd) + ' samples!');
            }
            SDL.audio.curBufferEnd = Math.round(playtime * SDL.audio.freq + sizeSamplesPerChannel);
            */SDL.audio.nextPlayTime=playtime+SDL.audio.bufferDurationSecs;}catch(e){err(`Web Audio API error playing back audio: ${e.toString()}`);}};if(obtained){// Report back the initialized audio parameters.
HEAP32[obtained>>>2>>>0]=SDL.audio.freq;HEAP16[obtained+4>>>1>>>0]=SDL.audio.format;HEAP8[obtained+6>>>0]=SDL.audio.channels;HEAP8[obtained+7>>>0]=SDL.audio.silence;HEAP16[obtained+8>>>1>>>0]=SDL.audio.samples;HEAPU32[obtained+16>>>2>>>0]=SDL.audio.callback;HEAPU32[obtained+20>>>2>>>0]=SDL.audio.userdata;}SDL.allocateChannels(32);}catch(e){err(`Initializing SDL audio threw an exception: "${e.toString()}"! Continuing without audio`);SDL.audio=null;SDL.allocateChannels(0);if(obtained){HEAP32[obtained>>>2>>>0]=0;HEAP16[obtained+4>>>1>>>0]=0;HEAP8[obtained+6>>>0]=0;HEAP8[obtained+7>>>0]=0;HEAP16[obtained+8>>>1>>>0]=0;HEAPU32[obtained+16>>>2>>>0]=0;HEAPU32[obtained+20>>>2>>>0]=0;}}if(!SDL.audio){return-1;}return 0;}_SDL_OpenAudio.sig="ipp";var _SDL_PauseAudio=pauseOn=>{if(!SDL.audio){return;}if(pauseOn){if(SDL.audio.timer!==undefined){clearTimeout(SDL.audio.timer);SDL.audio.numAudioTimersPending=0;SDL.audio.timer=undefined;}}else if(!SDL.audio.timer){// Start the audio playback timer callback loop.
SDL.audio.numAudioTimersPending=1;SDL.audio.timer=safeSetTimeout(SDL.audio.caller,1);}SDL.audio.paused=pauseOn;};_SDL_PauseAudio.sig="vi";var _SDL_CloseAudio=()=>{if(SDL.audio){if(SDL.audio.callbackRemover){SDL.audio.callbackRemover();SDL.audio.callbackRemover=null;}_SDL_PauseAudio(1);_free(SDL.audio.buffer);SDL.audio=null;SDL.allocateChannels(0);}};_SDL_CloseAudio.sig="v";var _SDL_LockAudio=()=>{};_SDL_LockAudio.sig="v";var _SDL_UnlockAudio=()=>{};_SDL_UnlockAudio.sig="v";function _SDL_CreateMutex(){return 0;}_SDL_CreateMutex.sig="p";function _SDL_mutexP(mutex){mutex>>>=0;return 0;}_SDL_mutexP.sig="ip";function _SDL_mutexV(mutex){mutex>>>=0;return 0;}_SDL_mutexV.sig="ip";function _SDL_DestroyMutex(mutex){mutex>>>=0;}_SDL_DestroyMutex.sig="vp";function _SDL_CreateCond(){return 0;}_SDL_CreateCond.sig="p";function _SDL_CondSignal(cond){cond>>>=0;}_SDL_CondSignal.sig="ip";function _SDL_CondWait(cond,mutex){cond>>>=0;mutex>>>=0;}_SDL_CondWait.sig="ipp";function _SDL_DestroyCond(cond){cond>>>=0;}_SDL_DestroyCond.sig="vp";var _SDL_StartTextInput=()=>{SDL.textInput=true;};_SDL_StartTextInput.sig="v";var _SDL_StopTextInput=()=>{SDL.textInput=false;};_SDL_StopTextInput.sig="v";var _Mix_Init=flags=>{if(!flags)return 0;return 8;};/* MIX_INIT_OGG */_Mix_Init.sig="ii";var _Mix_Quit=()=>{};_Mix_Quit.sig="v";var _Mix_OpenAudio=(frequency,format,channels,chunksize)=>{SDL.openAudioContext();autoResumeAudioContext(SDL.audioContext);SDL.allocateChannels(32);// Just record the values for a later call to Mix_QuickLoad_RAW
SDL.mixerFrequency=frequency;SDL.mixerFormat=format;SDL.mixerNumChannels=channels;SDL.mixerChunkSize=chunksize;return 0;};_Mix_OpenAudio.sig="iiiii";var _Mix_CloseAudio=_SDL_CloseAudio;_Mix_CloseAudio.sig="v";var _Mix_AllocateChannels=num=>{SDL.allocateChannels(num);return num;};_Mix_AllocateChannels.sig="ii";function _Mix_ChannelFinished(func){func>>>=0;SDL.channelFinished=func;}_Mix_ChannelFinished.sig="vp";var _Mix_Volume=(channel,volume)=>{if(channel==-1){for(var i=0;i<SDL.numChannels-1;i++){_Mix_Volume(i,volume);}return _Mix_Volume(SDL.numChannels-1,volume);}return SDL.setGetVolume(SDL.channels[channel],volume);};_Mix_Volume.sig="iii";var _Mix_SetPanning=(channel,left,right)=>{// SDL API uses [0-255], while PannerNode has an (x, y, z) position.
// Normalizing.
left/=255;right/=255;// Set the z coordinate a little forward, otherwise there won't be any
// smooth transition between left and right.
SDL.setPannerPosition(SDL.channels[channel],right-left,0,.1);return 1;};_Mix_SetPanning.sig="iiii";/** @param {number} freesrc */function _Mix_LoadWAV_RW(rwopsID,freesrc){rwopsID>>>=0;var rwops=SDL.rwops[rwopsID];if(rwops===undefined)return 0;var filename="";var audio;var webAudio;var bytes;if(rwops.filename!==undefined){filename=PATH_FS.resolve(rwops.filename);var raw=preloadedAudios[filename];if(!raw){if(raw===null)err("Trying to reuse preloaded audio, but freePreloadedMediaOnUse is set!");if(!Module["noAudioDecoding"])warnOnce("Cannot find preloaded audio "+filename);// see if we can read the file-contents from the in-memory FS
try{bytes=FS.readFile(filename);}catch(e){err(`Couldn't find file for: ${filename}`);return 0;}}if(Module["freePreloadedMediaOnUse"]){preloadedAudios[filename]=null;}audio=raw;}else if(rwops.bytes!==undefined){// For Web Audio context buffer decoding, we must make a clone of the audio data, but for <media> element,
// a view to existing data is sufficient.
if(SDL.webAudioAvailable())bytes=HEAPU8.buffer.slice(rwops.bytes,rwops.bytes+rwops.count);else bytes=HEAPU8.subarray(rwops.bytes>>>0,rwops.bytes+rwops.count>>>0);}else{return 0;}var arrayBuffer=bytes?bytes.buffer||bytes:bytes;// To allow user code to work around browser bugs with audio playback on <audio> elements an Web Audio, enable
// the user code to hook in a callback to decide on a file basis whether each file should use Web Audio or <audio> for decoding and playback.
// In particular, see https://bugzilla.mozilla.org/show_bug.cgi?id=654787 and ?id=1012801 for tradeoffs.
var canPlayWithWebAudio=Module["SDL_canPlayWithWebAudio"]===undefined||Module["SDL_canPlayWithWebAudio"](filename,arrayBuffer);if(bytes!==undefined&&SDL.webAudioAvailable()&&canPlayWithWebAudio){audio=undefined;webAudio={};// The audio decoding process is asynchronous, which gives trouble if user code plays the audio data back immediately
// after loading. Therefore prepare an array of callback handlers to run when this audio decoding is complete, which
// will then start the playback (with some delay).
webAudio.onDecodeComplete=[];// While this member array exists, decoding hasn't finished yet.
var onDecodeComplete=data=>{webAudio.decodedBuffer=data;// Call all handlers that were waiting for this decode to finish, and clear the handler list.
webAudio.onDecodeComplete.forEach(e=>e());webAudio.onDecodeComplete=undefined;};// Don't allow more callback handlers since audio has finished decoding.
SDL.audioContext["decodeAudioData"](arrayBuffer,onDecodeComplete);}else if(audio===undefined&&bytes){// Here, we didn't find a preloaded audio but we either were passed a filepath for
// which we loaded bytes, or we were passed some bytes
var blob=new Blob([bytes],{type:rwops.mimetype});var url=URL.createObjectURL(blob);audio=new Audio();audio.src=url;audio.mozAudioChannelType="content";}// bugzilla 910340
var id=SDL.audios.length;// Keep the loaded audio in the audio arrays, ready for playback
SDL.audios.push({source:filename,audio,// Points to the <audio> element, if loaded
webAudio});// Points to a Web Audio -specific resource object, if loaded
return id;}_Mix_LoadWAV_RW.sig="ppi";function _Mix_LoadWAV(filename){filename>>>=0;var rwops=_SDL_RWFromFile(filename,0);var result=_Mix_LoadWAV_RW(rwops,0);_SDL_FreeRW(rwops);return result;}_Mix_LoadWAV.sig="pp";function _Mix_QuickLoad_RAW(mem,len){mem>>>=0;var audio;var webAudio;var numSamples=len>>1;// len is the length in bytes, and the array contains 16-bit PCM values
var buffer=new Float32Array(numSamples);for(var i=0;i<numSamples;++i){buffer[i]=HEAP16[mem+i*2>>>1>>>0]/32768;}// hardcoded 16-bit audio, signed (TODO: reSign if not ta2?)
if(SDL.webAudioAvailable()){webAudio={};webAudio.decodedBuffer=buffer;}else{audio=new Audio();audio.mozAudioChannelType="content";// bugzilla 910340
// Record the number of channels and frequency for later usage
audio.numChannels=SDL.mixerNumChannels;audio.frequency=SDL.mixerFrequency;}// FIXME: doesn't make sense to keep the audio element in the buffer
var id=SDL.audios.length;SDL.audios.push({source:"",audio,webAudio,buffer});return id;}_Mix_QuickLoad_RAW.sig="ppi";function _Mix_FreeChunk(id){id>>>=0;SDL.audios[id]=null;}_Mix_FreeChunk.sig="vp";var _Mix_ReserveChannels=num=>{SDL.channelMinimumNumber=num;};_Mix_ReserveChannels.sig="ii";function _Mix_PlayChannelTimed(channel,id,loops,ticks){id>>>=0;// TODO: handle fixed amount of N loops. Currently loops either 0 or infinite times.
assert(ticks==-1);// Get the audio element associated with the ID
var info=SDL.audios[id];if(!info)return-1;if(!info.audio&&!info.webAudio)return-1;// If the user asks us to allocate a channel automatically, get the first
// free one.
if(channel==-1){for(var i=SDL.channelMinimumNumber;i<SDL.numChannels;i++){if(!SDL.channels[i].audio){channel=i;break;}}if(channel==-1){err(`All ${SDL.numChannels}  channels in use!`);return-1;}}var channelInfo=SDL.channels[channel];var audio;if(info.webAudio){// Create an instance of the WebAudio object.
audio={};audio.resource=info;// This new object is an instance that refers to this existing resource.
audio.paused=false;audio.currentPosition=0;// Make our instance look similar to the instance of a <media> to make api simple.
audio.play=function(){SDL.playWebAudio(this);};audio.pause=function(){SDL.pauseWebAudio(this);};}else{// We clone the audio node to utilize the preloaded audio buffer, since
// the browser has already preloaded the audio file.
audio=info.audio.cloneNode(true);audio.numChannels=info.audio.numChannels;audio.frequency=info.audio.frequency;}audio["onended"]=function(){// TODO: cache these
if(channelInfo.audio==this){channelInfo.audio.paused=true;channelInfo.audio=null;}if(SDL.channelFinished)(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */channel);};channelInfo.audio=audio;// TODO: handle N loops. Behavior matches Mix_PlayMusic
audio.loop=loops!=0;audio.volume=channelInfo.volume;audio.play();return channel;}_Mix_PlayChannelTimed.sig="iipii";var _Mix_FadingChannel=channel=>0;_Mix_FadingChannel.sig="ii";var _Mix_HaltChannel=channel=>{function halt(channel){var info=/** @type {{ audio: HTMLMediaElement }} */SDL.channels[channel];if(info.audio){info.audio.pause();info.audio=null;}if(SDL.channelFinished){(a1=>{})(/* a dynamic function call to signature vi, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */channel);}}if(channel!=-1){halt(channel);}else{for(var i=0;i<SDL.channels.length;++i)halt(i);}return 0;};_Mix_HaltChannel.sig="ii";var _Mix_HaltMusic=()=>{var audio=/** @type {HTMLMediaElement} */SDL.music.audio;if(audio){audio.src=audio.src;// rewind <media> element
audio.currentPosition=0;// rewind Web Audio graph playback.
audio.pause();}SDL.music.audio=null;if(SDL.hookMusicFinished){(()=>{})();}/* a dynamic function call to signature v, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */return 0;};_Mix_HaltMusic.sig="i";function _Mix_HookMusicFinished(func){func>>>=0;SDL.hookMusicFinished=func;if(SDL.music.audio){// ensure the callback will be called, if a music is already playing
SDL.music.audio["onended"]=_Mix_HaltMusic;}}_Mix_HookMusicFinished.sig="vp";var _Mix_VolumeMusic=volume=>SDL.setGetVolume(SDL.music,volume);_Mix_VolumeMusic.sig="ii";function _Mix_LoadMUS_RW(filename){filename>>>=0;return _Mix_LoadWAV_RW(filename,0);}_Mix_LoadMUS_RW.sig="pp";function _Mix_LoadMUS(filename){filename>>>=0;var rwops=_SDL_RWFromFile(filename,0);var result=_Mix_LoadMUS_RW(rwops);_SDL_FreeRW(rwops);return result;}_Mix_LoadMUS.sig="pp";var _Mix_FreeMusic=_Mix_FreeChunk;_Mix_FreeMusic.sig="vp";function _Mix_PlayMusic(id,loops){id>>>=0;// Pause old music if it exists.
if(SDL.music.audio){if(!SDL.music.audio.paused)err(`Music is already playing. ${SDL.music.source}`);SDL.music.audio.pause();}var info=SDL.audios[id];var audio;if(info.webAudio){// Play via Web Audio API
// Create an instance of the WebAudio object.
audio={};audio.resource=info;// This new webAudio object is an instance that refers to this existing resource.
audio.paused=false;audio.currentPosition=0;audio.play=function(){SDL.playWebAudio(this);};audio.pause=function(){SDL.pauseWebAudio(this);};}else if(info.audio){// Play via the <audio> element
audio=info.audio;}audio["onended"]=function(){if(SDL.music.audio==this)_Mix_HaltMusic();};// will send callback
audio.loop=loops!=0&&loops!=1;// TODO: handle N loops for finite N
audio.volume=SDL.music.volume;SDL.music.audio=audio;audio.play();return 0;}_Mix_PlayMusic.sig="ipi";var _Mix_PauseMusic=()=>{var audio=/** @type {HTMLMediaElement} */SDL.music.audio;audio?.pause();};_Mix_PauseMusic.sig="v";var _Mix_ResumeMusic=()=>{var audio=SDL.music.audio;audio?.play();};_Mix_ResumeMusic.sig="v";var _Mix_FadeInMusicPos=_Mix_PlayMusic;_Mix_FadeInMusicPos.sig="ipiid";var _Mix_FadeOutMusic=_Mix_HaltMusic;_Mix_FadeOutMusic.sig="ii";var _Mix_PlayingMusic=()=>SDL.music.audio&&!SDL.music.audio.paused?1:0;_Mix_PlayingMusic.sig="i";var _Mix_Playing=channel=>{if(channel===-1){var count=0;for(var i=0;i<SDL.channels.length;i++){count+=_Mix_Playing(i);}return count;}var info=SDL.channels[channel];if(info?.audio&&!info.audio.paused){return 1;}return 0;};_Mix_Playing.sig="ii";var _Mix_Pause=channel=>{if(channel===-1){for(var i=0;i<SDL.channels.length;i++){_Mix_Pause(i);}return;}/** @type {{ audio: HTMLMediaElement }} */var info=SDL.channels[channel];if(info?.audio){info.audio.pause();}else{}};//err(`Mix_Pause: no sound found for channel: ${channel}`);
_Mix_Pause.sig="vi";var _Mix_Paused=channel=>{if(channel===-1){var pausedCount=0;for(var i=0;i<SDL.channels.length;i++){pausedCount+=_Mix_Paused(i);}return pausedCount;}var info=SDL.channels[channel];if(info?.audio?.paused){return 1;}return 0;};_Mix_Paused.sig="ii";var _Mix_PausedMusic=()=>SDL.music.audio?.paused?1:0;_Mix_PausedMusic.sig="i";var _Mix_Resume=channel=>{if(channel===-1){for(var i=0;i<SDL.channels.length;i++){_Mix_Resume(i);}return;}var info=SDL.channels[channel];if(info?.audio)info.audio.play();};_Mix_Resume.sig="vi";var _TTF_Init=()=>{// OffscreenCanvas 2D is faster than Canvas for text operations, so we use
// it if it's available.
try{var offscreenCanvas=new OffscreenCanvas(0,0);SDL.ttfContext=offscreenCanvas.getContext("2d");// Firefox support for OffscreenCanvas is still experimental, and it seems
// like CI might be creating a context here but one that is not entirely
// valid. Check that explicitly and fall back to a plain Canvas if we need
// to. See https://github.com/emscripten-core/emscripten/issues/16242
if(typeof SDL.ttfContext.measureText!="function"){throw"bad context";}}catch(ex){var canvas=/** @type {HTMLCanvasElement} */document.createElement("canvas");SDL.ttfContext=canvas.getContext("2d");}return 0;};_TTF_Init.sig="i";function _TTF_OpenFont(name,size){name>>>=0;name=PATH.normalize(UTF8ToString(name));var id=SDL.fonts.length;SDL.fonts.push({name,// but we don't actually do anything with it..
size});return id;}_TTF_OpenFont.sig="ppi";function _TTF_CloseFont(font){font>>>=0;SDL.fonts[font]=null;}_TTF_CloseFont.sig="vp";function _TTF_RenderText_Solid(font,text,color){font>>>=0;text>>>=0;color>>>=0;// XXX the font and color are ignored
text=UTF8ToString(text)||" ";// if given an empty string, still return a valid surface
var fontData=SDL.fonts[font];var w=SDL.estimateTextWidth(fontData,text);var h=fontData.size;color=SDL.loadColorToCSSRGB(color);// XXX alpha breaks fonts?
var fontString=SDL.makeFontString(h,fontData.name);var surf=SDL.makeSurface(w,h,0,false,"text:"+text);// bogus numbers..
var surfData=SDL.surfaces[surf];surfData.ctx.save();surfData.ctx.fillStyle=color;surfData.ctx.font=fontString;// use bottom alignment, because it works
// same in all browsers, more info here:
// https://bugzilla.mozilla.org/show_bug.cgi?id=737852
surfData.ctx.textBaseline="bottom";surfData.ctx.fillText(text,0,h|0);surfData.ctx.restore();return surf;}_TTF_RenderText_Solid.sig="pppp";var _TTF_RenderText_Blended=_TTF_RenderText_Solid;_TTF_RenderText_Blended.sig="pppp";var _TTF_RenderText_Shaded=_TTF_RenderText_Solid;_TTF_RenderText_Shaded.sig="ppppp";var _TTF_RenderUTF8_Solid=_TTF_RenderText_Solid;_TTF_RenderUTF8_Solid.sig="pppp";/** @suppress {duplicate } */function _TTF_SizeText(font,text,w,h){font>>>=0;text>>>=0;w>>>=0;h>>>=0;var fontData=SDL.fonts[font];if(w){HEAP32[w>>>2>>>0]=SDL.estimateTextWidth(fontData,UTF8ToString(text));}if(h){HEAP32[h>>>2>>>0]=fontData.size;}return 0;}_TTF_SizeText.sig="ipppp";var _TTF_SizeUTF8=_TTF_SizeText;_TTF_SizeUTF8.sig="ipppp";function _TTF_GlyphMetrics(font,ch,minx,maxx,miny,maxy,advance){font>>>=0;minx>>>=0;maxx>>>=0;miny>>>=0;maxy>>>=0;advance>>>=0;var fontData=SDL.fonts[font];var width=SDL.estimateTextWidth(fontData,String.fromCharCode(ch));if(advance){HEAP32[advance>>>2>>>0]=width;}if(minx){HEAP32[minx>>>2>>>0]=0;}if(maxx){HEAP32[maxx>>>2>>>0]=width;}if(miny){HEAP32[miny>>>2>>>0]=0;}if(maxy){HEAP32[maxy>>>2>>>0]=fontData.size;}}_TTF_GlyphMetrics.sig="ipippppp";function _TTF_FontAscent(font){font>>>=0;var fontData=SDL.fonts[font];return fontData.size*.98|0;}_TTF_FontAscent.sig="ip";function _TTF_FontDescent(font){font>>>=0;var fontData=SDL.fonts[font];return fontData.size*.02|0;}_TTF_FontDescent.sig="ip";function _TTF_FontHeight(font){font>>>=0;var fontData=SDL.fonts[font];return fontData.size;}_TTF_FontHeight.sig="ip";var _TTF_FontLineSkip=_TTF_FontHeight;_TTF_FontLineSkip.sig="ip";var _TTF_Quit=()=>out("TTF_Quit called (and ignored)");_TTF_Quit.sig="v";var SDL_gfx={drawRectangle:(surf,x1,y1,x2,y2,action,cssColor)=>{x1=x1<<16>>16;y1=y1<<16>>16;x2=x2<<16>>16;y2=y2<<16>>16;var surfData=SDL.surfaces[surf];assert(!surfData.locked);// but we could unlock and re-lock if we must..
// TODO: if ctx does not change, leave as is, and also do not re-set xStyle etc.
var x=x1<x2?x1:x2;var y=y1<y2?y1:y2;var w=Math.abs(x2-x1);var h=Math.abs(y2-y1);surfData.ctx.save();surfData.ctx[action+"Style"]=cssColor;surfData.ctx[action+"Rect"](x,y,w,h);surfData.ctx.restore();},drawLine:(surf,x1,y1,x2,y2,cssColor)=>{x1=x1<<16>>16;y1=y1<<16>>16;x2=x2<<16>>16;y2=y2<<16>>16;var surfData=SDL.surfaces[surf];assert(!surfData.locked);// but we could unlock and re-lock if we must..
surfData.ctx.save();surfData.ctx.strokeStyle=cssColor;surfData.ctx.beginPath();surfData.ctx.moveTo(x1,y1);surfData.ctx.lineTo(x2,y2);surfData.ctx.stroke();surfData.ctx.restore();},drawEllipse:(surf,x,y,rx,ry,action,cssColor)=>{x=x<<16>>16;y=y<<16>>16;rx=rx<<16>>16;ry=ry<<16>>16;var surfData=SDL.surfaces[surf];assert(!surfData.locked);// but we could unlock and re-lock if we must..
surfData.ctx.save();surfData.ctx.beginPath();surfData.ctx.translate(x,y);surfData.ctx.scale(rx,ry);surfData.ctx.arc(0,0,1,0,2*Math.PI);surfData.ctx.restore();surfData.ctx.save();surfData.ctx[action+"Style"]=cssColor;surfData.ctx[action]();surfData.ctx.restore();},translateColorToCSSRGBA:rgba=>`rgba(${rgba>>>24},${rgba>>16&255},${rgba>>8&255},${rgba&255})`};function _boxColor(surf,x1,y1,x2,y2,color){surf>>>=0;return SDL_gfx.drawRectangle(surf,x1,y1,x2,y2,"fill",SDL_gfx.translateColorToCSSRGBA(color));}_boxColor.sig="ipiiiii";function _boxRGBA(surf,x1,y1,x2,y2,r,g,b,a){surf>>>=0;return SDL_gfx.drawRectangle(surf,x1,y1,x2,y2,"fill",SDL.translateRGBAToCSSRGBA(r,g,b,a));}_boxRGBA.sig="ipiiiiiiii";function _rectangleColor(surf,x1,y1,x2,y2,color){surf>>>=0;return SDL_gfx.drawRectangle(surf,x1,y1,x2,y2,"stroke",SDL_gfx.translateColorToCSSRGBA(color));}_rectangleColor.sig="ipiiiii";function _rectangleRGBA(surf,x1,y1,x2,y2,r,g,b,a){surf>>>=0;return SDL_gfx.drawRectangle(surf,x1,y1,x2,y2,"stroke",SDL.translateRGBAToCSSRGBA(r,g,b,a));}_rectangleRGBA.sig="ipiiiiiiii";function _ellipseColor(surf,x,y,rx,ry,color){surf>>>=0;return SDL_gfx.drawEllipse(surf,x,y,rx,ry,"stroke",SDL_gfx.translateColorToCSSRGBA(color));}_ellipseColor.sig="ipiiiii";function _ellipseRGBA(surf,x,y,rx,ry,r,g,b,a){surf>>>=0;return SDL_gfx.drawEllipse(surf,x,y,rx,ry,"stroke",SDL.translateRGBAToCSSRGBA(r,g,b,a));}_ellipseRGBA.sig="ipiiiiiiii";function _filledEllipseColor(surf,x,y,rx,ry,color){surf>>>=0;return SDL_gfx.drawEllipse(surf,x,y,rx,ry,"fill",SDL_gfx.translateColorToCSSRGBA(color));}_filledEllipseColor.sig="ipiiiii";function _filledEllipseRGBA(surf,x,y,rx,ry,r,g,b,a){surf>>>=0;return SDL_gfx.drawEllipse(surf,x,y,rx,ry,"fill",SDL.translateRGBAToCSSRGBA(r,g,b,a));}_filledEllipseRGBA.sig="ipiiiiiiii";function _lineColor(surf,x1,y1,x2,y2,color){surf>>>=0;return SDL_gfx.drawLine(surf,x1,y1,x2,y2,SDL_gfx.translateColorToCSSRGBA(color));}_lineColor.sig="ipiiiii";function _lineRGBA(surf,x1,y1,x2,y2,r,g,b,a){surf>>>=0;return SDL_gfx.drawLine(surf,x1,y1,x2,y2,SDL.translateRGBAToCSSRGBA(r,g,b,a));}_lineRGBA.sig="ipiiiiiiii";function _pixelRGBA(surf,x1,y1,r,g,b,a){surf>>>=0;return _boxRGBA(surf,x1,y1,x1,y1,r,g,b,a);}_pixelRGBA.sig="ipiiiiii";var _SDL_GL_SetAttribute=(attr,value)=>{if(!(attr in SDL.glAttributes)){abort("Unknown SDL GL attribute ("+attr+"). Please check if your SDL version is supported.");}SDL.glAttributes[attr]=value;};_SDL_GL_SetAttribute.sig="iii";function _SDL_GL_GetAttribute(attr,value){value>>>=0;if(!(attr in SDL.glAttributes)){abort("Unknown SDL GL attribute ("+attr+"). Please check if your SDL version is supported.");}if(value)HEAP32[value>>>2>>>0]=SDL.glAttributes[attr];return 0;}_SDL_GL_GetAttribute.sig="iip";var _SDL_GL_SwapBuffers=()=>{Browser.doSwapBuffers?.();};// in workers, this is used to send out a buffered frame
_SDL_GL_SwapBuffers.sig="v";function _SDL_GL_ExtensionSupported(extension){extension>>>=0;return Module.ctx.getExtension(extension)|0;}_SDL_GL_ExtensionSupported.sig="ip";function _SDL_DestroyWindow(window){window>>>=0;}_SDL_DestroyWindow.sig="vp";function _SDL_DestroyRenderer(renderer){renderer>>>=0;}_SDL_DestroyRenderer.sig="vp";function _SDL_GetWindowFlags(window){window>>>=0;if(Browser.isFullscreen){return 1;}return 0;}_SDL_GetWindowFlags.sig="ip";function _SDL_GL_SwapWindow(window){window>>>=0;}_SDL_GL_SwapWindow.sig="vp";function _SDL_GL_MakeCurrent(window,context){window>>>=0;context>>>=0;}_SDL_GL_MakeCurrent.sig="ipp";function _SDL_GL_DeleteContext(context){context>>>=0;}_SDL_GL_DeleteContext.sig="vp";var _SDL_GL_GetSwapInterval=()=>{if(Browser.mainLoop.timingMode==1)return Browser.mainLoop.timingValue;else return 0;};_SDL_GL_GetSwapInterval.sig="i";var _SDL_GL_SetSwapInterval=state=>{_emscripten_set_main_loop_timing(1,state);};_SDL_GL_SetSwapInterval.sig="ii";function _SDL_SetWindowTitle(window,title){window>>>=0;title>>>=0;if(title)document.title=UTF8ToString(title);}_SDL_SetWindowTitle.sig="vpp";function _SDL_GetWindowSize(window,width,height){window>>>=0;width>>>=0;height>>>=0;var w=Module["canvas"].width;var h=Module["canvas"].height;if(width)HEAP32[width>>>2>>>0]=w;if(height)HEAP32[height>>>2>>>0]=h;}_SDL_GetWindowSize.sig="vppp";function _SDL_LogSetOutputFunction(callback,userdata){callback>>>=0;userdata>>>=0;}_SDL_LogSetOutputFunction.sig="vpp";function _SDL_SetWindowFullscreen(window,fullscreen){window>>>=0;if(Browser.isFullscreen){Module["canvas"].exitFullscreen();return 1;}return 0;}_SDL_SetWindowFullscreen.sig="ipi";var _SDL_ClearError=()=>{};_SDL_ClearError.sig="v";var _SDL_SetGamma=(r,g,b)=>-1;_SDL_SetGamma.sig="ifff";function _SDL_SetGammaRamp(redTable,greenTable,blueTable){redTable>>>=0;greenTable>>>=0;blueTable>>>=0;return-1;}_SDL_SetGammaRamp.sig="ippp";var _SDL_NumJoysticks=()=>{var count=0;var gamepads=SDL.getGamepads();// The length is not the number of gamepads; check which ones are defined.
for(var i=0;i<gamepads.length;i++){if(gamepads[i]!==undefined)count++;}return count;};_SDL_NumJoysticks.sig="i";function _SDL_JoystickName(deviceIndex){var gamepad=SDL.getGamepad(deviceIndex);if(gamepad){var name=gamepad.id;if(SDL.joystickNamePool.hasOwnProperty(name)){return SDL.joystickNamePool[name];}return SDL.joystickNamePool[name]=stringToNewUTF8(name);}return 0;}_SDL_JoystickName.sig="pi";function _SDL_JoystickOpen(deviceIndex){var gamepad=SDL.getGamepad(deviceIndex);if(gamepad){// Use this as a unique 'pointer' for this joystick.
var joystick=deviceIndex+1;SDL.recordJoystickState(joystick,gamepad);return joystick;}return 0;}_SDL_JoystickOpen.sig="pi";var _SDL_JoystickOpened=deviceIndex=>SDL.lastJoystickState.hasOwnProperty(deviceIndex+1)?1:0;_SDL_JoystickOpened.sig="ii";function _SDL_JoystickIndex(joystick){joystick>>>=0;return joystick-1;}_SDL_JoystickIndex.sig="ip";function _SDL_JoystickNumAxes(joystick){joystick>>>=0;var gamepad=SDL.getGamepad(joystick-1);if(gamepad){return gamepad.axes.length;}return 0;}_SDL_JoystickNumAxes.sig="ip";function _SDL_JoystickNumBalls(joystick){joystick>>>=0;return 0;}_SDL_JoystickNumBalls.sig="ip";function _SDL_JoystickNumHats(joystick){joystick>>>=0;return 0;}_SDL_JoystickNumHats.sig="ip";function _SDL_JoystickNumButtons(joystick){joystick>>>=0;var gamepad=SDL.getGamepad(joystick-1);if(gamepad){return gamepad.buttons.length;}return 0;}_SDL_JoystickNumButtons.sig="ip";var _SDL_JoystickUpdate=()=>SDL.queryJoysticks();_SDL_JoystickUpdate.sig="v";var _SDL_JoystickEventState=state=>{if(state<0){// SDL_QUERY: Return current state.
return SDL.joystickEventState;}return SDL.joystickEventState=state;};_SDL_JoystickEventState.sig="ii";function _SDL_JoystickGetAxis(joystick,axis){joystick>>>=0;var gamepad=SDL.getGamepad(joystick-1);if(gamepad&&gamepad.axes.length>axis){return SDL.joystickAxisValueConversion(gamepad.axes[axis]);}return 0;}_SDL_JoystickGetAxis.sig="ipi";function _SDL_JoystickGetHat(joystick,hat){joystick>>>=0;return 0;}_SDL_JoystickGetHat.sig="ipi";function _SDL_JoystickGetBall(joystick,ball,dxptr,dyptr){joystick>>>=0;dxptr>>>=0;dyptr>>>=0;return-1;}_SDL_JoystickGetBall.sig="ipipp";function _SDL_JoystickGetButton(joystick,button){joystick>>>=0;var gamepad=SDL.getGamepad(joystick-1);if(gamepad&&gamepad.buttons.length>button){return SDL.getJoystickButtonState(gamepad.buttons[button])?1:0;}return 0;}_SDL_JoystickGetButton.sig="ipi";function _SDL_JoystickClose(joystick){joystick>>>=0;delete SDL.lastJoystickState[joystick];}_SDL_JoystickClose.sig="vp";var _SDL_InitSubSystem=flags=>0;_SDL_InitSubSystem.sig="ii";function _SDL_RWFromConstMem(mem,size){mem>>>=0;var id=SDL.rwops.length;// TODO: recycle ids when they are null
SDL.rwops.push({bytes:mem,count:size});return id;}_SDL_RWFromConstMem.sig="ppi";var _SDL_RWFromMem=_SDL_RWFromConstMem;_SDL_RWFromMem.sig="ppi";var _SDL_GetNumAudioDrivers=()=>1;_SDL_GetNumAudioDrivers.sig="i";function _SDL_GetCurrentAudioDriver(){return stringToNewUTF8("Emscripten Audio");}_SDL_GetCurrentAudioDriver.sig="p";var _SDL_GetScancodeFromKey=key=>SDL.scanCodes[key];_SDL_GetScancodeFromKey.sig="ii";function _SDL_GetAudioDriver(index){return _SDL_GetCurrentAudioDriver();}_SDL_GetAudioDriver.sig="pi";var _SDL_EnableUNICODE=on=>{var ret=SDL.unicode||0;SDL.unicode=on;return ret;};_SDL_EnableUNICODE.sig="ii";var _SDL_AddTimer=function(interval,callback,param){callback>>>=0;param>>>=0;return safeSetTimeout(()=>((a1,a2)=>{})(/* a dynamic function call to signature iii, but there are no exported function pointers with that signature, so this path should never be taken. Build with ASSERTIONS enabled to validate. */interval,param),interval);};_SDL_AddTimer.sig="iipp";var _SDL_RemoveTimer=id=>{clearTimeout(id);return true;};_SDL_RemoveTimer.sig="ii";function _SDL_CreateThread(fs,data,pfnBeginThread,pfnEndThread){fs>>>=0;data>>>=0;throw"SDL threads cannot be supported in the web platform because they assume shared state. See emscripten_create_worker etc. for a message-passing concurrency model that does let you run code in another thread.";}_SDL_CreateThread.sig="ppp";function _SDL_WaitThread(thread,status){thread>>>=0;status>>>=0;throw"SDL_WaitThread";}_SDL_WaitThread.sig="vpp";function _SDL_GetThreadID(thread){thread>>>=0;throw"SDL_GetThreadID";}_SDL_GetThreadID.sig="pp";function _SDL_ThreadID(){return 0;}_SDL_ThreadID.sig="p";function _SDL_AllocRW(){throw"SDL_AllocRW: TODO";}_SDL_AllocRW.sig="p";function _SDL_CondBroadcast(cond){cond>>>=0;throw"SDL_CondBroadcast: TODO";}_SDL_CondBroadcast.sig="ip";function _SDL_CondWaitTimeout(cond,mutex,ms){cond>>>=0;mutex>>>=0;throw"SDL_CondWaitTimeout: TODO";}_SDL_CondWaitTimeout.sig="ippi";var _SDL_WM_IconifyWindow=()=>{throw"SDL_WM_IconifyWindow TODO";};_SDL_WM_IconifyWindow.sig="i";function _Mix_SetPostMix(func,arg){func>>>=0;arg>>>=0;return warnOnce("Mix_SetPostMix: TODO");}_Mix_SetPostMix.sig="vpp";function _Mix_VolumeChunk(chunk,volume){chunk>>>=0;throw"Mix_VolumeChunk: TODO";}_Mix_VolumeChunk.sig="ipi";var _Mix_SetPosition=(channel,angle,distance)=>{throw"Mix_SetPosition: TODO";};_Mix_SetPosition.sig="iiii";function _Mix_QuerySpec(frequency,format,channels){frequency>>>=0;format>>>=0;channels>>>=0;throw"Mix_QuerySpec: TODO";}_Mix_QuerySpec.sig="ippp";function _Mix_FadeInChannelTimed(channel,chunk,loop,ms,ticks){chunk>>>=0;throw"Mix_FadeInChannelTimed";}_Mix_FadeInChannelTimed.sig="iipiii";var _Mix_FadeOutChannel=()=>{throw"Mix_FadeOutChannel";};_Mix_FadeOutChannel.sig="iii";function _Mix_Linked_Version(){throw"Mix_Linked_Version: TODO";}_Mix_Linked_Version.sig="p";function _SDL_SaveBMP_RW(surface,dst,freedst){surface>>>=0;dst>>>=0;throw"SDL_SaveBMP_RW: TODO";}_SDL_SaveBMP_RW.sig="ippi";function _SDL_WM_SetIcon(icon,mask){icon>>>=0;mask>>>=0;}_SDL_WM_SetIcon.sig="vpp";var _SDL_HasRDTSC=()=>0;_SDL_HasRDTSC.sig="i";var _SDL_HasMMX=()=>0;_SDL_HasMMX.sig="i";var _SDL_HasMMXExt=()=>0;_SDL_HasMMXExt.sig="i";var _SDL_Has3DNow=()=>0;_SDL_Has3DNow.sig="i";var _SDL_Has3DNowExt=()=>0;_SDL_Has3DNowExt.sig="i";var _SDL_HasSSE=()=>0;_SDL_HasSSE.sig="i";var _SDL_HasSSE2=()=>0;_SDL_HasSSE2.sig="i";var _SDL_HasAltiVec=()=>0;_SDL_HasAltiVec.sig="i";var ALLOC_NORMAL=0;var ALLOC_STACK=1;var allocate=(slab,allocator)=>{var ret;if(allocator==ALLOC_STACK){ret=stackAlloc(slab.length);}else{ret=_malloc(slab.length);}if(!slab.subarray&&!slab.slice){slab=new Uint8Array(slab);}HEAPU8.set(slab,ret>>>0);return ret;};/** @deprecated @param {boolean=} dontAddNull */var writeStringToMemory=(string,buffer,dontAddNull)=>{warnOnce("writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!");var/** @type {number} */lastChar,/** @type {number} */end;if(dontAddNull){// stringToUTF8 always appends null. If we don't want to do that, remember the
// character that existed at the location where the null will be placed, and restore
// that after the write (below).
end=buffer+lengthBytesUTF8(string);lastChar=HEAP8[end>>>0];}stringToUTF8(string,buffer,Infinity);if(dontAddNull)HEAP8[end>>>0]=lastChar;};/** @param {boolean=} dontAddNull */var writeAsciiToMemory=(str,buffer,dontAddNull)=>{for(var i=0;i<str.length;++i){HEAP8[buffer++>>>0]=str.charCodeAt(i);}// Null-terminate the string
if(!dontAddNull)HEAP8[buffer>>>0]=0;};var allocateUTF8=stringToNewUTF8;var allocateUTF8OnStack=stringToUTF8OnStack;var setErrNo=value=>{HEAP32[___errno_location()>>>2>>>0]=value;return value;};var demangle=func=>{// If demangle has failed before, stop demangling any further function names
// This avoids an infinite recursion with malloc()->abort()->stackTrace()->demangle()->malloc()->...
demangle.recursionGuard=(demangle.recursionGuard|0)+1;if(demangle.recursionGuard>1)return func;return withStackSave(()=>{try{var s=func;if(s.startsWith("__Z"))s=s.substr(1);var buf=stringToUTF8OnStack(s);var status=stackAlloc(4);var ret=___cxa_demangle(buf,0,0,status);if(HEAP32[status>>>2>>>0]===0&&ret){return UTF8ToString(ret);}}// otherwise, libcxxabi failed
catch(e){}finally{_free(ret);if(demangle.recursionGuard<2)--demangle.recursionGuard;}// failure when using libcxxabi, don't demangle
return func;});};function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return js;}var print=out;var printErr=err;var _emscripten_is_main_browser_thread=()=>!ENVIRONMENT_IS_WORKER;registerWasmPlugin();FS.createPreloadedFile=FS_createPreloadedFile;FS.staticInit();// Set module methods based on EXPORTED_RUNTIME_METHODS
Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;Module["FS_unlink"]=FS.unlink;Module["FS_createLazyFile"]=FS.createLazyFile;Module["FS_createDevice"]=FS.createDevice;// exports
Module["requestFullscreen"]=Browser.requestFullscreen;Module["requestAnimationFrame"]=Browser.requestAnimationFrame;Module["setCanvasSize"]=Browser.setCanvasSize;Module["pauseMainLoop"]=Browser.mainLoop.pause;Module["resumeMainLoop"]=Browser.mainLoop.resume;Module["getUserMedia"]=Browser.getUserMedia;Module["createContext"]=Browser.createContext;var preloadedImages={};var preloadedAudios={};for(var i=0;i<32;++i)tempFixedLengthArray.push(new Array(i));var miniTempWebGLFloatBuffersStorage=new Float32Array(288);// Create GL_POOL_TEMP_BUFFERS_SIZE+1 temporary buffers, for uploads of size 0 through GL_POOL_TEMP_BUFFERS_SIZE inclusive
for(/**@suppress{duplicate}*/var i=0;i<=288;++i){miniTempWebGLFloatBuffers[i]=miniTempWebGLFloatBuffersStorage.subarray(0,i);}var miniTempWebGLIntBuffersStorage=new Int32Array(288);// Create GL_POOL_TEMP_BUFFERS_SIZE+1 temporary buffers, for uploads of size 0 through GL_POOL_TEMP_BUFFERS_SIZE inclusive
for(/**@suppress{duplicate}*/var i=0;i<=288;++i){miniTempWebGLIntBuffers[i]=miniTempWebGLIntBuffersStorage.subarray(0,i);}var emSetImmediate;var emClearImmediate;if(typeof setImmediate!="undefined"){emSetImmediate=setImmediateWrapped;emClearImmediate=clearImmediateWrapped;}else if(typeof addEventListener=="function"){var __setImmediate_id_counter=0;var __setImmediate_queue=[];var __setImmediate_message_id="_si";/** @param {Event} e */var __setImmediate_cb=e=>{if(e.data===__setImmediate_message_id){e.stopPropagation();__setImmediate_queue.shift()();++__setImmediate_id_counter;}};addEventListener("message",__setImmediate_cb,true);emSetImmediate=func=>{postMessage(__setImmediate_message_id,"*");return __setImmediate_id_counter+__setImmediate_queue.push(func)-1;};emClearImmediate=/**@type{function(number=)}*/id=>{var index=id-__setImmediate_id_counter;// must preserve the order and count of elements in the queue, so replace the pending callback with an empty function
if(index>=0&&index<__setImmediate_queue.length)__setImmediate_queue[index]=()=>{};};}var wasmImports={/** @export */IMG_Init:_IMG_Init,/** @export */IMG_Load:_IMG_Load,/** @export */IMG_Load_RW:_IMG_Load_RW,/** @export */IMG_Quit:_IMG_Quit,/** @export */Mix_AllocateChannels:_Mix_AllocateChannels,/** @export */Mix_ChannelFinished:_Mix_ChannelFinished,/** @export */Mix_CloseAudio:_Mix_CloseAudio,/** @export */Mix_FadeInChannelTimed:_Mix_FadeInChannelTimed,/** @export */Mix_FadeInMusicPos:_Mix_FadeInMusicPos,/** @export */Mix_FadeOutChannel:_Mix_FadeOutChannel,/** @export */Mix_FadeOutMusic:_Mix_FadeOutMusic,/** @export */Mix_FadingChannel:_Mix_FadingChannel,/** @export */Mix_FreeChunk:_Mix_FreeChunk,/** @export */Mix_FreeMusic:_Mix_FreeMusic,/** @export */Mix_HaltChannel:_Mix_HaltChannel,/** @export */Mix_HaltMusic:_Mix_HaltMusic,/** @export */Mix_HookMusicFinished:_Mix_HookMusicFinished,/** @export */Mix_Init:_Mix_Init,/** @export */Mix_Linked_Version:_Mix_Linked_Version,/** @export */Mix_LoadMUS:_Mix_LoadMUS,/** @export */Mix_LoadMUS_RW:_Mix_LoadMUS_RW,/** @export */Mix_LoadWAV:_Mix_LoadWAV,/** @export */Mix_LoadWAV_RW:_Mix_LoadWAV_RW,/** @export */Mix_OpenAudio:_Mix_OpenAudio,/** @export */Mix_Pause:_Mix_Pause,/** @export */Mix_PauseMusic:_Mix_PauseMusic,/** @export */Mix_Paused:_Mix_Paused,/** @export */Mix_PausedMusic:_Mix_PausedMusic,/** @export */Mix_PlayChannelTimed:_Mix_PlayChannelTimed,/** @export */Mix_PlayMusic:_Mix_PlayMusic,/** @export */Mix_Playing:_Mix_Playing,/** @export */Mix_PlayingMusic:_Mix_PlayingMusic,/** @export */Mix_QuerySpec:_Mix_QuerySpec,/** @export */Mix_QuickLoad_RAW:_Mix_QuickLoad_RAW,/** @export */Mix_Quit:_Mix_Quit,/** @export */Mix_ReserveChannels:_Mix_ReserveChannels,/** @export */Mix_Resume:_Mix_Resume,/** @export */Mix_ResumeMusic:_Mix_ResumeMusic,/** @export */Mix_SetPanning:_Mix_SetPanning,/** @export */Mix_SetPosition:_Mix_SetPosition,/** @export */Mix_SetPostMix:_Mix_SetPostMix,/** @export */Mix_Volume:_Mix_Volume,/** @export */Mix_VolumeChunk:_Mix_VolumeChunk,/** @export */Mix_VolumeMusic:_Mix_VolumeMusic,/** @export */SDL_AddTimer:_SDL_AddTimer,/** @export */SDL_AllocRW:_SDL_AllocRW,/** @export */SDL_AudioDriverName:_SDL_AudioDriverName,/** @export */SDL_AudioQuit:_SDL_AudioQuit,/** @export */SDL_ClearError:_SDL_ClearError,/** @export */SDL_CloseAudio:_SDL_CloseAudio,/** @export */SDL_CondBroadcast:_SDL_CondBroadcast,/** @export */SDL_CondSignal:_SDL_CondSignal,/** @export */SDL_CondWait:_SDL_CondWait,/** @export */SDL_CondWaitTimeout:_SDL_CondWaitTimeout,/** @export */SDL_ConvertSurface:_SDL_ConvertSurface,/** @export */SDL_CreateCond:_SDL_CreateCond,/** @export */SDL_CreateMutex:_SDL_CreateMutex,/** @export */SDL_CreateRGBSurface:_SDL_CreateRGBSurface,/** @export */SDL_CreateRGBSurfaceFrom:_SDL_CreateRGBSurfaceFrom,/** @export */SDL_CreateThread:_SDL_CreateThread,/** @export */SDL_Delay:_SDL_Delay,/** @export */SDL_DestroyCond:_SDL_DestroyCond,/** @export */SDL_DestroyMutex:_SDL_DestroyMutex,/** @export */SDL_DestroyRenderer:_SDL_DestroyRenderer,/** @export */SDL_DestroyWindow:_SDL_DestroyWindow,/** @export */SDL_DisplayFormatAlpha:_SDL_DisplayFormatAlpha,/** @export */SDL_EnableKeyRepeat:_SDL_EnableKeyRepeat,/** @export */SDL_EnableUNICODE:_SDL_EnableUNICODE,/** @export */SDL_FillRect:_SDL_FillRect,/** @export */SDL_Flip:_SDL_Flip,/** @export */SDL_FreeRW:_SDL_FreeRW,/** @export */SDL_FreeSurface:_SDL_FreeSurface,/** @export */SDL_GL_DeleteContext:_SDL_GL_DeleteContext,/** @export */SDL_GL_ExtensionSupported:_SDL_GL_ExtensionSupported,/** @export */SDL_GL_GetAttribute:_SDL_GL_GetAttribute,/** @export */SDL_GL_GetSwapInterval:_SDL_GL_GetSwapInterval,/** @export */SDL_GL_MakeCurrent:_SDL_GL_MakeCurrent,/** @export */SDL_GL_SetAttribute:_SDL_GL_SetAttribute,/** @export */SDL_GL_SetSwapInterval:_SDL_GL_SetSwapInterval,/** @export */SDL_GL_SwapBuffers:_SDL_GL_SwapBuffers,/** @export */SDL_GL_SwapWindow:_SDL_GL_SwapWindow,/** @export */SDL_GetAppState:_SDL_GetAppState,/** @export */SDL_GetAudioDriver:_SDL_GetAudioDriver,/** @export */SDL_GetClipRect:_SDL_GetClipRect,/** @export */SDL_GetCurrentAudioDriver:_SDL_GetCurrentAudioDriver,/** @export */SDL_GetError:_SDL_GetError,/** @export */SDL_GetKeyName:_SDL_GetKeyName,/** @export */SDL_GetKeyState:_SDL_GetKeyState,/** @export */SDL_GetKeyboardState:_SDL_GetKeyboardState,/** @export */SDL_GetModState:_SDL_GetModState,/** @export */SDL_GetMouseState:_SDL_GetMouseState,/** @export */SDL_GetNumAudioDrivers:_SDL_GetNumAudioDrivers,/** @export */SDL_GetRGB:_SDL_GetRGB,/** @export */SDL_GetRGBA:_SDL_GetRGBA,/** @export */SDL_GetScancodeFromKey:_SDL_GetScancodeFromKey,/** @export */SDL_GetThreadID:_SDL_GetThreadID,/** @export */SDL_GetTicks:_SDL_GetTicks,/** @export */SDL_GetVideoInfo:_SDL_GetVideoInfo,/** @export */SDL_GetVideoSurface:_SDL_GetVideoSurface,/** @export */SDL_GetWindowFlags:_SDL_GetWindowFlags,/** @export */SDL_GetWindowSize:_SDL_GetWindowSize,/** @export */SDL_Has3DNow:_SDL_Has3DNow,/** @export */SDL_Has3DNowExt:_SDL_Has3DNowExt,/** @export */SDL_HasAltiVec:_SDL_HasAltiVec,/** @export */SDL_HasMMX:_SDL_HasMMX,/** @export */SDL_HasMMXExt:_SDL_HasMMXExt,/** @export */SDL_HasRDTSC:_SDL_HasRDTSC,/** @export */SDL_HasSSE:_SDL_HasSSE,/** @export */SDL_HasSSE2:_SDL_HasSSE2,/** @export */SDL_Init:_SDL_Init,/** @export */SDL_InitSubSystem:_SDL_InitSubSystem,/** @export */SDL_JoystickClose:_SDL_JoystickClose,/** @export */SDL_JoystickEventState:_SDL_JoystickEventState,/** @export */SDL_JoystickGetAxis:_SDL_JoystickGetAxis,/** @export */SDL_JoystickGetBall:_SDL_JoystickGetBall,/** @export */SDL_JoystickGetButton:_SDL_JoystickGetButton,/** @export */SDL_JoystickGetHat:_SDL_JoystickGetHat,/** @export */SDL_JoystickIndex:_SDL_JoystickIndex,/** @export */SDL_JoystickName:_SDL_JoystickName,/** @export */SDL_JoystickNumAxes:_SDL_JoystickNumAxes,/** @export */SDL_JoystickNumBalls:_SDL_JoystickNumBalls,/** @export */SDL_JoystickNumButtons:_SDL_JoystickNumButtons,/** @export */SDL_JoystickNumHats:_SDL_JoystickNumHats,/** @export */SDL_JoystickOpen:_SDL_JoystickOpen,/** @export */SDL_JoystickOpened:_SDL_JoystickOpened,/** @export */SDL_JoystickUpdate:_SDL_JoystickUpdate,/** @export */SDL_Linked_Version:_SDL_Linked_Version,/** @export */SDL_ListModes:_SDL_ListModes,/** @export */SDL_LoadBMP_RW:_SDL_LoadBMP_RW,/** @export */SDL_LockAudio:_SDL_LockAudio,/** @export */SDL_LockSurface:_SDL_LockSurface,/** @export */SDL_LogSetOutputFunction:_SDL_LogSetOutputFunction,/** @export */SDL_LowerBlit:_SDL_LowerBlit,/** @export */SDL_LowerBlitScaled:_SDL_LowerBlitScaled,/** @export */SDL_MapRGB:_SDL_MapRGB,/** @export */SDL_MapRGBA:_SDL_MapRGBA,/** @export */SDL_NumJoysticks:_SDL_NumJoysticks,/** @export */SDL_OpenAudio:_SDL_OpenAudio,/** @export */SDL_PauseAudio:_SDL_PauseAudio,/** @export */SDL_PeepEvents:_SDL_PeepEvents,/** @export */SDL_PollEvent:_SDL_PollEvent,/** @export */SDL_PumpEvents:_SDL_PumpEvents,/** @export */SDL_PushEvent:_SDL_PushEvent,/** @export */SDL_Quit:_SDL_Quit,/** @export */SDL_QuitSubSystem:_SDL_QuitSubSystem,/** @export */SDL_RWFromConstMem:_SDL_RWFromConstMem,/** @export */SDL_RWFromFile:_SDL_RWFromFile,/** @export */SDL_RWFromMem:_SDL_RWFromMem,/** @export */SDL_RemoveTimer:_SDL_RemoveTimer,/** @export */SDL_SaveBMP_RW:_SDL_SaveBMP_RW,/** @export */SDL_SetAlpha:_SDL_SetAlpha,/** @export */SDL_SetClipRect:_SDL_SetClipRect,/** @export */SDL_SetColorKey:_SDL_SetColorKey,/** @export */SDL_SetColors:_SDL_SetColors,/** @export */SDL_SetError:_SDL_SetError,/** @export */SDL_SetGamma:_SDL_SetGamma,/** @export */SDL_SetGammaRamp:_SDL_SetGammaRamp,/** @export */SDL_SetPalette:_SDL_SetPalette,/** @export */SDL_SetVideoMode:_SDL_SetVideoMode,/** @export */SDL_SetWindowFullscreen:_SDL_SetWindowFullscreen,/** @export */SDL_SetWindowTitle:_SDL_SetWindowTitle,/** @export */SDL_ShowCursor:_SDL_ShowCursor,/** @export */SDL_StartTextInput:_SDL_StartTextInput,/** @export */SDL_StopTextInput:_SDL_StopTextInput,/** @export */SDL_ThreadID:_SDL_ThreadID,/** @export */SDL_UnlockAudio:_SDL_UnlockAudio,/** @export */SDL_UnlockSurface:_SDL_UnlockSurface,/** @export */SDL_UpdateRect:_SDL_UpdateRect,/** @export */SDL_UpdateRects:_SDL_UpdateRects,/** @export */SDL_UpperBlit:_SDL_UpperBlit,/** @export */SDL_UpperBlitScaled:_SDL_UpperBlitScaled,/** @export */SDL_VideoDriverName:_SDL_VideoDriverName,/** @export */SDL_VideoModeOK:_SDL_VideoModeOK,/** @export */SDL_VideoQuit:_SDL_VideoQuit,/** @export */SDL_WM_GrabInput:_SDL_WM_GrabInput,/** @export */SDL_WM_IconifyWindow:_SDL_WM_IconifyWindow,/** @export */SDL_WM_SetCaption:_SDL_WM_SetCaption,/** @export */SDL_WM_SetIcon:_SDL_WM_SetIcon,/** @export */SDL_WM_ToggleFullScreen:_SDL_WM_ToggleFullScreen,/** @export */SDL_WaitThread:_SDL_WaitThread,/** @export */SDL_WarpMouse:_SDL_WarpMouse,/** @export */SDL_WasInit:_SDL_WasInit,/** @export */SDL_mutexP:_SDL_mutexP,/** @export */SDL_mutexV:_SDL_mutexV,/** @export */TTF_CloseFont:_TTF_CloseFont,/** @export */TTF_FontAscent:_TTF_FontAscent,/** @export */TTF_FontDescent:_TTF_FontDescent,/** @export */TTF_FontHeight:_TTF_FontHeight,/** @export */TTF_FontLineSkip:_TTF_FontLineSkip,/** @export */TTF_GlyphMetrics:_TTF_GlyphMetrics,/** @export */TTF_Init:_TTF_Init,/** @export */TTF_OpenFont:_TTF_OpenFont,/** @export */TTF_Quit:_TTF_Quit,/** @export */TTF_RenderText_Blended:_TTF_RenderText_Blended,/** @export */TTF_RenderText_Shaded:_TTF_RenderText_Shaded,/** @export */TTF_RenderText_Solid:_TTF_RenderText_Solid,/** @export */TTF_RenderUTF8_Solid:_TTF_RenderUTF8_Solid,/** @export */TTF_SizeText:_TTF_SizeText,/** @export */TTF_SizeUTF8:_TTF_SizeUTF8,/** @export */UTF8ToHtml:_UTF8ToHtml,/** @export */UTF8Toisolat1:_UTF8Toisolat1,/** @export */XChangeWindowAttributes:_XChangeWindowAttributes,/** @export */XCreateWindow:_XCreateWindow,/** @export */XInternAtom:_XInternAtom,/** @export */XMapWindow:_XMapWindow,/** @export */XOpenDisplay:_XOpenDisplay,/** @export */XPending:_XPending,/** @export */XSendEvent:_XSendEvent,/** @export */XSetWMHints:_XSetWMHints,/** @export */XStoreName:_XStoreName,/** @export */_Unwind_Backtrace:__Unwind_Backtrace,/** @export */_Unwind_DeleteException:__Unwind_DeleteException,/** @export */_Unwind_FindEnclosingFunction:__Unwind_FindEnclosingFunction,/** @export */_Unwind_GetIPInfo:__Unwind_GetIPInfo,/** @export */_Unwind_RaiseException:__Unwind_RaiseException,/** @export */__asctime_r:___asctime_r,/** @export */__assert_fail:___assert_fail,/** @export */__asyncify_data:___asyncify_data,/** @export */__asyncify_state:___asyncify_state,/** @export */__asyncjs__pdo_pglite_real_db_handle_factory,/** @export */__asyncjs__pdo_pglite_real_handle_begin,/** @export */__asyncjs__pdo_pglite_real_handle_commit,/** @export */__asyncjs__pdo_pglite_real_handle_rollback,/** @export */__asyncjs__pdo_pglite_real_last_insert_id,/** @export */__asyncjs__pdo_pglite_real_stmt_execute,/** @export */__asyncjs__pdo_vrzno_real_stmt_execute,/** @export */__asyncjs__vrzno_await_internal,/** @export */__call_sighandler:___call_sighandler,/** @export */__cxa_begin_catch:___cxa_begin_catch,/** @export */__cxa_call_unexpected:___cxa_call_unexpected,/** @export */__cxa_end_catch:___cxa_end_catch,/** @export */__cxa_find_matching_catch_2:___cxa_find_matching_catch_2,/** @export */__cxa_find_matching_catch_3:___cxa_find_matching_catch_3,/** @export */__cxa_find_matching_catch_4:___cxa_find_matching_catch_4,/** @export */__cxa_rethrow:___cxa_rethrow,/** @export */__cxa_throw:___cxa_throw,/** @export */__global_base:___global_base,/** @export */__heap_base:___heap_base,/** @export */__indirect_function_table:wasmTable,/** @export */__memory_base:___memory_base,/** @export */__resumeException:___resumeException,/** @export */__stack_high:___stack_high,/** @export */__stack_low:___stack_low,/** @export */__stack_pointer:___stack_pointer,/** @export */__syscall__newselect:___syscall__newselect,/** @export */__syscall_accept4:___syscall_accept4,/** @export */__syscall_bind:___syscall_bind,/** @export */__syscall_chdir:___syscall_chdir,/** @export */__syscall_chmod:___syscall_chmod,/** @export */__syscall_connect:___syscall_connect,/** @export */__syscall_dup:___syscall_dup,/** @export */__syscall_dup3:___syscall_dup3,/** @export */__syscall_faccessat:___syscall_faccessat,/** @export */__syscall_fadvise64:___syscall_fadvise64,/** @export */__syscall_fallocate:___syscall_fallocate,/** @export */__syscall_fchdir:___syscall_fchdir,/** @export */__syscall_fchmod:___syscall_fchmod,/** @export */__syscall_fchmodat2:___syscall_fchmodat2,/** @export */__syscall_fchown32:___syscall_fchown32,/** @export */__syscall_fchownat:___syscall_fchownat,/** @export */__syscall_fcntl64:___syscall_fcntl64,/** @export */__syscall_fdatasync:___syscall_fdatasync,/** @export */__syscall_fstat64:___syscall_fstat64,/** @export */__syscall_fstatfs64:___syscall_fstatfs64,/** @export */__syscall_ftruncate64:___syscall_ftruncate64,/** @export */__syscall_getcwd:___syscall_getcwd,/** @export */__syscall_getdents64:___syscall_getdents64,/** @export */__syscall_getpeername:___syscall_getpeername,/** @export */__syscall_getsockname:___syscall_getsockname,/** @export */__syscall_getsockopt:___syscall_getsockopt,/** @export */__syscall_ioctl:___syscall_ioctl,/** @export */__syscall_listen:___syscall_listen,/** @export */__syscall_lstat64:___syscall_lstat64,/** @export */__syscall_mkdirat:___syscall_mkdirat,/** @export */__syscall_mknodat:___syscall_mknodat,/** @export */__syscall_newfstatat:___syscall_newfstatat,/** @export */__syscall_openat:___syscall_openat,/** @export */__syscall_pipe:___syscall_pipe,/** @export */__syscall_poll:___syscall_poll,/** @export */__syscall_readlinkat:___syscall_readlinkat,/** @export */__syscall_recvfrom:___syscall_recvfrom,/** @export */__syscall_recvmsg:___syscall_recvmsg,/** @export */__syscall_renameat:___syscall_renameat,/** @export */__syscall_rmdir:___syscall_rmdir,/** @export */__syscall_sendmsg:___syscall_sendmsg,/** @export */__syscall_sendto:___syscall_sendto,/** @export */__syscall_socket:___syscall_socket,/** @export */__syscall_stat64:___syscall_stat64,/** @export */__syscall_statfs64:___syscall_statfs64,/** @export */__syscall_symlink:___syscall_symlink,/** @export */__syscall_symlinkat:___syscall_symlinkat,/** @export */__syscall_truncate64:___syscall_truncate64,/** @export */__syscall_unlinkat:___syscall_unlinkat,/** @export */__syscall_utimensat:___syscall_utimensat,/** @export */__table_base:___table_base,/** @export */__xmlOutputBufferCreateFilename:___xmlOutputBufferCreateFilename,/** @export */__xmlParserInputBufferCreateFilename:___xmlParserInputBufferCreateFilename,/** @export */__xmlRegisterCallbacks:___xmlRegisterCallbacks,/** @export */_abort_js:__abort_js,/** @export */_dlopen_js:__dlopen_js,/** @export */_dlsym_catchup_js:__dlsym_catchup_js,/** @export */_dlsym_js:__dlsym_js,/** @export */_emscripten_dlopen_js:__emscripten_dlopen_js,/** @export */_emscripten_fs_load_embedded_files:__emscripten_fs_load_embedded_files,/** @export */_emscripten_get_now_is_monotonic:__emscripten_get_now_is_monotonic,/** @export */_emscripten_get_progname:__emscripten_get_progname,/** @export */_emscripten_lookup_name:__emscripten_lookup_name,/** @export */_emscripten_memcpy_js:__emscripten_memcpy_js,/** @export */_emscripten_push_main_loop_blocker:__emscripten_push_main_loop_blocker,/** @export */_emscripten_push_uncounted_main_loop_blocker:__emscripten_push_uncounted_main_loop_blocker,/** @export */_emscripten_runtime_keepalive_clear:__emscripten_runtime_keepalive_clear,/** @export */_emscripten_set_offscreencanvas_size:__emscripten_set_offscreencanvas_size,/** @export */_emscripten_system:__emscripten_system,/** @export */_emscripten_throw_longjmp:__emscripten_throw_longjmp,/** @export */_glGetActiveAttribOrUniform:__glGetActiveAttribOrUniform,/** @export */_gmtime_js:__gmtime_js,/** @export */_load_secondary_module:__load_secondary_module,/** @export */_localtime_js:__localtime_js,/** @export */_mktime_js:__mktime_js,/** @export */_mmap_js:__mmap_js,/** @export */_msync_js:__msync_js,/** @export */_munmap_js:__munmap_js,/** @export */_setitimer_js:__setitimer_js,/** @export */_timegm_js:__timegm_js,/** @export */_tzset_js:__tzset_js,/** @export */alBuffer3f:_alBuffer3f,/** @export */alBuffer3i:_alBuffer3i,/** @export */alBufferData:_alBufferData,/** @export */alBufferf:_alBufferf,/** @export */alBufferfv:_alBufferfv,/** @export */alBufferi:_alBufferi,/** @export */alBufferiv:_alBufferiv,/** @export */alDeleteBuffers:_alDeleteBuffers,/** @export */alDeleteSources:_alDeleteSources,/** @export */alDisable:_alDisable,/** @export */alDistanceModel:_alDistanceModel,/** @export */alDopplerFactor:_alDopplerFactor,/** @export */alDopplerVelocity:_alDopplerVelocity,/** @export */alEnable:_alEnable,/** @export */alGenBuffers:_alGenBuffers,/** @export */alGenSources:_alGenSources,/** @export */alGetBoolean:_alGetBoolean,/** @export */alGetBooleanv:_alGetBooleanv,/** @export */alGetBuffer3f:_alGetBuffer3f,/** @export */alGetBuffer3i:_alGetBuffer3i,/** @export */alGetBufferf:_alGetBufferf,/** @export */alGetBufferfv:_alGetBufferfv,/** @export */alGetBufferi:_alGetBufferi,/** @export */alGetBufferiv:_alGetBufferiv,/** @export */alGetDouble:_alGetDouble,/** @export */alGetDoublev:_alGetDoublev,/** @export */alGetEnumValue:_alGetEnumValue,/** @export */alGetError:_alGetError,/** @export */alGetFloat:_alGetFloat,/** @export */alGetFloatv:_alGetFloatv,/** @export */alGetInteger:_alGetInteger,/** @export */alGetIntegerv:_alGetIntegerv,/** @export */alGetListener3f:_alGetListener3f,/** @export */alGetListener3i:_alGetListener3i,/** @export */alGetListenerf:_alGetListenerf,/** @export */alGetListenerfv:_alGetListenerfv,/** @export */alGetListeneri:_alGetListeneri,/** @export */alGetListeneriv:_alGetListeneriv,/** @export */alGetSource3f:_alGetSource3f,/** @export */alGetSource3i:_alGetSource3i,/** @export */alGetSourcef:_alGetSourcef,/** @export */alGetSourcefv:_alGetSourcefv,/** @export */alGetSourcei:_alGetSourcei,/** @export */alGetSourceiv:_alGetSourceiv,/** @export */alGetString:_alGetString,/** @export */alIsBuffer:_alIsBuffer,/** @export */alIsEnabled:_alIsEnabled,/** @export */alIsExtensionPresent:_alIsExtensionPresent,/** @export */alIsSource:_alIsSource,/** @export */alListener3f:_alListener3f,/** @export */alListener3i:_alListener3i,/** @export */alListenerf:_alListenerf,/** @export */alListenerfv:_alListenerfv,/** @export */alListeneri:_alListeneri,/** @export */alListeneriv:_alListeneriv,/** @export */alSource3f:_alSource3f,/** @export */alSource3i:_alSource3i,/** @export */alSourcePause:_alSourcePause,/** @export */alSourcePausev:_alSourcePausev,/** @export */alSourcePlay:_alSourcePlay,/** @export */alSourcePlayv:_alSourcePlayv,/** @export */alSourceQueueBuffers:_alSourceQueueBuffers,/** @export */alSourceRewind:_alSourceRewind,/** @export */alSourceRewindv:_alSourceRewindv,/** @export */alSourceStop:_alSourceStop,/** @export */alSourceStopv:_alSourceStopv,/** @export */alSourceUnqueueBuffers:_alSourceUnqueueBuffers,/** @export */alSourcef:_alSourcef,/** @export */alSourcefv:_alSourcefv,/** @export */alSourcei:_alSourcei,/** @export */alSourceiv:_alSourceiv,/** @export */alSpeedOfSound:_alSpeedOfSound,/** @export */alcCaptureCloseDevice:_alcCaptureCloseDevice,/** @export */alcCaptureOpenDevice:_alcCaptureOpenDevice,/** @export */alcCaptureSamples:_alcCaptureSamples,/** @export */alcCaptureStart:_alcCaptureStart,/** @export */alcCaptureStop:_alcCaptureStop,/** @export */alcCloseDevice:_alcCloseDevice,/** @export */alcCreateContext:_alcCreateContext,/** @export */alcDestroyContext:_alcDestroyContext,/** @export */alcGetContextsDevice:_alcGetContextsDevice,/** @export */alcGetCurrentContext:_alcGetCurrentContext,/** @export */alcGetEnumValue:_alcGetEnumValue,/** @export */alcGetError:_alcGetError,/** @export */alcGetIntegerv:_alcGetIntegerv,/** @export */alcGetString:_alcGetString,/** @export */alcIsExtensionPresent:_alcIsExtensionPresent,/** @export */alcMakeContextCurrent:_alcMakeContextCurrent,/** @export */alcOpenDevice:_alcOpenDevice,/** @export */alcProcessContext:_alcProcessContext,/** @export */alcSuspendContext:_alcSuspendContext,/** @export */boxColor:_boxColor,/** @export */boxRGBA:_boxRGBA,/** @export */clock_res_get:_clock_res_get,/** @export */clock_time_get:_clock_time_get,/** @export */docbDefaultSAXHandler:_docbDefaultSAXHandler,/** @export */eglBindAPI:_eglBindAPI,/** @export */eglChooseConfig:_eglChooseConfig,/** @export */eglCreateContext:_eglCreateContext,/** @export */eglCreateWindowSurface:_eglCreateWindowSurface,/** @export */eglDestroyContext:_eglDestroyContext,/** @export */eglDestroySurface:_eglDestroySurface,/** @export */eglGetConfigAttrib:_eglGetConfigAttrib,/** @export */eglGetConfigs:_eglGetConfigs,/** @export */eglGetCurrentContext:_eglGetCurrentContext,/** @export */eglGetCurrentDisplay:_eglGetCurrentDisplay,/** @export */eglGetCurrentSurface:_eglGetCurrentSurface,/** @export */eglGetDisplay:_eglGetDisplay,/** @export */eglGetError:_eglGetError,/** @export */eglInitialize:_eglInitialize,/** @export */eglMakeCurrent:_eglMakeCurrent,/** @export */eglQueryAPI:_eglQueryAPI,/** @export */eglQueryContext:_eglQueryContext,/** @export */eglQueryString:_eglQueryString,/** @export */eglQuerySurface:_eglQuerySurface,/** @export */eglReleaseThread:_eglReleaseThread,/** @export */eglSwapBuffers:_eglSwapBuffers,/** @export */eglSwapInterval:_eglSwapInterval,/** @export */eglTerminate:_eglTerminate,/** @export */eglWaitClient:_eglWaitClient,/** @export */eglWaitGL:_eglWaitGL,/** @export */eglWaitNative:_eglWaitNative,/** @export */ellipseColor:_ellipseColor,/** @export */ellipseRGBA:_ellipseRGBA,/** @export */emscripten_SDL_SetEventHandler:_emscripten_SDL_SetEventHandler,/** @export */emscripten_alcDevicePauseSOFT:_emscripten_alcDevicePauseSOFT,/** @export */emscripten_alcDeviceResumeSOFT:_emscripten_alcDeviceResumeSOFT,/** @export */emscripten_alcGetStringiSOFT:_emscripten_alcGetStringiSOFT,/** @export */emscripten_alcResetDeviceSOFT:_emscripten_alcResetDeviceSOFT,/** @export */emscripten_asm_const_async_on_main_thread:_emscripten_asm_const_async_on_main_thread,/** @export */emscripten_asm_const_double:_emscripten_asm_const_double,/** @export */emscripten_asm_const_double_sync_on_main_thread:_emscripten_asm_const_double_sync_on_main_thread,/** @export */emscripten_asm_const_int:_emscripten_asm_const_int,/** @export */emscripten_asm_const_int_sync_on_main_thread:_emscripten_asm_const_int_sync_on_main_thread,/** @export */emscripten_asm_const_ptr:_emscripten_asm_const_ptr,/** @export */emscripten_asm_const_ptr_sync_on_main_thread:_emscripten_asm_const_ptr_sync_on_main_thread,/** @export */emscripten_async_call:_emscripten_async_call,/** @export */emscripten_async_load_script:_emscripten_async_load_script,/** @export */emscripten_async_run_script:_emscripten_async_run_script,/** @export */emscripten_async_wget:_emscripten_async_wget,/** @export */emscripten_async_wget2:_emscripten_async_wget2,/** @export */emscripten_async_wget2_abort:_emscripten_async_wget2_abort,/** @export */emscripten_async_wget2_data:_emscripten_async_wget2_data,/** @export */emscripten_async_wget_data:_emscripten_async_wget_data,/** @export */emscripten_call_worker:_emscripten_call_worker,/** @export */emscripten_cancel_animation_frame:_emscripten_cancel_animation_frame,/** @export */emscripten_cancel_main_loop:_emscripten_cancel_main_loop,/** @export */emscripten_clear_immediate:_emscripten_clear_immediate,/** @export */emscripten_clear_interval:_emscripten_clear_interval,/** @export */emscripten_clear_timeout:_emscripten_clear_timeout,/** @export */emscripten_console_error:_emscripten_console_error,/** @export */emscripten_console_log:_emscripten_console_log,/** @export */emscripten_console_trace:_emscripten_console_trace,/** @export */emscripten_console_warn:_emscripten_console_warn,/** @export */emscripten_create_worker:_emscripten_create_worker,/** @export */emscripten_date_now:_emscripten_date_now,/** @export */emscripten_debugger:_emscripten_debugger,/** @export */emscripten_destroy_worker:_emscripten_destroy_worker,/** @export */emscripten_enter_soft_fullscreen:_emscripten_enter_soft_fullscreen,/** @export */emscripten_err:_emscripten_err,/** @export */emscripten_errn:_emscripten_errn,/** @export */emscripten_exit_fullscreen:_emscripten_exit_fullscreen,/** @export */emscripten_exit_pointerlock:_emscripten_exit_pointerlock,/** @export */emscripten_exit_soft_fullscreen:_emscripten_exit_soft_fullscreen,/** @export */emscripten_exit_with_live_runtime:_emscripten_exit_with_live_runtime,/** @export */emscripten_fiber_swap:_emscripten_fiber_swap,/** @export */emscripten_force_exit:_emscripten_force_exit,/** @export */emscripten_get_battery_status:_emscripten_get_battery_status,/** @export */emscripten_get_callstack:_emscripten_get_callstack,/** @export */emscripten_get_canvas_element_size:_emscripten_get_canvas_element_size,/** @export */emscripten_get_canvas_size:_emscripten_get_canvas_size,/** @export */emscripten_get_compiler_setting:_emscripten_get_compiler_setting,/** @export */emscripten_get_device_pixel_ratio:_emscripten_get_device_pixel_ratio,/** @export */emscripten_get_devicemotion_status:_emscripten_get_devicemotion_status,/** @export */emscripten_get_deviceorientation_status:_emscripten_get_deviceorientation_status,/** @export */emscripten_get_element_css_size:_emscripten_get_element_css_size,/** @export */emscripten_get_fullscreen_status:_emscripten_get_fullscreen_status,/** @export */emscripten_get_gamepad_status:_emscripten_get_gamepad_status,/** @export */emscripten_get_heap_max:_emscripten_get_heap_max,/** @export */emscripten_get_main_loop_timing:_emscripten_get_main_loop_timing,/** @export */emscripten_get_mouse_status:_emscripten_get_mouse_status,/** @export */emscripten_get_now:_emscripten_get_now,/** @export */emscripten_get_now_res:_emscripten_get_now_res,/** @export */emscripten_get_num_gamepads:_emscripten_get_num_gamepads,/** @export */emscripten_get_orientation_status:_emscripten_get_orientation_status,/** @export */emscripten_get_pointerlock_status:_emscripten_get_pointerlock_status,/** @export */emscripten_get_preloaded_image_data:_emscripten_get_preloaded_image_data,/** @export */emscripten_get_preloaded_image_data_from_FILE:_emscripten_get_preloaded_image_data_from_FILE,/** @export */emscripten_get_screen_size:_emscripten_get_screen_size,/** @export */emscripten_get_visibility_status:_emscripten_get_visibility_status,/** @export */emscripten_get_window_title:_emscripten_get_window_title,/** @export */emscripten_get_worker_queue_size:_emscripten_get_worker_queue_size,/** @export */emscripten_glActiveTexture:_emscripten_glActiveTexture,/** @export */emscripten_glAttachShader:_emscripten_glAttachShader,/** @export */emscripten_glBegin:_emscripten_glBegin,/** @export */emscripten_glBeginQueryEXT:_emscripten_glBeginQueryEXT,/** @export */emscripten_glBindAttribLocation:_emscripten_glBindAttribLocation,/** @export */emscripten_glBindBuffer:_emscripten_glBindBuffer,/** @export */emscripten_glBindFramebuffer:_emscripten_glBindFramebuffer,/** @export */emscripten_glBindRenderbuffer:_emscripten_glBindRenderbuffer,/** @export */emscripten_glBindTexture:_emscripten_glBindTexture,/** @export */emscripten_glBindVertexArray:_emscripten_glBindVertexArray,/** @export */emscripten_glBindVertexArrayOES:_emscripten_glBindVertexArrayOES,/** @export */emscripten_glBlendColor:_emscripten_glBlendColor,/** @export */emscripten_glBlendEquation:_emscripten_glBlendEquation,/** @export */emscripten_glBlendEquationSeparate:_emscripten_glBlendEquationSeparate,/** @export */emscripten_glBlendFunc:_emscripten_glBlendFunc,/** @export */emscripten_glBlendFuncSeparate:_emscripten_glBlendFuncSeparate,/** @export */emscripten_glBufferData:_emscripten_glBufferData,/** @export */emscripten_glBufferSubData:_emscripten_glBufferSubData,/** @export */emscripten_glCheckFramebufferStatus:_emscripten_glCheckFramebufferStatus,/** @export */emscripten_glClear:_emscripten_glClear,/** @export */emscripten_glClearColor:_emscripten_glClearColor,/** @export */emscripten_glClearDepth:_emscripten_glClearDepth,/** @export */emscripten_glClearDepthf:_emscripten_glClearDepthf,/** @export */emscripten_glClearStencil:_emscripten_glClearStencil,/** @export */emscripten_glClipControlEXT:_emscripten_glClipControlEXT,/** @export */emscripten_glColorMask:_emscripten_glColorMask,/** @export */emscripten_glCompileShader:_emscripten_glCompileShader,/** @export */emscripten_glCompressedTexImage2D:_emscripten_glCompressedTexImage2D,/** @export */emscripten_glCompressedTexSubImage2D:_emscripten_glCompressedTexSubImage2D,/** @export */emscripten_glCopyTexImage2D:_emscripten_glCopyTexImage2D,/** @export */emscripten_glCopyTexSubImage2D:_emscripten_glCopyTexSubImage2D,/** @export */emscripten_glCreateProgram:_emscripten_glCreateProgram,/** @export */emscripten_glCreateShader:_emscripten_glCreateShader,/** @export */emscripten_glCullFace:_emscripten_glCullFace,/** @export */emscripten_glDeleteBuffers:_emscripten_glDeleteBuffers,/** @export */emscripten_glDeleteFramebuffers:_emscripten_glDeleteFramebuffers,/** @export */emscripten_glDeleteProgram:_emscripten_glDeleteProgram,/** @export */emscripten_glDeleteQueriesEXT:_emscripten_glDeleteQueriesEXT,/** @export */emscripten_glDeleteRenderbuffers:_emscripten_glDeleteRenderbuffers,/** @export */emscripten_glDeleteShader:_emscripten_glDeleteShader,/** @export */emscripten_glDeleteTextures:_emscripten_glDeleteTextures,/** @export */emscripten_glDeleteVertexArrays:_emscripten_glDeleteVertexArrays,/** @export */emscripten_glDeleteVertexArraysOES:_emscripten_glDeleteVertexArraysOES,/** @export */emscripten_glDepthFunc:_emscripten_glDepthFunc,/** @export */emscripten_glDepthMask:_emscripten_glDepthMask,/** @export */emscripten_glDepthRange:_emscripten_glDepthRange,/** @export */emscripten_glDepthRangef:_emscripten_glDepthRangef,/** @export */emscripten_glDetachShader:_emscripten_glDetachShader,/** @export */emscripten_glDisable:_emscripten_glDisable,/** @export */emscripten_glDisableVertexAttribArray:_emscripten_glDisableVertexAttribArray,/** @export */emscripten_glDrawArrays:_emscripten_glDrawArrays,/** @export */emscripten_glDrawArraysInstanced:_emscripten_glDrawArraysInstanced,/** @export */emscripten_glDrawArraysInstancedANGLE:_emscripten_glDrawArraysInstancedANGLE,/** @export */emscripten_glDrawArraysInstancedARB:_emscripten_glDrawArraysInstancedARB,/** @export */emscripten_glDrawArraysInstancedEXT:_emscripten_glDrawArraysInstancedEXT,/** @export */emscripten_glDrawArraysInstancedNV:_emscripten_glDrawArraysInstancedNV,/** @export */emscripten_glDrawBuffers:_emscripten_glDrawBuffers,/** @export */emscripten_glDrawBuffersEXT:_emscripten_glDrawBuffersEXT,/** @export */emscripten_glDrawBuffersWEBGL:_emscripten_glDrawBuffersWEBGL,/** @export */emscripten_glDrawElements:_emscripten_glDrawElements,/** @export */emscripten_glDrawElementsInstanced:_emscripten_glDrawElementsInstanced,/** @export */emscripten_glDrawElementsInstancedANGLE:_emscripten_glDrawElementsInstancedANGLE,/** @export */emscripten_glDrawElementsInstancedARB:_emscripten_glDrawElementsInstancedARB,/** @export */emscripten_glDrawElementsInstancedEXT:_emscripten_glDrawElementsInstancedEXT,/** @export */emscripten_glDrawElementsInstancedNV:_emscripten_glDrawElementsInstancedNV,/** @export */emscripten_glEnable:_emscripten_glEnable,/** @export */emscripten_glEnableVertexAttribArray:_emscripten_glEnableVertexAttribArray,/** @export */emscripten_glEndQueryEXT:_emscripten_glEndQueryEXT,/** @export */emscripten_glFinish:_emscripten_glFinish,/** @export */emscripten_glFlush:_emscripten_glFlush,/** @export */emscripten_glFramebufferRenderbuffer:_emscripten_glFramebufferRenderbuffer,/** @export */emscripten_glFramebufferTexture2D:_emscripten_glFramebufferTexture2D,/** @export */emscripten_glFrontFace:_emscripten_glFrontFace,/** @export */emscripten_glGenBuffers:_emscripten_glGenBuffers,/** @export */emscripten_glGenFramebuffers:_emscripten_glGenFramebuffers,/** @export */emscripten_glGenQueriesEXT:_emscripten_glGenQueriesEXT,/** @export */emscripten_glGenRenderbuffers:_emscripten_glGenRenderbuffers,/** @export */emscripten_glGenTextures:_emscripten_glGenTextures,/** @export */emscripten_glGenVertexArrays:_emscripten_glGenVertexArrays,/** @export */emscripten_glGenVertexArraysOES:_emscripten_glGenVertexArraysOES,/** @export */emscripten_glGenerateMipmap:_emscripten_glGenerateMipmap,/** @export */emscripten_glGetActiveAttrib:_emscripten_glGetActiveAttrib,/** @export */emscripten_glGetActiveUniform:_emscripten_glGetActiveUniform,/** @export */emscripten_glGetAttachedShaders:_emscripten_glGetAttachedShaders,/** @export */emscripten_glGetAttribLocation:_emscripten_glGetAttribLocation,/** @export */emscripten_glGetBooleanv:_emscripten_glGetBooleanv,/** @export */emscripten_glGetBufferParameteriv:_emscripten_glGetBufferParameteriv,/** @export */emscripten_glGetError:_emscripten_glGetError,/** @export */emscripten_glGetFloatv:_emscripten_glGetFloatv,/** @export */emscripten_glGetFramebufferAttachmentParameteriv:_emscripten_glGetFramebufferAttachmentParameteriv,/** @export */emscripten_glGetIntegerv:_emscripten_glGetIntegerv,/** @export */emscripten_glGetProgramInfoLog:_emscripten_glGetProgramInfoLog,/** @export */emscripten_glGetProgramiv:_emscripten_glGetProgramiv,/** @export */emscripten_glGetQueryObjecti64vEXT:_emscripten_glGetQueryObjecti64vEXT,/** @export */emscripten_glGetQueryObjectivEXT:_emscripten_glGetQueryObjectivEXT,/** @export */emscripten_glGetQueryObjectui64vEXT:_emscripten_glGetQueryObjectui64vEXT,/** @export */emscripten_glGetQueryObjectuivEXT:_emscripten_glGetQueryObjectuivEXT,/** @export */emscripten_glGetQueryivEXT:_emscripten_glGetQueryivEXT,/** @export */emscripten_glGetRenderbufferParameteriv:_emscripten_glGetRenderbufferParameteriv,/** @export */emscripten_glGetShaderInfoLog:_emscripten_glGetShaderInfoLog,/** @export */emscripten_glGetShaderPrecisionFormat:_emscripten_glGetShaderPrecisionFormat,/** @export */emscripten_glGetShaderSource:_emscripten_glGetShaderSource,/** @export */emscripten_glGetShaderiv:_emscripten_glGetShaderiv,/** @export */emscripten_glGetString:_emscripten_glGetString,/** @export */emscripten_glGetTexParameterfv:_emscripten_glGetTexParameterfv,/** @export */emscripten_glGetTexParameteriv:_emscripten_glGetTexParameteriv,/** @export */emscripten_glGetUniformLocation:_emscripten_glGetUniformLocation,/** @export */emscripten_glGetUniformfv:_emscripten_glGetUniformfv,/** @export */emscripten_glGetUniformiv:_emscripten_glGetUniformiv,/** @export */emscripten_glGetVertexAttribPointerv:_emscripten_glGetVertexAttribPointerv,/** @export */emscripten_glGetVertexAttribfv:_emscripten_glGetVertexAttribfv,/** @export */emscripten_glGetVertexAttribiv:_emscripten_glGetVertexAttribiv,/** @export */emscripten_glHint:_emscripten_glHint,/** @export */emscripten_glIsBuffer:_emscripten_glIsBuffer,/** @export */emscripten_glIsEnabled:_emscripten_glIsEnabled,/** @export */emscripten_glIsFramebuffer:_emscripten_glIsFramebuffer,/** @export */emscripten_glIsProgram:_emscripten_glIsProgram,/** @export */emscripten_glIsQueryEXT:_emscripten_glIsQueryEXT,/** @export */emscripten_glIsRenderbuffer:_emscripten_glIsRenderbuffer,/** @export */emscripten_glIsShader:_emscripten_glIsShader,/** @export */emscripten_glIsTexture:_emscripten_glIsTexture,/** @export */emscripten_glIsVertexArray:_emscripten_glIsVertexArray,/** @export */emscripten_glIsVertexArrayOES:_emscripten_glIsVertexArrayOES,/** @export */emscripten_glLineWidth:_emscripten_glLineWidth,/** @export */emscripten_glLinkProgram:_emscripten_glLinkProgram,/** @export */emscripten_glLoadIdentity:_emscripten_glLoadIdentity,/** @export */emscripten_glMatrixMode:_emscripten_glMatrixMode,/** @export */emscripten_glMultiDrawArrays:_emscripten_glMultiDrawArrays,/** @export */emscripten_glMultiDrawArraysANGLE:_emscripten_glMultiDrawArraysANGLE,/** @export */emscripten_glMultiDrawArraysInstancedANGLE:_emscripten_glMultiDrawArraysInstancedANGLE,/** @export */emscripten_glMultiDrawArraysInstancedWEBGL:_emscripten_glMultiDrawArraysInstancedWEBGL,/** @export */emscripten_glMultiDrawArraysWEBGL:_emscripten_glMultiDrawArraysWEBGL,/** @export */emscripten_glMultiDrawElements:_emscripten_glMultiDrawElements,/** @export */emscripten_glMultiDrawElementsANGLE:_emscripten_glMultiDrawElementsANGLE,/** @export */emscripten_glMultiDrawElementsInstancedANGLE:_emscripten_glMultiDrawElementsInstancedANGLE,/** @export */emscripten_glMultiDrawElementsInstancedWEBGL:_emscripten_glMultiDrawElementsInstancedWEBGL,/** @export */emscripten_glMultiDrawElementsWEBGL:_emscripten_glMultiDrawElementsWEBGL,/** @export */emscripten_glPixelStorei:_emscripten_glPixelStorei,/** @export */emscripten_glPolygonModeWEBGL:_emscripten_glPolygonModeWEBGL,/** @export */emscripten_glPolygonOffset:_emscripten_glPolygonOffset,/** @export */emscripten_glPolygonOffsetClampEXT:_emscripten_glPolygonOffsetClampEXT,/** @export */emscripten_glQueryCounterEXT:_emscripten_glQueryCounterEXT,/** @export */emscripten_glReadPixels:_emscripten_glReadPixels,/** @export */emscripten_glReleaseShaderCompiler:_emscripten_glReleaseShaderCompiler,/** @export */emscripten_glRenderbufferStorage:_emscripten_glRenderbufferStorage,/** @export */emscripten_glSampleCoverage:_emscripten_glSampleCoverage,/** @export */emscripten_glScissor:_emscripten_glScissor,/** @export */emscripten_glShaderBinary:_emscripten_glShaderBinary,/** @export */emscripten_glShaderSource:_emscripten_glShaderSource,/** @export */emscripten_glStencilFunc:_emscripten_glStencilFunc,/** @export */emscripten_glStencilFuncSeparate:_emscripten_glStencilFuncSeparate,/** @export */emscripten_glStencilMask:_emscripten_glStencilMask,/** @export */emscripten_glStencilMaskSeparate:_emscripten_glStencilMaskSeparate,/** @export */emscripten_glStencilOp:_emscripten_glStencilOp,/** @export */emscripten_glStencilOpSeparate:_emscripten_glStencilOpSeparate,/** @export */emscripten_glTexImage2D:_emscripten_glTexImage2D,/** @export */emscripten_glTexParameterf:_emscripten_glTexParameterf,/** @export */emscripten_glTexParameterfv:_emscripten_glTexParameterfv,/** @export */emscripten_glTexParameteri:_emscripten_glTexParameteri,/** @export */emscripten_glTexParameteriv:_emscripten_glTexParameteriv,/** @export */emscripten_glTexSubImage2D:_emscripten_glTexSubImage2D,/** @export */emscripten_glUniform1f:_emscripten_glUniform1f,/** @export */emscripten_glUniform1fv:_emscripten_glUniform1fv,/** @export */emscripten_glUniform1i:_emscripten_glUniform1i,/** @export */emscripten_glUniform1iv:_emscripten_glUniform1iv,/** @export */emscripten_glUniform2f:_emscripten_glUniform2f,/** @export */emscripten_glUniform2fv:_emscripten_glUniform2fv,/** @export */emscripten_glUniform2i:_emscripten_glUniform2i,/** @export */emscripten_glUniform2iv:_emscripten_glUniform2iv,/** @export */emscripten_glUniform3f:_emscripten_glUniform3f,/** @export */emscripten_glUniform3fv:_emscripten_glUniform3fv,/** @export */emscripten_glUniform3i:_emscripten_glUniform3i,/** @export */emscripten_glUniform3iv:_emscripten_glUniform3iv,/** @export */emscripten_glUniform4f:_emscripten_glUniform4f,/** @export */emscripten_glUniform4fv:_emscripten_glUniform4fv,/** @export */emscripten_glUniform4i:_emscripten_glUniform4i,/** @export */emscripten_glUniform4iv:_emscripten_glUniform4iv,/** @export */emscripten_glUniformMatrix2fv:_emscripten_glUniformMatrix2fv,/** @export */emscripten_glUniformMatrix3fv:_emscripten_glUniformMatrix3fv,/** @export */emscripten_glUniformMatrix4fv:_emscripten_glUniformMatrix4fv,/** @export */emscripten_glUseProgram:_emscripten_glUseProgram,/** @export */emscripten_glValidateProgram:_emscripten_glValidateProgram,/** @export */emscripten_glVertexAttrib1f:_emscripten_glVertexAttrib1f,/** @export */emscripten_glVertexAttrib1fv:_emscripten_glVertexAttrib1fv,/** @export */emscripten_glVertexAttrib2f:_emscripten_glVertexAttrib2f,/** @export */emscripten_glVertexAttrib2fv:_emscripten_glVertexAttrib2fv,/** @export */emscripten_glVertexAttrib3f:_emscripten_glVertexAttrib3f,/** @export */emscripten_glVertexAttrib3fv:_emscripten_glVertexAttrib3fv,/** @export */emscripten_glVertexAttrib4f:_emscripten_glVertexAttrib4f,/** @export */emscripten_glVertexAttrib4fv:_emscripten_glVertexAttrib4fv,/** @export */emscripten_glVertexAttribDivisor:_emscripten_glVertexAttribDivisor,/** @export */emscripten_glVertexAttribDivisorANGLE:_emscripten_glVertexAttribDivisorANGLE,/** @export */emscripten_glVertexAttribDivisorARB:_emscripten_glVertexAttribDivisorARB,/** @export */emscripten_glVertexAttribDivisorEXT:_emscripten_glVertexAttribDivisorEXT,/** @export */emscripten_glVertexAttribDivisorNV:_emscripten_glVertexAttribDivisorNV,/** @export */emscripten_glVertexAttribPointer:_emscripten_glVertexAttribPointer,/** @export */emscripten_glVertexPointer:_emscripten_glVertexPointer,/** @export */emscripten_glViewport:_emscripten_glViewport,/** @export */emscripten_has_asyncify:_emscripten_has_asyncify,/** @export */emscripten_hide_mouse:_emscripten_hide_mouse,/** @export */emscripten_html5_remove_all_event_listeners:_emscripten_html5_remove_all_event_listeners,/** @export */emscripten_idb_async_clear:_emscripten_idb_async_clear,/** @export */emscripten_idb_async_delete:_emscripten_idb_async_delete,/** @export */emscripten_idb_async_exists:_emscripten_idb_async_exists,/** @export */emscripten_idb_async_load:_emscripten_idb_async_load,/** @export */emscripten_idb_async_store:_emscripten_idb_async_store,/** @export */emscripten_idb_clear:_emscripten_idb_clear,/** @export */emscripten_idb_delete:_emscripten_idb_delete,/** @export */emscripten_idb_exists:_emscripten_idb_exists,/** @export */emscripten_idb_free_blob:_emscripten_idb_free_blob,/** @export */emscripten_idb_load:_emscripten_idb_load,/** @export */emscripten_idb_load_blob:_emscripten_idb_load_blob,/** @export */emscripten_idb_read_from_blob:_emscripten_idb_read_from_blob,/** @export */emscripten_idb_store:_emscripten_idb_store,/** @export */emscripten_idb_store_blob:_emscripten_idb_store_blob,/** @export */emscripten_is_main_browser_thread:_emscripten_is_main_browser_thread,/** @export */emscripten_is_webgl_context_lost:_emscripten_is_webgl_context_lost,/** @export */emscripten_lazy_load_code:_emscripten_lazy_load_code,/** @export */emscripten_lock_orientation:_emscripten_lock_orientation,/** @export */emscripten_log:_emscripten_log,/** @export */emscripten_math_acos:_emscripten_math_acos,/** @export */emscripten_math_acosh:_emscripten_math_acosh,/** @export */emscripten_math_asin:_emscripten_math_asin,/** @export */emscripten_math_asinh:_emscripten_math_asinh,/** @export */emscripten_math_atan:_emscripten_math_atan,/** @export */emscripten_math_atan2:_emscripten_math_atan2,/** @export */emscripten_math_atanh:_emscripten_math_atanh,/** @export */emscripten_math_cbrt:_emscripten_math_cbrt,/** @export */emscripten_math_cos:_emscripten_math_cos,/** @export */emscripten_math_cosh:_emscripten_math_cosh,/** @export */emscripten_math_exp:_emscripten_math_exp,/** @export */emscripten_math_expm1:_emscripten_math_expm1,/** @export */emscripten_math_fmod:_emscripten_math_fmod,/** @export */emscripten_math_hypot:_emscripten_math_hypot,/** @export */emscripten_math_log:_emscripten_math_log,/** @export */emscripten_math_log10:_emscripten_math_log10,/** @export */emscripten_math_log1p:_emscripten_math_log1p,/** @export */emscripten_math_log2:_emscripten_math_log2,/** @export */emscripten_math_pow:_emscripten_math_pow,/** @export */emscripten_math_random:_emscripten_math_random,/** @export */emscripten_math_round:_emscripten_math_round,/** @export */emscripten_math_sign:_emscripten_math_sign,/** @export */emscripten_math_sin:_emscripten_math_sin,/** @export */emscripten_math_sinh:_emscripten_math_sinh,/** @export */emscripten_math_sqrt:_emscripten_math_sqrt,/** @export */emscripten_math_tan:_emscripten_math_tan,/** @export */emscripten_math_tanh:_emscripten_math_tanh,/** @export */emscripten_notify_memory_growth:_emscripten_notify_memory_growth,/** @export */emscripten_out:_emscripten_out,/** @export */emscripten_outn:_emscripten_outn,/** @export */emscripten_pause_main_loop:_emscripten_pause_main_loop,/** @export */emscripten_pc_get_column:_emscripten_pc_get_column,/** @export */emscripten_pc_get_file:_emscripten_pc_get_file,/** @export */emscripten_pc_get_function:_emscripten_pc_get_function,/** @export */emscripten_pc_get_line:_emscripten_pc_get_line,/** @export */emscripten_performance_now:_emscripten_performance_now,/** @export */emscripten_print_double:_emscripten_print_double,/** @export */emscripten_promise_all:_emscripten_promise_all,/** @export */emscripten_promise_all_settled:_emscripten_promise_all_settled,/** @export */emscripten_promise_any:_emscripten_promise_any,/** @export */emscripten_promise_await:_emscripten_promise_await,/** @export */emscripten_promise_create:_emscripten_promise_create,/** @export */emscripten_promise_destroy:_emscripten_promise_destroy,/** @export */emscripten_promise_race:_emscripten_promise_race,/** @export */emscripten_promise_resolve:_emscripten_promise_resolve,/** @export */emscripten_promise_then:_emscripten_promise_then,/** @export */emscripten_random:_emscripten_random,/** @export */emscripten_request_animation_frame:_emscripten_request_animation_frame,/** @export */emscripten_request_animation_frame_loop:_emscripten_request_animation_frame_loop,/** @export */emscripten_request_fullscreen:_emscripten_request_fullscreen,/** @export */emscripten_request_fullscreen_strategy:_emscripten_request_fullscreen_strategy,/** @export */emscripten_request_pointerlock:_emscripten_request_pointerlock,/** @export */emscripten_resize_heap:_emscripten_resize_heap,/** @export */emscripten_resume_main_loop:_emscripten_resume_main_loop,/** @export */emscripten_return_address:_emscripten_return_address,/** @export */emscripten_run_preload_plugins:_emscripten_run_preload_plugins,/** @export */emscripten_run_preload_plugins_data:_emscripten_run_preload_plugins_data,/** @export */emscripten_run_script:_emscripten_run_script,/** @export */emscripten_run_script_int:_emscripten_run_script_int,/** @export */emscripten_run_script_string:_emscripten_run_script_string,/** @export */emscripten_runtime_keepalive_check:_emscripten_runtime_keepalive_check,/** @export */emscripten_runtime_keepalive_pop:_emscripten_runtime_keepalive_pop,/** @export */emscripten_runtime_keepalive_push:_emscripten_runtime_keepalive_push,/** @export */emscripten_sample_gamepad_data:_emscripten_sample_gamepad_data,/** @export */emscripten_scan_registers:_emscripten_scan_registers,/** @export */emscripten_set_batterychargingchange_callback_on_thread:_emscripten_set_batterychargingchange_callback_on_thread,/** @export */emscripten_set_batterylevelchange_callback_on_thread:_emscripten_set_batterylevelchange_callback_on_thread,/** @export */emscripten_set_beforeunload_callback_on_thread:_emscripten_set_beforeunload_callback_on_thread,/** @export */emscripten_set_blur_callback_on_thread:_emscripten_set_blur_callback_on_thread,/** @export */emscripten_set_canvas_element_size:_emscripten_set_canvas_element_size,/** @export */emscripten_set_canvas_size:_emscripten_set_canvas_size,/** @export */emscripten_set_click_callback_on_thread:_emscripten_set_click_callback_on_thread,/** @export */emscripten_set_dblclick_callback_on_thread:_emscripten_set_dblclick_callback_on_thread,/** @export */emscripten_set_devicemotion_callback_on_thread:_emscripten_set_devicemotion_callback_on_thread,/** @export */emscripten_set_deviceorientation_callback_on_thread:_emscripten_set_deviceorientation_callback_on_thread,/** @export */emscripten_set_element_css_size:_emscripten_set_element_css_size,/** @export */emscripten_set_focus_callback_on_thread:_emscripten_set_focus_callback_on_thread,/** @export */emscripten_set_focusin_callback_on_thread:_emscripten_set_focusin_callback_on_thread,/** @export */emscripten_set_focusout_callback_on_thread:_emscripten_set_focusout_callback_on_thread,/** @export */emscripten_set_fullscreenchange_callback_on_thread:_emscripten_set_fullscreenchange_callback_on_thread,/** @export */emscripten_set_gamepadconnected_callback_on_thread:_emscripten_set_gamepadconnected_callback_on_thread,/** @export */emscripten_set_gamepaddisconnected_callback_on_thread:_emscripten_set_gamepaddisconnected_callback_on_thread,/** @export */emscripten_set_immediate:_emscripten_set_immediate,/** @export */emscripten_set_immediate_loop:_emscripten_set_immediate_loop,/** @export */emscripten_set_interval:_emscripten_set_interval,/** @export */emscripten_set_keydown_callback_on_thread:_emscripten_set_keydown_callback_on_thread,/** @export */emscripten_set_keypress_callback_on_thread:_emscripten_set_keypress_callback_on_thread,/** @export */emscripten_set_keyup_callback_on_thread:_emscripten_set_keyup_callback_on_thread,/** @export */emscripten_set_main_loop:_emscripten_set_main_loop,/** @export */emscripten_set_main_loop_arg:_emscripten_set_main_loop_arg,/** @export */emscripten_set_main_loop_expected_blockers:_emscripten_set_main_loop_expected_blockers,/** @export */emscripten_set_main_loop_timing:_emscripten_set_main_loop_timing,/** @export */emscripten_set_mousedown_callback_on_thread:_emscripten_set_mousedown_callback_on_thread,/** @export */emscripten_set_mouseenter_callback_on_thread:_emscripten_set_mouseenter_callback_on_thread,/** @export */emscripten_set_mouseleave_callback_on_thread:_emscripten_set_mouseleave_callback_on_thread,/** @export */emscripten_set_mousemove_callback_on_thread:_emscripten_set_mousemove_callback_on_thread,/** @export */emscripten_set_mouseout_callback_on_thread:_emscripten_set_mouseout_callback_on_thread,/** @export */emscripten_set_mouseover_callback_on_thread:_emscripten_set_mouseover_callback_on_thread,/** @export */emscripten_set_mouseup_callback_on_thread:_emscripten_set_mouseup_callback_on_thread,/** @export */emscripten_set_orientationchange_callback_on_thread:_emscripten_set_orientationchange_callback_on_thread,/** @export */emscripten_set_pointerlockchange_callback_on_thread:_emscripten_set_pointerlockchange_callback_on_thread,/** @export */emscripten_set_pointerlockerror_callback_on_thread:_emscripten_set_pointerlockerror_callback_on_thread,/** @export */emscripten_set_resize_callback_on_thread:_emscripten_set_resize_callback_on_thread,/** @export */emscripten_set_scroll_callback_on_thread:_emscripten_set_scroll_callback_on_thread,/** @export */emscripten_set_socket_close_callback:_emscripten_set_socket_close_callback,/** @export */emscripten_set_socket_connection_callback:_emscripten_set_socket_connection_callback,/** @export */emscripten_set_socket_error_callback:_emscripten_set_socket_error_callback,/** @export */emscripten_set_socket_listen_callback:_emscripten_set_socket_listen_callback,/** @export */emscripten_set_socket_message_callback:_emscripten_set_socket_message_callback,/** @export */emscripten_set_socket_open_callback:_emscripten_set_socket_open_callback,/** @export */emscripten_set_timeout:_emscripten_set_timeout,/** @export */emscripten_set_timeout_loop:_emscripten_set_timeout_loop,/** @export */emscripten_set_touchcancel_callback_on_thread:_emscripten_set_touchcancel_callback_on_thread,/** @export */emscripten_set_touchend_callback_on_thread:_emscripten_set_touchend_callback_on_thread,/** @export */emscripten_set_touchmove_callback_on_thread:_emscripten_set_touchmove_callback_on_thread,/** @export */emscripten_set_touchstart_callback_on_thread:_emscripten_set_touchstart_callback_on_thread,/** @export */emscripten_set_visibilitychange_callback_on_thread:_emscripten_set_visibilitychange_callback_on_thread,/** @export */emscripten_set_webglcontextlost_callback_on_thread:_emscripten_set_webglcontextlost_callback_on_thread,/** @export */emscripten_set_webglcontextrestored_callback_on_thread:_emscripten_set_webglcontextrestored_callback_on_thread,/** @export */emscripten_set_wheel_callback_on_thread:_emscripten_set_wheel_callback_on_thread,/** @export */emscripten_set_window_title:_emscripten_set_window_title,/** @export */emscripten_sleep:_emscripten_sleep,/** @export */emscripten_stack_snapshot:_emscripten_stack_snapshot,/** @export */emscripten_stack_unwind_buffer:_emscripten_stack_unwind_buffer,/** @export */emscripten_supports_offscreencanvas:_emscripten_supports_offscreencanvas,/** @export */emscripten_throw_number:_emscripten_throw_number,/** @export */emscripten_throw_string:_emscripten_throw_string,/** @export */emscripten_unlock_orientation:_emscripten_unlock_orientation,/** @export */emscripten_unwind_to_js_event_loop:_emscripten_unwind_to_js_event_loop,/** @export */emscripten_vibrate:_emscripten_vibrate,/** @export */emscripten_vibrate_pattern:_emscripten_vibrate_pattern,/** @export */emscripten_webgl_commit_frame:_emscripten_webgl_commit_frame,/** @export */emscripten_webgl_create_context:_emscripten_webgl_create_context,/** @export */emscripten_webgl_destroy_context:_emscripten_webgl_destroy_context,/** @export */emscripten_webgl_do_commit_frame:_emscripten_webgl_do_commit_frame,/** @export */emscripten_webgl_do_create_context:_emscripten_webgl_do_create_context,/** @export */emscripten_webgl_do_get_current_context:_emscripten_webgl_do_get_current_context,/** @export */emscripten_webgl_enable_ANGLE_instanced_arrays:_emscripten_webgl_enable_ANGLE_instanced_arrays,/** @export */emscripten_webgl_enable_EXT_clip_control:_emscripten_webgl_enable_EXT_clip_control,/** @export */emscripten_webgl_enable_EXT_polygon_offset_clamp:_emscripten_webgl_enable_EXT_polygon_offset_clamp,/** @export */emscripten_webgl_enable_OES_vertex_array_object:_emscripten_webgl_enable_OES_vertex_array_object,/** @export */emscripten_webgl_enable_WEBGL_draw_buffers:_emscripten_webgl_enable_WEBGL_draw_buffers,/** @export */emscripten_webgl_enable_WEBGL_multi_draw:_emscripten_webgl_enable_WEBGL_multi_draw,/** @export */emscripten_webgl_enable_WEBGL_polygon_mode:_emscripten_webgl_enable_WEBGL_polygon_mode,/** @export */emscripten_webgl_enable_extension:_emscripten_webgl_enable_extension,/** @export */emscripten_webgl_get_context_attributes:_emscripten_webgl_get_context_attributes,/** @export */emscripten_webgl_get_current_context:_emscripten_webgl_get_current_context,/** @export */emscripten_webgl_get_drawing_buffer_size:_emscripten_webgl_get_drawing_buffer_size,/** @export */emscripten_webgl_get_parameter_d:_emscripten_webgl_get_parameter_d,/** @export */emscripten_webgl_get_parameter_i64v:_emscripten_webgl_get_parameter_i64v,/** @export */emscripten_webgl_get_parameter_o:_emscripten_webgl_get_parameter_o,/** @export */emscripten_webgl_get_parameter_utf8:_emscripten_webgl_get_parameter_utf8,/** @export */emscripten_webgl_get_parameter_v:_emscripten_webgl_get_parameter_v,/** @export */emscripten_webgl_get_program_info_log_utf8:_emscripten_webgl_get_program_info_log_utf8,/** @export */emscripten_webgl_get_program_parameter_d:_emscripten_webgl_get_program_parameter_d,/** @export */emscripten_webgl_get_shader_info_log_utf8:_emscripten_webgl_get_shader_info_log_utf8,/** @export */emscripten_webgl_get_shader_parameter_d:_emscripten_webgl_get_shader_parameter_d,/** @export */emscripten_webgl_get_shader_source_utf8:_emscripten_webgl_get_shader_source_utf8,/** @export */emscripten_webgl_get_supported_extensions:_emscripten_webgl_get_supported_extensions,/** @export */emscripten_webgl_get_uniform_d:_emscripten_webgl_get_uniform_d,/** @export */emscripten_webgl_get_uniform_v:_emscripten_webgl_get_uniform_v,/** @export */emscripten_webgl_get_vertex_attrib_d:_emscripten_webgl_get_vertex_attrib_d,/** @export */emscripten_webgl_get_vertex_attrib_o:_emscripten_webgl_get_vertex_attrib_o,/** @export */emscripten_webgl_get_vertex_attrib_v:_emscripten_webgl_get_vertex_attrib_v,/** @export */emscripten_webgl_make_context_current:_emscripten_webgl_make_context_current,/** @export */emscripten_wget_data:_emscripten_wget_data,/** @export */endprotoent:_endprotoent,/** @export */environ_get:_environ_get,/** @export */environ_sizes_get:_environ_sizes_get,/** @export */exit:_exit,/** @export */fd_close:_fd_close,/** @export */fd_fdstat_get:_fd_fdstat_get,/** @export */fd_pread:_fd_pread,/** @export */fd_pwrite:_fd_pwrite,/** @export */fd_read:_fd_read,/** @export */fd_seek:_fd_seek,/** @export */fd_sync:_fd_sync,/** @export */fd_write:_fd_write,/** @export */filledEllipseColor:_filledEllipseColor,/** @export */filledEllipseRGBA:_filledEllipseRGBA,/** @export */getaddrinfo:_getaddrinfo,/** @export */getcontext:_getcontext,/** @export */getdtablesize:_getdtablesize,/** @export */getentropy:_getentropy,/** @export */getnameinfo:_getnameinfo,/** @export */getprotobyname:_getprotobyname,/** @export */getprotobynumber:_getprotobynumber,/** @export */getprotoent:_getprotoent,/** @export */glActiveTexture:_glActiveTexture,/** @export */glAttachShader:_glAttachShader,/** @export */glBegin:_glBegin,/** @export */glBeginQueryEXT:_glBeginQueryEXT,/** @export */glBindAttribLocation:_glBindAttribLocation,/** @export */glBindBuffer:_glBindBuffer,/** @export */glBindFramebuffer:_glBindFramebuffer,/** @export */glBindRenderbuffer:_glBindRenderbuffer,/** @export */glBindTexture:_glBindTexture,/** @export */glBindVertexArray:_glBindVertexArray,/** @export */glBindVertexArrayOES:_glBindVertexArrayOES,/** @export */glBlendColor:_glBlendColor,/** @export */glBlendEquation:_glBlendEquation,/** @export */glBlendEquationSeparate:_glBlendEquationSeparate,/** @export */glBlendFunc:_glBlendFunc,/** @export */glBlendFuncSeparate:_glBlendFuncSeparate,/** @export */glBufferData:_glBufferData,/** @export */glBufferSubData:_glBufferSubData,/** @export */glCheckFramebufferStatus:_glCheckFramebufferStatus,/** @export */glClear:_glClear,/** @export */glClearColor:_glClearColor,/** @export */glClearDepth:_glClearDepth,/** @export */glClearDepthf:_glClearDepthf,/** @export */glClearStencil:_glClearStencil,/** @export */glClipControlEXT:_glClipControlEXT,/** @export */glColorMask:_glColorMask,/** @export */glCompileShader:_glCompileShader,/** @export */glCompressedTexImage2D:_glCompressedTexImage2D,/** @export */glCompressedTexSubImage2D:_glCompressedTexSubImage2D,/** @export */glCopyTexImage2D:_glCopyTexImage2D,/** @export */glCopyTexSubImage2D:_glCopyTexSubImage2D,/** @export */glCreateProgram:_glCreateProgram,/** @export */glCreateShader:_glCreateShader,/** @export */glCullFace:_glCullFace,/** @export */glDeleteBuffers:_glDeleteBuffers,/** @export */glDeleteFramebuffers:_glDeleteFramebuffers,/** @export */glDeleteProgram:_glDeleteProgram,/** @export */glDeleteQueriesEXT:_glDeleteQueriesEXT,/** @export */glDeleteRenderbuffers:_glDeleteRenderbuffers,/** @export */glDeleteShader:_glDeleteShader,/** @export */glDeleteTextures:_glDeleteTextures,/** @export */glDeleteVertexArrays:_glDeleteVertexArrays,/** @export */glDeleteVertexArraysOES:_glDeleteVertexArraysOES,/** @export */glDepthFunc:_glDepthFunc,/** @export */glDepthMask:_glDepthMask,/** @export */glDepthRange:_glDepthRange,/** @export */glDepthRangef:_glDepthRangef,/** @export */glDetachShader:_glDetachShader,/** @export */glDisable:_glDisable,/** @export */glDisableVertexAttribArray:_glDisableVertexAttribArray,/** @export */glDrawArrays:_glDrawArrays,/** @export */glDrawArraysInstanced:_glDrawArraysInstanced,/** @export */glDrawArraysInstancedANGLE:_glDrawArraysInstancedANGLE,/** @export */glDrawArraysInstancedARB:_glDrawArraysInstancedARB,/** @export */glDrawArraysInstancedEXT:_glDrawArraysInstancedEXT,/** @export */glDrawArraysInstancedNV:_glDrawArraysInstancedNV,/** @export */glDrawBuffers:_glDrawBuffers,/** @export */glDrawBuffersEXT:_glDrawBuffersEXT,/** @export */glDrawBuffersWEBGL:_glDrawBuffersWEBGL,/** @export */glDrawElements:_glDrawElements,/** @export */glDrawElementsInstanced:_glDrawElementsInstanced,/** @export */glDrawElementsInstancedANGLE:_glDrawElementsInstancedANGLE,/** @export */glDrawElementsInstancedARB:_glDrawElementsInstancedARB,/** @export */glDrawElementsInstancedEXT:_glDrawElementsInstancedEXT,/** @export */glDrawElementsInstancedNV:_glDrawElementsInstancedNV,/** @export */glEnable:_glEnable,/** @export */glEnableVertexAttribArray:_glEnableVertexAttribArray,/** @export */glEndQueryEXT:_glEndQueryEXT,/** @export */glFinish:_glFinish,/** @export */glFlush:_glFlush,/** @export */glFramebufferRenderbuffer:_glFramebufferRenderbuffer,/** @export */glFramebufferTexture2D:_glFramebufferTexture2D,/** @export */glFrontFace:_glFrontFace,/** @export */glGenBuffers:_glGenBuffers,/** @export */glGenFramebuffers:_glGenFramebuffers,/** @export */glGenQueriesEXT:_glGenQueriesEXT,/** @export */glGenRenderbuffers:_glGenRenderbuffers,/** @export */glGenTextures:_glGenTextures,/** @export */glGenVertexArrays:_glGenVertexArrays,/** @export */glGenVertexArraysOES:_glGenVertexArraysOES,/** @export */glGenerateMipmap:_glGenerateMipmap,/** @export */glGetActiveAttrib:_glGetActiveAttrib,/** @export */glGetActiveUniform:_glGetActiveUniform,/** @export */glGetAttachedShaders:_glGetAttachedShaders,/** @export */glGetAttribLocation:_glGetAttribLocation,/** @export */glGetBooleanv:_glGetBooleanv,/** @export */glGetBufferParameteriv:_glGetBufferParameteriv,/** @export */glGetError:_glGetError,/** @export */glGetFloatv:_glGetFloatv,/** @export */glGetFramebufferAttachmentParameteriv:_glGetFramebufferAttachmentParameteriv,/** @export */glGetIntegerv:_glGetIntegerv,/** @export */glGetProgramInfoLog:_glGetProgramInfoLog,/** @export */glGetProgramiv:_glGetProgramiv,/** @export */glGetQueryObjecti64vEXT:_glGetQueryObjecti64vEXT,/** @export */glGetQueryObjectivEXT:_glGetQueryObjectivEXT,/** @export */glGetQueryObjectui64vEXT:_glGetQueryObjectui64vEXT,/** @export */glGetQueryObjectuivEXT:_glGetQueryObjectuivEXT,/** @export */glGetQueryivEXT:_glGetQueryivEXT,/** @export */glGetRenderbufferParameteriv:_glGetRenderbufferParameteriv,/** @export */glGetShaderInfoLog:_glGetShaderInfoLog,/** @export */glGetShaderPrecisionFormat:_glGetShaderPrecisionFormat,/** @export */glGetShaderSource:_glGetShaderSource,/** @export */glGetShaderiv:_glGetShaderiv,/** @export */glGetString:_glGetString,/** @export */glGetTexParameterfv:_glGetTexParameterfv,/** @export */glGetTexParameteriv:_glGetTexParameteriv,/** @export */glGetUniformLocation:_glGetUniformLocation,/** @export */glGetUniformfv:_glGetUniformfv,/** @export */glGetUniformiv:_glGetUniformiv,/** @export */glGetVertexAttribPointerv:_glGetVertexAttribPointerv,/** @export */glGetVertexAttribfv:_glGetVertexAttribfv,/** @export */glGetVertexAttribiv:_glGetVertexAttribiv,/** @export */glHint:_glHint,/** @export */glIsBuffer:_glIsBuffer,/** @export */glIsEnabled:_glIsEnabled,/** @export */glIsFramebuffer:_glIsFramebuffer,/** @export */glIsProgram:_glIsProgram,/** @export */glIsQueryEXT:_glIsQueryEXT,/** @export */glIsRenderbuffer:_glIsRenderbuffer,/** @export */glIsShader:_glIsShader,/** @export */glIsTexture:_glIsTexture,/** @export */glIsVertexArray:_glIsVertexArray,/** @export */glIsVertexArrayOES:_glIsVertexArrayOES,/** @export */glLineWidth:_glLineWidth,/** @export */glLinkProgram:_glLinkProgram,/** @export */glLoadIdentity:_glLoadIdentity,/** @export */glMatrixMode:_glMatrixMode,/** @export */glMultiDrawArrays:_glMultiDrawArrays,/** @export */glMultiDrawArraysANGLE:_glMultiDrawArraysANGLE,/** @export */glMultiDrawArraysInstancedANGLE:_glMultiDrawArraysInstancedANGLE,/** @export */glMultiDrawArraysInstancedWEBGL:_glMultiDrawArraysInstancedWEBGL,/** @export */glMultiDrawArraysWEBGL:_glMultiDrawArraysWEBGL,/** @export */glMultiDrawElements:_glMultiDrawElements,/** @export */glMultiDrawElementsANGLE:_glMultiDrawElementsANGLE,/** @export */glMultiDrawElementsInstancedANGLE:_glMultiDrawElementsInstancedANGLE,/** @export */glMultiDrawElementsInstancedWEBGL:_glMultiDrawElementsInstancedWEBGL,/** @export */glMultiDrawElementsWEBGL:_glMultiDrawElementsWEBGL,/** @export */glPixelStorei:_glPixelStorei,/** @export */glPolygonModeWEBGL:_glPolygonModeWEBGL,/** @export */glPolygonOffset:_glPolygonOffset,/** @export */glPolygonOffsetClampEXT:_glPolygonOffsetClampEXT,/** @export */glQueryCounterEXT:_glQueryCounterEXT,/** @export */glReadPixels:_glReadPixels,/** @export */glReleaseShaderCompiler:_glReleaseShaderCompiler,/** @export */glRenderbufferStorage:_glRenderbufferStorage,/** @export */glSampleCoverage:_glSampleCoverage,/** @export */glScissor:_glScissor,/** @export */glShaderBinary:_glShaderBinary,/** @export */glShaderSource:_glShaderSource,/** @export */glStencilFunc:_glStencilFunc,/** @export */glStencilFuncSeparate:_glStencilFuncSeparate,/** @export */glStencilMask:_glStencilMask,/** @export */glStencilMaskSeparate:_glStencilMaskSeparate,/** @export */glStencilOp:_glStencilOp,/** @export */glStencilOpSeparate:_glStencilOpSeparate,/** @export */glTexImage2D:_glTexImage2D,/** @export */glTexParameterf:_glTexParameterf,/** @export */glTexParameterfv:_glTexParameterfv,/** @export */glTexParameteri:_glTexParameteri,/** @export */glTexParameteriv:_glTexParameteriv,/** @export */glTexSubImage2D:_glTexSubImage2D,/** @export */glUniform1f:_glUniform1f,/** @export */glUniform1fv:_glUniform1fv,/** @export */glUniform1i:_glUniform1i,/** @export */glUniform1iv:_glUniform1iv,/** @export */glUniform2f:_glUniform2f,/** @export */glUniform2fv:_glUniform2fv,/** @export */glUniform2i:_glUniform2i,/** @export */glUniform2iv:_glUniform2iv,/** @export */glUniform3f:_glUniform3f,/** @export */glUniform3fv:_glUniform3fv,/** @export */glUniform3i:_glUniform3i,/** @export */glUniform3iv:_glUniform3iv,/** @export */glUniform4f:_glUniform4f,/** @export */glUniform4fv:_glUniform4fv,/** @export */glUniform4i:_glUniform4i,/** @export */glUniform4iv:_glUniform4iv,/** @export */glUniformMatrix2fv:_glUniformMatrix2fv,/** @export */glUniformMatrix3fv:_glUniformMatrix3fv,/** @export */glUniformMatrix4fv:_glUniformMatrix4fv,/** @export */glUseProgram:_glUseProgram,/** @export */glValidateProgram:_glValidateProgram,/** @export */glVertexAttrib1f:_glVertexAttrib1f,/** @export */glVertexAttrib1fv:_glVertexAttrib1fv,/** @export */glVertexAttrib2f:_glVertexAttrib2f,/** @export */glVertexAttrib2fv:_glVertexAttrib2fv,/** @export */glVertexAttrib3f:_glVertexAttrib3f,/** @export */glVertexAttrib3fv:_glVertexAttrib3fv,/** @export */glVertexAttrib4f:_glVertexAttrib4f,/** @export */glVertexAttrib4fv:_glVertexAttrib4fv,/** @export */glVertexAttribDivisor:_glVertexAttribDivisor,/** @export */glVertexAttribDivisorANGLE:_glVertexAttribDivisorANGLE,/** @export */glVertexAttribDivisorARB:_glVertexAttribDivisorARB,/** @export */glVertexAttribDivisorEXT:_glVertexAttribDivisorEXT,/** @export */glVertexAttribDivisorNV:_glVertexAttribDivisorNV,/** @export */glVertexAttribPointer:_glVertexAttribPointer,/** @export */glVertexPointer:_glVertexPointer,/** @export */glViewport:_glViewport,/** @export */glewGetErrorString:_glewGetErrorString,/** @export */glewGetExtension:_glewGetExtension,/** @export */glewGetString:_glewGetString,/** @export */glewInit:_glewInit,/** @export */glewIsSupported:_glewIsSupported,/** @export */glutCreateWindow:_glutCreateWindow,/** @export */glutDestroyWindow:_glutDestroyWindow,/** @export */glutDisplayFunc:_glutDisplayFunc,/** @export */glutFullScreen:_glutFullScreen,/** @export */glutGet:_glutGet,/** @export */glutGetModifiers:_glutGetModifiers,/** @export */glutIdleFunc:_glutIdleFunc,/** @export */glutInit:_glutInit,/** @export */glutInitDisplayMode:_glutInitDisplayMode,/** @export */glutInitWindowPosition:_glutInitWindowPosition,/** @export */glutInitWindowSize:_glutInitWindowSize,/** @export */glutKeyboardFunc:_glutKeyboardFunc,/** @export */glutKeyboardUpFunc:_glutKeyboardUpFunc,/** @export */glutMainLoop:_glutMainLoop,/** @export */glutMotionFunc:_glutMotionFunc,/** @export */glutMouseFunc:_glutMouseFunc,/** @export */glutPassiveMotionFunc:_glutPassiveMotionFunc,/** @export */glutPositionWindow:_glutPositionWindow,/** @export */glutPostRedisplay:_glutPostRedisplay,/** @export */glutReshapeFunc:_glutReshapeFunc,/** @export */glutReshapeWindow:_glutReshapeWindow,/** @export */glutSetCursor:_glutSetCursor,/** @export */glutSpecialFunc:_glutSpecialFunc,/** @export */glutSpecialUpFunc:_glutSpecialUpFunc,/** @export */glutSwapBuffers:_glutSwapBuffers,/** @export */glutTimerFunc:_glutTimerFunc,/** @export */htmlDefaultSAXHandler:_htmlDefaultSAXHandler,/** @export */invoke_i,/** @export */invoke_ii,/** @export */invoke_iii,/** @export */invoke_iiii,/** @export */invoke_iiiii,/** @export */invoke_iiiiii,/** @export */invoke_iiiiiii,/** @export */invoke_iiiiiiii,/** @export */invoke_iiiiiiiiii,/** @export */invoke_v,/** @export */invoke_vi,/** @export */invoke_vii,/** @export */invoke_viii,/** @export */invoke_viiii,/** @export */invoke_viiiiii,/** @export */isolat1ToUTF8:_isolat1ToUTF8,/** @export */lineColor:_lineColor,/** @export */lineRGBA:_lineRGBA,/** @export */llvm_eh_typeid_for:_llvm_eh_typeid_for,/** @export */makecontext:_makecontext,/** @export */memory:wasmMemory,/** @export */oldXMLWDcompatibility:_oldXMLWDcompatibility,/** @export */php_embed_init:_php_embed_init,/** @export */php_embed_shutdown:_php_embed_shutdown,/** @export */pixelRGBA:_pixelRGBA,/** @export */posix_spawnp:_posix_spawnp,/** @export */proc_exit:_proc_exit,/** @export */random_get:_random_get,/** @export */rectangleColor:_rectangleColor,/** @export */rectangleRGBA:_rectangleRGBA,/** @export */rotozoomSurface:_rotozoomSurface,/** @export */setNetworkCallback:_setNetworkCallback,/** @export */setprotoent:_setprotoent,/** @export */stackAlloc:_stackAlloc,/** @export */stackRestore:_stackRestore,/** @export */stackSave:_stackSave,/** @export */strptime:_strptime,/** @export */strptime_l:_strptime_l,/** @export */swapcontext:_swapcontext,/** @export */uuid_clear:_uuid_clear,/** @export */uuid_compare:_uuid_compare,/** @export */uuid_copy:_uuid_copy,/** @export */uuid_generate:_uuid_generate,/** @export */uuid_is_null:_uuid_is_null,/** @export */uuid_parse:_uuid_parse,/** @export */uuid_type:_uuid_type,/** @export */uuid_unparse:_uuid_unparse,/** @export */uuid_unparse_lower:_uuid_unparse_lower,/** @export */uuid_unparse_upper:_uuid_unparse_upper,/** @export */uuid_variant:_uuid_variant,/** @export */xmlAllocOutputBuffer:_xmlAllocOutputBuffer,/** @export */xmlAllocParserInputBuffer:_xmlAllocParserInputBuffer,/** @export */xmlBufferAllocScheme:_xmlBufferAllocScheme,/** @export */xmlCopyError:_xmlCopyError,/** @export */xmlDefaultBufferSize:_xmlDefaultBufferSize,/** @export */xmlDefaultSAXHandler:_xmlDefaultSAXHandler,/** @export */xmlDefaultSAXLocator:_xmlDefaultSAXLocator,/** @export */xmlDeregisterNodeDefaultValue:_xmlDeregisterNodeDefaultValue,/** @export */xmlDictOwns:_xmlDictOwns,/** @export */xmlDoValidityCheckingDefaultValue:_xmlDoValidityCheckingDefaultValue,/** @export */xmlFileClose:_xmlFileClose,/** @export */xmlFileMatch:_xmlFileMatch,/** @export */xmlFileOpen:_xmlFileOpen,/** @export */xmlFileRead:_xmlFileRead,/** @export */xmlFree:_xmlFree,/** @export */xmlFreeDoc:_xmlFreeDoc,/** @export */xmlFreeNode:_xmlFreeNode,/** @export */xmlFreeNodeList:_xmlFreeNodeList,/** @export */xmlFreeNs:_xmlFreeNs,/** @export */xmlFreeParserInputBuffer:_xmlFreeParserInputBuffer,/** @export */xmlFreeProp:_xmlFreeProp,/** @export */xmlFreeURI:_xmlFreeURI,/** @export */xmlGenericError:_xmlGenericError,/** @export */xmlGenericErrorContext:_xmlGenericErrorContext,/** @export */xmlGenericErrorDefaultFunc:_xmlGenericErrorDefaultFunc,/** @export */xmlGetExternalEntityLoader:_xmlGetExternalEntityLoader,/** @export */xmlGetLastError:_xmlGetLastError,/** @export */xmlGetWarningsDefaultValue:_xmlGetWarningsDefaultValue,/** @export */xmlHashDefaultDeallocator:_xmlHashDefaultDeallocator,/** @export */xmlHashLookup:_xmlHashLookup,/** @export */xmlHashRemoveEntry:_xmlHashRemoveEntry,/** @export */xmlHashScan:_xmlHashScan,/** @export */xmlIndentTreeOutput:_xmlIndentTreeOutput,/** @export */xmlInitParser:_xmlInitParser,/** @export */xmlInputReadCallbackNop:_xmlInputReadCallbackNop,/** @export */xmlIsBaseCharGroup:_xmlIsBaseCharGroup,/** @export */xmlIsCombiningGroup:_xmlIsCombiningGroup,/** @export */xmlIsDigitGroup:_xmlIsDigitGroup,/** @export */xmlIsExtenderGroup:_xmlIsExtenderGroup,/** @export */xmlIsPubidChar_tab:_xmlIsPubidChar_tab,/** @export */xmlKeepBlanksDefaultValue:_xmlKeepBlanksDefaultValue,/** @export */xmlLastError:_xmlLastError,/** @export */xmlLineNumbersDefaultValue:_xmlLineNumbersDefaultValue,/** @export */xmlLoadExtDtdDefaultValue:_xmlLoadExtDtdDefaultValue,/** @export */xmlMalloc:_xmlMalloc,/** @export */xmlMallocAtomic:_xmlMallocAtomic,/** @export */xmlMemStrdup:_xmlMemStrdup,/** @export */xmlNewIOInputStream:_xmlNewIOInputStream,/** @export */xmlNewInputFromFile:_xmlNewInputFromFile,/** @export */xmlOutputBufferCreateFilenameDefault:_xmlOutputBufferCreateFilenameDefault,/** @export */xmlOutputBufferCreateFilenameValue:_xmlOutputBufferCreateFilenameValue,/** @export */xmlParseCharEncoding:_xmlParseCharEncoding,/** @export */xmlParseURI:_xmlParseURI,/** @export */xmlParserDebugEntities:_xmlParserDebugEntities,/** @export */xmlParserError:_xmlParserError,/** @export */xmlParserInputBufferCreateFilenameDefault:_xmlParserInputBufferCreateFilenameDefault,/** @export */xmlParserInputBufferCreateFilenameValue:_xmlParserInputBufferCreateFilenameValue,/** @export */xmlParserMaxDepth:_xmlParserMaxDepth,/** @export */xmlParserValidityError:_xmlParserValidityError,/** @export */xmlParserValidityWarning:_xmlParserValidityWarning,/** @export */xmlParserVersion:_xmlParserVersion,/** @export */xmlParserWarning:_xmlParserWarning,/** @export */xmlPedanticParserDefaultValue:_xmlPedanticParserDefaultValue,/** @export */xmlRealloc:_xmlRealloc,/** @export */xmlReconciliateNs:_xmlReconciliateNs,/** @export */xmlRegisterNodeDefaultValue:_xmlRegisterNodeDefaultValue,/** @export */xmlRelaxNGCleanupTypes:_xmlRelaxNGCleanupTypes,/** @export */xmlRemoveID:_xmlRemoveID,/** @export */xmlResetError:_xmlResetError,/** @export */xmlResetLastError:_xmlResetLastError,/** @export */xmlSAX2AttributeDecl:_xmlSAX2AttributeDecl,/** @export */xmlSAX2CDataBlock:_xmlSAX2CDataBlock,/** @export */xmlSAX2Characters:_xmlSAX2Characters,/** @export */xmlSAX2Comment:_xmlSAX2Comment,/** @export */xmlSAX2ElementDecl:_xmlSAX2ElementDecl,/** @export */xmlSAX2EndDocument:_xmlSAX2EndDocument,/** @export */xmlSAX2EndElement:_xmlSAX2EndElement,/** @export */xmlSAX2EndElementNs:_xmlSAX2EndElementNs,/** @export */xmlSAX2EntityDecl:_xmlSAX2EntityDecl,/** @export */xmlSAX2ExternalSubset:_xmlSAX2ExternalSubset,/** @export */xmlSAX2GetColumnNumber:_xmlSAX2GetColumnNumber,/** @export */xmlSAX2GetEntity:_xmlSAX2GetEntity,/** @export */xmlSAX2GetLineNumber:_xmlSAX2GetLineNumber,/** @export */xmlSAX2GetParameterEntity:_xmlSAX2GetParameterEntity,/** @export */xmlSAX2GetPublicId:_xmlSAX2GetPublicId,/** @export */xmlSAX2GetSystemId:_xmlSAX2GetSystemId,/** @export */xmlSAX2HasExternalSubset:_xmlSAX2HasExternalSubset,/** @export */xmlSAX2HasInternalSubset:_xmlSAX2HasInternalSubset,/** @export */xmlSAX2IgnorableWhitespace:_xmlSAX2IgnorableWhitespace,/** @export */xmlSAX2InternalSubset:_xmlSAX2InternalSubset,/** @export */xmlSAX2IsStandalone:_xmlSAX2IsStandalone,/** @export */xmlSAX2NotationDecl:_xmlSAX2NotationDecl,/** @export */xmlSAX2ProcessingInstruction:_xmlSAX2ProcessingInstruction,/** @export */xmlSAX2Reference:_xmlSAX2Reference,/** @export */xmlSAX2ResolveEntity:_xmlSAX2ResolveEntity,/** @export */xmlSAX2SetDocumentLocator:_xmlSAX2SetDocumentLocator,/** @export */xmlSAX2StartDocument:_xmlSAX2StartDocument,/** @export */xmlSAX2StartElement:_xmlSAX2StartElement,/** @export */xmlSAX2StartElementNs:_xmlSAX2StartElementNs,/** @export */xmlSAX2UnparsedEntityDecl:_xmlSAX2UnparsedEntityDecl,/** @export */xmlSaveNoEmptyTags:_xmlSaveNoEmptyTags,/** @export */xmlSetExternalEntityLoader:_xmlSetExternalEntityLoader,/** @export */xmlSetGenericErrorFunc:_xmlSetGenericErrorFunc,/** @export */xmlSetStructuredErrorFunc:_xmlSetStructuredErrorFunc,/** @export */xmlStrdup:_xmlStrdup,/** @export */xmlStringComment:_xmlStringComment,/** @export */xmlStringText:_xmlStringText,/** @export */xmlStringTextNoenc:_xmlStringTextNoenc,/** @export */xmlStrncmp:_xmlStrncmp,/** @export */xmlStructuredError:_xmlStructuredError,/** @export */xmlStructuredErrorContext:_xmlStructuredErrorContext,/** @export */xmlSubstituteEntitiesDefaultValue:_xmlSubstituteEntitiesDefaultValue,/** @export */xmlTreeIndentString:_xmlTreeIndentString,/** @export */xmlUCSIsAegeanNumbers:_xmlUCSIsAegeanNumbers,/** @export */xmlUCSIsAlphabeticPresentationForms:_xmlUCSIsAlphabeticPresentationForms,/** @export */xmlUCSIsArabic:_xmlUCSIsArabic,/** @export */xmlUCSIsArabicPresentationFormsA:_xmlUCSIsArabicPresentationFormsA,/** @export */xmlUCSIsArabicPresentationFormsB:_xmlUCSIsArabicPresentationFormsB,/** @export */xmlUCSIsArmenian:_xmlUCSIsArmenian,/** @export */xmlUCSIsArrows:_xmlUCSIsArrows,/** @export */xmlUCSIsBasicLatin:_xmlUCSIsBasicLatin,/** @export */xmlUCSIsBengali:_xmlUCSIsBengali,/** @export */xmlUCSIsBlockElements:_xmlUCSIsBlockElements,/** @export */xmlUCSIsBopomofo:_xmlUCSIsBopomofo,/** @export */xmlUCSIsBopomofoExtended:_xmlUCSIsBopomofoExtended,/** @export */xmlUCSIsBoxDrawing:_xmlUCSIsBoxDrawing,/** @export */xmlUCSIsBraillePatterns:_xmlUCSIsBraillePatterns,/** @export */xmlUCSIsBuhid:_xmlUCSIsBuhid,/** @export */xmlUCSIsByzantineMusicalSymbols:_xmlUCSIsByzantineMusicalSymbols,/** @export */xmlUCSIsCJKCompatibility:_xmlUCSIsCJKCompatibility,/** @export */xmlUCSIsCJKCompatibilityForms:_xmlUCSIsCJKCompatibilityForms,/** @export */xmlUCSIsCJKCompatibilityIdeographs:_xmlUCSIsCJKCompatibilityIdeographs,/** @export */xmlUCSIsCJKCompatibilityIdeographsSupplement:_xmlUCSIsCJKCompatibilityIdeographsSupplement,/** @export */xmlUCSIsCJKRadicalsSupplement:_xmlUCSIsCJKRadicalsSupplement,/** @export */xmlUCSIsCJKSymbolsandPunctuation:_xmlUCSIsCJKSymbolsandPunctuation,/** @export */xmlUCSIsCJKUnifiedIdeographs:_xmlUCSIsCJKUnifiedIdeographs,/** @export */xmlUCSIsCJKUnifiedIdeographsExtensionA:_xmlUCSIsCJKUnifiedIdeographsExtensionA,/** @export */xmlUCSIsCJKUnifiedIdeographsExtensionB:_xmlUCSIsCJKUnifiedIdeographsExtensionB,/** @export */xmlUCSIsCatC:_xmlUCSIsCatC,/** @export */xmlUCSIsCatCc:_xmlUCSIsCatCc,/** @export */xmlUCSIsCatCf:_xmlUCSIsCatCf,/** @export */xmlUCSIsCatCo:_xmlUCSIsCatCo,/** @export */xmlUCSIsCatCs:_xmlUCSIsCatCs,/** @export */xmlUCSIsCatL:_xmlUCSIsCatL,/** @export */xmlUCSIsCatLl:_xmlUCSIsCatLl,/** @export */xmlUCSIsCatLm:_xmlUCSIsCatLm,/** @export */xmlUCSIsCatLo:_xmlUCSIsCatLo,/** @export */xmlUCSIsCatLt:_xmlUCSIsCatLt,/** @export */xmlUCSIsCatLu:_xmlUCSIsCatLu,/** @export */xmlUCSIsCatM:_xmlUCSIsCatM,/** @export */xmlUCSIsCatMc:_xmlUCSIsCatMc,/** @export */xmlUCSIsCatMe:_xmlUCSIsCatMe,/** @export */xmlUCSIsCatMn:_xmlUCSIsCatMn,/** @export */xmlUCSIsCatN:_xmlUCSIsCatN,/** @export */xmlUCSIsCatNd:_xmlUCSIsCatNd,/** @export */xmlUCSIsCatNl:_xmlUCSIsCatNl,/** @export */xmlUCSIsCatNo:_xmlUCSIsCatNo,/** @export */xmlUCSIsCatP:_xmlUCSIsCatP,/** @export */xmlUCSIsCatPc:_xmlUCSIsCatPc,/** @export */xmlUCSIsCatPd:_xmlUCSIsCatPd,/** @export */xmlUCSIsCatPe:_xmlUCSIsCatPe,/** @export */xmlUCSIsCatPf:_xmlUCSIsCatPf,/** @export */xmlUCSIsCatPi:_xmlUCSIsCatPi,/** @export */xmlUCSIsCatPo:_xmlUCSIsCatPo,/** @export */xmlUCSIsCatPs:_xmlUCSIsCatPs,/** @export */xmlUCSIsCatS:_xmlUCSIsCatS,/** @export */xmlUCSIsCatSc:_xmlUCSIsCatSc,/** @export */xmlUCSIsCatSk:_xmlUCSIsCatSk,/** @export */xmlUCSIsCatSm:_xmlUCSIsCatSm,/** @export */xmlUCSIsCatSo:_xmlUCSIsCatSo,/** @export */xmlUCSIsCatZ:_xmlUCSIsCatZ,/** @export */xmlUCSIsCatZl:_xmlUCSIsCatZl,/** @export */xmlUCSIsCatZp:_xmlUCSIsCatZp,/** @export */xmlUCSIsCatZs:_xmlUCSIsCatZs,/** @export */xmlUCSIsCherokee:_xmlUCSIsCherokee,/** @export */xmlUCSIsCombiningDiacriticalMarks:_xmlUCSIsCombiningDiacriticalMarks,/** @export */xmlUCSIsCombiningDiacriticalMarksforSymbols:_xmlUCSIsCombiningDiacriticalMarksforSymbols,/** @export */xmlUCSIsCombiningHalfMarks:_xmlUCSIsCombiningHalfMarks,/** @export */xmlUCSIsCombiningMarksforSymbols:_xmlUCSIsCombiningMarksforSymbols,/** @export */xmlUCSIsControlPictures:_xmlUCSIsControlPictures,/** @export */xmlUCSIsCurrencySymbols:_xmlUCSIsCurrencySymbols,/** @export */xmlUCSIsCypriotSyllabary:_xmlUCSIsCypriotSyllabary,/** @export */xmlUCSIsCyrillic:_xmlUCSIsCyrillic,/** @export */xmlUCSIsCyrillicSupplement:_xmlUCSIsCyrillicSupplement,/** @export */xmlUCSIsDeseret:_xmlUCSIsDeseret,/** @export */xmlUCSIsDevanagari:_xmlUCSIsDevanagari,/** @export */xmlUCSIsDingbats:_xmlUCSIsDingbats,/** @export */xmlUCSIsEnclosedAlphanumerics:_xmlUCSIsEnclosedAlphanumerics,/** @export */xmlUCSIsEnclosedCJKLettersandMonths:_xmlUCSIsEnclosedCJKLettersandMonths,/** @export */xmlUCSIsEthiopic:_xmlUCSIsEthiopic,/** @export */xmlUCSIsGeneralPunctuation:_xmlUCSIsGeneralPunctuation,/** @export */xmlUCSIsGeometricShapes:_xmlUCSIsGeometricShapes,/** @export */xmlUCSIsGeorgian:_xmlUCSIsGeorgian,/** @export */xmlUCSIsGothic:_xmlUCSIsGothic,/** @export */xmlUCSIsGreek:_xmlUCSIsGreek,/** @export */xmlUCSIsGreekExtended:_xmlUCSIsGreekExtended,/** @export */xmlUCSIsGreekandCoptic:_xmlUCSIsGreekandCoptic,/** @export */xmlUCSIsGujarati:_xmlUCSIsGujarati,/** @export */xmlUCSIsGurmukhi:_xmlUCSIsGurmukhi,/** @export */xmlUCSIsHalfwidthandFullwidthForms:_xmlUCSIsHalfwidthandFullwidthForms,/** @export */xmlUCSIsHangulCompatibilityJamo:_xmlUCSIsHangulCompatibilityJamo,/** @export */xmlUCSIsHangulJamo:_xmlUCSIsHangulJamo,/** @export */xmlUCSIsHangulSyllables:_xmlUCSIsHangulSyllables,/** @export */xmlUCSIsHanunoo:_xmlUCSIsHanunoo,/** @export */xmlUCSIsHebrew:_xmlUCSIsHebrew,/** @export */xmlUCSIsHighPrivateUseSurrogates:_xmlUCSIsHighPrivateUseSurrogates,/** @export */xmlUCSIsHighSurrogates:_xmlUCSIsHighSurrogates,/** @export */xmlUCSIsHiragana:_xmlUCSIsHiragana,/** @export */xmlUCSIsIPAExtensions:_xmlUCSIsIPAExtensions,/** @export */xmlUCSIsIdeographicDescriptionCharacters:_xmlUCSIsIdeographicDescriptionCharacters,/** @export */xmlUCSIsKanbun:_xmlUCSIsKanbun,/** @export */xmlUCSIsKangxiRadicals:_xmlUCSIsKangxiRadicals,/** @export */xmlUCSIsKannada:_xmlUCSIsKannada,/** @export */xmlUCSIsKatakana:_xmlUCSIsKatakana,/** @export */xmlUCSIsKatakanaPhoneticExtensions:_xmlUCSIsKatakanaPhoneticExtensions,/** @export */xmlUCSIsKhmer:_xmlUCSIsKhmer,/** @export */xmlUCSIsKhmerSymbols:_xmlUCSIsKhmerSymbols,/** @export */xmlUCSIsLao:_xmlUCSIsLao,/** @export */xmlUCSIsLatin1Supplement:_xmlUCSIsLatin1Supplement,/** @export */xmlUCSIsLatinExtendedA:_xmlUCSIsLatinExtendedA,/** @export */xmlUCSIsLatinExtendedAdditional:_xmlUCSIsLatinExtendedAdditional,/** @export */xmlUCSIsLatinExtendedB:_xmlUCSIsLatinExtendedB,/** @export */xmlUCSIsLetterlikeSymbols:_xmlUCSIsLetterlikeSymbols,/** @export */xmlUCSIsLimbu:_xmlUCSIsLimbu,/** @export */xmlUCSIsLinearBIdeograms:_xmlUCSIsLinearBIdeograms,/** @export */xmlUCSIsLinearBSyllabary:_xmlUCSIsLinearBSyllabary,/** @export */xmlUCSIsLowSurrogates:_xmlUCSIsLowSurrogates,/** @export */xmlUCSIsMalayalam:_xmlUCSIsMalayalam,/** @export */xmlUCSIsMathematicalAlphanumericSymbols:_xmlUCSIsMathematicalAlphanumericSymbols,/** @export */xmlUCSIsMathematicalOperators:_xmlUCSIsMathematicalOperators,/** @export */xmlUCSIsMiscellaneousMathematicalSymbolsA:_xmlUCSIsMiscellaneousMathematicalSymbolsA,/** @export */xmlUCSIsMiscellaneousMathematicalSymbolsB:_xmlUCSIsMiscellaneousMathematicalSymbolsB,/** @export */xmlUCSIsMiscellaneousSymbols:_xmlUCSIsMiscellaneousSymbols,/** @export */xmlUCSIsMiscellaneousSymbolsandArrows:_xmlUCSIsMiscellaneousSymbolsandArrows,/** @export */xmlUCSIsMiscellaneousTechnical:_xmlUCSIsMiscellaneousTechnical,/** @export */xmlUCSIsMongolian:_xmlUCSIsMongolian,/** @export */xmlUCSIsMusicalSymbols:_xmlUCSIsMusicalSymbols,/** @export */xmlUCSIsMyanmar:_xmlUCSIsMyanmar,/** @export */xmlUCSIsNumberForms:_xmlUCSIsNumberForms,/** @export */xmlUCSIsOgham:_xmlUCSIsOgham,/** @export */xmlUCSIsOldItalic:_xmlUCSIsOldItalic,/** @export */xmlUCSIsOpticalCharacterRecognition:_xmlUCSIsOpticalCharacterRecognition,/** @export */xmlUCSIsOriya:_xmlUCSIsOriya,/** @export */xmlUCSIsOsmanya:_xmlUCSIsOsmanya,/** @export */xmlUCSIsPhoneticExtensions:_xmlUCSIsPhoneticExtensions,/** @export */xmlUCSIsPrivateUse:_xmlUCSIsPrivateUse,/** @export */xmlUCSIsPrivateUseArea:_xmlUCSIsPrivateUseArea,/** @export */xmlUCSIsRunic:_xmlUCSIsRunic,/** @export */xmlUCSIsShavian:_xmlUCSIsShavian,/** @export */xmlUCSIsSinhala:_xmlUCSIsSinhala,/** @export */xmlUCSIsSmallFormVariants:_xmlUCSIsSmallFormVariants,/** @export */xmlUCSIsSpacingModifierLetters:_xmlUCSIsSpacingModifierLetters,/** @export */xmlUCSIsSpecials:_xmlUCSIsSpecials,/** @export */xmlUCSIsSuperscriptsandSubscripts:_xmlUCSIsSuperscriptsandSubscripts,/** @export */xmlUCSIsSupplementalArrowsA:_xmlUCSIsSupplementalArrowsA,/** @export */xmlUCSIsSupplementalArrowsB:_xmlUCSIsSupplementalArrowsB,/** @export */xmlUCSIsSupplementalMathematicalOperators:_xmlUCSIsSupplementalMathematicalOperators,/** @export */xmlUCSIsSupplementaryPrivateUseAreaA:_xmlUCSIsSupplementaryPrivateUseAreaA,/** @export */xmlUCSIsSupplementaryPrivateUseAreaB:_xmlUCSIsSupplementaryPrivateUseAreaB,/** @export */xmlUCSIsSyriac:_xmlUCSIsSyriac,/** @export */xmlUCSIsTagalog:_xmlUCSIsTagalog,/** @export */xmlUCSIsTagbanwa:_xmlUCSIsTagbanwa,/** @export */xmlUCSIsTags:_xmlUCSIsTags,/** @export */xmlUCSIsTaiLe:_xmlUCSIsTaiLe,/** @export */xmlUCSIsTaiXuanJingSymbols:_xmlUCSIsTaiXuanJingSymbols,/** @export */xmlUCSIsTamil:_xmlUCSIsTamil,/** @export */xmlUCSIsTelugu:_xmlUCSIsTelugu,/** @export */xmlUCSIsThaana:_xmlUCSIsThaana,/** @export */xmlUCSIsThai:_xmlUCSIsThai,/** @export */xmlUCSIsTibetan:_xmlUCSIsTibetan,/** @export */xmlUCSIsUgaritic:_xmlUCSIsUgaritic,/** @export */xmlUCSIsUnifiedCanadianAboriginalSyllabics:_xmlUCSIsUnifiedCanadianAboriginalSyllabics,/** @export */xmlUCSIsVariationSelectors:_xmlUCSIsVariationSelectors,/** @export */xmlUCSIsVariationSelectorsSupplement:_xmlUCSIsVariationSelectorsSupplement,/** @export */xmlUCSIsYiRadicals:_xmlUCSIsYiRadicals,/** @export */xmlUCSIsYiSyllables:_xmlUCSIsYiSyllables,/** @export */xmlUCSIsYijingHexagramSymbols:_xmlUCSIsYijingHexagramSymbols,/** @export */xmlURIUnescapeString:_xmlURIUnescapeString,/** @export */xmlUnlinkNode:_xmlUnlinkNode,/** @export */xmlXPathBooleanFunction:_xmlXPathBooleanFunction,/** @export */xmlXPathCeilingFunction:_xmlXPathCeilingFunction,/** @export */xmlXPathConcatFunction:_xmlXPathConcatFunction,/** @export */xmlXPathContainsFunction:_xmlXPathContainsFunction,/** @export */xmlXPathCountFunction:_xmlXPathCountFunction,/** @export */xmlXPathFalseFunction:_xmlXPathFalseFunction,/** @export */xmlXPathFloorFunction:_xmlXPathFloorFunction,/** @export */xmlXPathIdFunction:_xmlXPathIdFunction,/** @export */xmlXPathLangFunction:_xmlXPathLangFunction,/** @export */xmlXPathLastFunction:_xmlXPathLastFunction,/** @export */xmlXPathLocalNameFunction:_xmlXPathLocalNameFunction,/** @export */xmlXPathNAN:_xmlXPathNAN,/** @export */xmlXPathNINF:_xmlXPathNINF,/** @export */xmlXPathNamespaceURIFunction:_xmlXPathNamespaceURIFunction,/** @export */xmlXPathNextAncestor:_xmlXPathNextAncestor,/** @export */xmlXPathNextAncestorOrSelf:_xmlXPathNextAncestorOrSelf,/** @export */xmlXPathNextAttribute:_xmlXPathNextAttribute,/** @export */xmlXPathNextChild:_xmlXPathNextChild,/** @export */xmlXPathNextDescendant:_xmlXPathNextDescendant,/** @export */xmlXPathNextDescendantOrSelf:_xmlXPathNextDescendantOrSelf,/** @export */xmlXPathNextFollowing:_xmlXPathNextFollowing,/** @export */xmlXPathNextFollowingSibling:_xmlXPathNextFollowingSibling,/** @export */xmlXPathNextNamespace:_xmlXPathNextNamespace,/** @export */xmlXPathNextParent:_xmlXPathNextParent,/** @export */xmlXPathNextPrecedingSibling:_xmlXPathNextPrecedingSibling,/** @export */xmlXPathNextSelf:_xmlXPathNextSelf,/** @export */xmlXPathNormalizeFunction:_xmlXPathNormalizeFunction,/** @export */xmlXPathNotFunction:_xmlXPathNotFunction,/** @export */xmlXPathNumberFunction:_xmlXPathNumberFunction,/** @export */xmlXPathPINF:_xmlXPathPINF,/** @export */xmlXPathPositionFunction:_xmlXPathPositionFunction,/** @export */xmlXPathRoundFunction:_xmlXPathRoundFunction,/** @export */xmlXPathStartsWithFunction:_xmlXPathStartsWithFunction,/** @export */xmlXPathStringFunction:_xmlXPathStringFunction,/** @export */xmlXPathStringLengthFunction:_xmlXPathStringLengthFunction,/** @export */xmlXPathSubstringAfterFunction:_xmlXPathSubstringAfterFunction,/** @export */xmlXPathSubstringBeforeFunction:_xmlXPathSubstringBeforeFunction,/** @export */xmlXPathSubstringFunction:_xmlXPathSubstringFunction,/** @export */xmlXPathSumFunction:_xmlXPathSumFunction,/** @export */xmlXPathTranslateFunction:_xmlXPathTranslateFunction,/** @export */xmlXPathTrueFunction:_xmlXPathTrueFunction,/** @export */zoomSurface:_zoomSurface};var wasmExports=createWasm();var ___wasm_call_ctors=()=>(___wasm_call_ctors=wasmExports["__wasm_call_ctors"])();var ___wasm_apply_data_relocs=()=>(___wasm_apply_data_relocs=wasmExports["__wasm_apply_data_relocs"])();var _time=a0=>(_time=wasmExports["time"])(a0);var _strlen=a0=>(_strlen=wasmExports["strlen"])(a0);var _memcmp=(a0,a1,a2)=>(_memcmp=wasmExports["memcmp"])(a0,a1,a2);var _strcmp=(a0,a1)=>(_strcmp=wasmExports["strcmp"])(a0,a1);var _free=a0=>(_free=wasmExports["free"])(a0);var _strchr=(a0,a1)=>(_strchr=wasmExports["strchr"])(a0,a1);var ___errno_location=()=>(___errno_location=wasmExports["__errno_location"])();var _snprintf=(a0,a1,a2,a3)=>(_snprintf=wasmExports["snprintf"])(a0,a1,a2,a3);var _toupper=a0=>(_toupper=wasmExports["toupper"])(a0);var _malloc=a0=>(_malloc=wasmExports["malloc"])(a0);var _memchr=(a0,a1,a2)=>(_memchr=wasmExports["memchr"])(a0,a1,a2);var _strcpy=(a0,a1)=>(_strcpy=wasmExports["strcpy"])(a0,a1);var _stat=(a0,a1)=>(_stat=wasmExports["stat"])(a0,a1);var _strncmp=(a0,a1,a2)=>(_strncmp=wasmExports["strncmp"])(a0,a1,a2);var _strncpy=(a0,a1,a2)=>(_strncpy=wasmExports["strncpy"])(a0,a1,a2);var _main=Module["_main"]=(a0,a1)=>(_main=Module["_main"]=wasmExports["main"])(a0,a1);var _pib_storage_init=Module["_pib_storage_init"]=()=>(_pib_storage_init=Module["_pib_storage_init"]=wasmExports["pib_storage_init"])();var _pib_init=Module["_pib_init"]=()=>(_pib_init=Module["_pib_init"]=wasmExports["pib_init"])();var _pib_destroy=Module["_pib_destroy"]=()=>(_pib_destroy=Module["_pib_destroy"]=wasmExports["pib_destroy"])();var _pib_refresh=Module["_pib_refresh"]=()=>(_pib_refresh=Module["_pib_refresh"]=wasmExports["pib_refresh"])();var _pib_flush=Module["_pib_flush"]=()=>(_pib_flush=Module["_pib_flush"]=wasmExports["pib_flush"])();var _pib_exec=Module["_pib_exec"]=a0=>(_pib_exec=Module["_pib_exec"]=wasmExports["pib_exec"])(a0);var _pib_run=Module["_pib_run"]=a0=>(_pib_run=Module["_pib_run"]=wasmExports["pib_run"])(a0);var _pib_php_version=Module["_pib_php_version"]=()=>(_pib_php_version=Module["_pib_php_version"]=wasmExports["pib_php_version"])();var _pib_php_ext_api_version=Module["_pib_php_ext_api_version"]=()=>(_pib_php_ext_api_version=Module["_pib_php_ext_api_version"]=wasmExports["pib_php_ext_api_version"])();var _pib_tokenize=Module["_pib_tokenize"]=a0=>(_pib_tokenize=Module["_pib_tokenize"]=wasmExports["pib_tokenize"])(a0);var _close=a0=>(_close=wasmExports["close"])(a0);var _open=(a0,a1,a2)=>(_open=wasmExports["open"])(a0,a1,a2);var _strerror=a0=>(_strerror=wasmExports["strerror"])(a0);var _read=(a0,a1,a2)=>(_read=wasmExports["read"])(a0,a1,a2);var _write=(a0,a1,a2)=>(_write=wasmExports["write"])(a0,a1,a2);var _realloc=(a0,a1)=>(_realloc=wasmExports["realloc"])(a0,a1);var _strcat=(a0,a1)=>(_strcat=wasmExports["strcat"])(a0,a1);var _htonl=a0=>(_htonl=wasmExports["htonl"])(a0);var _getenv=a0=>(_getenv=wasmExports["getenv"])(a0);var _ntohs=a0=>(_ntohs=wasmExports["ntohs"])(a0);var _htons=a0=>(_htons=wasmExports["htons"])(a0);var _fopen=(a0,a1)=>(_fopen=wasmExports["fopen"])(a0,a1);var _getcwd=(a0,a1)=>(_getcwd=wasmExports["getcwd"])(a0,a1);var _dlopen=(a0,a1)=>(_dlopen=wasmExports["dlopen"])(a0,a1);var _dlerror=()=>(_dlerror=wasmExports["dlerror"])();var _dlsym=(a0,a1)=>(_dlsym=wasmExports["dlsym"])(a0,a1);var _dlclose=a0=>(_dlclose=wasmExports["dlclose"])(a0);var _fclose=a0=>(_fclose=wasmExports["fclose"])(a0);var _sscanf=(a0,a1,a2)=>(_sscanf=wasmExports["sscanf"])(a0,a1,a2);var _fileno=a0=>(_fileno=wasmExports["fileno"])(a0);var _fprintf=(a0,a1,a2)=>(_fprintf=wasmExports["fprintf"])(a0,a1,a2);var _vrzno_expose_inc_refcount=Module["_vrzno_expose_inc_refcount"]=a0=>(_vrzno_expose_inc_refcount=Module["_vrzno_expose_inc_refcount"]=wasmExports["vrzno_expose_inc_refcount"])(a0);var _vrzno_expose_dec_refcount=Module["_vrzno_expose_dec_refcount"]=a0=>(_vrzno_expose_dec_refcount=Module["_vrzno_expose_dec_refcount"]=wasmExports["vrzno_expose_dec_refcount"])(a0);var _vrzno_expose_refcount=Module["_vrzno_expose_refcount"]=a0=>(_vrzno_expose_refcount=Module["_vrzno_expose_refcount"]=wasmExports["vrzno_expose_refcount"])(a0);var _vrzno_expose_efree=Module["_vrzno_expose_efree"]=(a0,a1)=>(_vrzno_expose_efree=Module["_vrzno_expose_efree"]=wasmExports["vrzno_expose_efree"])(a0,a1);var _vrzno_expose_create_bool=Module["_vrzno_expose_create_bool"]=a0=>(_vrzno_expose_create_bool=Module["_vrzno_expose_create_bool"]=wasmExports["vrzno_expose_create_bool"])(a0);var _vrzno_expose_create_null=Module["_vrzno_expose_create_null"]=()=>(_vrzno_expose_create_null=Module["_vrzno_expose_create_null"]=wasmExports["vrzno_expose_create_null"])();var _vrzno_expose_create_undef=Module["_vrzno_expose_create_undef"]=()=>(_vrzno_expose_create_undef=Module["_vrzno_expose_create_undef"]=wasmExports["vrzno_expose_create_undef"])();var _vrzno_expose_create_long=Module["_vrzno_expose_create_long"]=a0=>(_vrzno_expose_create_long=Module["_vrzno_expose_create_long"]=wasmExports["vrzno_expose_create_long"])(a0);var _vrzno_expose_create_double=Module["_vrzno_expose_create_double"]=a0=>(_vrzno_expose_create_double=Module["_vrzno_expose_create_double"]=wasmExports["vrzno_expose_create_double"])(a0);var _vrzno_expose_create_string=Module["_vrzno_expose_create_string"]=a0=>(_vrzno_expose_create_string=Module["_vrzno_expose_create_string"]=wasmExports["vrzno_expose_create_string"])(a0);var _vrzno_expose_create_object_for_target=Module["_vrzno_expose_create_object_for_target"]=(a0,a1)=>(_vrzno_expose_create_object_for_target=Module["_vrzno_expose_create_object_for_target"]=wasmExports["vrzno_expose_create_object_for_target"])(a0,a1);var _vrzno_expose_create_params=Module["_vrzno_expose_create_params"]=a0=>(_vrzno_expose_create_params=Module["_vrzno_expose_create_params"]=wasmExports["vrzno_expose_create_params"])(a0);var _vrzno_expose_set_param=Module["_vrzno_expose_set_param"]=(a0,a1,a2)=>(_vrzno_expose_set_param=Module["_vrzno_expose_set_param"]=wasmExports["vrzno_expose_set_param"])(a0,a1,a2);var _vrzno_expose_zval_is_target=Module["_vrzno_expose_zval_is_target"]=a0=>(_vrzno_expose_zval_is_target=Module["_vrzno_expose_zval_is_target"]=wasmExports["vrzno_expose_zval_is_target"])(a0);var _vrzno_expose_object_keys=Module["_vrzno_expose_object_keys"]=a0=>(_vrzno_expose_object_keys=Module["_vrzno_expose_object_keys"]=wasmExports["vrzno_expose_object_keys"])(a0);var _vrzno_expose_zval_deref=Module["_vrzno_expose_zval_deref"]=a0=>(_vrzno_expose_zval_deref=Module["_vrzno_expose_zval_deref"]=wasmExports["vrzno_expose_zval_deref"])(a0);var _vrzno_expose_zval_dump=Module["_vrzno_expose_zval_dump"]=a0=>(_vrzno_expose_zval_dump=Module["_vrzno_expose_zval_dump"]=wasmExports["vrzno_expose_zval_dump"])(a0);var _vrzno_expose_type=Module["_vrzno_expose_type"]=a0=>(_vrzno_expose_type=Module["_vrzno_expose_type"]=wasmExports["vrzno_expose_type"])(a0);var _vrzno_expose_callable=Module["_vrzno_expose_callable"]=a0=>(_vrzno_expose_callable=Module["_vrzno_expose_callable"]=wasmExports["vrzno_expose_callable"])(a0);var _vrzno_expose_long=Module["_vrzno_expose_long"]=a0=>(_vrzno_expose_long=Module["_vrzno_expose_long"]=wasmExports["vrzno_expose_long"])(a0);var _vrzno_expose_double=Module["_vrzno_expose_double"]=a0=>(_vrzno_expose_double=Module["_vrzno_expose_double"]=wasmExports["vrzno_expose_double"])(a0);var _vrzno_expose_string=Module["_vrzno_expose_string"]=a0=>(_vrzno_expose_string=Module["_vrzno_expose_string"]=wasmExports["vrzno_expose_string"])(a0);var _vrzno_expose_property_type=Module["_vrzno_expose_property_type"]=(a0,a1)=>(_vrzno_expose_property_type=Module["_vrzno_expose_property_type"]=wasmExports["vrzno_expose_property_type"])(a0,a1);var _vrzno_expose_property_callable=Module["_vrzno_expose_property_callable"]=(a0,a1)=>(_vrzno_expose_property_callable=Module["_vrzno_expose_property_callable"]=wasmExports["vrzno_expose_property_callable"])(a0,a1);var _vrzno_expose_property_long=Module["_vrzno_expose_property_long"]=(a0,a1)=>(_vrzno_expose_property_long=Module["_vrzno_expose_property_long"]=wasmExports["vrzno_expose_property_long"])(a0,a1);var _vrzno_expose_property_double=Module["_vrzno_expose_property_double"]=(a0,a1)=>(_vrzno_expose_property_double=Module["_vrzno_expose_property_double"]=wasmExports["vrzno_expose_property_double"])(a0,a1);var _vrzno_expose_property_string=Module["_vrzno_expose_property_string"]=(a0,a1)=>(_vrzno_expose_property_string=Module["_vrzno_expose_property_string"]=wasmExports["vrzno_expose_property_string"])(a0,a1);var _vrzno_expose_property_pointer=Module["_vrzno_expose_property_pointer"]=(a0,a1)=>(_vrzno_expose_property_pointer=Module["_vrzno_expose_property_pointer"]=wasmExports["vrzno_expose_property_pointer"])(a0,a1);var _vrzno_expose_dimension_type=Module["_vrzno_expose_dimension_type"]=(a0,a1)=>(_vrzno_expose_dimension_type=Module["_vrzno_expose_dimension_type"]=wasmExports["vrzno_expose_dimension_type"])(a0,a1);var _vrzno_expose_dimension_pointer=Module["_vrzno_expose_dimension_pointer"]=(a0,a1)=>(_vrzno_expose_dimension_pointer=Module["_vrzno_expose_dimension_pointer"]=wasmExports["vrzno_expose_dimension_pointer"])(a0,a1);var _vrzno_exec_callback=Module["_vrzno_exec_callback"]=(a0,a1,a2)=>(_vrzno_exec_callback=Module["_vrzno_exec_callback"]=wasmExports["vrzno_exec_callback"])(a0,a1,a2);var _vrzno_del_callback=Module["_vrzno_del_callback"]=a0=>(_vrzno_del_callback=Module["_vrzno_del_callback"]=wasmExports["vrzno_del_callback"])(a0);var _fwrite=(a0,a1,a2,a3)=>(_fwrite=wasmExports["fwrite"])(a0,a1,a2,a3);var _fflush=a0=>(_fflush=wasmExports["fflush"])(a0);var _fread=(a0,a1,a2,a3)=>(_fread=wasmExports["fread"])(a0,a1,a2,a3);var _vfprintf=(a0,a1,a2)=>(_vfprintf=wasmExports["vfprintf"])(a0,a1,a2);var _calloc=(a0,a1)=>(_calloc=wasmExports["calloc"])(a0,a1);var _main=Module["_main"]=(a0,a1)=>(_main=Module["_main"]=wasmExports["__main_argc_argv"])(a0,a1);var _wasm_sapi_cgi_init=Module["_wasm_sapi_cgi_init"]=()=>(_wasm_sapi_cgi_init=Module["_wasm_sapi_cgi_init"]=wasmExports["wasm_sapi_cgi_init"])();var _wasm_sapi_cgi_getenv=Module["_wasm_sapi_cgi_getenv"]=a0=>(_wasm_sapi_cgi_getenv=Module["_wasm_sapi_cgi_getenv"]=wasmExports["wasm_sapi_cgi_getenv"])(a0);var _wasm_sapi_cgi_putenv=Module["_wasm_sapi_cgi_putenv"]=(a0,a1)=>(_wasm_sapi_cgi_putenv=Module["_wasm_sapi_cgi_putenv"]=wasmExports["wasm_sapi_cgi_putenv"])(a0,a1);var _memset=(a0,a1,a2)=>(_memset=wasmExports["memset"])(a0,a1,a2);var ___funcs_on_exit=()=>(___funcs_on_exit=wasmExports["__funcs_on_exit"])();var _vsnprintf=(a0,a1,a2,a3)=>(_vsnprintf=wasmExports["vsnprintf"])(a0,a1,a2,a3);var ___dl_seterr=(a0,a1)=>(___dl_seterr=wasmExports["__dl_seterr"])(a0,a1);var _memcpy=(a0,a1,a2)=>(_memcpy=wasmExports["memcpy"])(a0,a1,a2);var _memmove=(a0,a1,a2)=>(_memmove=wasmExports["memmove"])(a0,a1,a2);var _ferror=a0=>(_ferror=wasmExports["ferror"])(a0);var _fmod=(a0,a1)=>(_fmod=wasmExports["fmod"])(a0,a1);var _fiprintf=(a0,a1,a2)=>(_fiprintf=wasmExports["fiprintf"])(a0,a1,a2);var ___small_fprintf=(a0,a1,a2)=>(___small_fprintf=wasmExports["__small_fprintf"])(a0,a1,a2);var _fputc=(a0,a1)=>(_fputc=wasmExports["fputc"])(a0,a1);var _fputs=(a0,a1)=>(_fputs=wasmExports["fputs"])(a0,a1);var _iconv_open=(a0,a1)=>(_iconv_open=wasmExports["iconv_open"])(a0,a1);var _iconv=(a0,a1,a2,a3,a4)=>(_iconv=wasmExports["iconv"])(a0,a1,a2,a3,a4);var _iconv_close=a0=>(_iconv_close=wasmExports["iconv_close"])(a0);var _log10=a0=>(_log10=wasmExports["log10"])(a0);var _emscripten_builtin_memalign=(a0,a1)=>(_emscripten_builtin_memalign=wasmExports["emscripten_builtin_memalign"])(a0,a1);var _pow=(a0,a1)=>(_pow=wasmExports["pow"])(a0,a1);var _puts=a0=>(_puts=wasmExports["puts"])(a0);var _rand_r=a0=>(_rand_r=wasmExports["rand_r"])(a0);var __emscripten_timeout=(a0,a1)=>(__emscripten_timeout=wasmExports["_emscripten_timeout"])(a0,a1);var _setThrew=(a0,a1)=>(_setThrew=wasmExports["setThrew"])(a0,a1);var __emscripten_tempret_set=a0=>(__emscripten_tempret_set=wasmExports["_emscripten_tempret_set"])(a0);var __emscripten_tempret_get=()=>(__emscripten_tempret_get=wasmExports["_emscripten_tempret_get"])();var ___get_temp_ret=()=>(___get_temp_ret=wasmExports["__get_temp_ret"])();var ___set_temp_ret=a0=>(___set_temp_ret=wasmExports["__set_temp_ret"])(a0);var _getTempRet0=()=>(_getTempRet0=wasmExports["getTempRet0"])();var _emscripten_stack_set_limits=(a0,a1)=>(_emscripten_stack_set_limits=wasmExports["emscripten_stack_set_limits"])(a0,a1);var __emscripten_stack_restore=a0=>(__emscripten_stack_restore=wasmExports["_emscripten_stack_restore"])(a0);var __emscripten_stack_alloc=a0=>(__emscripten_stack_alloc=wasmExports["_emscripten_stack_alloc"])(a0);var _emscripten_stack_get_current=()=>(_emscripten_stack_get_current=wasmExports["emscripten_stack_get_current"])();var ___cxa_demangle=(a0,a1,a2,a3)=>(___cxa_demangle=wasmExports["__cxa_demangle"])(a0,a1,a2,a3);var ___cxa_increment_exception_refcount=a0=>(___cxa_increment_exception_refcount=wasmExports["__cxa_increment_exception_refcount"])(a0);var ___cxa_decrement_exception_refcount=a0=>(___cxa_decrement_exception_refcount=wasmExports["__cxa_decrement_exception_refcount"])(a0);var ___cxa_can_catch=(a0,a1,a2)=>(___cxa_can_catch=wasmExports["__cxa_can_catch"])(a0,a1,a2);var ___cxa_get_exception_ptr=a0=>(___cxa_get_exception_ptr=wasmExports["__cxa_get_exception_ptr"])(a0);var _asyncify_start_unwind=a0=>(_asyncify_start_unwind=wasmExports["asyncify_start_unwind"])(a0);var _asyncify_stop_unwind=()=>(_asyncify_stop_unwind=wasmExports["asyncify_stop_unwind"])();var _asyncify_start_rewind=a0=>(_asyncify_start_rewind=wasmExports["asyncify_start_rewind"])(a0);var _asyncify_stop_rewind=()=>(_asyncify_stop_rewind=wasmExports["asyncify_stop_rewind"])();var _stdin=Module["_stdin"]=1321488;var _stdout=Module["_stdout"]=1321640;var _stderr=Module["_stderr"]=1321336;function invoke_iiii(index,a1,a2,a3){var sp=stackSave();try{return Module["dynCall_iiii"](index,a1,a2,a3);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vi(index,a1){var sp=stackSave();try{Module["dynCall_vi"](index,a1);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_v(index){var sp=stackSave();try{Module["dynCall_v"](index);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_i(index){var sp=stackSave();try{return Module["dynCall_i"](index);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iii(index,a1,a2){var sp=stackSave();try{return Module["dynCall_iii"](index,a1,a2);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viii(index,a1,a2,a3){var sp=stackSave();try{Module["dynCall_viii"](index,a1,a2,a3);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_vii(index,a1,a2){var sp=stackSave();try{Module["dynCall_vii"](index,a1,a2);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiii(index,a1,a2,a3,a4){var sp=stackSave();try{Module["dynCall_viiii"](index,a1,a2,a3,a4);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_ii(index,a1){var sp=stackSave();try{return Module["dynCall_ii"](index,a1);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return Module["dynCall_iiiii"](index,a1,a2,a3,a4);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{Module["dynCall_viiiiii"](index,a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return Module["dynCall_iiiiii"](index,a1,a2,a3,a4,a5);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{return Module["dynCall_iiiiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7,a8,a9);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return Module["dynCall_iiiiiiii"](index,a1,a2,a3,a4,a5,a6,a7);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return Module["dynCall_iiiiiii"](index,a1,a2,a3,a4,a5,a6);}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0);}}// Argument name here must shadow the `wasmExports` global so
// that it is recognised by metadce and minify-import-export-names
// passes.
function applySignatureConversions(wasmExports){// First, make a copy of the incoming exports object
wasmExports=Object.assign({},wasmExports);var makeWrapper_p=f=>()=>f()>>>0;var makeWrapper_pp=f=>a0=>f(a0)>>>0;var makeWrapper_p_=f=>a0=>f(a0)>>>0;var makeWrapper_ppp=f=>(a0,a1)=>f(a0,a1)>>>0;var makeWrapper_pppp=f=>(a0,a1,a2)=>f(a0,a1,a2)>>>0;var makeWrapper_pP=f=>a0=>f(a0)>>>0;wasmExports["__errno_location"]=makeWrapper_p(wasmExports["__errno_location"]);wasmExports["malloc"]=makeWrapper_pp(wasmExports["malloc"]);wasmExports["strerror"]=makeWrapper_p_(wasmExports["strerror"]);wasmExports["calloc"]=makeWrapper_ppp(wasmExports["calloc"]);wasmExports["emscripten_builtin_malloc"]=makeWrapper_pp(wasmExports["emscripten_builtin_malloc"]);wasmExports["memcpy"]=makeWrapper_pppp(wasmExports["memcpy"]);wasmExports["emscripten_stack_get_base"]=makeWrapper_p(wasmExports["emscripten_stack_get_base"]);wasmExports["emscripten_stack_get_end"]=makeWrapper_p(wasmExports["emscripten_stack_get_end"]);wasmExports["emscripten_builtin_memalign"]=makeWrapper_ppp(wasmExports["emscripten_builtin_memalign"]);wasmExports["emscripten_stack_get_current"]=makeWrapper_p(wasmExports["emscripten_stack_get_current"]);wasmExports["pthread_self"]=makeWrapper_p(wasmExports["pthread_self"]);wasmExports["emscripten_main_runtime_thread_id"]=makeWrapper_p(wasmExports["emscripten_main_runtime_thread_id"]);wasmExports["sbrk"]=makeWrapper_pP(wasmExports["sbrk"]);wasmExports["memalign"]=makeWrapper_ppp(wasmExports["memalign"]);wasmExports["emscripten_builtin_calloc"]=makeWrapper_ppp(wasmExports["emscripten_builtin_calloc"]);wasmExports["_emscripten_stack_alloc"]=makeWrapper_pp(wasmExports["_emscripten_stack_alloc"]);wasmExports["__cxa_get_exception_ptr"]=makeWrapper_pp(wasmExports["__cxa_get_exception_ptr"]);return wasmExports;}// include: postamble.js
// === Auto-generated postamble setup entry stuff ===
Module["addRunDependency"]=addRunDependency;Module["removeRunDependency"]=removeRunDependency;Module["ccall"]=ccall;Module["getValue"]=getValue;Module["UTF8ToString"]=UTF8ToString;Module["lengthBytesUTF8"]=lengthBytesUTF8;Module["FS_createPreloadedFile"]=FS_createPreloadedFile;Module["FS_unlink"]=FS_unlink;Module["FS_createPath"]=FS_createPath;Module["FS_createDevice"]=FS_createDevice;Module["FS"]=FS;Module["FS_createDataFile"]=FS_createDataFile;Module["FS_createLazyFile"]=FS_createLazyFile;var calledRun;dependenciesFulfilled=function runCaller(){// If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};// try this again later, after new deps are fulfilled
function callMain(args=[]){var entryFunction=resolveGlobalSymbol("main").sym;// Main modules can't tell if they have main() at compile time, since it may
// arrive from a dynamic library.
if(!entryFunction)return;args.unshift(thisProgram);var argc=args.length;var argv=stackAlloc((argc+1)*4);var argv_ptr=argv;args.forEach(arg=>{HEAPU32[argv_ptr>>>2>>>0]=stringToUTF8OnStack(arg);argv_ptr+=4;});HEAPU32[argv_ptr>>>2>>>0]=0;try{var ret=entryFunction(argc,argv);// if we're not running an evented main loop, it's time to exit
exitJS(ret,/* implicit = */true);return ret;}catch(e){return handleException(e);}}function run(args=arguments_){if(runDependencies>0){return;}preRun();// a preRun added a dependency, run will be called later
if(runDependencies>0){return;}function doRun(){// run may have just been called through dependencies being fulfilled just in this very frame,
// or while the async setStatus time below was happening
if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve(Module);Module["onRuntimeInitialized"]?.();if(shouldRunNow)callMain(args);postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(()=>{setTimeout(()=>Module["setStatus"](""),1);doRun();},1);}else{doRun();}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}// shouldRunNow refers to calling main(), not run().
var shouldRunNow=false;if(Module["noInitialRun"])shouldRunNow=false;run();// end include: postamble.js
// include: postamble_modularize.js
// In MODULARIZE mode we wrap the generated code in a factory function
// and return either the Module itself, or a promise of the module.
// We assign to the `moduleRtn` global here and configure closure to see
// this as and extern so it won't get minified.
moduleRtn=readyPromise;return moduleRtn;};})();/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PHP);

/***/ }),

/***/ "../packages/php-cgi-wasm/resolveDependencies.mjs":
/*!********************************************************!*\
  !*** ../packages/php-cgi-wasm/resolveDependencies.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveDependencies: () => (/* binding */ resolveDependencies)
/* harmony export */ });
/**
 * An object representing files, libs and urlLibs for a shared library.
 * @typedef {object} ResolvedDependencies
 * @property {FileDef[]} files
 * @property {LibDef[]} libs
 * @property {Object<string, string|url>} urlLibs mapping of resource names to URLs
 */

/**
 * Resolves dependencies related to dynamically loaded shared libs.
 * Normalizes LibDefs & FileDefs, and extracts URLs to specified resources.
 * @param {LibDef[]} sharedLibs List of LibDefs to resolve dependencies for.
 * @param {object} wrapper PHP Object to resolve depencencies for.
 * @returns {ResolvedDependencies} Normalized LibDefs, FileDefs, and their URLs.
 */
const resolveDependencies = (sharedLibs, wrapper) => {
  const _files = [];
  const _libs = [];
  (sharedLibs || []).forEach(libDef => {
    if (typeof libDef === 'object') {
      if (typeof libDef.getLibs === 'function') {
        _libs.push(...libDef.getLibs(wrapper.constructor));
      } else {
        _libs.push(libDef);
      }
      if (typeof libDef.getFiles === 'function') {
        _files.push(...libDef.getFiles(wrapper.constructor));
      }
    } else {
      _libs.push(libDef);
    }
  });
  const files = _files.map(fileDef => {
    const url = String(fileDef.url);
    const path = fileDef.path;
    const name = fileDef.name || path.split('/').pop();
    const parent = path.substr(0, path.length - name.length);
    return {
      parent,
      name,
      url
    };
  });
  const urlLibs = {};
  const libs = _libs.map(libDef => {
    if (typeof libDef === 'string' || libDef instanceof URL) {
      if (libDef.substr(0, 1) == '/' || libDef.substr(0, 2) == './' || libDef.substr(0, 8) == 'https://' || libDef.substr(0, 7) == 'http://') {
        const name = String(libDef).split('/').pop();
        const url = libDef;
        urlLibs[name] = url;
        return {
          name,
          url,
          ini: true
        };
      }
      return libDef;
    } else if (typeof libDef === 'object') {
      const name = libDef.name ?? String(libDef.url).split('/').pop();
      urlLibs[name] = libDef.url;
      return libDef;
    }
  });
  return {
    files,
    libs,
    urlLibs
  };
};

/***/ }),

/***/ "../packages/php-cgi-wasm/webTransactions.mjs":
/*!****************************************************!*\
  !*** ../packages/php-cgi-wasm/webTransactions.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   commitTransaction: () => (/* binding */ commitTransaction),
/* harmony export */   startTransaction: () => (/* binding */ startTransaction)
/* harmony export */ });
async function startTransaction(wrapper) {
  const php = await wrapper.binary;
  if (wrapper.transactionStarted || !php.persist) {
    return;
  }
  return await new Promise((accept, reject) => {
    php.FS.syncfs(true, error => {
      if (error) {
        reject(error);
      } else {
        wrapper.transactionStarted = true;
        accept();
      }
    });
  });
}
async function commitTransaction(wrapper) {
  const php = await wrapper.binary;
  if (!php.persist) {
    return;
  }
  if (!wrapper.transactionStarted) {
    throw new Error('No transaction initialized.');
  }
  return await new Promise((accept, reject) => {
    php.FS.syncfs(false, error => {
      if (error) {
        reject(error);
      } else {
        wrapper.transactionStarted = false;
        accept();
      }
    });
  });
}

/***/ }),

/***/ "../../../software/pglite/packages/pglite/dist/chunk-3BCYDNSE.js":
/*!***********************************************************************!*\
  !*** ../../../software/pglite/packages/pglite/dist/chunk-3BCYDNSE.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ l),
/* harmony export */   b: () => (/* binding */ p),
/* harmony export */   c: () => (/* binding */ f),
/* harmony export */   d: () => (/* binding */ g)
/* harmony export */ });
/* harmony import */ var _chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-Y3AVQXKT.js */ "../../../software/pglite/packages/pglite/dist/chunk-Y3AVQXKT.js");
(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var l=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";async function p(){let t=new URL(/* asset import */ __webpack_require__(/*! ./postgres.wasm */ "../../../software/pglite/packages/pglite/dist/postgres.wasm"), __webpack_require__.b),r=new URL(/* asset import */ __webpack_require__(/*! ./postgres.data */ "../../../software/pglite/packages/pglite/dist/postgres.data"), __webpack_require__.b),e=o=>o.pathname;return l&&(e=(await __webpack_require__.e(/*! import() */ "_4f23").then(__webpack_require__.t.bind(__webpack_require__, /*! url */ "?4f23", 19))).fileURLToPath),o=>{let n=null;switch(o){case"postgres.data":n=r;break;case"postgres.wasm":n=t;break;default:console.error("makeLocateFile",o)}return n?.protocol==="file:"?e(n):n?.toString()??""}}var f=()=>{if(globalThis.crypto?.randomUUID)return globalThis.crypto.randomUUID();let t=new Uint8Array(16);if(globalThis.crypto?.getRandomValues)globalThis.crypto.getRandomValues(t);else for(let e=0;e<t.length;e++)t[e]=Math.floor(Math.random()*256);t[6]=t[6]&15|64,t[8]=t[8]&63|128;let r=[];return t.forEach(e=>{r.push(e.toString(16).padStart(2,"0"))}),r.slice(0,4).join("")+"-"+r.slice(4,6).join("")+"-"+r.slice(6,8).join("")+"-"+r.slice(8,10).join("")+"-"+r.slice(10).join("")};async function g(t,r,e){if(!e||e.length===0)return r;let o=r.replace(/\$([0-9]+)/g,(i,s)=>"%"+s+"L");return(await t.query(`SELECT format($1, ${e.map((i,s)=>`$${s+2}`).join(", ")}) as query`,[o,...e],{setAllTypes:!0})).rows[0].query}
//# sourceMappingURL=chunk-3BCYDNSE.js.map

/***/ }),

/***/ "../../../software/pglite/packages/pglite/dist/chunk-7M5G4I52.js":
/*!***********************************************************************!*\
  !*** ../../../software/pglite/packages/pglite/dist/chunk-7M5G4I52.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ qt),
/* harmony export */   B: () => (/* binding */ Ht),
/* harmony export */   C: () => (/* binding */ Yt),
/* harmony export */   D: () => (/* binding */ M),
/* harmony export */   E: () => (/* binding */ sr),
/* harmony export */   F: () => (/* binding */ rr),
/* harmony export */   G: () => (/* binding */ Me),
/* harmony export */   a: () => (/* binding */ Rs),
/* harmony export */   b: () => (/* binding */ Ds),
/* harmony export */   c: () => (/* binding */ St),
/* harmony export */   d: () => (/* binding */ Et),
/* harmony export */   e: () => (/* binding */ Rt),
/* harmony export */   f: () => (/* binding */ Ct),
/* harmony export */   g: () => (/* binding */ Dt),
/* harmony export */   h: () => (/* binding */ Pt),
/* harmony export */   i: () => (/* binding */ Mt),
/* harmony export */   j: () => (/* binding */ Ot),
/* harmony export */   k: () => (/* binding */ Bt),
/* harmony export */   l: () => (/* binding */ Ut),
/* harmony export */   m: () => (/* binding */ Lt),
/* harmony export */   n: () => (/* binding */ kt),
/* harmony export */   o: () => (/* binding */ vt),
/* harmony export */   p: () => (/* binding */ Nt),
/* harmony export */   q: () => (/* binding */ $),
/* harmony export */   r: () => (/* binding */ _t),
/* harmony export */   s: () => (/* binding */ xt),
/* harmony export */   t: () => (/* binding */ zt),
/* harmony export */   u: () => (/* binding */ Ft),
/* harmony export */   v: () => (/* binding */ Gt),
/* harmony export */   w: () => (/* binding */ Vt),
/* harmony export */   x: () => (/* binding */ Wt),
/* harmony export */   y: () => (/* binding */ Qt),
/* harmony export */   z: () => (/* binding */ jt)
/* harmony export */ });
/* harmony import */ var _chunk_TAZBUB4Z_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-TAZBUB4Z.js */ "../../../software/pglite/packages/pglite/dist/chunk-TAZBUB4Z.js");
/* harmony import */ var _chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-Y3AVQXKT.js */ "../../../software/pglite/packages/pglite/dist/chunk-Y3AVQXKT.js");
var Rs={};(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.b)(Rs,{ABSTIME:()=>We,ACLITEM:()=>Xe,BIT:()=>ss,BOOL:()=>ht,BPCHAR:()=>$e,BYTEA:()=>V,CHAR:()=>re,CID:()=>Ne,CIDR:()=>Ve,CIRCLE:()=>qe,DATE:()=>pt,FLOAT4:()=>yt,FLOAT8:()=>j,GTSVECTOR:()=>ws,INET:()=>Ke,INT2:()=>ct,INT4:()=>ut,INT8:()=>N,INTERVAL:()=>ts,JSON:()=>Q,JSONB:()=>wt,MACADDR:()=>Je,MACADDR8:()=>He,MONEY:()=>Ye,NUMERIC:()=>as,OID:()=>ft,PATH:()=>Fe,PG_DEPENDENCIES:()=>ps,PG_LSN:()=>ys,PG_NDISTINCT:()=>ds,PG_NODE_TREE:()=>xe,POLYGON:()=>Ge,REFCURSOR:()=>ns,REGCLASS:()=>hs,REGCONFIG:()=>bs,REGDICTIONARY:()=>Ts,REGNAMESPACE:()=>As,REGOPER:()=>ls,REGOPERATOR:()=>os,REGPROC:()=>Le,REGPROCEDURE:()=>is,REGROLE:()=>Is,REGTYPE:()=>cs,RELTIME:()=>Qe,SMGR:()=>ze,TEXT:()=>W,TID:()=>ke,TIME:()=>Ze,TIMESTAMP:()=>mt,TIMESTAMPTZ:()=>gt,TIMETZ:()=>es,TINTERVAL:()=>je,TSQUERY:()=>gs,TSVECTOR:()=>ms,TXID_SNAPSHOT:()=>fs,UUID:()=>us,VARBIT:()=>rs,VARCHAR:()=>dt,XID:()=>ve,XML:()=>_e,arrayTypes:()=>F,parseArray:()=>oe,parseType:()=>K,parsers:()=>ae,serializeType:()=>J,serializerFor:()=>ie,serializerInstanceof:()=>ne,serializers:()=>G,types:()=>bt});(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.i)();var Be=globalThis.JSON.parse,Ue=globalThis.JSON.stringify,ht=16,V=17,re=18,N=20,ct=21,ut=23,Le=24,W=25,ft=26,ke=27,ve=28,Ne=29,Q=114,_e=142,xe=194,ze=210,Fe=602,Ge=604,Ve=650,yt=700,j=701,We=702,Qe=703,je=704,qe=718,He=774,Ye=790,Je=829,Ke=869,Xe=1033,$e=1042,dt=1043,pt=1082,Ze=1083,mt=1114,gt=1184,ts=1186,es=1266,ss=1560,rs=1562,as=1700,ns=1790,is=2202,ls=2203,os=2204,hs=2205,cs=2206,us=2950,fs=2970,ys=3220,ds=3361,ps=3402,ms=3614,gs=3615,ws=3642,bs=3734,Ts=3769,wt=3802,As=4089,Is=4096,F={1001:V,1002:re,1016:N,1005:ct,1007:ut,1009:W,1028:ft,199:Q,1021:yt,1022:j,1015:dt,3807:wt,1182:pt,1115:mt,1116:gt},bt={string:{to:0,from:[W,dt],serialize:t=>t,parse:t=>t,forceTo:W},number:{to:0,from:[ct,ut,ft,yt,j],serialize:t=>t.toString(),parse:t=>+t,forceTo:t=>Number.isInteger(t)?N:j},bigint:{to:N,from:[N],js:[BigInt],serialize:t=>t.toString(),parse:t=>{let e=BigInt(t);return e<Number.MIN_SAFE_INTEGER||e>Number.MAX_SAFE_INTEGER?e:Number(e)}},json:{to:Q,from:[Q,wt],serialize:t=>Ue(t),parse:t=>Be(t)},boolean:{to:ht,from:[ht],serialize:t=>t===!0?"t":"f",parse:t=>t==="t"},date:{to:1184,from:[pt,mt,gt],js:[Date],serialize:t=>(t instanceof Date?t:new Date(t)).toISOString(),parse:t=>new Date(t)},bytea:{to:V,from:[V],js:[Uint8Array],serialize:t=>"\\x"+Array.from(t).map(e=>e.toString(16).padStart(2,"0")).join(""),parse:t=>{let e=t.slice(2);return Uint8Array.from({length:e.length/2},(s,r)=>parseInt(e.substring(r*2,(r+1)*2),16))}},array:{to:0,from:Object.keys(F).map(t=>+t),serialize:t=>le(t),parse:(t,e)=>{let s;return e&&e in F&&(s=ae[F[e]]),oe(t,s)}}},Y=Es(bt),ae=Y.parsers,G=Y.serializers,ne=Y.serializerInstanceof;function ie(t){if(Array.isArray(t))return G.array;let e=G[typeof t];if(e)return e;for(let[s,r]of ne)if(t instanceof s)return r;return G.json}function J(t,e=!1){return t==null?[null,0]:ie(t)(t,e)}function Ss(t){return'"'+t.replace(/\\/g,"\\\\").replace(/"/g,'\\"')+'"'}function le(t){let e="{";for(let s=0;s<t.length;s++)if(s>0&&(e=e+","),t[s]===null||typeof t[s]>"u")e=e+"NULL";else if(Array.isArray(t[s]))e=e+le(t[s]);else if(ArrayBuffer.isView(t[s])||t[s]instanceof ArrayBuffer){let r=ArrayBuffer.isView(t[s])?new Uint8Array(t[s].buffer,t[s].byteOffset,t[s].byteLength):new Uint8Array(t[s]);e+="\\"+bt.bytea.serialize(r)}else e+=Ss(J(t[s])[0]);return e=e+"}",e}function oe(t,e){let s=0,r=null,n="",i=!1,h=0,l;function R(d){let b=[];for(;s<d.length;s++){if(r=d[s],i)r==="\\"?n+=d[++s]:r==='"'?(b.push(e?e(n):n),n="",i=d[s+1]==='"',h=s+2):n+=r;else if(r==='"')i=!0;else if(r==="{")h=++s,b.push(R(d));else if(r==="}"){i=!1,h<s&&b.push(e?e(d.slice(h,s)):d.slice(h,s)),h=s+1;break}else r===","&&l!=="}"&&l!=='"'&&(b.push(e?e(d.slice(h,s)):d.slice(h,s)),h=s+1);l=r}return h<s&&b.push(e?e(d.slice(h,s+1)):d.slice(h,s+1)),b}return R(t)[0]}function K(t,e,s){if(t===null)return null;let r=s?.[e]??Y.parsers[e];return r?r(t,e):t}function Es(t){return Object.keys(t).reduce(({parsers:e,serializers:s,serializerInstanceof:r},n)=>{let{to:i,from:h,serialize:l,parse:R=null,forceTo:d}=t[n],b=(C,Oe=!1)=>[l(C),Oe&&d?typeof d=="function"?d(C):d:i];return s[i]=b,s[n]=b,t[n].js&&t[n].js.forEach(C=>r.push([C,b])),R&&(Array.isArray(h)?h.forEach(C=>e[C]=R):e[h]=R,e[n]=R),{parsers:e,serializers:s,serializerInstanceof:r}},{parsers:{},serializers:{},serializerInstanceof:[]})}var Ds={};(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.b)(Ds,{parseResults:()=>X});(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.i)();function X(t,e,s){let r=[],n={rows:[],fields:[]},i=0,h=t.filter(l=>l.name==="rowDescription"||l.name==="dataRow"||l.name==="commandComplete");return h.forEach((l,R)=>{if(l.name==="rowDescription"){let d=l;n.fields=d.fields.map(b=>({name:b.name,dataTypeID:b.dataTypeID}))}else if(l.name==="dataRow"&&n){let d=l;e?.rowMode==="array"?n.rows.push(d.fields.map((b,C)=>K(b,n.fields[C].dataTypeID,e?.parsers))):n.rows.push(Object.fromEntries(d.fields.map((b,C)=>[n.fields[C].name,K(b,n.fields[C].dataTypeID,e?.parsers)])))}else l.name==="commandComplete"&&(i+=Cs(l),R===h.length-1?r.push({...n,affectedRows:i,...s?{blob:s}:{}}):r.push(n),n={rows:[],fields:[]})}),r.length===0&&r.push({rows:[],fields:[]}),r}function Cs(t){let e=t.text.split(" ");switch(e[0]){case"INSERT":return parseInt(e[2],10);case"UPDATE":case"DELETE":return parseInt(e[1],10);default:return 0}}var rr={};(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.b)(rr,{Parser:()=>sr,messages:()=>It,serialize:()=>M});(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.i)();(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.i)();var Ps=Object.defineProperty,he=t=>{throw TypeError(t)},Ms=(t,e)=>{for(var s in e)Ps(t,s,{get:e[s],enumerable:!0})},Tt=(t,e,s)=>e.has(t)||he("Cannot "+s),a=(t,e,s)=>(Tt(t,e,"read from private field"),s?s.call(t):e.get(t)),T=(t,e,s)=>e.has(t)?he("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,s),u=(t,e,s,r)=>(Tt(t,e,"write to private field"),r?r.call(t,s):e.set(t,s),s),c=(t,e,s)=>(Tt(t,e,"access private method"),s),At=(t,e,s,r)=>({set _(n){u(t,e,n,s)},get _(){return a(t,e,r)}}),It={};Ms(It,{AuthenticationCleartextPassword:()=>Ut,AuthenticationMD5Password:()=>Lt,AuthenticationOk:()=>Bt,AuthenticationSASL:()=>kt,AuthenticationSASLContinue:()=>vt,AuthenticationSASLFinal:()=>Nt,BackendKeyDataMessage:()=>Wt,CommandCompleteMessage:()=>qt,CopyDataMessage:()=>_t,CopyResponse:()=>xt,DataRowMessage:()=>Ht,DatabaseError:()=>$,Field:()=>zt,NoticeMessage:()=>Yt,NotificationResponseMessage:()=>Qt,ParameterDescriptionMessage:()=>Gt,ParameterStatusMessage:()=>Vt,ReadyForQueryMessage:()=>jt,RowDescriptionMessage:()=>Ft,bindComplete:()=>Et,closeComplete:()=>Rt,copyDone:()=>Ot,emptyQuery:()=>Mt,noData:()=>Ct,parseComplete:()=>St,portalSuspended:()=>Dt,replicationStart:()=>Pt});var St={name:"parseComplete",length:5},Et={name:"bindComplete",length:5},Rt={name:"closeComplete",length:5},Ct={name:"noData",length:5},Dt={name:"portalSuspended",length:5},Pt={name:"replicationStart",length:4},Mt={name:"emptyQuery",length:4},Ot={name:"copyDone",length:4},Bt=class{constructor(t){this.length=t,this.name="authenticationOk"}},Ut=class{constructor(t){this.length=t,this.name="authenticationCleartextPassword"}},Lt=class{constructor(t,e){this.length=t,this.salt=e,this.name="authenticationMD5Password"}},kt=class{constructor(t,e){this.length=t,this.mechanisms=e,this.name="authenticationSASL"}},vt=class{constructor(t,e){this.length=t,this.data=e,this.name="authenticationSASLContinue"}},Nt=class{constructor(t,e){this.length=t,this.data=e,this.name="authenticationSASLFinal"}},$=class extends Error{constructor(t,e,s){super(t),this.length=e,this.name=s}},_t=class{constructor(t,e){this.length=t,this.chunk=e,this.name="copyData"}},xt=class{constructor(t,e,s,r){this.length=t,this.name=e,this.binary=s,this.columnTypes=new Array(r)}},zt=class{constructor(t,e,s,r,n,i,h){this.name=t,this.tableID=e,this.columnID=s,this.dataTypeID=r,this.dataTypeSize=n,this.dataTypeModifier=i,this.format=h}},Ft=class{constructor(t,e){this.length=t,this.fieldCount=e,this.name="rowDescription",this.fields=new Array(this.fieldCount)}},Gt=class{constructor(t,e){this.length=t,this.parameterCount=e,this.name="parameterDescription",this.dataTypeIDs=new Array(this.parameterCount)}},Vt=class{constructor(t,e,s){this.length=t,this.parameterName=e,this.parameterValue=s,this.name="parameterStatus"}},Wt=class{constructor(t,e,s){this.length=t,this.processID=e,this.secretKey=s,this.name="backendKeyData"}},Qt=class{constructor(t,e,s,r){this.length=t,this.processId=e,this.channel=s,this.payload=r,this.name="notification"}},jt=class{constructor(t,e){this.length=t,this.status=e,this.name="readyForQuery"}},qt=class{constructor(t,e){this.length=t,this.text=e,this.name="commandComplete"}},Ht=class{constructor(t,e){this.length=t,this.fields=e,this.name="dataRow",this.fieldCount=e.length}},Yt=class{constructor(t,e){this.length=t,this.message=e,this.name="notice"}};function et(t){let e=t.length;for(let s=t.length-1;s>=0;s--){let r=t.charCodeAt(s);r>127&&r<=2047?e++:r>2047&&r<=65535&&(e+=2),r>=56320&&r<=57343&&s--}return e}var A,m,x,Xt,_,D,tt,k,Ce,st=class{constructor(t=256){this.size=t,T(this,D),T(this,A),T(this,m,5),T(this,x,!1),T(this,Xt,new TextEncoder),T(this,_,0),u(this,A,c(this,D,tt).call(this,t))}addInt32(t){return c(this,D,k).call(this,4),a(this,A).setInt32(a(this,m),t,a(this,x)),u(this,m,a(this,m)+4),this}addInt16(t){return c(this,D,k).call(this,2),a(this,A).setInt16(a(this,m),t,a(this,x)),u(this,m,a(this,m)+2),this}addCString(t){return t&&this.addString(t),c(this,D,k).call(this,1),a(this,A).setUint8(a(this,m),0),At(this,m)._++,this}addString(t=""){let e=et(t);return c(this,D,k).call(this,e),a(this,Xt).encodeInto(t,new Uint8Array(a(this,A).buffer,a(this,m))),u(this,m,a(this,m)+e),this}add(t){return c(this,D,k).call(this,t.byteLength),new Uint8Array(a(this,A).buffer).set(new Uint8Array(t),a(this,m)),u(this,m,a(this,m)+t.byteLength),this}flush(t){let e=c(this,D,Ce).call(this,t);return u(this,m,5),u(this,A,c(this,D,tt).call(this,this.size)),new Uint8Array(e)}};A=new WeakMap,m=new WeakMap,x=new WeakMap,Xt=new WeakMap,_=new WeakMap,D=new WeakSet,tt=function(t){return new DataView(new ArrayBuffer(t))},k=function(t){if(a(this,A).byteLength-a(this,m)<t){let e=a(this,A).buffer,s=e.byteLength+(e.byteLength>>1)+t;u(this,A,c(this,D,tt).call(this,s)),new Uint8Array(a(this,A).buffer).set(new Uint8Array(e))}},Ce=function(t){if(t){a(this,A).setUint8(a(this,_),t);let e=a(this,m)-(a(this,_)+1);a(this,A).setInt32(a(this,_)+1,e,a(this,x))}return a(this,A).buffer.slice(t?0:5,a(this,m))};var y=new st,Os=t=>{y.addInt16(3).addInt16(0);for(let r of Object.keys(t))y.addCString(r).addCString(t[r]);y.addCString("client_encoding").addCString("UTF8");let e=y.addCString("").flush(),s=e.byteLength+4;return new st().addInt32(s).add(e).flush()},Bs=()=>{let t=new DataView(new ArrayBuffer(8));return t.setInt32(0,8,!1),t.setInt32(4,80877103,!1),new Uint8Array(t.buffer)},Us=t=>y.addCString(t).flush(112),Ls=(t,e)=>(y.addCString(t).addInt32(et(e)).addString(e),y.flush(112)),ks=t=>y.addString(t).flush(112),vs=t=>y.addCString(t).flush(81),Ns=[],_s=t=>{let e=t.name??"";e.length>63&&(console.error("Warning! Postgres only supports 63 characters for query names."),console.error("You supplied %s (%s)",e,e.length),console.error("This can cause conflicts and silent errors executing queries"));let s=y.addCString(e).addCString(t.text).addInt16(t.types?.length??0);return t.types?.forEach(r=>s.addInt32(r)),y.flush(80)},v=new st,xs=(t,e)=>{for(let s=0;s<t.length;s++){let r=e?e(t[s],s):t[s];if(r===null)y.addInt16(0),v.addInt32(-1);else if(r instanceof ArrayBuffer||ArrayBuffer.isView(r)){let n=ArrayBuffer.isView(r)?r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength):r;y.addInt16(1),v.addInt32(n.byteLength),v.add(n)}else y.addInt16(0),v.addInt32(et(r)),v.addString(r)}},zs=(t={})=>{let e=t.portal??"",s=t.statement??"",r=t.binary??!1,n=t.values??Ns,i=n.length;return y.addCString(e).addCString(s),y.addInt16(i),xs(n,t.valueMapper),y.addInt16(i),y.add(v.flush()),y.addInt16(r?1:0),y.flush(66)},Fs=new Uint8Array([69,0,0,0,9,0,0,0,0,0]),Gs=t=>{if(!t||!t.portal&&!t.rows)return Fs;let e=t.portal??"",s=t.rows??0,r=et(e),n=4+r+1+4,i=new DataView(new ArrayBuffer(1+n));return i.setUint8(0,69),i.setInt32(1,n,!1),new TextEncoder().encodeInto(e,new Uint8Array(i.buffer,5)),i.setUint8(r+5,0),i.setUint32(i.byteLength-4,s,!1),new Uint8Array(i.buffer)},Vs=(t,e)=>{let s=new DataView(new ArrayBuffer(16));return s.setInt32(0,16,!1),s.setInt16(4,1234,!1),s.setInt16(6,5678,!1),s.setInt32(8,t,!1),s.setInt32(12,e,!1),new Uint8Array(s.buffer)},ee=(t,e)=>{let s=new st;return s.addCString(e),s.flush(t)},Ws=y.addCString("P").flush(68),Qs=y.addCString("S").flush(68),js=t=>t.name?ee(68,`${t.type}${t.name??""}`):t.type==="P"?Ws:Qs,qs=t=>{let e=`${t.type}${t.name??""}`;return ee(67,e)},Hs=t=>y.add(t).flush(100),Ys=t=>ee(102,t),rt=t=>new Uint8Array([t,0,0,0,4]),Js=rt(72),Ks=rt(83),Xs=rt(88),$s=rt(99),M={startup:Os,password:Us,requestSsl:Bs,sendSASLInitialResponseMessage:Ls,sendSCRAMClientFinalMessage:ks,query:vs,parse:_s,bind:zs,execute:Gs,describe:js,close:qs,flush:()=>Js,sync:()=>Ks,end:()=>Xs,copyData:Hs,copyDone:()=>$s,copyFail:Ys,cancel:Vs},ce={text:0,binary:1},Zs=new ArrayBuffer(0),O,w,$t,Zt,Z,tr=class{constructor(t=0){T(this,O,new DataView(Zs)),T(this,w),T(this,$t,"utf-8"),T(this,Zt,new TextDecoder(a(this,$t))),T(this,Z,!1),u(this,w,t)}setBuffer(t,e){u(this,w,t),u(this,O,new DataView(e))}int16(){let t=a(this,O).getInt16(a(this,w),a(this,Z));return u(this,w,a(this,w)+2),t}byte(){let t=a(this,O).getUint8(a(this,w));return At(this,w)._++,t}int32(){let t=a(this,O).getInt32(a(this,w),a(this,Z));return u(this,w,a(this,w)+4),t}string(t){return a(this,Zt).decode(this.bytes(t))}cstring(){let t=a(this,w),e=t;for(;a(this,O).getUint8(e++)!==0;);let s=this.string(e-t-1);return u(this,w,e),s}bytes(t){let e=a(this,O).buffer.slice(a(this,w),a(this,w)+t);return u(this,w,a(this,w)+t),new Uint8Array(e)}};O=new WeakMap,w=new WeakMap,$t=new WeakMap,Zt=new WeakMap,Z=new WeakMap;var te=1,er=4,ue=te+er,fe=new ArrayBuffer(0),I,S,E,o,p,De,Pe,ye,de,pe,me,ge,Jt,we,be,Te,Ae,Ie,Se,Ee,Re,Kt,sr=class{constructor(){T(this,p),T(this,I,new DataView(fe)),T(this,S,0),T(this,E,0),T(this,o,new tr)}parse(t,e){c(this,p,De).call(this,ArrayBuffer.isView(t)?t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength):t);let s=a(this,E)+a(this,S),r=a(this,E);for(;r+ue<=s;){let n=a(this,I).getUint8(r),i=a(this,I).getUint32(r+te,!1),h=te+i;if(h+r<=s){let l=c(this,p,Pe).call(this,r+ue,n,i,a(this,I).buffer);e(l),r+=h}else break}r===s?(u(this,I,new DataView(fe)),u(this,S,0),u(this,E,0)):(u(this,S,s-r),u(this,E,r))}};I=new WeakMap,S=new WeakMap,E=new WeakMap,o=new WeakMap,p=new WeakSet,De=function(t){if(a(this,S)>0){let e=a(this,S)+t.byteLength;if(e+a(this,E)>a(this,I).byteLength){let s;if(e<=a(this,I).byteLength&&a(this,E)>=a(this,S))s=a(this,I).buffer;else{let r=a(this,I).byteLength*2;for(;e>=r;)r*=2;s=new ArrayBuffer(r)}new Uint8Array(s).set(new Uint8Array(a(this,I).buffer,a(this,E),a(this,S))),u(this,I,new DataView(s)),u(this,E,0)}new Uint8Array(a(this,I).buffer).set(new Uint8Array(t),a(this,E)+a(this,S)),u(this,S,e)}else u(this,I,new DataView(t)),u(this,E,0),u(this,S,t.byteLength)},Pe=function(t,e,s,r){switch(e){case 50:return Et;case 49:return St;case 51:return Rt;case 110:return Ct;case 115:return Dt;case 99:return Ot;case 87:return Pt;case 73:return Mt;case 68:return c(this,p,Ie).call(this,t,s,r);case 67:return c(this,p,de).call(this,t,s,r);case 90:return c(this,p,ye).call(this,t,s,r);case 65:return c(this,p,we).call(this,t,s,r);case 82:return c(this,p,Re).call(this,t,s,r);case 83:return c(this,p,Se).call(this,t,s,r);case 75:return c(this,p,Ee).call(this,t,s,r);case 69:return c(this,p,Kt).call(this,t,s,r,"error");case 78:return c(this,p,Kt).call(this,t,s,r,"notice");case 84:return c(this,p,be).call(this,t,s,r);case 116:return c(this,p,Ae).call(this,t,s,r);case 71:return c(this,p,me).call(this,t,s,r);case 72:return c(this,p,ge).call(this,t,s,r);case 100:return c(this,p,pe).call(this,t,s,r);default:return new $("received invalid response: "+e.toString(16),s,"error")}},ye=function(t,e,s){a(this,o).setBuffer(t,s);let r=a(this,o).string(1);return new jt(e,r)},de=function(t,e,s){a(this,o).setBuffer(t,s);let r=a(this,o).cstring();return new qt(e,r)},pe=function(t,e,s){let r=s.slice(t,t+(e-4));return new _t(e,new Uint8Array(r))},me=function(t,e,s){return c(this,p,Jt).call(this,t,e,s,"copyInResponse")},ge=function(t,e,s){return c(this,p,Jt).call(this,t,e,s,"copyOutResponse")},Jt=function(t,e,s,r){a(this,o).setBuffer(t,s);let n=a(this,o).byte()!==0,i=a(this,o).int16(),h=new xt(e,r,n,i);for(let l=0;l<i;l++)h.columnTypes[l]=a(this,o).int16();return h},we=function(t,e,s){a(this,o).setBuffer(t,s);let r=a(this,o).int32(),n=a(this,o).cstring(),i=a(this,o).cstring();return new Qt(e,r,n,i)},be=function(t,e,s){a(this,o).setBuffer(t,s);let r=a(this,o).int16(),n=new Ft(e,r);for(let i=0;i<r;i++)n.fields[i]=c(this,p,Te).call(this);return n},Te=function(){let t=a(this,o).cstring(),e=a(this,o).int32(),s=a(this,o).int16(),r=a(this,o).int32(),n=a(this,o).int16(),i=a(this,o).int32(),h=a(this,o).int16()===0?ce.text:ce.binary;return new zt(t,e,s,r,n,i,h)},Ae=function(t,e,s){a(this,o).setBuffer(t,s);let r=a(this,o).int16(),n=new Gt(e,r);for(let i=0;i<r;i++)n.dataTypeIDs[i]=a(this,o).int32();return n},Ie=function(t,e,s){a(this,o).setBuffer(t,s);let r=a(this,o).int16(),n=new Array(r);for(let i=0;i<r;i++){let h=a(this,o).int32();n[i]=h===-1?null:a(this,o).string(h)}return new Ht(e,n)},Se=function(t,e,s){a(this,o).setBuffer(t,s);let r=a(this,o).cstring(),n=a(this,o).cstring();return new Vt(e,r,n)},Ee=function(t,e,s){a(this,o).setBuffer(t,s);let r=a(this,o).int32(),n=a(this,o).int32();return new Wt(e,r,n)},Re=function(t,e,s){a(this,o).setBuffer(t,s);let r=a(this,o).int32();switch(r){case 0:return new Bt(e);case 3:return new Ut(e);case 5:return new Lt(e,a(this,o).bytes(4));case 10:{let n=[];for(;;){let i=a(this,o).cstring();if(i.length===0)return new kt(e,n);n.push(i)}}case 11:return new vt(e,a(this,o).string(e-8));case 12:return new Nt(e,a(this,o).string(e-8));default:throw new Error("Unknown authenticationOk message type "+r)}},Kt=function(t,e,s,r){a(this,o).setBuffer(t,s);let n={},i=a(this,o).string(1);for(;i!=="\0";)n[i]=a(this,o).cstring(),i=a(this,o).string(1);let h=n.M,l=r==="notice"?new Yt(e,h):new $(h,e,r);return l.severity=n.S,l.code=n.C,l.detail=n.D,l.hint=n.H,l.position=n.P,l.internalPosition=n.p,l.internalQuery=n.q,l.where=n.W,l.schema=n.s,l.table=n.t,l.column=n.c,l.dataType=n.d,l.constraint=n.n,l.file=n.F,l.line=n.L,l.routine=n.R,l};(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.i)();var U,f,B,at,L,se,Me=class{constructor(){(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.e)(this,f);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.e)(this,U,!1)}async query(e,s,r){return await this._checkReady(),await this._runExclusiveTransaction(async()=>await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,at).call(this,e,s,r))}async sql(e,...s){let{query:r,params:n}=(0,_chunk_TAZBUB4Z_js__WEBPACK_IMPORTED_MODULE_0__.d)(e,...s);return await this.query(r,n)}async exec(e,s){return await this._checkReady(),await this._runExclusiveTransaction(async()=>await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,L).call(this,e,s))}async transaction(e){return await this._checkReady(),await this._runExclusiveTransaction(async()=>{await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,L).call(this,"BEGIN"),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.f)(this,U,!0);let s=!1,r=()=>{if(s)throw new Error("Transaction is closed")},n={query:async(i,h,l)=>(r(),await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,at).call(this,i,h,l)),sql:async(i,...h)=>{let{query:l,params:R}=(0,_chunk_TAZBUB4Z_js__WEBPACK_IMPORTED_MODULE_0__.d)(i,...h);return await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,at).call(this,l,R)},exec:async(i,h)=>(r(),await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,L).call(this,i,h)),rollback:async()=>{r(),await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,L).call(this,"ROLLBACK"),s=!0},get closed(){return s}};try{let i=await e(n);return s||(s=!0,await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,L).call(this,"COMMIT")),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.f)(this,U,!1),i}catch(i){throw s||await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,L).call(this,"ROLLBACK"),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.f)(this,U,!1),i}})}};U=new WeakMap,f=new WeakSet,B=async function(e,s={}){return await this.execProtocol(e,{...s,syncToFs:!1})},at=async function(e,s,r){return await this._runExclusiveQuery(async()=>{(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,se).call(this,"runQuery",e,s,r),await this._handleBlob(r?.blob);let n=s?.map(l=>J(l,r?.setAllTypes))||[],i;try{i=[...await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,B).call(this,M.parse({text:e,types:n.map(([,l])=>l)}),r),...await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,B).call(this,M.bind({values:n.map(([l])=>l)}),r),...await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,B).call(this,M.describe({type:"P"}),r),...await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,B).call(this,M.execute({}),r)]}finally{await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,B).call(this,M.sync(),r)}await this._cleanupBlob(),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.d)(this,U)||await this.syncToFs();let h=await this._getWrittenBlob();return X(i.map(([l])=>l),r,h)[0]})},L=async function(e,s){return await this._runExclusiveQuery(async()=>{(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,se).call(this,"runExec",e,s),await this._handleBlob(s?.blob);let r;try{r=await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,B).call(this,M.query(e),s)}finally{await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.g)(this,f,B).call(this,M.sync(),s)}this._cleanupBlob(),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_1__.d)(this,U)||await this.syncToFs();let n=await this._getWrittenBlob();return X(r.map(([i])=>i),s,n)})},se=function(...e){this.debug>0&&console.log(...e)};
//# sourceMappingURL=chunk-7M5G4I52.js.map

/***/ }),

/***/ "../../../software/pglite/packages/pglite/dist/chunk-SJVDOE3S.js":
/*!***********************************************************************!*\
  !*** ../../../software/pglite/packages/pglite/dist/chunk-SJVDOE3S.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ P),
/* harmony export */   b: () => (/* binding */ cr),
/* harmony export */   c: () => (/* binding */ L),
/* harmony export */   d: () => (/* binding */ Ce),
/* harmony export */   e: () => (/* binding */ O),
/* harmony export */   f: () => (/* binding */ R),
/* harmony export */   g: () => (/* binding */ Hr),
/* harmony export */   h: () => (/* binding */ v),
/* harmony export */   i: () => (/* binding */ he),
/* harmony export */   j: () => (/* binding */ Se)
/* harmony export */ });
/* harmony import */ var _chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-Y3AVQXKT.js */ "../../../software/pglite/packages/pglite/dist/chunk-Y3AVQXKT.js");
var C=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.a)((Qr,f)=>{"use strict";(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var W=9007199254740991,Y=function(r){return r}();function mr(r){return r===Y}function X(r){return typeof r=="string"||Object.prototype.toString.call(r)=="[object String]"}function fr(r){return Object.prototype.toString.call(r)=="[object Date]"}function z(r){return r!==null&&typeof r=="object"}function I(r){return typeof r=="function"}function lr(r){return typeof r=="number"&&r>-1&&r%1==0&&r<=W}function dr(r){return Object.prototype.toString.call(r)=="[object Array]"}function K(r){return z(r)&&!I(r)&&lr(r.length)}function N(r){return Object.prototype.toString.call(r)=="[object ArrayBuffer]"}function yr(r,e){return Array.prototype.map.call(r,e)}function gr(r,e){var t=Y;return I(e)&&Array.prototype.every.call(r,function(n,o,a){var s=e(n,o,a);return s&&(t=n),!s}),t}function Tr(r){return Object.assign.apply(null,arguments)}function $(r){var e,t,n;if(X(r)){for(t=r.length,n=new Uint8Array(t),e=0;e<t;e++)n[e]=r.charCodeAt(e)&255;return n}return N(r)?new Uint8Array(r):z(r)&&N(r.buffer)?new Uint8Array(r.buffer):K(r)?new Uint8Array(r):z(r)&&I(r.toString)?$(r.toString()):new Uint8Array}f.exports.MAX_SAFE_INTEGER=W;f.exports.isUndefined=mr;f.exports.isString=X;f.exports.isObject=z;f.exports.isDateTime=fr;f.exports.isFunction=I;f.exports.isArray=dr;f.exports.isArrayLike=K;f.exports.isArrayBuffer=N;f.exports.map=yr;f.exports.find=gr;f.exports.extend=Tr;f.exports.toUint8Array=$});var b=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.a)((re,Z)=>{"use strict";(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var G="\0";Z.exports={NULL_CHAR:G,TMAGIC:"ustar"+G+"00",OLDGNU_MAGIC:"ustar  "+G,REGTYPE:0,LNKTYPE:1,SYMTYPE:2,CHRTYPE:3,BLKTYPE:4,DIRTYPE:5,FIFOTYPE:6,CONTTYPE:7,TSUID:parseInt("4000",8),TSGID:parseInt("2000",8),TSVTX:parseInt("1000",8),TUREAD:parseInt("0400",8),TUWRITE:parseInt("0200",8),TUEXEC:parseInt("0100",8),TGREAD:parseInt("0040",8),TGWRITE:parseInt("0020",8),TGEXEC:parseInt("0010",8),TOREAD:parseInt("0004",8),TOWRITE:parseInt("0002",8),TOEXEC:parseInt("0001",8),TPERMALL:parseInt("0777",8),TPERMMASK:parseInt("0777",8)}});var j=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.a)((te,l)=>{"use strict";(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var J=C(),p=b(),xr=512,H=p.TPERMALL,Q=0,V=0,_=[["name",100,0,function(r,e){return E(r[e[0]],e[1])},function(r,e,t){return h(r.slice(e,e+t[1]))}],["mode",8,100,function(r,e){var t=r[e[0]]||H;return t=t&p.TPERMMASK,U(t,e[1],H)},function(r,e,t){var n=x(r.slice(e,e+t[1]));return n&=p.TPERMMASK,n}],["uid",8,108,function(r,e){return U(r[e[0]],e[1],Q)},function(r,e,t){return x(r.slice(e,e+t[1]))}],["gid",8,116,function(r,e){return U(r[e[0]],e[1],V)},function(r,e,t){return x(r.slice(e,e+t[1]))}],["size",12,124,function(r,e){return U(r.data.length,e[1])},function(r,e,t){return x(r.slice(e,e+t[1]))}],["modifyTime",12,136,function(r,e){return M(r[e[0]],e[1])},function(r,e,t){return D(r.slice(e,e+t[1]))}],["checksum",8,148,function(r,e){return"        "},function(r,e,t){return x(r.slice(e,e+t[1]))}],["type",1,156,function(r,e){return""+(parseInt(r[e[0]],10)||0)%8},function(r,e,t){return(parseInt(String.fromCharCode(r[e]),10)||0)%8}],["linkName",100,157,function(r,e){return""},function(r,e,t){return h(r.slice(e,e+t[1]))}],["ustar",8,257,function(r,e){return p.TMAGIC},function(r,e,t){return Fr(h(r.slice(e,e+t[1]),!0))},function(r,e){return r[e[0]]==p.TMAGIC||r[e[0]]==p.OLDGNU_MAGIC}],["owner",32,265,function(r,e){return E(r[e[0]],e[1])},function(r,e,t){return h(r.slice(e,e+t[1]))}],["group",32,297,function(r,e){return E(r[e[0]],e[1])},function(r,e,t){return h(r.slice(e,e+t[1]))}],["majorNumber",8,329,function(r,e){return""},function(r,e,t){return x(r.slice(e,e+t[1]))}],["minorNumber",8,337,function(r,e){return""},function(r,e,t){return x(r.slice(e,e+t[1]))}],["prefix",131,345,function(r,e){return E(r[e[0]],e[1])},function(r,e,t){return h(r.slice(e,e+t[1]))}],["accessTime",12,476,function(r,e){return M(r[e[0]],e[1])},function(r,e,t){return D(r.slice(e,e+t[1]))}],["createTime",12,488,function(r,e){return M(r[e[0]],e[1])},function(r,e,t){return D(r.slice(e,e+t[1]))}]],rr=function(r){var e=r[r.length-1];return e[2]+e[1]}(_);function Fr(r){if(r.length==8){var e=r.split("");if(e[5]==p.NULL_CHAR)return(e[6]==" "||e[6]==p.NULL_CHAR)&&(e[6]="0"),(e[7]==" "||e[7]==p.NULL_CHAR)&&(e[7]="0"),e=e.join(""),e==p.TMAGIC?e:r;if(e[7]==p.NULL_CHAR)return e[5]==p.NULL_CHAR&&(e[5]=" "),e[6]==p.NULL_CHAR&&(e[6]=" "),e==p.OLDGNU_MAGIC?e:r}return r}function E(r,e){return e-=1,J.isUndefined(r)&&(r=""),r=(""+r).substr(0,e),r+p.NULL_CHAR}function U(r,e,t){for(t=parseInt(t)||0,e-=1,r=(parseInt(r)||t).toString(8).substr(-e,e);r.length<e;)r="0"+r;return r+p.NULL_CHAR}function M(r,e){if(J.isDateTime(r))r=Math.floor(1*r/1e3);else if(r=parseInt(r,10),isFinite(r)){if(r<=0)return""}else r=Math.floor(1*new Date/1e3);return U(r,e,0)}function h(r,e){var t=String.fromCharCode.apply(null,r);if(e)return t;var n=t.indexOf(p.NULL_CHAR);return n>=0?t.substr(0,n):t}function x(r){var e=String.fromCharCode.apply(null,r);return parseInt(e.replace(/^0+$/g,""),8)||0}function D(r){return r.length==0||r[0]==0?null:new Date(1e3*x(r))}function Ar(r,e,t){var n=parseInt(e,10)||0,o=Math.min(n+rr,r.length),a=0,s=0,i=0;t&&_.every(function(F){return F[0]=="checksum"?(s=n+F[2],i=s+F[1],!1):!0});for(var c=32,m=n;m<o;m++){var S=m>=s&&m<i?c:r[m];a=(a+S)%262144}return a}l.exports.recordSize=xr;l.exports.defaultFileMode=H;l.exports.defaultUid=Q;l.exports.defaultGid=V;l.exports.posixHeader=_;l.exports.effectiveHeaderSize=rr;l.exports.calculateChecksum=Ar;l.exports.formatTarString=E;l.exports.formatTarNumber=U;l.exports.formatTarDateTime=M;l.exports.parseTarString=h;l.exports.parseTarNumber=x;l.exports.parseTarDateTime=D});var ir=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.a)((ie,nr)=>{"use strict";(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var hr=b(),k=C(),A=j();function er(r){return A.recordSize}function tr(r){return Math.ceil(r.data.length/A.recordSize)*A.recordSize}function Sr(r){var e=0;return r.forEach(function(t){e+=er(t)+tr(t)}),e+=A.recordSize*2,new Uint8Array(e)}function wr(r,e,t){t=parseInt(t)||0;var n=t;A.posixHeader.forEach(function(c){for(var m=c[3](e,c),S=m.length,F=0;F<S;F+=1)r[n+F]=m.charCodeAt(F)&255;n+=c[1]});var o=k.find(A.posixHeader,function(c){return c[0]=="checksum"});if(o){var a=A.calculateChecksum(r,t,!0),s=A.formatTarNumber(a,o[1]-2)+hr.NULL_CHAR+" ";n=t+o[2];for(var i=0;i<s.length;i+=1)r[n]=s.charCodeAt(i)&255,n++}return t+er(e)}function Pr(r,e,t){return t=parseInt(t,10)||0,r.set(e.data,t),t+tr(e)}function Ur(r){r=k.map(r,function(n){return k.extend({},n,{data:k.toUint8Array(n.data)})});var e=Sr(r),t=0;return r.forEach(function(n){t=wr(e,n,t),t=Pr(e,n,t)}),e}nr.exports.tar=Ur});var sr=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.a)((se,or)=>{"use strict";(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var Cr=b(),q=C(),g=j(),br={extractData:!0,checkHeader:!0,checkChecksum:!0,checkFileSize:!0},Er={size:!0,checksum:!0,ustar:!0},B={unexpectedEndOfFile:"Unexpected end of file.",fileCorrupted:"File is corrupted.",checksumCheckFailed:"Checksum check failed."};function vr(r){return g.recordSize}function zr(r){return Math.ceil(r/g.recordSize)*g.recordSize}function Ir(r,e){for(var t=e,n=Math.min(r.length,e+g.recordSize*2),o=t;o<n;o++)if(r[o]!=0)return!1;return!0}function Mr(r,e,t){if(r.length-e<g.recordSize){if(t.checkFileSize)throw new Error(B.unexpectedEndOfFile);return null}e=parseInt(e)||0;var n={},o=e;if(g.posixHeader.forEach(function(i){n[i[0]]=i[4](r,o,i),o+=i[1]}),n.type!=0&&(n.size=0),t.checkHeader&&g.posixHeader.forEach(function(i){if(q.isFunction(i[5])&&!i[5](n,i)){var c=new Error(B.fileCorrupted);throw c.data={offset:e+i[2],field:i[0]},c}}),t.checkChecksum){var a=g.calculateChecksum(r,e,!0);if(a!=n.checksum){var s=new Error(B.checksumCheckFailed);throw s.data={offset:e,header:n,checksum:a},s}}return n}function Dr(r,e,t,n){return n.extractData?t.size<=0?new Uint8Array:r.slice(e,e+t.size):null}function kr(r,e){var t={};return g.posixHeader.forEach(function(n){var o=n[0];Er[o]||(t[o]=r[o])}),t.isOldGNUFormat=r.ustar==Cr.OLDGNU_MAGIC,e&&(t.data=e),t}function Or(r,e){e=q.extend({},br,e);for(var t=[],n=0,o=r.length;o-n>=g.recordSize;){r=q.toUint8Array(r);var a=Mr(r,n,e);if(!a)break;n+=vr(a);var s=Dr(r,n,a,e);if(t.push(kr(a,s)),n+=zr(a.size),Ir(r,n))break}return t}or.exports.untar=Or});var cr=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.a)((ce,ar)=>{"use strict";(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var Lr=C(),Rr=b(),Nr=ir(),Gr=sr();Lr.extend(ar.exports,Nr,Gr,Rr)});(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var P=class{constructor(e){this.dataDir=e}async syncToFs(e,t){}async initialSyncFs(e){}async close(e){}};(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var T=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.c)(cr(),1);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var O=class extends P{async emscriptenOpts(e){return{...e,preRun:[...e.preRun||[],n=>{let o=n.FS.filesystems.IDBFS;n.FS.mkdir("/pglite"),n.FS.mkdir(`/pglite/${this.dataDir}`),n.FS.mount(o,{},`/pglite/${this.dataDir}`),n.FS.symlink(`/pglite/${this.dataDir}`,v)}]}}initialSyncFs(e){return new Promise((t,n)=>{e.syncfs(!0,o=>{o?n(o):t()})})}syncToFs(e,t){return new Promise((n,o)=>{e.syncfs(!1,a=>{a?o(a):n()})})}async dumpTar(e,t,n){return L(e,t,n)}async close(e){let t=e.filesystems.IDBFS.dbs[this.dataDir];t&&t.close(),e.quit()}};(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var R=class extends P{async emscriptenOpts(e){return e}async dumpTar(e,t,n){return L(e,t,n)}async close(e){e.quit()}};var Hr="/tmp/pglite",v=Hr+"/base";function he(r){let e;if(r?.startsWith("file://")){if(r=r.slice(7),!r)throw new Error("Invalid dataDir, must be a valid path");e="nodefs"}else r?.startsWith("idb://")?(r=r.slice(6),e="idbfs"):r?.startsWith("opfs-ahp://")?(r=r.slice(11),e="opfs-ahp"):!r||r?.startsWith("memory://")?e="memoryfs":e="nodefs";return{dataDir:r,fsType:e}}async function Se(r,e){let t;if(r&&e==="nodefs"){let{NodeFS:n}=await __webpack_require__.e(/*! import() */ "software_pglite_packages_pglite_dist_fs_nodefs_js").then(__webpack_require__.bind(__webpack_require__, /*! ./fs/nodefs.js */ "../../../software/pglite/packages/pglite/dist/fs/nodefs.js"));t=new n(r)}else if(r&&e==="idbfs")t=new O(r);else if(r&&e==="opfs-ahp"){let{OpfsAhpFS:n}=await __webpack_require__.e(/*! import() */ "software_pglite_packages_pglite_dist_fs_opfs-ahp_index_js").then(__webpack_require__.bind(__webpack_require__, /*! ./fs/opfs-ahp/index.js */ "../../../software/pglite/packages/pglite/dist/fs/opfs-ahp/index.js"));t=new n(r)}else t=new R;return t}async function L(r,e,t="auto"){let n=Br(r,v),[o,a]=await qr(n,t),s=(e||"pgdata")+(a?".tar.gz":".tar"),i=a?"application/x-gzip":"application/x-tar";return typeof File<"u"?new File([o],s,{type:i}):new Blob([o],{type:i})}var _r=["application/x-gtar","application/x-tar+gzip","application/x-gzip","application/gzip"];async function Ce(r,e){let t=new Uint8Array(await e.arrayBuffer()),n=typeof File<"u"&&e instanceof File?e.name:void 0;(_r.includes(e.type)||n?.endsWith(".tgz")||n?.endsWith(".tar.gz"))&&(t=await Xr(t));let a=(0,T.untar)(t);for(let s of a){let i=v+s.name,c=i.split("/").slice(0,-1);for(let m=1;m<=c.length;m++){let S=c.slice(0,m).join("/");r.analyzePath(S).exists||r.mkdir(S)}s.type===T.REGTYPE?(r.writeFile(i,s.data),r.utime(i,ur(s.modifyTime),ur(s.modifyTime))):s.type===T.DIRTYPE&&r.mkdir(i)}}function jr(r,e){let t=[],n=o=>{r.readdir(o).forEach(s=>{if(s==="."||s==="..")return;let i=o+"/"+s,c=r.stat(i),m=r.isFile(c.mode)?r.readFile(i,{encoding:"binary"}):new Uint8Array(0);t.push({name:i.substring(e.length),mode:c.mode,size:c.size,type:r.isFile(c.mode)?T.REGTYPE:T.DIRTYPE,modifyTime:c.mtime,data:m}),r.isDir(c.mode)&&n(i)})};return n(e),t}function Br(r,e){let t=jr(r,e);return(0,T.tar)(t)}async function qr(r,e="auto"){if(e==="none")return[r,!1];if(typeof CompressionStream<"u")return[await Wr(r),!0];if(typeof process<"u"&&process.versions&&process.versions.node)return[await Yr(r),!0];if(e==="auto")return[r,!1];throw new Error("Compression not supported in this environment")}async function Wr(r){let e=new CompressionStream("gzip"),t=e.writable.getWriter(),n=e.readable.getReader();t.write(r),t.close();let o=[];for(;;){let{value:i,done:c}=await n.read();if(c)break;i&&o.push(i)}let a=new Uint8Array(o.reduce((i,c)=>i+c.length,0)),s=0;return o.forEach(i=>{a.set(i,s),s+=i.length}),a}async function Yr(r){let{promisify:e}=await __webpack_require__.e(/*! import() */ "vendors-node_modules_util_util_js").then(__webpack_require__.t.bind(__webpack_require__, /*! util */ "../../../node_modules/util/util.js", 19)),{gzip:t}=await __webpack_require__.e(/*! import() */ "_6253").then(__webpack_require__.t.bind(__webpack_require__, /*! zlib */ "?6253", 19));return await e(t)(r)}async function Xr(r){if(typeof CompressionStream<"u")return await Kr(r);if(typeof process<"u"&&process.versions&&process.versions.node)return await $r(r);throw new Error("Unsupported environment for decompression")}async function Kr(r){let e=new DecompressionStream("gzip"),t=e.writable.getWriter(),n=e.readable.getReader();t.write(r),t.close();let o=[];for(;;){let{value:i,done:c}=await n.read();if(c)break;i&&o.push(i)}let a=new Uint8Array(o.reduce((i,c)=>i+c.length,0)),s=0;return o.forEach(i=>{a.set(i,s),s+=i.length}),a}async function $r(r){let{promisify:e}=await __webpack_require__.e(/*! import() */ "vendors-node_modules_util_util_js").then(__webpack_require__.t.bind(__webpack_require__, /*! util */ "../../../node_modules/util/util.js", 19)),{gunzip:t}=await __webpack_require__.e(/*! import() */ "_6253").then(__webpack_require__.t.bind(__webpack_require__, /*! zlib */ "?6253", 19));return await e(t)(r)}function ur(r){return r?typeof r=="number"?r:Math.floor(r.getTime()/1e3):Math.floor(Date.now()/1e3)}
//# sourceMappingURL=chunk-SJVDOE3S.js.map

/***/ }),

/***/ "../../../software/pglite/packages/pglite/dist/chunk-TAZBUB4Z.js":
/*!***********************************************************************!*\
  !*** ../../../software/pglite/packages/pglite/dist/chunk-TAZBUB4Z.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ y),
/* harmony export */   b: () => (/* binding */ c),
/* harmony export */   c: () => (/* binding */ m),
/* harmony export */   d: () => (/* binding */ g)
/* harmony export */ });
/* harmony import */ var _chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-Y3AVQXKT.js */ "../../../software/pglite/packages/pglite/dist/chunk-Y3AVQXKT.js");
(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_0__.i)();var o={part:"part",container:"container"};function s(t,r,...e){let a=t.length-1,p=e.length-1;if(p!==-1){if(p===0){t[a]=t[a]+e[0]+r;return}t[a]=t[a]+e[0],t.push(...e.slice(1,p)),t.push(e[p]+r)}}function y(t,...r){let e=[t[0]];e.raw=[t.raw[0]];let a=[];for(let p=0;p<r.length;p++){let n=r[p],i=p+1;if(n._templateType===o.part){s(e,t[i],n.str),s(e.raw,t.raw[i],n.str);continue}if(n._templateType===o.container){s(e,t[i],...n.strings),s(e.raw,t.raw[i],...n.strings.raw),a.push(...n.values);continue}e.push(t[i]),e.raw.push(t.raw[i]),a.push(n)}return{_templateType:"container",strings:e,values:a}}function c(t,...r){return{_templateType:"part",str:`"${String.raw(t,...r)}"`}}function m(t,...r){return{_templateType:"part",str:String.raw(t,...r)}}function g(t,...r){let{strings:e,values:a}=y(t,...r);return{query:[e[0],...a.flatMap((p,n)=>[`$${n+1}`,e[n+1]])].join(""),params:a}}
//# sourceMappingURL=chunk-TAZBUB4Z.js.map

/***/ }),

/***/ "../../../software/pglite/packages/pglite/dist/chunk-Y3AVQXKT.js":
/*!***********************************************************************!*\
  !*** ../../../software/pglite/packages/pglite/dist/chunk-Y3AVQXKT.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ u),
/* harmony export */   b: () => (/* binding */ D),
/* harmony export */   c: () => (/* binding */ F),
/* harmony export */   d: () => (/* binding */ g),
/* harmony export */   e: () => (/* binding */ L),
/* harmony export */   f: () => (/* binding */ h),
/* harmony export */   g: () => (/* binding */ P),
/* harmony export */   h: () => (/* binding */ R),
/* harmony export */   i: () => (/* binding */ x)
/* harmony export */ });
var p=Object.create;var i=Object.defineProperty;var c=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var l=Object.getPrototypeOf,s=Object.prototype.hasOwnProperty;var a=t=>{throw TypeError(t)};var _=(t,e)=>()=>(t&&(e=t(t=0)),e);var u=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),D=(t,e)=>{for(var o in e)i(t,o,{get:e[o],enumerable:!0})},d=(t,e,o,m)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of f(e))!s.call(t,r)&&r!==o&&i(t,r,{get:()=>e[r],enumerable:!(m=c(e,r))||m.enumerable});return t};var F=(t,e,o)=>(o=t!=null?p(l(t)):{},d(e||!t||!t.__esModule?i(o,"default",{value:t,enumerable:!0}):o,t));var n=(t,e,o)=>e.has(t)||a("Cannot "+o);var g=(t,e,o)=>(n(t,e,"read from private field"),o?o.call(t):e.get(t)),L=(t,e,o)=>e.has(t)?a("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,o),h=(t,e,o,m)=>(n(t,e,"write to private field"),m?m.call(t,o):e.set(t,o),o),P=(t,e,o)=>(n(t,e,"access private method"),o);var R=(t,e,o,m)=>({set _(r){h(t,e,r,o)},get _(){return g(t,e,m)}});var x=_(()=>{"use strict"});
//# sourceMappingURL=chunk-Y3AVQXKT.js.map

/***/ }),

/***/ "../../../software/pglite/packages/pglite/dist/index.js":
/*!**************************************************************!*\
  !*** ../../../software/pglite/packages/pglite/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IdbFs: () => (/* reexport safe */ _chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.e),
/* harmony export */   MemoryFS: () => (/* reexport safe */ _chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.f),
/* harmony export */   Mutex: () => (/* binding */ E),
/* harmony export */   PGlite: () => (/* binding */ Ne),
/* harmony export */   formatQuery: () => (/* reexport safe */ _chunk_3BCYDNSE_js__WEBPACK_IMPORTED_MODULE_3__.d),
/* harmony export */   messages: () => (/* binding */ Be),
/* harmony export */   parse: () => (/* reexport safe */ _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.b),
/* harmony export */   protocol: () => (/* reexport safe */ _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.F),
/* harmony export */   types: () => (/* reexport safe */ _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.a),
/* harmony export */   uuid: () => (/* reexport safe */ _chunk_3BCYDNSE_js__WEBPACK_IMPORTED_MODULE_3__.c)
/* harmony export */ });
/* harmony import */ var _chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-SJVDOE3S.js */ "../../../software/pglite/packages/pglite/dist/chunk-SJVDOE3S.js");
/* harmony import */ var _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-7M5G4I52.js */ "../../../software/pglite/packages/pglite/dist/chunk-7M5G4I52.js");
/* harmony import */ var _chunk_TAZBUB4Z_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-TAZBUB4Z.js */ "../../../software/pglite/packages/pglite/dist/chunk-TAZBUB4Z.js");
/* harmony import */ var _chunk_3BCYDNSE_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-3BCYDNSE.js */ "../../../software/pglite/packages/pglite/dist/chunk-3BCYDNSE.js");
/* harmony import */ var _chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-Y3AVQXKT.js */ "../../../software/pglite/packages/pglite/dist/chunk-Y3AVQXKT.js");
/* harmony import */ var _postgres_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./postgres.js */ "../../../software/pglite/packages/pglite/dist/postgres.js");
(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.i)();(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.i)();(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.i)();var et=new Error("timeout while waiting for mutex to become available"),tt=new Error("mutex already locked"),Ke=new Error("request for lock canceled"),Xe=function(u,t,e,s){function d(r){return r instanceof e?r:new e(function(n){n(r)})}return new(e||(e=Promise))(function(r,n){function o(c){try{l(s.next(c))}catch(m){n(m)}}function a(c){try{l(s.throw(c))}catch(m){n(m)}}function l(c){c.done?r(c.value):d(c.value).then(o,a)}l((s=s.apply(u,t||[])).next())})},H=class{constructor(t,e=Ke){this._value=t,this._cancelError=e,this._weightedQueues=[],this._weightedWaiters=[]}acquire(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);return new Promise((e,s)=>{this._weightedQueues[t-1]||(this._weightedQueues[t-1]=[]),this._weightedQueues[t-1].push({resolve:e,reject:s}),this._dispatch()})}runExclusive(t,e=1){return Xe(this,void 0,void 0,function*(){let[s,d]=yield this.acquire(e);try{return yield t(s)}finally{d()}})}waitForUnlock(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);return new Promise(e=>{this._weightedWaiters[t-1]||(this._weightedWaiters[t-1]=[]),this._weightedWaiters[t-1].push(e),this._dispatch()})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(t){this._value=t,this._dispatch()}release(t=1){if(t<=0)throw new Error(`invalid weight ${t}: must be positive`);this._value+=t,this._dispatch()}cancel(){this._weightedQueues.forEach(t=>t.forEach(e=>e.reject(this._cancelError))),this._weightedQueues=[]}_dispatch(){var t;for(let e=this._value;e>0;e--){let s=(t=this._weightedQueues[e-1])===null||t===void 0?void 0:t.shift();if(!s)continue;let d=this._value,r=e;this._value-=e,e=this._value+1,s.resolve([d,this._newReleaser(r)])}this._drainUnlockWaiters()}_newReleaser(t){let e=!1;return()=>{e||(e=!0,this.release(t))}}_drainUnlockWaiters(){for(let t=this._value;t>0;t--)this._weightedWaiters[t-1]&&(this._weightedWaiters[t-1].forEach(e=>e()),this._weightedWaiters[t-1]=[])}},Ye=function(u,t,e,s){function d(r){return r instanceof e?r:new e(function(n){n(r)})}return new(e||(e=Promise))(function(r,n){function o(c){try{l(s.next(c))}catch(m){n(m)}}function a(c){try{l(s.throw(c))}catch(m){n(m)}}function l(c){c.done?r(c.value):d(c.value).then(o,a)}l((s=s.apply(u,t||[])).next())})},E=class{constructor(t){this._semaphore=new H(1,t)}acquire(){return Ye(this,void 0,void 0,function*(){let[,t]=yield this._semaphore.acquire();return t})}runExclusive(t){return this._semaphore.runExclusive(()=>t())}isLocked(){return this._semaphore.isLocked()}waitForUnlock(){return this._semaphore.waitForUnlock()}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}};(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.i)();var Oe=_postgres_js__WEBPACK_IMPORTED_MODULE_5__["default"];(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.i)();var Ie=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.c)((0,_chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.b)(),1);async function J(u){if(_chunk_3BCYDNSE_js__WEBPACK_IMPORTED_MODULE_3__.a){let t=await __webpack_require__.e(/*! import() */ "_7718").then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ "?7718", 19)),e=await __webpack_require__.e(/*! import() */ "_6253").then(__webpack_require__.t.bind(__webpack_require__, /*! zlib */ "?6253", 19)),{Writable:s}=await __webpack_require__.e(/*! import() */ "_545d").then(__webpack_require__.t.bind(__webpack_require__, /*! stream */ "?545d", 19)),{pipeline:d}=await __webpack_require__.e(/*! import() */ "_ea88").then(__webpack_require__.t.bind(__webpack_require__, /*! stream/promises */ "?ea88", 19));if(!t.existsSync(u))throw new Error(`Extension bundle not found: ${u}`);let r=e.createGunzip(),n=[];return await d(t.createReadStream(u),r,new s({write(o,a,l){n.push(o),l()}})),new Blob(n)}else{let t=await fetch(u.toString());if(!t.ok||!t.body)return null;if(t.headers.get("Content-Encoding")==="gzip")return t.blob();{let e=new DecompressionStream("gzip");return new Response(t.body.pipeThrough(e)).blob()}}}async function ke(u,t){for(let e in u.pg_extensions){let s;try{s=await u.pg_extensions[e]}catch(d){console.error("Failed to fetch extension:",e,d);continue}if(s){let d=new Uint8Array(await s.arrayBuffer());Je(u,e,d,t)}else console.error("Could not get binary data for extension:",e)}}function Je(u,t,e,s){Ie.default.untar(e).forEach(r=>{if(!r.name.startsWith(".")){let n=u.WASM_PREFIX+"/"+r.name;if(r.name.endsWith(".so")){let o=(...l)=>{s("pgfs:ext OK",n,l)},a=(...l)=>{s("pgfs:ext FAIL",n,l)};u.FS.createPreloadedFile(Ze(n),r.name.split("/").pop().slice(0,-3),r.data,!0,!0,o,a,!1)}else u.FS.writeFile(n,r.data)}})}function Ze(u){let t=u.lastIndexOf("/");return t>0?u.slice(0,t):u}var Be={};(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.b)(Be,{AuthenticationCleartextPassword:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.l,AuthenticationMD5Password:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.m,AuthenticationOk:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.k,AuthenticationSASL:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.n,AuthenticationSASLContinue:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.o,AuthenticationSASLFinal:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.p,BackendKeyDataMessage:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.x,CommandCompleteMessage:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.A,CopyDataMessage:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.r,CopyResponse:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.s,DataRowMessage:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.B,DatabaseError:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.q,Field:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.t,NoticeMessage:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.C,NotificationResponseMessage:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.y,ParameterDescriptionMessage:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.v,ParameterStatusMessage:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.w,ReadyForQueryMessage:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.z,RowDescriptionMessage:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.u,bindComplete:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.d,closeComplete:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.e,copyDone:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.j,emptyQuery:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.i,noData:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.f,parseComplete:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.c,portalSuspended:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.g,replicationStart:()=>_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.h});(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.i)();var M,P,_,R,O,z,j,V,I,N,U,L,T,x,y,F,w,Ue,B,Z=class Z extends _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.G{constructor(e={},s={}){super();(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,w);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,M,!1);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,P,!1);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,_,!1);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,R,!1);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,O,!1);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,z,new E);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,j,new E);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,V,new E);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,I,!1);this.debug=0;(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,N);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,U,[]);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,L,new _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.E);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,T);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,x);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,y,new Map);(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.e)(this,F,new Set);typeof e=="string"?s={dataDir:e,...s}:s=e,this.dataDir=s.dataDir,s?.debug!==void 0&&(this.debug=s.debug),s?.relaxedDurability!==void 0&&(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,O,s.relaxedDurability),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,N,s.extensions??{}),this.waitReady=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.g)(this,w,Ue).call(this,s??{})}static async create(e,s){let d=typeof e=="string"?{dataDir:e,...s??{}}:e??{},r=new Z(d);return await r.waitReady,r}get Module(){return this.mod}get ready(){return (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,M)&&!(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,P)&&!(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,_)}get closed(){return (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,_)}async close(){await this._checkReady(),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,P,!0);for(let e of (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,U))await e();try{await this.execProtocol(_chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.D.end())}catch(e){let s=e;if(!(s.name==="ExitStatus"&&s.status===0))throw e}await this.fs.close(this.mod.FS),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,_,!0),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,P,!1)}async[Symbol.asyncDispose](){await this.close()}async _handleBlob(e){(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,T,e?await e.arrayBuffer():void 0)}async _cleanupBlob(){(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,T,void 0)}async _getWrittenBlob(){if(!(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,x))return;let e=new Blob((0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,x));return (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,x,void 0),e}async _checkReady(){if((0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,P))throw new Error("PGlite is closing");if((0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,_))throw new Error("PGlite is closed");(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,M)||await this.waitReady}async execProtocolRaw(e,{syncToFs:s=!0}={}){let d=e.length,r=this.mod;r._interactive_write(d),r.HEAPU8.set(e,1),r._interactive_one();let n=d+2,o=n+r._interactive_read(),a=r.HEAPU8.subarray(n,o);return s&&await this.syncToFs(),a}async execProtocol(e,{syncToFs:s=!0,onNotice:d}={}){let r=await this.execProtocolRaw(e,{syncToFs:s}),n=[];return (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,L).parse(r,o=>{if(o instanceof _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.q)throw (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,L,new _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.E),o;if(o instanceof _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.C)this.debug>0&&console.warn(o),d&&d(o);else if(o instanceof _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.A)switch(o.text){case"BEGIN":(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,R,!0);break;case"COMMIT":case"ROLLBACK":(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,R,!1);break}else if(o instanceof _chunk_7M5G4I52_js__WEBPACK_IMPORTED_MODULE_1__.y){let a=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,y).get(o.channel);a&&a.forEach(l=>{queueMicrotask(()=>l(o.payload))}),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,F).forEach(l=>{queueMicrotask(()=>l(o.channel,o.payload))})}n.push([o,r])}),n}isInTransaction(){return (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,R)}async syncToFs(){if((0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,I))return;(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,I,!0);let e=async()=>{await (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,V).runExclusive(async()=>{(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,I,!1),await this.fs.syncToFs(this.mod.FS,(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,O))})};(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,O)?e():await e()}async listen(e,s){return (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,y).has(e)||(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,y).set(e,new Set),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,y).get(e).add(s),await this.exec(`LISTEN ${e}`),async()=>{await this.unlisten(e,s)}}async unlisten(e,s){s?((0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,y).get(e)?.delete(s),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,y).get(e)?.size===0&&(await this.exec(`UNLISTEN ${e}`),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,y).delete(e))):(await this.exec(`UNLISTEN ${e}`),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,y).delete(e))}onNotification(e){return (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,F).add(e),()=>{(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,F).delete(e)}}offNotification(e){(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,F).delete(e)}async dumpDataDir(e){let s=this.dataDir?.split("/").pop()??"pgdata";return this.fs.dumpTar(this.mod.FS,s,e)}_runExclusiveQuery(e){return (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,z).runExclusive(e)}_runExclusiveTransaction(e){return (0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,j).runExclusive(e)}};M=new WeakMap,P=new WeakMap,_=new WeakMap,R=new WeakMap,O=new WeakMap,z=new WeakMap,j=new WeakMap,V=new WeakMap,I=new WeakMap,N=new WeakMap,U=new WeakMap,L=new WeakMap,T=new WeakMap,x=new WeakMap,y=new WeakMap,F=new WeakMap,w=new WeakSet,Ue=async function(e){if(e.fs)this.fs=e.fs;else{let{dataDir:a,fsType:l}=(0,_chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.i)(e.dataDir);this.fs=await (0,_chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.j)(a,l)}let s={},d=[],r=[`PGDATA=${_chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.h}`,`PREFIX=${_chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.g}`,`PGUSER=${e.username??"postgres"}`,`PGDATABASE=${e.database??"template1"}`,"MODE=REACT","REPL=N",...this.debug?["-d",this.debug.toString()]:[]],n={WASM_PREFIX:_chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.g,arguments:r,INITIAL_MEMORY:e.initialMemory,noExitRuntime:!0,...this.debug>0?{print:console.info,printErr:console.error}:{print:()=>{},printErr:()=>{}},locateFile:await (0,_chunk_3BCYDNSE_js__WEBPACK_IMPORTED_MODULE_3__.b)(),preRun:[a=>{let l=a.FS.makedev(64,0),c={open:m=>{},close:m=>{},read:(m,k,b,v,g)=>{let ee=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,T);if(!ee)throw new Error("No /dev/blob File or Blob provided to read from");let K=new Uint8Array(ee);if(g>=K.length)return 0;let te=Math.min(K.length-g,v);for(let q=0;q<te;q++)k[b+q]=K[g+q];return te},write:(m,k,b,v,g)=>((0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,x)??(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,x,[]),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,x).push(k.slice(b,b+v)),v),llseek:(m,k,b)=>{let v=(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,T);if(!v)throw new Error("No /dev/blob File or Blob provided to llseek");let g=k;if(b===1?g+=m.position:b===2&&(g=new Uint8Array(v).length),g<0)throw new a.FS.ErrnoError(28);return g}};a.FS.registerDevice(l,c),a.FS.mkdev("/dev/blob",l)}]};n=await this.fs.emscriptenOpts(n);for(let[a,l]of Object.entries((0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,N)))if(l instanceof URL)s[a]=J(l);else{let c=await l.setup(this,n);if(c.emscriptenOpts&&(n=c.emscriptenOpts),c.namespaceObj){let m=this;m[a]=c.namespaceObj}c.bundlePath&&(s[a]=J(c.bundlePath)),c.init&&d.push(c.init),c.close&&(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.d)(this,U).push(c.close)}if(n.pg_extensions=s,this.mod=await Oe(n),await this.fs.initialSyncFs(this.mod.FS),e.loadDataDir){if(this.mod.FS.analyzePath(_chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.h+"/PG_VERSION").exists)throw new Error("Database already exists, cannot load from tarball");(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.g)(this,w,B).call(this,"pglite: loading data from tarball"),await (0,_chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.d)(this.mod.FS,e.loadDataDir)}this.mod.FS.analyzePath(_chunk_SJVDOE3S_js__WEBPACK_IMPORTED_MODULE_0__.h+"/PG_VERSION").exists?(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.g)(this,w,B).call(this,"pglite: found DB, resuming"):(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.g)(this,w,B).call(this,"pglite: no db"),await ke(this.mod,(...a)=>(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.g)(this,w,B).call(this,...a));let o=this.mod._pg_initdb();if(!o)throw new Error("INITDB failed to return value");if(o&1)throw new Error("INITDB failed");if(o&2){let a=e.username??"postgres",l=e.database??"template1";if(o&4){if(!(o&12))throw new Error("Invalid db/user combination")}else if(l!=="template1"&&a!=="postgres")throw new Error("INITDB created a new datadir, but an alternative db/user was requested")}await this.syncToFs(),(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.f)(this,M,!0),await this.exec("SET search_path TO public;");for(let a of d)await a()},B=function(...e){this.debug>0&&console.log(...e)};var Ne=Z;(0,_chunk_Y3AVQXKT_js__WEBPACK_IMPORTED_MODULE_4__.i)();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../../software/pglite/packages/pglite/dist/postgres.js":
/*!*****************************************************************!*\
  !*** ../../../software/pglite/packages/pglite/dist/postgres.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var Module = (() => {
  var _scriptName = "file:///home/sean/software/pglite/packages/pglite/dist/postgres.js";

  return (
async function(moduleArg = {}) {
  var moduleRtn;

// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(moduleArg) => Promise<Module>
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = moduleArg;

// Set up the promise that indicates the Module is initialized
var readyPromiseResolve, readyPromiseReject;
var readyPromise = new Promise((resolve, reject) => {
  readyPromiseResolve = resolve;
  readyPromiseReject = reject;
});

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
  // `require()` is no-op in an ESM module, use `createRequire()` to construct
  // the require()` function.  This is only necessary for multi-environment
  // builds, `-sENVIRONMENT=node` emits a static import declaration instead.
  // TODO: Swap all `require()`'s with `import()`'s?
  const { createRequire } = await __webpack_require__.e(/*! import() */ "_fc6e").then(__webpack_require__.t.bind(__webpack_require__, /*! module */ "?fc6e", 19));
  /** @suppress{duplicate} */
  var require = createRequire("file:///home/sean/software/pglite/packages/pglite/dist/postgres.js");

}

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// include: /tmp/tmpaasp3a41.js

  if (!Module['expectedDataFileDownloads']) {
    Module['expectedDataFileDownloads'] = 0;
  }

  Module['expectedDataFileDownloads']++;
  (() => {
    // Do not attempt to redownload the virtual filesystem data when in a pthread or a Wasm Worker context.
    var isPthread = typeof ENVIRONMENT_IS_PTHREAD != 'undefined' && ENVIRONMENT_IS_PTHREAD;
    var isWasmWorker = typeof ENVIRONMENT_IS_WASM_WORKER != 'undefined' && ENVIRONMENT_IS_WASM_WORKER;
    if (isPthread || isWasmWorker) return;
    function loadPackage(metadata) {

      var PACKAGE_PATH = '';
      if (typeof window === 'object') {
        PACKAGE_PATH = window['encodeURIComponent'](window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf('/')) + '/');
      } else if (typeof process === 'undefined' && typeof location !== 'undefined') {
        // web worker
        PACKAGE_PATH = encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf('/')) + '/');
      }
      var PACKAGE_NAME = 'postgres.data';
      var REMOTE_PACKAGE_BASE = 'postgres.data';
      if (typeof Module['locateFilePackage'] === 'function' && !Module['locateFile']) {
        Module['locateFile'] = Module['locateFilePackage'];
        err('warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)');
      }
      var REMOTE_PACKAGE_NAME = Module['locateFile'] ? Module['locateFile'](REMOTE_PACKAGE_BASE, '') : REMOTE_PACKAGE_BASE;
var REMOTE_PACKAGE_SIZE = metadata['remote_package_size'];

      function fetchRemotePackage(packageName, packageSize, callback, errback) {
        if (typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string') {
          require('fs').readFile(packageName, (err, contents) => {
            if (err) {
              errback(err);
            } else {
              callback(contents.buffer);
            }
          });
          return;
        }
        Module.dataFileDownloads ??= {};
        fetch(packageName)
          .catch((cause) => Promise.reject(new Error(`Network Error: ${packageName}`, {cause}))) // If fetch fails, rewrite the error to include the failing URL & the cause.
          .then((response) => {

            let loaded = 0;

            if (!response.ok) {
              return Promise.reject(new Error(`${response.status}: ${response.url}`));
            }

            // If we're using the polyfill, readers won't be available...
            if (!response.body && response.arrayBuffer) {
              response.arrayBuffer().then(callback);
              return;
            }

            const reader = response.body.getReader();
            const headers = response.headers;

            const size = headers.get('Content-Length') ?? packageSize;
            const chunks = [];

            const iterate = () => reader.read().then(handleChunk).catch((cause) => {
              return Promise.reject(new Error(`Unexpected error while handling : ${response.url} ${cause}`, {cause}));
            });

            const handleChunk = ({done, value}) => {
              if (!done) {
                chunks.push(value);
                loaded += value.length;
                Module.dataFileDownloads[packageName] = Module.dataFileDownloads[packageName] ?? {};
                Module.dataFileDownloads[packageName].loaded = loaded;
                Module.dataFileDownloads[packageName].total = size;

                let totalLoaded = 0;
                let totalSize = 0;

                for (const dowload of Object.values(Module.dataFileDownloads)) {
                  totalLoaded += dowload.loaded;
                  totalSize += dowload.total;
                }

                if (totalSize) {
                  if (Module['setStatus']) Module['setStatus'](`Downloading data... (${totalLoaded}/${totalSize})`);
                } else {
                  if (Module['setStatus']) Module['setStatus']('Downloading data...');
                }
                return iterate();
              } else {
                const packageData = new Uint8Array(chunks.map((c) => c.length).reduce((a, b) => a + b, 0));
                let offset = 0;
                for (const chunk of chunks) {
                  packageData.set(chunk, offset);
                  offset += chunk.length;
                }

                callback(packageData.buffer);
              }
            };
            return iterate();
          });
      };

      function handleError(error) {
        console.error('package error:', error);
      };

      var fetchedCallback = null;
      var fetched = Module['getPreloadedPackage'] ? Module['getPreloadedPackage'](REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null;

      if (!fetched) fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, (data) => {
        if (fetchedCallback) {
          fetchedCallback(data);
          fetchedCallback = null;
        } else {
          fetched = data;
        }
      }, handleError);

    function runWithFS(Module) {

      function assert(check, msg) {
        if (!check) throw msg + new Error().stack;
      }
Module['FS_createPath']("/", "home", true, true);
Module['FS_createPath']("/home", "web_user", true, true);
Module['FS_createPath']("/", "tmp", true, true);
Module['FS_createPath']("/tmp", "pglite", true, true);
Module['FS_createPath']("/tmp/pglite", "bin", true, true);
Module['FS_createPath']("/tmp/pglite", "lib", true, true);
Module['FS_createPath']("/tmp/pglite/lib", "postgresql", true, true);
Module['FS_createPath']("/tmp/pglite/lib/postgresql", "pgxs", true, true);
Module['FS_createPath']("/tmp/pglite/lib/postgresql/pgxs", "config", true, true);
Module['FS_createPath']("/tmp/pglite/lib/postgresql/pgxs", "src", true, true);
Module['FS_createPath']("/tmp/pglite/lib/postgresql/pgxs/src", "makefiles", true, true);
Module['FS_createPath']("/tmp/pglite/lib/postgresql/pgxs/src", "test", true, true);
Module['FS_createPath']("/tmp/pglite/lib/postgresql/pgxs/src/test", "isolation", true, true);
Module['FS_createPath']("/tmp/pglite/lib/postgresql/pgxs/src/test", "regress", true, true);
Module['FS_createPath']("/tmp/pglite", "share", true, true);
Module['FS_createPath']("/tmp/pglite/share", "postgresql", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql", "extension", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql", "timezone", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Africa", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "America", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone/America", "Argentina", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone/America", "Indiana", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone/America", "Kentucky", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone/America", "North_Dakota", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Antarctica", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Arctic", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Asia", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Atlantic", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Australia", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Brazil", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Canada", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Chile", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Etc", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Europe", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Indian", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Mexico", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "Pacific", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql/timezone", "US", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql", "timezonesets", true, true);
Module['FS_createPath']("/tmp/pglite/share/postgresql", "tsearch_data", true, true);

      /** @constructor */
      function DataRequest(start, end, audio) {
        this.start = start;
        this.end = end;
        this.audio = audio;
      }
      DataRequest.prototype = {
        requests: {},
        open: function(mode, name) {
          this.name = name;
          this.requests[name] = this;
          Module['addRunDependency'](`fp ${this.name}`);
        },
        send: function() {},
        onload: function() {
          var byteArray = this.byteArray.subarray(this.start, this.end);
          this.finish(byteArray);
        },
        finish: function(byteArray) {
          var that = this;
          // canOwn this data in the filesystem, it is a slide into the heap that will never change
          Module['FS_createDataFile'](this.name, null, byteArray, true, true, true);
          Module['removeRunDependency'](`fp ${that.name}`);
          this.requests[this.name] = null;
        }
      };

      var files = metadata['files'];
      for (var i = 0; i < files.length; ++i) {
        new DataRequest(files[i]['start'], files[i]['end'], files[i]['audio'] || 0).open('GET', files[i]['filename']);
      }

      function processPackageData(arrayBuffer) {
        assert(arrayBuffer, 'Loading data file failed.');
        assert(arrayBuffer.constructor.name === ArrayBuffer.name, 'bad input to processPackageData');
        var byteArray = new Uint8Array(arrayBuffer);
        var curr;
        // Reuse the bytearray from the XHR as the source for file reads.
          DataRequest.prototype.byteArray = byteArray;
          var files = metadata['files'];
          for (var i = 0; i < files.length; ++i) {
            DataRequest.prototype.requests[files[i].filename].onload();
          }          Module['removeRunDependency']('datafile_postgres.data');

      };
      Module['addRunDependency']('datafile_postgres.data');

      if (!Module['preloadResults']) Module['preloadResults'] = {};

      Module['preloadResults'][PACKAGE_NAME] = {fromCache: false};
      if (fetched) {
        processPackageData(fetched);
        fetched = null;
      } else {
        fetchedCallback = processPackageData;
      }

    }
    if (Module['calledRun']) {
      runWithFS(Module);
    } else {
      if (!Module['preRun']) Module['preRun'] = [];
      Module["preRun"].push(runWithFS); // FS is not initialized yet, wait for it
    }

    }
    loadPackage({"files": [{"filename": "/home/web_user/.pgpass", "start": 0, "end": 135}, {"filename": "/tmp/pglite/bin/initdb", "start": 135, "end": 147}, {"filename": "/tmp/pglite/bin/postgres", "start": 147, "end": 159}, {"filename": "/tmp/pglite/lib/postgresql/cyrillic_and_mic.so", "start": 159, "end": 5738}, {"filename": "/tmp/pglite/lib/postgresql/dict_snowball.so", "start": 5738, "end": 580797}, {"filename": "/tmp/pglite/lib/postgresql/euc2004_sjis2004.so", "start": 580797, "end": 583175}, {"filename": "/tmp/pglite/lib/postgresql/euc_cn_and_mic.so", "start": 583175, "end": 584442}, {"filename": "/tmp/pglite/lib/postgresql/euc_jp_and_sjis.so", "start": 584442, "end": 592205}, {"filename": "/tmp/pglite/lib/postgresql/euc_kr_and_mic.so", "start": 592205, "end": 593512}, {"filename": "/tmp/pglite/lib/postgresql/euc_tw_and_big5.so", "start": 593512, "end": 598627}, {"filename": "/tmp/pglite/lib/postgresql/latin2_and_win1250.so", "start": 598627, "end": 600572}, {"filename": "/tmp/pglite/lib/postgresql/latin_and_mic.so", "start": 600572, "end": 602045}, {"filename": "/tmp/pglite/lib/postgresql/libpqwalreceiver.so", "start": 602045, "end": 725218}, {"filename": "/tmp/pglite/lib/postgresql/pgoutput.so", "start": 725218, "end": 741288}, {"filename": "/tmp/pglite/lib/postgresql/pgxs/config/install-sh", "start": 741288, "end": 755285}, {"filename": "/tmp/pglite/lib/postgresql/pgxs/config/missing", "start": 755285, "end": 756633}, {"filename": "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.global", "start": 756633, "end": 792638}, {"filename": "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.port", "start": 792638, "end": 792914}, {"filename": "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.shlib", "start": 792914, "end": 808952}, {"filename": "/tmp/pglite/lib/postgresql/pgxs/src/makefiles/pgxs.mk", "start": 808952, "end": 823880}, {"filename": "/tmp/pglite/lib/postgresql/pgxs/src/nls-global.mk", "start": 823880, "end": 830765}, {"filename": "/tmp/pglite/lib/postgresql/pgxs/src/test/isolation/isolationtester.cjs", "start": 830765, "end": 927082}, {"filename": "/tmp/pglite/lib/postgresql/pgxs/src/test/isolation/pg_isolation_regress.cjs", "start": 927082, "end": 1003635}, {"filename": "/tmp/pglite/lib/postgresql/pgxs/src/test/regress/pg_regress.cjs", "start": 1003635, "end": 1080178}, {"filename": "/tmp/pglite/lib/postgresql/plpgsql.so", "start": 1080178, "end": 1239222}, {"filename": "/tmp/pglite/password", "start": 1239222, "end": 1239231}, {"filename": "/tmp/pglite/share/postgresql/errcodes.txt", "start": 1239231, "end": 1272689}, {"filename": "/tmp/pglite/share/postgresql/extension/plpgsql--1.0.sql", "start": 1272689, "end": 1273347}, {"filename": "/tmp/pglite/share/postgresql/extension/plpgsql.control", "start": 1273347, "end": 1273540}, {"filename": "/tmp/pglite/share/postgresql/fix-CVE-2024-4317.sql", "start": 1273540, "end": 1279305}, {"filename": "/tmp/pglite/share/postgresql/information_schema.sql", "start": 1279305, "end": 1394280}, {"filename": "/tmp/pglite/share/postgresql/pg_hba.conf.sample", "start": 1394280, "end": 1399905}, {"filename": "/tmp/pglite/share/postgresql/pg_ident.conf.sample", "start": 1399905, "end": 1402545}, {"filename": "/tmp/pglite/share/postgresql/pg_service.conf.sample", "start": 1402545, "end": 1403149}, {"filename": "/tmp/pglite/share/postgresql/postgres.bki", "start": 1403149, "end": 2347253}, {"filename": "/tmp/pglite/share/postgresql/postgresql.conf.sample", "start": 2347253, "end": 2376900}, {"filename": "/tmp/pglite/share/postgresql/psqlrc.sample", "start": 2376900, "end": 2377178}, {"filename": "/tmp/pglite/share/postgresql/snowball_create.sql", "start": 2377178, "end": 2421354}, {"filename": "/tmp/pglite/share/postgresql/sql_features.txt", "start": 2421354, "end": 2457035}, {"filename": "/tmp/pglite/share/postgresql/system_constraints.sql", "start": 2457035, "end": 2465930}, {"filename": "/tmp/pglite/share/postgresql/system_functions.sql", "start": 2465930, "end": 2489245}, {"filename": "/tmp/pglite/share/postgresql/system_views.sql", "start": 2489245, "end": 2539518}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Abidjan", "start": 2539518, "end": 2539648}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Accra", "start": 2539648, "end": 2539778}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Addis_Ababa", "start": 2539778, "end": 2539969}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Algiers", "start": 2539969, "end": 2540439}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Asmara", "start": 2540439, "end": 2540630}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Asmera", "start": 2540630, "end": 2540821}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Bamako", "start": 2540821, "end": 2540951}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Bangui", "start": 2540951, "end": 2541131}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Banjul", "start": 2541131, "end": 2541261}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Bissau", "start": 2541261, "end": 2541410}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Blantyre", "start": 2541410, "end": 2541541}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Brazzaville", "start": 2541541, "end": 2541721}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Bujumbura", "start": 2541721, "end": 2541852}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Cairo", "start": 2541852, "end": 2543161}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Casablanca", "start": 2543161, "end": 2545080}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Ceuta", "start": 2545080, "end": 2545642}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Conakry", "start": 2545642, "end": 2545772}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Dakar", "start": 2545772, "end": 2545902}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Dar_es_Salaam", "start": 2545902, "end": 2546093}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Djibouti", "start": 2546093, "end": 2546284}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Douala", "start": 2546284, "end": 2546464}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/El_Aaiun", "start": 2546464, "end": 2548294}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Freetown", "start": 2548294, "end": 2548424}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Gaborone", "start": 2548424, "end": 2548555}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Harare", "start": 2548555, "end": 2548686}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Johannesburg", "start": 2548686, "end": 2548876}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Juba", "start": 2548876, "end": 2549334}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Kampala", "start": 2549334, "end": 2549525}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Khartoum", "start": 2549525, "end": 2549983}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Kigali", "start": 2549983, "end": 2550114}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Kinshasa", "start": 2550114, "end": 2550294}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Lagos", "start": 2550294, "end": 2550474}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Libreville", "start": 2550474, "end": 2550654}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Lome", "start": 2550654, "end": 2550784}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Luanda", "start": 2550784, "end": 2550964}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Lubumbashi", "start": 2550964, "end": 2551095}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Lusaka", "start": 2551095, "end": 2551226}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Malabo", "start": 2551226, "end": 2551406}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Maputo", "start": 2551406, "end": 2551537}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Maseru", "start": 2551537, "end": 2551727}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Mbabane", "start": 2551727, "end": 2551917}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Mogadishu", "start": 2551917, "end": 2552108}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Monrovia", "start": 2552108, "end": 2552272}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Nairobi", "start": 2552272, "end": 2552463}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Ndjamena", "start": 2552463, "end": 2552623}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Niamey", "start": 2552623, "end": 2552803}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Nouakchott", "start": 2552803, "end": 2552933}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Ouagadougou", "start": 2552933, "end": 2553063}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Porto-Novo", "start": 2553063, "end": 2553243}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Sao_Tome", "start": 2553243, "end": 2553416}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Timbuktu", "start": 2553416, "end": 2553546}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Tripoli", "start": 2553546, "end": 2553977}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Tunis", "start": 2553977, "end": 2554426}, {"filename": "/tmp/pglite/share/postgresql/timezone/Africa/Windhoek", "start": 2554426, "end": 2555064}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Adak", "start": 2555064, "end": 2556033}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Anchorage", "start": 2556033, "end": 2557010}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Anguilla", "start": 2557010, "end": 2557187}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Antigua", "start": 2557187, "end": 2557364}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Araguaina", "start": 2557364, "end": 2557956}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Buenos_Aires", "start": 2557956, "end": 2558664}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Catamarca", "start": 2558664, "end": 2559372}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/ComodRivadavia", "start": 2559372, "end": 2560080}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Cordoba", "start": 2560080, "end": 2560788}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Jujuy", "start": 2560788, "end": 2561478}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/La_Rioja", "start": 2561478, "end": 2562195}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Mendoza", "start": 2562195, "end": 2562903}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Rio_Gallegos", "start": 2562903, "end": 2563611}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Salta", "start": 2563611, "end": 2564301}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/San_Juan", "start": 2564301, "end": 2565018}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/San_Luis", "start": 2565018, "end": 2565735}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Tucuman", "start": 2565735, "end": 2566461}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Argentina/Ushuaia", "start": 2566461, "end": 2567169}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Aruba", "start": 2567169, "end": 2567346}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Asuncion", "start": 2567346, "end": 2568230}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Atikokan", "start": 2568230, "end": 2568379}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Atka", "start": 2568379, "end": 2569348}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Bahia", "start": 2569348, "end": 2570030}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Bahia_Banderas", "start": 2570030, "end": 2570758}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Barbados", "start": 2570758, "end": 2571036}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Belem", "start": 2571036, "end": 2571430}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Belize", "start": 2571430, "end": 2572475}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Blanc-Sablon", "start": 2572475, "end": 2572652}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Boa_Vista", "start": 2572652, "end": 2573082}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Bogota", "start": 2573082, "end": 2573261}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Boise", "start": 2573261, "end": 2574260}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Buenos_Aires", "start": 2574260, "end": 2574968}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Cambridge_Bay", "start": 2574968, "end": 2575851}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Campo_Grande", "start": 2575851, "end": 2576803}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Cancun", "start": 2576803, "end": 2577332}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Caracas", "start": 2577332, "end": 2577522}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Catamarca", "start": 2577522, "end": 2578230}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Cayenne", "start": 2578230, "end": 2578381}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Cayman", "start": 2578381, "end": 2578530}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Chicago", "start": 2578530, "end": 2580284}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Chihuahua", "start": 2580284, "end": 2580975}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Ciudad_Juarez", "start": 2580975, "end": 2581693}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Coral_Harbour", "start": 2581693, "end": 2581842}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Cordoba", "start": 2581842, "end": 2582550}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Costa_Rica", "start": 2582550, "end": 2582782}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Creston", "start": 2582782, "end": 2583022}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Cuiaba", "start": 2583022, "end": 2583956}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Curacao", "start": 2583956, "end": 2584133}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Danmarkshavn", "start": 2584133, "end": 2584580}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Dawson", "start": 2584580, "end": 2585609}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Dawson_Creek", "start": 2585609, "end": 2586292}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Denver", "start": 2586292, "end": 2587334}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Detroit", "start": 2587334, "end": 2588233}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Dominica", "start": 2588233, "end": 2588410}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Edmonton", "start": 2588410, "end": 2589380}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Eirunepe", "start": 2589380, "end": 2589816}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/El_Salvador", "start": 2589816, "end": 2589992}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Ensenada", "start": 2589992, "end": 2591017}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Fort_Nelson", "start": 2591017, "end": 2592465}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Fort_Wayne", "start": 2592465, "end": 2592996}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Fortaleza", "start": 2592996, "end": 2593480}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Glace_Bay", "start": 2593480, "end": 2594360}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Godthab", "start": 2594360, "end": 2595325}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Goose_Bay", "start": 2595325, "end": 2596905}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Grand_Turk", "start": 2596905, "end": 2597758}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Grenada", "start": 2597758, "end": 2597935}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Guadeloupe", "start": 2597935, "end": 2598112}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Guatemala", "start": 2598112, "end": 2598324}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Guayaquil", "start": 2598324, "end": 2598503}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Guyana", "start": 2598503, "end": 2598684}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Halifax", "start": 2598684, "end": 2600356}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Havana", "start": 2600356, "end": 2601473}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Hermosillo", "start": 2601473, "end": 2601759}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Indianapolis", "start": 2601759, "end": 2602290}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Knox", "start": 2602290, "end": 2603306}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Marengo", "start": 2603306, "end": 2603873}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Petersburg", "start": 2603873, "end": 2604556}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Tell_City", "start": 2604556, "end": 2605078}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Vevay", "start": 2605078, "end": 2605447}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Vincennes", "start": 2605447, "end": 2606005}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Indiana/Winamac", "start": 2606005, "end": 2606617}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Indianapolis", "start": 2606617, "end": 2607148}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Inuvik", "start": 2607148, "end": 2607965}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Iqaluit", "start": 2607965, "end": 2608820}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Jamaica", "start": 2608820, "end": 2609159}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Jujuy", "start": 2609159, "end": 2609849}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Juneau", "start": 2609849, "end": 2610815}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Kentucky/Louisville", "start": 2610815, "end": 2612057}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Kentucky/Monticello", "start": 2612057, "end": 2613029}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Knox_IN", "start": 2613029, "end": 2614045}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Kralendijk", "start": 2614045, "end": 2614222}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/La_Paz", "start": 2614222, "end": 2614392}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Lima", "start": 2614392, "end": 2614675}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Los_Angeles", "start": 2614675, "end": 2615969}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Louisville", "start": 2615969, "end": 2617211}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Lower_Princes", "start": 2617211, "end": 2617388}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Maceio", "start": 2617388, "end": 2617890}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Managua", "start": 2617890, "end": 2618185}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Manaus", "start": 2618185, "end": 2618597}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Marigot", "start": 2618597, "end": 2618774}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Martinique", "start": 2618774, "end": 2618952}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Matamoros", "start": 2618952, "end": 2619389}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Mazatlan", "start": 2619389, "end": 2620107}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Mendoza", "start": 2620107, "end": 2620815}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Menominee", "start": 2620815, "end": 2621732}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Merida", "start": 2621732, "end": 2622386}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Metlakatla", "start": 2622386, "end": 2622981}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Mexico_City", "start": 2622981, "end": 2623754}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Miquelon", "start": 2623754, "end": 2624304}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Moncton", "start": 2624304, "end": 2625797}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Monterrey", "start": 2625797, "end": 2626441}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Montevideo", "start": 2626441, "end": 2627410}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Montreal", "start": 2627410, "end": 2629127}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Montserrat", "start": 2629127, "end": 2629304}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Nassau", "start": 2629304, "end": 2631021}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/New_York", "start": 2631021, "end": 2632765}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Nipigon", "start": 2632765, "end": 2634482}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Nome", "start": 2634482, "end": 2635457}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Noronha", "start": 2635457, "end": 2635941}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/Beulah", "start": 2635941, "end": 2636984}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/Center", "start": 2636984, "end": 2637974}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/New_Salem", "start": 2637974, "end": 2638964}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Nuuk", "start": 2638964, "end": 2639929}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Ojinaga", "start": 2639929, "end": 2640638}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Panama", "start": 2640638, "end": 2640787}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Pangnirtung", "start": 2640787, "end": 2641642}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Paramaribo", "start": 2641642, "end": 2641829}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Phoenix", "start": 2641829, "end": 2642069}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Port-au-Prince", "start": 2642069, "end": 2642634}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Port_of_Spain", "start": 2642634, "end": 2642811}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Porto_Acre", "start": 2642811, "end": 2643229}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Porto_Velho", "start": 2643229, "end": 2643623}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Puerto_Rico", "start": 2643623, "end": 2643800}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Punta_Arenas", "start": 2643800, "end": 2645018}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Rainy_River", "start": 2645018, "end": 2646312}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Rankin_Inlet", "start": 2646312, "end": 2647119}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Recife", "start": 2647119, "end": 2647603}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Regina", "start": 2647603, "end": 2648241}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Resolute", "start": 2648241, "end": 2649048}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Rio_Branco", "start": 2649048, "end": 2649466}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Rosario", "start": 2649466, "end": 2650174}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Santa_Isabel", "start": 2650174, "end": 2651199}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Santarem", "start": 2651199, "end": 2651608}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Santiago", "start": 2651608, "end": 2652962}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Santo_Domingo", "start": 2652962, "end": 2653279}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Sao_Paulo", "start": 2653279, "end": 2654231}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Scoresbysund", "start": 2654231, "end": 2655215}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Shiprock", "start": 2655215, "end": 2656257}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Sitka", "start": 2656257, "end": 2657213}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/St_Barthelemy", "start": 2657213, "end": 2657390}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/St_Johns", "start": 2657390, "end": 2659268}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/St_Kitts", "start": 2659268, "end": 2659445}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/St_Lucia", "start": 2659445, "end": 2659622}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/St_Thomas", "start": 2659622, "end": 2659799}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/St_Vincent", "start": 2659799, "end": 2659976}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Swift_Current", "start": 2659976, "end": 2660344}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Tegucigalpa", "start": 2660344, "end": 2660538}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Thule", "start": 2660538, "end": 2660993}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Thunder_Bay", "start": 2660993, "end": 2662710}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Tijuana", "start": 2662710, "end": 2663735}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Toronto", "start": 2663735, "end": 2665452}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Tortola", "start": 2665452, "end": 2665629}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Vancouver", "start": 2665629, "end": 2666959}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Virgin", "start": 2666959, "end": 2667136}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Whitehorse", "start": 2667136, "end": 2668165}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Winnipeg", "start": 2668165, "end": 2669459}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Yakutat", "start": 2669459, "end": 2670405}, {"filename": "/tmp/pglite/share/postgresql/timezone/America/Yellowknife", "start": 2670405, "end": 2671375}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Casey", "start": 2671375, "end": 2671662}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Davis", "start": 2671662, "end": 2671859}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/DumontDUrville", "start": 2671859, "end": 2672013}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Macquarie", "start": 2672013, "end": 2672989}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Mawson", "start": 2672989, "end": 2673141}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/McMurdo", "start": 2673141, "end": 2674184}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Palmer", "start": 2674184, "end": 2675071}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Rothera", "start": 2675071, "end": 2675203}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/South_Pole", "start": 2675203, "end": 2676246}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Syowa", "start": 2676246, "end": 2676379}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Troll", "start": 2676379, "end": 2676556}, {"filename": "/tmp/pglite/share/postgresql/timezone/Antarctica/Vostok", "start": 2676556, "end": 2676726}, {"filename": "/tmp/pglite/share/postgresql/timezone/Arctic/Longyearbyen", "start": 2676726, "end": 2677431}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Aden", "start": 2677431, "end": 2677564}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Almaty", "start": 2677564, "end": 2678182}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Amman", "start": 2678182, "end": 2679110}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Anadyr", "start": 2679110, "end": 2679853}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Aqtau", "start": 2679853, "end": 2680459}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Aqtobe", "start": 2680459, "end": 2681074}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ashgabat", "start": 2681074, "end": 2681449}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ashkhabad", "start": 2681449, "end": 2681824}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Atyrau", "start": 2681824, "end": 2682440}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Baghdad", "start": 2682440, "end": 2683070}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Bahrain", "start": 2683070, "end": 2683222}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Baku", "start": 2683222, "end": 2683966}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Bangkok", "start": 2683966, "end": 2684118}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Barnaul", "start": 2684118, "end": 2684871}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Beirut", "start": 2684871, "end": 2685603}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Bishkek", "start": 2685603, "end": 2686221}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Brunei", "start": 2686221, "end": 2686541}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Calcutta", "start": 2686541, "end": 2686761}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Chita", "start": 2686761, "end": 2687511}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Choibalsan", "start": 2687511, "end": 2688130}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Chongqing", "start": 2688130, "end": 2688523}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Chungking", "start": 2688523, "end": 2688916}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Colombo", "start": 2688916, "end": 2689163}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Dacca", "start": 2689163, "end": 2689394}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Damascus", "start": 2689394, "end": 2690628}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Dhaka", "start": 2690628, "end": 2690859}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Dili", "start": 2690859, "end": 2691029}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Dubai", "start": 2691029, "end": 2691162}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Dushanbe", "start": 2691162, "end": 2691528}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Famagusta", "start": 2691528, "end": 2692468}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Gaza", "start": 2692468, "end": 2694914}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Harbin", "start": 2694914, "end": 2695307}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Hebron", "start": 2695307, "end": 2697771}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ho_Chi_Minh", "start": 2697771, "end": 2698007}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Hong_Kong", "start": 2698007, "end": 2698782}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Hovd", "start": 2698782, "end": 2699376}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Irkutsk", "start": 2699376, "end": 2700136}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Istanbul", "start": 2700136, "end": 2701336}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Jakarta", "start": 2701336, "end": 2701584}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Jayapura", "start": 2701584, "end": 2701755}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Jerusalem", "start": 2701755, "end": 2702829}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kabul", "start": 2702829, "end": 2702988}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kamchatka", "start": 2702988, "end": 2703715}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Karachi", "start": 2703715, "end": 2703981}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kashgar", "start": 2703981, "end": 2704114}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kathmandu", "start": 2704114, "end": 2704275}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Katmandu", "start": 2704275, "end": 2704436}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Khandyga", "start": 2704436, "end": 2705211}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kolkata", "start": 2705211, "end": 2705431}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Krasnoyarsk", "start": 2705431, "end": 2706172}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kuala_Lumpur", "start": 2706172, "end": 2706428}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kuching", "start": 2706428, "end": 2706748}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Kuwait", "start": 2706748, "end": 2706881}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Macao", "start": 2706881, "end": 2707672}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Macau", "start": 2707672, "end": 2708463}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Magadan", "start": 2708463, "end": 2709214}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Makassar", "start": 2709214, "end": 2709404}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Manila", "start": 2709404, "end": 2709642}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Muscat", "start": 2709642, "end": 2709775}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Nicosia", "start": 2709775, "end": 2710372}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Novokuznetsk", "start": 2710372, "end": 2711098}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Novosibirsk", "start": 2711098, "end": 2711851}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Omsk", "start": 2711851, "end": 2712592}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Oral", "start": 2712592, "end": 2713217}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Phnom_Penh", "start": 2713217, "end": 2713369}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Pontianak", "start": 2713369, "end": 2713616}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Pyongyang", "start": 2713616, "end": 2713799}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Qatar", "start": 2713799, "end": 2713951}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Qostanay", "start": 2713951, "end": 2714575}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Qyzylorda", "start": 2714575, "end": 2715199}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Rangoon", "start": 2715199, "end": 2715386}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Riyadh", "start": 2715386, "end": 2715519}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Saigon", "start": 2715519, "end": 2715755}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Sakhalin", "start": 2715755, "end": 2716510}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Samarkand", "start": 2716510, "end": 2716876}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Seoul", "start": 2716876, "end": 2717291}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Shanghai", "start": 2717291, "end": 2717684}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Singapore", "start": 2717684, "end": 2717940}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Srednekolymsk", "start": 2717940, "end": 2718682}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Taipei", "start": 2718682, "end": 2719193}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tashkent", "start": 2719193, "end": 2719559}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tbilisi", "start": 2719559, "end": 2720188}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tehran", "start": 2720188, "end": 2721000}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tel_Aviv", "start": 2721000, "end": 2722074}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Thimbu", "start": 2722074, "end": 2722228}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Thimphu", "start": 2722228, "end": 2722382}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tokyo", "start": 2722382, "end": 2722595}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Tomsk", "start": 2722595, "end": 2723348}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ujung_Pandang", "start": 2723348, "end": 2723538}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ulaanbaatar", "start": 2723538, "end": 2724132}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ulan_Bator", "start": 2724132, "end": 2724726}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Urumqi", "start": 2724726, "end": 2724859}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Ust-Nera", "start": 2724859, "end": 2725630}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Vientiane", "start": 2725630, "end": 2725782}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Vladivostok", "start": 2725782, "end": 2726524}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Yakutsk", "start": 2726524, "end": 2727265}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Yangon", "start": 2727265, "end": 2727452}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Yekaterinburg", "start": 2727452, "end": 2728212}, {"filename": "/tmp/pglite/share/postgresql/timezone/Asia/Yerevan", "start": 2728212, "end": 2728920}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Azores", "start": 2728920, "end": 2730373}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Bermuda", "start": 2730373, "end": 2731397}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Canary", "start": 2731397, "end": 2731875}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Cape_Verde", "start": 2731875, "end": 2732050}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Faeroe", "start": 2732050, "end": 2732491}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Faroe", "start": 2732491, "end": 2732932}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Jan_Mayen", "start": 2732932, "end": 2733637}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Madeira", "start": 2733637, "end": 2735090}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Reykjavik", "start": 2735090, "end": 2735220}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/South_Georgia", "start": 2735220, "end": 2735352}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/St_Helena", "start": 2735352, "end": 2735482}, {"filename": "/tmp/pglite/share/postgresql/timezone/Atlantic/Stanley", "start": 2735482, "end": 2736271}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/ACT", "start": 2736271, "end": 2737175}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Adelaide", "start": 2737175, "end": 2738096}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Brisbane", "start": 2738096, "end": 2738385}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Broken_Hill", "start": 2738385, "end": 2739326}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Canberra", "start": 2739326, "end": 2740230}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Currie", "start": 2740230, "end": 2741233}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Darwin", "start": 2741233, "end": 2741467}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Eucla", "start": 2741467, "end": 2741781}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Hobart", "start": 2741781, "end": 2742784}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/LHI", "start": 2742784, "end": 2743476}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Lindeman", "start": 2743476, "end": 2743801}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Lord_Howe", "start": 2743801, "end": 2744493}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Melbourne", "start": 2744493, "end": 2745397}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/NSW", "start": 2745397, "end": 2746301}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/North", "start": 2746301, "end": 2746535}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Perth", "start": 2746535, "end": 2746841}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Queensland", "start": 2746841, "end": 2747130}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/South", "start": 2747130, "end": 2748051}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Sydney", "start": 2748051, "end": 2748955}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Tasmania", "start": 2748955, "end": 2749958}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Victoria", "start": 2749958, "end": 2750862}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/West", "start": 2750862, "end": 2751168}, {"filename": "/tmp/pglite/share/postgresql/timezone/Australia/Yancowinna", "start": 2751168, "end": 2752109}, {"filename": "/tmp/pglite/share/postgresql/timezone/Brazil/Acre", "start": 2752109, "end": 2752527}, {"filename": "/tmp/pglite/share/postgresql/timezone/Brazil/DeNoronha", "start": 2752527, "end": 2753011}, {"filename": "/tmp/pglite/share/postgresql/timezone/Brazil/East", "start": 2753011, "end": 2753963}, {"filename": "/tmp/pglite/share/postgresql/timezone/Brazil/West", "start": 2753963, "end": 2754375}, {"filename": "/tmp/pglite/share/postgresql/timezone/CET", "start": 2754375, "end": 2754996}, {"filename": "/tmp/pglite/share/postgresql/timezone/CST6CDT", "start": 2754996, "end": 2755947}, {"filename": "/tmp/pglite/share/postgresql/timezone/Canada/Atlantic", "start": 2755947, "end": 2757619}, {"filename": "/tmp/pglite/share/postgresql/timezone/Canada/Central", "start": 2757619, "end": 2758913}, {"filename": "/tmp/pglite/share/postgresql/timezone/Canada/Eastern", "start": 2758913, "end": 2760630}, {"filename": "/tmp/pglite/share/postgresql/timezone/Canada/Mountain", "start": 2760630, "end": 2761600}, {"filename": "/tmp/pglite/share/postgresql/timezone/Canada/Newfoundland", "start": 2761600, "end": 2763478}, {"filename": "/tmp/pglite/share/postgresql/timezone/Canada/Pacific", "start": 2763478, "end": 2764808}, {"filename": "/tmp/pglite/share/postgresql/timezone/Canada/Saskatchewan", "start": 2764808, "end": 2765446}, {"filename": "/tmp/pglite/share/postgresql/timezone/Canada/Yukon", "start": 2765446, "end": 2766475}, {"filename": "/tmp/pglite/share/postgresql/timezone/Chile/Continental", "start": 2766475, "end": 2767829}, {"filename": "/tmp/pglite/share/postgresql/timezone/Chile/EasterIsland", "start": 2767829, "end": 2769003}, {"filename": "/tmp/pglite/share/postgresql/timezone/Cuba", "start": 2769003, "end": 2770120}, {"filename": "/tmp/pglite/share/postgresql/timezone/EET", "start": 2770120, "end": 2770617}, {"filename": "/tmp/pglite/share/postgresql/timezone/EST", "start": 2770617, "end": 2770728}, {"filename": "/tmp/pglite/share/postgresql/timezone/EST5EDT", "start": 2770728, "end": 2771679}, {"filename": "/tmp/pglite/share/postgresql/timezone/Egypt", "start": 2771679, "end": 2772988}, {"filename": "/tmp/pglite/share/postgresql/timezone/Eire", "start": 2772988, "end": 2774484}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT", "start": 2774484, "end": 2774595}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+0", "start": 2774595, "end": 2774706}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+1", "start": 2774706, "end": 2774819}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+10", "start": 2774819, "end": 2774933}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+11", "start": 2774933, "end": 2775047}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+12", "start": 2775047, "end": 2775161}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+2", "start": 2775161, "end": 2775274}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+3", "start": 2775274, "end": 2775387}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+4", "start": 2775387, "end": 2775500}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+5", "start": 2775500, "end": 2775613}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+6", "start": 2775613, "end": 2775726}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+7", "start": 2775726, "end": 2775839}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+8", "start": 2775839, "end": 2775952}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT+9", "start": 2775952, "end": 2776065}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-0", "start": 2776065, "end": 2776176}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-1", "start": 2776176, "end": 2776290}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-10", "start": 2776290, "end": 2776405}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-11", "start": 2776405, "end": 2776520}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-12", "start": 2776520, "end": 2776635}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-13", "start": 2776635, "end": 2776750}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-14", "start": 2776750, "end": 2776865}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-2", "start": 2776865, "end": 2776979}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-3", "start": 2776979, "end": 2777093}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-4", "start": 2777093, "end": 2777207}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-5", "start": 2777207, "end": 2777321}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-6", "start": 2777321, "end": 2777435}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-7", "start": 2777435, "end": 2777549}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-8", "start": 2777549, "end": 2777663}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT-9", "start": 2777663, "end": 2777777}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/GMT0", "start": 2777777, "end": 2777888}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/Greenwich", "start": 2777888, "end": 2777999}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/UCT", "start": 2777999, "end": 2778110}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/UTC", "start": 2778110, "end": 2778221}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/Universal", "start": 2778221, "end": 2778332}, {"filename": "/tmp/pglite/share/postgresql/timezone/Etc/Zulu", "start": 2778332, "end": 2778443}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Amsterdam", "start": 2778443, "end": 2779546}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Andorra", "start": 2779546, "end": 2779935}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Astrakhan", "start": 2779935, "end": 2780661}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Athens", "start": 2780661, "end": 2781343}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Belfast", "start": 2781343, "end": 2782942}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Belgrade", "start": 2782942, "end": 2783420}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Berlin", "start": 2783420, "end": 2784125}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Bratislava", "start": 2784125, "end": 2784848}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Brussels", "start": 2784848, "end": 2785951}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Bucharest", "start": 2785951, "end": 2786612}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Budapest", "start": 2786612, "end": 2787378}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Busingen", "start": 2787378, "end": 2787875}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Chisinau", "start": 2787875, "end": 2788630}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Copenhagen", "start": 2788630, "end": 2789335}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Dublin", "start": 2789335, "end": 2790831}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Gibraltar", "start": 2790831, "end": 2792051}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Guernsey", "start": 2792051, "end": 2793650}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Helsinki", "start": 2793650, "end": 2794131}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Isle_of_Man", "start": 2794131, "end": 2795730}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Istanbul", "start": 2795730, "end": 2796930}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Jersey", "start": 2796930, "end": 2798529}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Kaliningrad", "start": 2798529, "end": 2799433}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Kiev", "start": 2799433, "end": 2799991}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Kirov", "start": 2799991, "end": 2800726}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Kyiv", "start": 2800726, "end": 2801284}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Lisbon", "start": 2801284, "end": 2802738}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Ljubljana", "start": 2802738, "end": 2803216}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/London", "start": 2803216, "end": 2804815}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Luxembourg", "start": 2804815, "end": 2805918}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Madrid", "start": 2805918, "end": 2806815}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Malta", "start": 2806815, "end": 2807743}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Mariehamn", "start": 2807743, "end": 2808224}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Minsk", "start": 2808224, "end": 2809032}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Monaco", "start": 2809032, "end": 2810137}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Moscow", "start": 2810137, "end": 2811045}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Nicosia", "start": 2811045, "end": 2811642}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Oslo", "start": 2811642, "end": 2812347}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Paris", "start": 2812347, "end": 2813452}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Podgorica", "start": 2813452, "end": 2813930}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Prague", "start": 2813930, "end": 2814653}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Riga", "start": 2814653, "end": 2815347}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Rome", "start": 2815347, "end": 2816294}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Samara", "start": 2816294, "end": 2817026}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/San_Marino", "start": 2817026, "end": 2817973}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Sarajevo", "start": 2817973, "end": 2818451}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Saratov", "start": 2818451, "end": 2819177}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Simferopol", "start": 2819177, "end": 2820042}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Skopje", "start": 2820042, "end": 2820520}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Sofia", "start": 2820520, "end": 2821112}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Stockholm", "start": 2821112, "end": 2821817}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Tallinn", "start": 2821817, "end": 2822492}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Tirane", "start": 2822492, "end": 2823096}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Tiraspol", "start": 2823096, "end": 2823851}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Ulyanovsk", "start": 2823851, "end": 2824611}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Uzhgorod", "start": 2824611, "end": 2825169}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Vaduz", "start": 2825169, "end": 2825666}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Vatican", "start": 2825666, "end": 2826613}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Vienna", "start": 2826613, "end": 2827271}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Vilnius", "start": 2827271, "end": 2827947}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Volgograd", "start": 2827947, "end": 2828700}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Warsaw", "start": 2828700, "end": 2829623}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Zagreb", "start": 2829623, "end": 2830101}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Zaporozhye", "start": 2830101, "end": 2830659}, {"filename": "/tmp/pglite/share/postgresql/timezone/Europe/Zurich", "start": 2830659, "end": 2831156}, {"filename": "/tmp/pglite/share/postgresql/timezone/Factory", "start": 2831156, "end": 2831269}, {"filename": "/tmp/pglite/share/postgresql/timezone/GB", "start": 2831269, "end": 2832868}, {"filename": "/tmp/pglite/share/postgresql/timezone/GB-Eire", "start": 2832868, "end": 2834467}, {"filename": "/tmp/pglite/share/postgresql/timezone/GMT", "start": 2834467, "end": 2834578}, {"filename": "/tmp/pglite/share/postgresql/timezone/GMT+0", "start": 2834578, "end": 2834689}, {"filename": "/tmp/pglite/share/postgresql/timezone/GMT-0", "start": 2834689, "end": 2834800}, {"filename": "/tmp/pglite/share/postgresql/timezone/GMT0", "start": 2834800, "end": 2834911}, {"filename": "/tmp/pglite/share/postgresql/timezone/Greenwich", "start": 2834911, "end": 2835022}, {"filename": "/tmp/pglite/share/postgresql/timezone/HST", "start": 2835022, "end": 2835134}, {"filename": "/tmp/pglite/share/postgresql/timezone/Hongkong", "start": 2835134, "end": 2835909}, {"filename": "/tmp/pglite/share/postgresql/timezone/Iceland", "start": 2835909, "end": 2836039}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Antananarivo", "start": 2836039, "end": 2836230}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Chagos", "start": 2836230, "end": 2836382}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Christmas", "start": 2836382, "end": 2836534}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Cocos", "start": 2836534, "end": 2836721}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Comoro", "start": 2836721, "end": 2836912}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Kerguelen", "start": 2836912, "end": 2837064}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Mahe", "start": 2837064, "end": 2837197}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Maldives", "start": 2837197, "end": 2837349}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Mauritius", "start": 2837349, "end": 2837528}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Mayotte", "start": 2837528, "end": 2837719}, {"filename": "/tmp/pglite/share/postgresql/timezone/Indian/Reunion", "start": 2837719, "end": 2837852}, {"filename": "/tmp/pglite/share/postgresql/timezone/Iran", "start": 2837852, "end": 2838664}, {"filename": "/tmp/pglite/share/postgresql/timezone/Israel", "start": 2838664, "end": 2839738}, {"filename": "/tmp/pglite/share/postgresql/timezone/Jamaica", "start": 2839738, "end": 2840077}, {"filename": "/tmp/pglite/share/postgresql/timezone/Japan", "start": 2840077, "end": 2840290}, {"filename": "/tmp/pglite/share/postgresql/timezone/Kwajalein", "start": 2840290, "end": 2840509}, {"filename": "/tmp/pglite/share/postgresql/timezone/Libya", "start": 2840509, "end": 2840940}, {"filename": "/tmp/pglite/share/postgresql/timezone/MET", "start": 2840940, "end": 2841561}, {"filename": "/tmp/pglite/share/postgresql/timezone/MST", "start": 2841561, "end": 2841672}, {"filename": "/tmp/pglite/share/postgresql/timezone/MST7MDT", "start": 2841672, "end": 2842623}, {"filename": "/tmp/pglite/share/postgresql/timezone/Mexico/BajaNorte", "start": 2842623, "end": 2843648}, {"filename": "/tmp/pglite/share/postgresql/timezone/Mexico/BajaSur", "start": 2843648, "end": 2844366}, {"filename": "/tmp/pglite/share/postgresql/timezone/Mexico/General", "start": 2844366, "end": 2845139}, {"filename": "/tmp/pglite/share/postgresql/timezone/NZ", "start": 2845139, "end": 2846182}, {"filename": "/tmp/pglite/share/postgresql/timezone/NZ-CHAT", "start": 2846182, "end": 2846990}, {"filename": "/tmp/pglite/share/postgresql/timezone/Navajo", "start": 2846990, "end": 2848032}, {"filename": "/tmp/pglite/share/postgresql/timezone/PRC", "start": 2848032, "end": 2848425}, {"filename": "/tmp/pglite/share/postgresql/timezone/PST8PDT", "start": 2848425, "end": 2849376}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Apia", "start": 2849376, "end": 2849783}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Auckland", "start": 2849783, "end": 2850826}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Bougainville", "start": 2850826, "end": 2851027}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Chatham", "start": 2851027, "end": 2851835}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Chuuk", "start": 2851835, "end": 2851989}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Easter", "start": 2851989, "end": 2853163}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Efate", "start": 2853163, "end": 2853505}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Enderbury", "start": 2853505, "end": 2853677}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Fakaofo", "start": 2853677, "end": 2853830}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Fiji", "start": 2853830, "end": 2854226}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Funafuti", "start": 2854226, "end": 2854360}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Galapagos", "start": 2854360, "end": 2854535}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Gambier", "start": 2854535, "end": 2854667}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Guadalcanal", "start": 2854667, "end": 2854801}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Guam", "start": 2854801, "end": 2855151}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Honolulu", "start": 2855151, "end": 2855372}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Johnston", "start": 2855372, "end": 2855593}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Kanton", "start": 2855593, "end": 2855765}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Kiritimati", "start": 2855765, "end": 2855939}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Kosrae", "start": 2855939, "end": 2856181}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Kwajalein", "start": 2856181, "end": 2856400}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Majuro", "start": 2856400, "end": 2856534}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Marquesas", "start": 2856534, "end": 2856673}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Midway", "start": 2856673, "end": 2856819}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Nauru", "start": 2856819, "end": 2857002}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Niue", "start": 2857002, "end": 2857156}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Norfolk", "start": 2857156, "end": 2857403}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Noumea", "start": 2857403, "end": 2857601}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Pago_Pago", "start": 2857601, "end": 2857747}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Palau", "start": 2857747, "end": 2857895}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Pitcairn", "start": 2857895, "end": 2858048}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Pohnpei", "start": 2858048, "end": 2858182}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Ponape", "start": 2858182, "end": 2858316}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Port_Moresby", "start": 2858316, "end": 2858470}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Rarotonga", "start": 2858470, "end": 2858876}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Saipan", "start": 2858876, "end": 2859226}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Samoa", "start": 2859226, "end": 2859372}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Tahiti", "start": 2859372, "end": 2859505}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Tarawa", "start": 2859505, "end": 2859639}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Tongatapu", "start": 2859639, "end": 2859876}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Truk", "start": 2859876, "end": 2860030}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Wake", "start": 2860030, "end": 2860164}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Wallis", "start": 2860164, "end": 2860298}, {"filename": "/tmp/pglite/share/postgresql/timezone/Pacific/Yap", "start": 2860298, "end": 2860452}, {"filename": "/tmp/pglite/share/postgresql/timezone/Poland", "start": 2860452, "end": 2861375}, {"filename": "/tmp/pglite/share/postgresql/timezone/Portugal", "start": 2861375, "end": 2862829}, {"filename": "/tmp/pglite/share/postgresql/timezone/ROC", "start": 2862829, "end": 2863340}, {"filename": "/tmp/pglite/share/postgresql/timezone/ROK", "start": 2863340, "end": 2863755}, {"filename": "/tmp/pglite/share/postgresql/timezone/Singapore", "start": 2863755, "end": 2864011}, {"filename": "/tmp/pglite/share/postgresql/timezone/Turkey", "start": 2864011, "end": 2865211}, {"filename": "/tmp/pglite/share/postgresql/timezone/UCT", "start": 2865211, "end": 2865322}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Alaska", "start": 2865322, "end": 2866299}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Aleutian", "start": 2866299, "end": 2867268}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Arizona", "start": 2867268, "end": 2867508}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Central", "start": 2867508, "end": 2869262}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/East-Indiana", "start": 2869262, "end": 2869793}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Eastern", "start": 2869793, "end": 2871537}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Hawaii", "start": 2871537, "end": 2871758}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Indiana-Starke", "start": 2871758, "end": 2872774}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Michigan", "start": 2872774, "end": 2873673}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Mountain", "start": 2873673, "end": 2874715}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Pacific", "start": 2874715, "end": 2876009}, {"filename": "/tmp/pglite/share/postgresql/timezone/US/Samoa", "start": 2876009, "end": 2876155}, {"filename": "/tmp/pglite/share/postgresql/timezone/UTC", "start": 2876155, "end": 2876266}, {"filename": "/tmp/pglite/share/postgresql/timezone/Universal", "start": 2876266, "end": 2876377}, {"filename": "/tmp/pglite/share/postgresql/timezone/W-SU", "start": 2876377, "end": 2877285}, {"filename": "/tmp/pglite/share/postgresql/timezone/WET", "start": 2877285, "end": 2877779}, {"filename": "/tmp/pglite/share/postgresql/timezone/Zulu", "start": 2877779, "end": 2877890}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Africa.txt", "start": 2877890, "end": 2884863}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/America.txt", "start": 2884863, "end": 2895870}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Antarctica.txt", "start": 2895870, "end": 2897004}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Asia.txt", "start": 2897004, "end": 2905315}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Atlantic.txt", "start": 2905315, "end": 2908848}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Australia", "start": 2908848, "end": 2909983}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Australia.txt", "start": 2909983, "end": 2913367}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Default", "start": 2913367, "end": 2940617}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Etc.txt", "start": 2940617, "end": 2941867}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Europe.txt", "start": 2941867, "end": 2950649}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/India", "start": 2950649, "end": 2951242}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Indian.txt", "start": 2951242, "end": 2952503}, {"filename": "/tmp/pglite/share/postgresql/timezonesets/Pacific.txt", "start": 2952503, "end": 2956271}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/danish.stop", "start": 2956271, "end": 2956695}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/dutch.stop", "start": 2956695, "end": 2957148}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/english.stop", "start": 2957148, "end": 2957770}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/finnish.stop", "start": 2957770, "end": 2959349}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/french.stop", "start": 2959349, "end": 2960154}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/german.stop", "start": 2960154, "end": 2961503}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/hungarian.stop", "start": 2961503, "end": 2962730}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample.affix", "start": 2962730, "end": 2962973}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_long.affix", "start": 2962973, "end": 2963606}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_long.dict", "start": 2963606, "end": 2963704}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_num.affix", "start": 2963704, "end": 2964166}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_num.dict", "start": 2964166, "end": 2964295}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/ispell_sample.affix", "start": 2964295, "end": 2964760}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/ispell_sample.dict", "start": 2964760, "end": 2964841}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/italian.stop", "start": 2964841, "end": 2966495}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/nepali.stop", "start": 2966495, "end": 2970756}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/norwegian.stop", "start": 2970756, "end": 2971607}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/portuguese.stop", "start": 2971607, "end": 2972874}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/russian.stop", "start": 2972874, "end": 2974109}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/spanish.stop", "start": 2974109, "end": 2976287}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/swedish.stop", "start": 2976287, "end": 2976846}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/synonym_sample.syn", "start": 2976846, "end": 2976919}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/thesaurus_sample.ths", "start": 2976919, "end": 2977392}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/turkish.stop", "start": 2977392, "end": 2977652}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/unaccent.rules", "start": 2977652, "end": 2987591}, {"filename": "/tmp/pglite/share/postgresql/tsearch_data/xsyn_sample.rules", "start": 2987591, "end": 2987730}], "remote_package_size": 2987730});

  })();

// end include: /tmp/tmpaasp3a41.js


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var readAsync, readBinary;

if (ENVIRONMENT_IS_NODE) {

  // These modules will usually be used on Node.js. Load them eagerly to avoid
  // the complexity of lazy-loading.
  var fs = require('fs');
  var nodePath = require('path');

  // EXPORT_ES6 + ENVIRONMENT_IS_NODE always requires use of import.meta.url,
  // since there's no way getting the current absolute path of the module when
  // support for that is not available.
  scriptDirectory = path.dirname(require('url').fileURLToPath("file:///home/sean/software/pglite/packages/pglite/dist/postgres.js")); // includes trailing slash
  // scriptDirectory = require('url').fileURLToPath(new URL('./', Object(import.meta).url)); // includes trailing slash
//   scriptDirectory = require('url').fileURLToPath(new URL('./', import.meta.url)); // includes trailing slash

// include: node_shell_read.js
readBinary = (filename) => {
  // We need to re-wrap `file://` strings to URLs. Normalizing isn't
  // necessary in that case, the path should already be absolute.
  filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
  var ret = fs.readFileSync(filename);
  return ret;
};

readAsync = (filename, binary = true) => {
  // See the comment in the `readBinary` function.
  filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
  return new Promise((resolve, reject) => {
    fs.readFile(filename, binary ? undefined : 'utf8', (err, data) => {
      if (err) reject(err);
      else resolve(binary ? data.buffer : data);
    });
  });
};
// end include: node_shell_read.js
  if (!Module['thisProgram'] && process.argv.length > 1) {
    thisProgram = process.argv[1].replace(/\\/g, '/');
  }

  arguments_ = process.argv.slice(2);

  // MODULARIZE will export the module in the proper place outside, we don't need to export here

  quit_ = (status, toThrow) => {
    process.exitCode = status;
    throw toThrow;
  };

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // When MODULARIZE, this JS may be executed later, after document.currentScript
  // is gone, so we saved it, and we use it here instead of any other info.
  if (_scriptName) {
    scriptDirectory = _scriptName;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.startsWith('blob:')) {
    scriptDirectory = '';
  } else {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/')+1);
  }

  {
// include: web_or_worker_shell_read.js
if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.responseType = 'arraybuffer';
      xhr.send(null);
      return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = (url) => {
    // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
    // See https://github.com/github/fetch/pull/92#issuecomment-140665932
    // Cordova or Electron apps are typically loaded from a file:// url.
    // So use XHR on webview if URL is a file URL.
    if (isFileURI(url)) {
      return new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = () => {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            resolve(xhr.response);
            return;
          }
          reject(xhr.status);
        };
        xhr.onerror = reject;
        xhr.send(null);
      });
    }
    return fetch(url, { credentials: 'same-origin' })
      .then((response) => {
        if (response.ok) {
          return response.arrayBuffer();
        }
        return Promise.reject(new Error(response.status + ' : ' + response.url));
      })
  };
// end include: web_or_worker_shell_read.js
  }
} else
{
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.error.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// end include: shell.js

// include: preamble.js
// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var dynamicLibraries = Module['dynamicLibraries'] || [];

var wasmBinary = Module['wasmBinary'];

// include: base64Utils.js
// Converts a string of base64 into a byte array (Uint8Array).
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE != 'undefined' && ENVIRONMENT_IS_NODE) {
    var buf = Buffer.from(s, 'base64');
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
  }

  var decoded = atob(s);
  var bytes = new Uint8Array(decoded.length);
  for (var i = 0 ; i < decoded.length ; ++i) {
    bytes[i] = decoded.charCodeAt(i);
  }
  return bytes;
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}
// end include: base64Utils.js
// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we
// don't define it at all in release modes.  This matches the behaviour of
// MINIMAL_RUNTIME.
// TODO(sbc): Make this the default even without STRICT enabled.
/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    // This build was created without ASSERTIONS defined.  `assert()` should not
    // ever be called in this configuration but in case there are callers in
    // the wild leave this simple abort() implementation here for now.
    abort(text);
  }
}

// Memory management

var HEAP,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/* BigInt64Array type is not correctly defined in closure
/** not-@type {!BigInt64Array} */
  HEAP64,
/* BigUint64Array type is not correctly defined in closure
/** not-t@type {!BigUint64Array} */
  HEAPU64,
/** @type {!Float64Array} */
  HEAPF64;

// include: runtime_shared.js
function updateMemoryViews() {
  var b = wasmMemory.buffer;
  Module['HEAP8'] = HEAP8 = new Int8Array(b);
  Module['HEAP16'] = HEAP16 = new Int16Array(b);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
  Module['HEAP32'] = HEAP32 = new Int32Array(b);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
  Module['HEAP64'] = HEAP64 = new BigInt64Array(b);
  Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);
}

// end include: runtime_shared.js
// In non-standalone/normal mode, we create the memory here.
// include: runtime_init_memory.js
// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)

// check for full engine support (use string 'subarray' to avoid closure compiler confusion)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 134217728;

    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_MEMORY / 65536,
      // In theory we should not need to emit the maximum if we want "unlimited"
      // or 4GB of memory, but VMs error on that atm, see
      // https://github.com/emscripten-core/emscripten/issues/14130
      // And in the pthreads case we definitely need to emit a maximum. So
      // always emit one.
      'maximum': 32768,
    });
  }

  updateMemoryViews();

// end include: runtime_init_memory.js

// include: runtime_stack_check.js
// end include: runtime_stack_check.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var __RELOC_FUNCS__ = [];

var runtimeInitialized = false;

function preRun() {
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  callRuntimeCallbacks(__RELOC_FUNCS__);

if (!Module['noFSInit'] && !FS.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
SOCKFS.root = FS.mount(SOCKFS, {}, null);
PIPEFS.root = FS.mount(PIPEFS, {}, null);
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {

  callRuntimeCallbacks(__ATMAIN__);
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  Module['monitorRunDependencies']?.(runDependencies);

}

function removeRunDependency(id) {
  runDependencies--;

  Module['monitorRunDependencies']?.(runDependencies);

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  Module['onAbort']?.(what);

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;

  what += '. Build with -sASSERTIONS for more info.';

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // definition for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject(e);
  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// include: memoryprofiler.js
// end include: memoryprofiler.js
// include: URIUtils.js
// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

/**
 * Indicates whether filename is a base64 data URI.
 * @noinline
 */
var isDataURI = (filename) => filename.startsWith(dataURIPrefix);

/**
 * Indicates whether filename is delivered via file protocol (as opposed to http/https)
 * @noinline
 */
var isFileURI = (filename) => filename.startsWith('file://');
// end include: URIUtils.js
// include: runtime_exceptions.js
// end include: runtime_exceptions.js
function findWasmBinary() {
  if (Module['locateFile']) {
    var f = 'postgres.wasm';
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
  }
  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.
  return new URL(/* asset import */ __webpack_require__(/*! postgres.wasm */ "../../../software/pglite/packages/pglite/dist/postgres.wasm"), __webpack_require__.b).href;
}

var wasmBinaryFile;

function getBinarySync(file) {
  if (file == wasmBinaryFile && wasmBinary) {
    return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
    return readBinary(file);
  }
  throw 'both async and sync fetching of the wasm failed';
}

function getBinaryPromise(binaryFile) {
  // If we don't have the binary yet, load it asynchronously using readAsync.
  if (!wasmBinary
      ) {
    // Fetch the binary using readAsync
    return readAsync(binaryFile).then(
      (response) => new Uint8Array(/** @type{!ArrayBuffer} */(response)),
      // Fall back to getBinarySync if readAsync fails
      () => getBinarySync(binaryFile)
    );
  }

  // Otherwise, getBinarySync should be able to get it synchronously
  return Promise.resolve().then(() => getBinarySync(binaryFile));
}

function instantiateArrayBuffer(binaryFile, imports, receiver) {
  return getBinaryPromise(binaryFile).then((binary) => {
    return WebAssembly.instantiate(binary, imports);
  }).then(receiver, (reason) => {
    err(`failed to asynchronously prepare wasm: ${reason}`);

    abort(reason);
  });
}

function instantiateAsync(binary, binaryFile, imports, callback) {
  if (!binary &&
      typeof WebAssembly.instantiateStreaming == 'function' &&
      !isDataURI(binaryFile) &&
      // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
      !isFileURI(binaryFile) &&
      // Avoid instantiateStreaming() on Node.js environment for now, as while
      // Node.js v18.1.0 implements it, it does not have a full fetch()
      // implementation yet.
      //
      // Reference:
      //   https://github.com/emscripten-core/emscripten/pull/16917
      !ENVIRONMENT_IS_NODE &&
      typeof fetch == 'function') {
    return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {
      // Suppress closure warning here since the upstream definition for
      // instantiateStreaming only allows Promise<Repsponse> rather than
      // an actual Response.
      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
      /** @suppress {checkTypes} */
      var result = WebAssembly.instantiateStreaming(response, imports);

      return result.then(
        callback,
        function(reason) {
          // We expect the most common failure cause to be a bad MIME type for the binary,
          // in which case falling back to ArrayBuffer instantiation should work.
          err(`wasm streaming compile failed: ${reason}`);
          err('falling back to ArrayBuffer instantiation');
          return instantiateArrayBuffer(binaryFile, imports, callback);
        });
    });
  }
  return instantiateArrayBuffer(binaryFile, imports, callback);
}

function getWasmImports() {
  // prepare imports
  return {
    'env': wasmImports,
    'wasi_snapshot_preview1': wasmImports,
    'GOT.mem': new Proxy(wasmImports, GOTHandler),
    'GOT.func': new Proxy(wasmImports, GOTHandler),
  }
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  var info = getWasmImports();
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    wasmExports = instance.exports;

    wasmExports = relocateExports(wasmExports, 67108864);

    var metadata = getDylinkMetadata(module);
    if (metadata.neededDynlibs) {
      dynamicLibraries = metadata.neededDynlibs.concat(dynamicLibraries);
    }
    mergeLibSymbols(wasmExports, 'main')
    LDSO.init();
    loadDylibs();



    addOnInit(wasmExports['__wasm_call_ctors']);

    __RELOC_FUNCS__.push(wasmExports['__wasm_apply_data_relocs']);

    removeRunDependency('wasm-instantiate');
    return wasmExports;
  }
  // wait for the pthread pool (if any)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    receiveInstance(result['instance'], result['module']);
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to
  // run the instantiation parallel to any other async startup actions they are
  // performing.
  // Also pthreads and wasm workers initialize the wasm instance through this
  // path.
  if (Module['instantiateWasm']) {
    try {
      return Module['instantiateWasm'](info, receiveInstance);
    } catch(e) {
      err(`Module.instantiateWasm callback failed with error: ${e}`);
        // If instantiation fails, reject the module ready promise.
        readyPromiseReject(e);
    }
  }

  if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();

  // If instantiation fails, reject the module ready promise.
  instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
  return {}; // no exports yet; we'll fill them in later
}

// include: runtime_debug.js
// end include: runtime_debug.js
// === Body ===

var ASM_CONSTS = {
  69112304: ($0) => { Module.is_worker = (typeof WorkerGlobalScope !== 'undefined') && self instanceof WorkerGlobalScope; Module.FD_BUFFER_MAX = $0; Module.emscripten_copy_to = console.warn; },
 69112477: () => { Module['postMessage'] = function custom_postMessage(event) { console.log("# 1252: onCustomMessage:",__FILE__, event); }; },
 69112602: () => { if (Module.is_worker) { function onCustomMessage(event) { console.log("onCustomMessage:", event); }; Module['onCustomMessage'] = onCustomMessage; } else { Module['postMessage'] = function custom_postMessage(event) { switch (event.type) { case "raw" : { stringToUTF8( event.data, shm_rawinput, Module.FD_BUFFER_MAX); break; } case "stdin" : { stringToUTF8( event.data, 1, Module.FD_BUFFER_MAX); break; } case "rcon" : { stringToUTF8( event.data, shm_rcon, Module.FD_BUFFER_MAX); break; } default : console.warn("custom_postMessage?", event); } }; }; }
};
function is_web_env() { try { if (window) return 1; } catch(x) {return 0} }
is_web_env.sig = 'i';
function peek_fd(fd) { return test_data.length; }
function fnc_getfd(fd) { return fnc_stdin() }

// end include: preamble.js


  /** @constructor */
  function ExitStatus(status) {
      this.name = 'ExitStatus';
      this.message = `Program terminated with exit(${status})`;
      this.status = status;
    }

  var GOT = {
  };

  var currentModuleWeakSymbols = new Set([]);
  var GOTHandler = {
  get(obj, symName) {
        var rtn = GOT[symName];
        if (!rtn) {
          rtn = GOT[symName] = new WebAssembly.Global({'value': 'i32', 'mutable': true});
        }
        if (!currentModuleWeakSymbols.has(symName)) {
          // Any non-weak reference to a symbol marks it as `required`, which
          // enabled `reportUndefinedSymbols` to report undefeind symbol errors
          // correctly.
          rtn.required = true;
        }
        return rtn;
      },
  };

  var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        // Pass the module as the first argument.
        callbacks.shift()(Module);
      }
    };

  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;

    /**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number} idx
     * @param {number=} maxBytesToRead
     * @return {string}
     */
  var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      // TextDecoder needs to know the byte length in advance, it doesn't stop on
      // null terminator by itself.  Also, use the length info to avoid running tiny
      // strings through TextDecoder, since .subarray() allocates garbage.
      // (As a tiny code save trick, compare endPtr against endIdx using a negation,
      // so that undefined means Infinity)
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = '';
      // If building with TextDecoder, we have already computed the string length
      // above, so test loop end condition against that
      while (idx < endPtr) {
        // For UTF8 byte structure, see:
        // http://en.wikipedia.org/wiki/UTF-8#Description
        // https://www.ietf.org/rfc/rfc2279.txt
        // https://tools.ietf.org/html/rfc3629
        var u0 = heapOrArray[idx++];
        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 0xF0) == 0xE0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
        }

        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        }
      }
      return str;
    };
  var getDylinkMetadata = (binary) => {
      var offset = 0;
      var end = 0;

      function getU8() {
        return binary[offset++];
      }

      function getLEB() {
        var ret = 0;
        var mul = 1;
        while (1) {
          var byte = binary[offset++];
          ret += ((byte & 0x7f) * mul);
          mul *= 0x80;
          if (!(byte & 0x80)) break;
        }
        return ret;
      }

      function getString() {
        var len = getLEB();
        offset += len;
        return UTF8ArrayToString(binary, offset - len, len);
      }

      /** @param {string=} message */
      function failIf(condition, message) {
        if (condition) throw new Error(message);
      }

      var name = 'dylink.0';
      if (binary instanceof WebAssembly.Module) {
        var dylinkSection = WebAssembly.Module.customSections(binary, name);
        if (dylinkSection.length === 0) {
          name = 'dylink'
          dylinkSection = WebAssembly.Module.customSections(binary, name);
        }
        failIf(dylinkSection.length === 0, 'need dylink section');
        binary = new Uint8Array(dylinkSection[0]);
        end = binary.length
      } else {
        var int32View = new Uint32Array(new Uint8Array(binary.subarray(0, 24)).buffer);
        var magicNumberFound = int32View[0] == 0x6d736100;
        failIf(!magicNumberFound, 'need to see wasm magic number'); // \0asm
        // we should see the dylink custom section right after the magic number and wasm version
        failIf(binary[8] !== 0, 'need the dylink section to be first')
        offset = 9;
        var section_size = getLEB(); //section size
        end = offset + section_size;
        name = getString();
      }

      var customSection = { neededDynlibs: [], tlsExports: new Set(), weakImports: new Set() };
      if (name == 'dylink') {
        customSection.memorySize = getLEB();
        customSection.memoryAlign = getLEB();
        customSection.tableSize = getLEB();
        customSection.tableAlign = getLEB();
        // shared libraries this module needs. We need to load them first, so that
        // current module could resolve its imports. (see tools/shared.py
        // WebAssembly.make_shared_library() for "dylink" section extension format)
        var neededDynlibsCount = getLEB();
        for (var i = 0; i < neededDynlibsCount; ++i) {
          var libname = getString();
          customSection.neededDynlibs.push(libname);
        }
      } else {
        failIf(name !== 'dylink.0');
        var WASM_DYLINK_MEM_INFO = 0x1;
        var WASM_DYLINK_NEEDED = 0x2;
        var WASM_DYLINK_EXPORT_INFO = 0x3;
        var WASM_DYLINK_IMPORT_INFO = 0x4;
        var WASM_SYMBOL_TLS = 0x100;
        var WASM_SYMBOL_BINDING_MASK = 0x3;
        var WASM_SYMBOL_BINDING_WEAK = 0x1;
        while (offset < end) {
          var subsectionType = getU8();
          var subsectionSize = getLEB();
          if (subsectionType === WASM_DYLINK_MEM_INFO) {
            customSection.memorySize = getLEB();
            customSection.memoryAlign = getLEB();
            customSection.tableSize = getLEB();
            customSection.tableAlign = getLEB();
          } else if (subsectionType === WASM_DYLINK_NEEDED) {
            var neededDynlibsCount = getLEB();
            for (var i = 0; i < neededDynlibsCount; ++i) {
              libname = getString();
              customSection.neededDynlibs.push(libname);
            }
          } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
            var count = getLEB();
            while (count--) {
              var symname = getString();
              var flags = getLEB();
              if (flags & WASM_SYMBOL_TLS) {
                customSection.tlsExports.add(symname);
              }
            }
          } else if (subsectionType === WASM_DYLINK_IMPORT_INFO) {
            var count = getLEB();
            while (count--) {
              var modname = getString();
              var symname = getString();
              var flags = getLEB();
              if ((flags & WASM_SYMBOL_BINDING_MASK) == WASM_SYMBOL_BINDING_WEAK) {
                customSection.weakImports.add(symname);
              }
            }
          } else {
            // unknown subsection
            offset += subsectionSize;
          }
        }
      }

      return customSection;
    };


    /**
     * @param {number} ptr
     * @param {string} type
     */
  function getValue(ptr, type = 'i8') {
    if (type.endsWith('*')) type = '*';
    switch (type) {
      case 'i1': return HEAP8[ptr];
      case 'i8': return HEAP8[ptr];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP64[((ptr)>>3)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      case '*': return HEAPU32[((ptr)>>2)];
      default: abort(`invalid type for getValue: ${type}`);
    }
  }

  var newDSO = (name, handle, syms) => {
      var dso = {
        refcount: Infinity,
        name,
        exports: syms,
        global: true,
      };
      LDSO.loadedLibsByName[name] = dso;
      if (handle != undefined) {
        LDSO.loadedLibsByHandle[handle] = dso;
      }
      return dso;
    };
  var LDSO = {
  loadedLibsByName:{
  },
  loadedLibsByHandle:{
  },
  init() {
        newDSO('__main__', 0, wasmImports);
      },
  };



  var ___heap_base = 73463792;

  var zeroMemory = (address, size) => {
      HEAPU8.fill(0, address, address + size);
      return address;
    };

  var alignMemory = (size, alignment) => {
      return Math.ceil(size / alignment) * alignment;
    };

  var getMemory = (size) => {
      // After the runtime is initialized, we must only use sbrk() normally.
      if (runtimeInitialized) {
        // Currently we don't support freeing of static data when modules are
        // unloaded via dlclose.  This function is tagged as `noleakcheck` to
        // avoid having this reported as leak.
        return zeroMemory(_malloc(size), size);
      }
      var ret = ___heap_base;
      // Keep __heap_base stack aligned.
      var end = ret + alignMemory(size, 16);
      ___heap_base = end;
      GOT['__heap_base'].value = end;
      return ret;
    };


  var isInternalSym = (symName) => {
      // TODO: find a way to mark these in the binary or avoid exporting them.
      return [
        '__cpp_exception',
        '__c_longjmp',
        '__wasm_apply_data_relocs',
        '__dso_handle',
        '__tls_size',
        '__tls_align',
        '__set_stack_limits',
        '_emscripten_tls_init',
        '__wasm_init_tls',
        '__wasm_call_ctors',
        '__start_em_asm',
        '__stop_em_asm',
        '__start_em_js',
        '__stop_em_js',
      ].includes(symName) || symName.startsWith('__em_js__')
      ;
    };

  var uleb128Encode = (n, target) => {
      if (n < 128) {
        target.push(n);
      } else {
        target.push((n % 128) | 128, n >> 7);
      }
    };

  var sigToWasmTypes = (sig) => {
      var typeNames = {
        'i': 'i32',
        'j': 'i64',
        'f': 'f32',
        'd': 'f64',
        'e': 'externref',
        'p': 'i32',
      };
      var type = {
        parameters: [],
        results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
      };
      for (var i = 1; i < sig.length; ++i) {
        type.parameters.push(typeNames[sig[i]]);
      }
      return type;
    };

  var generateFuncType = (sig, target) => {
      var sigRet = sig.slice(0, 1);
      var sigParam = sig.slice(1);
      var typeCodes = {
        'i': 0x7f, // i32
        'p': 0x7f, // i32
        'j': 0x7e, // i64
        'f': 0x7d, // f32
        'd': 0x7c, // f64
        'e': 0x6f, // externref
      };

      // Parameters, length + signatures
      target.push(0x60 /* form: func */);
      uleb128Encode(sigParam.length, target);
      for (var i = 0; i < sigParam.length; ++i) {
        target.push(typeCodes[sigParam[i]]);
      }

      // Return values, length + signatures
      // With no multi-return in MVP, either 0 (void) or 1 (anything else)
      if (sigRet == 'v') {
        target.push(0x00);
      } else {
        target.push(0x01, typeCodes[sigRet]);
      }
    };
  var convertJsFunctionToWasm = (func, sig) => {

      // If the type reflection proposal is available, use the new
      // "WebAssembly.Function" constructor.
      // Otherwise, construct a minimal wasm module importing the JS function and
      // re-exporting it.
      if (typeof WebAssembly.Function == "function") {
        return new WebAssembly.Function(sigToWasmTypes(sig), func);
      }

      // The module is static, with the exception of the type section, which is
      // generated based on the signature passed in.
      var typeSectionBody = [
        0x01, // count: 1
      ];
      generateFuncType(sig, typeSectionBody);

      // Rest of the module is static
      var bytes = [
        0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
        0x01, 0x00, 0x00, 0x00, // version: 1
        0x01, // Type section code
      ];
      // Write the overall length of the type section followed by the body
      uleb128Encode(typeSectionBody.length, bytes);
      bytes.push(...typeSectionBody);

      // The rest of the module is static
      bytes.push(
        0x02, 0x07, // import section
          // (import "e" "f" (func 0 (type 0)))
          0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
        0x07, 0x05, // export section
          // (export "f" (func 0 (type 0)))
          0x01, 0x01, 0x66, 0x00, 0x00,
      );

      // We can compile this wasm module synchronously because it is very small.
      // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
      var module = new WebAssembly.Module(new Uint8Array(bytes));
      var instance = new WebAssembly.Instance(module, { 'e': { 'f': func } });
      var wrappedFunc = instance.exports['f'];
      return wrappedFunc;
    };

  var wasmTableMirror = [];

  /** @type {WebAssembly.Table} */
  var wasmTable = new WebAssembly.Table({
    'initial': 5358,
    'element': 'anyfunc'
  });
  ;
  var getWasmTableEntry = (funcPtr) => {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      return func;
    };

  var updateTableMap = (offset, count) => {
      if (functionsInTableMap) {
        for (var i = offset; i < offset + count; i++) {
          var item = getWasmTableEntry(i);
          // Ignore null values.
          if (item) {
            functionsInTableMap.set(item, i);
          }
        }
      }
    };

  var functionsInTableMap;

  var getFunctionAddress = (func) => {
      // First, create the map if this is the first use.
      if (!functionsInTableMap) {
        functionsInTableMap = new WeakMap();
        updateTableMap(0, wasmTable.length);
      }
      return functionsInTableMap.get(func) || 0;
    };


  var freeTableIndexes = [];

  var getEmptyTableSlot = () => {
      // Reuse a free index if there is one, otherwise grow.
      if (freeTableIndexes.length) {
        return freeTableIndexes.pop();
      }
      // Grow the table
      try {
        wasmTable.grow(1);
      } catch (err) {
        if (!(err instanceof RangeError)) {
          throw err;
        }
        throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
      }
      return wasmTable.length - 1;
    };



  var setWasmTableEntry = (idx, func) => {
      wasmTable.set(idx, func);
      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overridden to return wrapped
      // functions so we need to call it here to retrieve the potential wrapper correctly
      // instead of just storing 'func' directly into wasmTableMirror
      wasmTableMirror[idx] = wasmTable.get(idx);
    };

  /** @param {string=} sig */
  var addFunction = (func, sig) => {
      // Check if the function is already in the table, to ensure each function
      // gets a unique index.
      var rtn = getFunctionAddress(func);
      if (rtn) {
        return rtn;
      }

      // It's not in the table, add it now.

      var ret = getEmptyTableSlot();

      // Set the new value.
      try {
        // Attempting to call this with JS function will cause of table.set() to fail
        setWasmTableEntry(ret, func);
      } catch (err) {
        if (!(err instanceof TypeError)) {
          throw err;
        }
        var wrapped = convertJsFunctionToWasm(func, sig);
        setWasmTableEntry(ret, wrapped);
      }

      functionsInTableMap.set(func, ret);

      return ret;
    };

  var updateGOT = (exports, replace) => {
      for (var symName in exports) {
        if (isInternalSym(symName)) {
          continue;
        }

        var value = exports[symName];

        GOT[symName] ||= new WebAssembly.Global({'value': 'i32', 'mutable': true});
        if (replace || GOT[symName].value == 0) {
          if (typeof value == 'function') {
            GOT[symName].value = addFunction(value);
          } else if (typeof value == 'number') {
            GOT[symName].value = value;
          } else {
            err(`unhandled export type for '${symName}': ${typeof value}`);
          }
        }
      }
    };
  /** @param {boolean=} replace */
  var relocateExports = (exports, memoryBase, replace) => {
      var relocated = {};

      for (var e in exports) {
        var value = exports[e];
        if (typeof value == 'object') {
          // a breaking change in the wasm spec, globals are now objects
          // https://github.com/WebAssembly/mutable-global/issues/1
          value = value.value;
        }
        if (typeof value == 'number') {
          value += memoryBase;
        }
        relocated[e] = value;
      }
      updateGOT(relocated, replace);
      return relocated;
    };

  var isSymbolDefined = (symName) => {
      // Ignore 'stub' symbols that are auto-generated as part of the original
      // `wasmImports` used to instantiate the main module.
      var existing = wasmImports[symName];
      if (!existing || existing.stub) {
        return false;
      }
      return true;
    };

  var dynCall = (sig, ptr, args = []) => {
      var rtn = getWasmTableEntry(ptr)(...args);
      return rtn;
    };


  var stackSave = () => _emscripten_stack_get_current();

  var stackRestore = (val) => __emscripten_stack_restore(val);
  var createInvokeFunction = (sig) => (ptr, ...args) => {
      var sp = stackSave();
      try {
        return dynCall(sig, ptr, args);
      } catch(e) {
        stackRestore(sp);
        // Create a try-catch guard that rethrows the Emscripten EH exception.
        // Exceptions thrown from C++ will be a pointer (number) and longjmp
        // will throw the number Infinity. Use the compact and fast "e !== e+0"
        // test to check if e was not a Number.
        if (e !== e+0) throw e;
        _setThrew(1, 0);
        // In theory this if statement could be done on
        // creating the function, but I just added this to
        // save wasting code space as it only happens on exception.
        if (sig[0] == "j") return 0n;
      }
    };
  var resolveGlobalSymbol = (symName, direct = false) => {
      var sym;
      if (isSymbolDefined(symName)) {
        sym = wasmImports[symName];
      }
      // Asm.js-style exception handling: invoke wrapper generation
      else if (symName.startsWith('invoke_')) {
        // Create (and cache) new invoke_ functions on demand.
        sym = wasmImports[symName] = createInvokeFunction(symName.split('_')[1]);
      }
      return {sym, name: symName};
    };









    /**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index (i.e. maxBytesToRead will not
     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
     *   JS JIT optimizations off, so it is worth to consider consistently using one
     * @return {string}
     */
  var UTF8ToString = (ptr, maxBytesToRead) => {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
    };

     /**
      * @param {string=} libName
      * @param {Object=} localScope
      * @param {number=} handle
      */
  var loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {
      var metadata = getDylinkMetadata(binary);
      currentModuleWeakSymbols = metadata.weakImports;

      // loadModule loads the wasm module after all its dependencies have been loaded.
      // can be called both sync/async.
      function loadModule() {
        // The first thread to load a given module needs to allocate the static
        // table and memory regions.  Later threads re-use the same table region
        // and can ignore the memory region (since memory is shared between
        // threads already).
        // If `handle` is specified than it is assumed that the calling thread has
        // exclusive access to it for the duration of this function.  See the
        // locking in `dynlink.c`.
        var firstLoad = !handle || !HEAP8[(handle)+(8)];
        if (firstLoad) {
          // alignments are powers of 2
          var memAlign = Math.pow(2, metadata.memoryAlign);
          // prepare memory
          var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0; // TODO: add to cleanups
          var tableBase = metadata.tableSize ? wasmTable.length : 0;
          if (handle) {
            HEAP8[(handle)+(8)] = 1;
            HEAPU32[(((handle)+(12))>>2)] = memoryBase;
            HEAP32[(((handle)+(16))>>2)] = metadata.memorySize;
            HEAPU32[(((handle)+(20))>>2)] = tableBase;
            HEAP32[(((handle)+(24))>>2)] = metadata.tableSize;
          }
        } else {
          memoryBase = HEAPU32[(((handle)+(12))>>2)];
          tableBase = HEAPU32[(((handle)+(20))>>2)];
        }

        var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
        if (tableGrowthNeeded > 0) {
          wasmTable.grow(tableGrowthNeeded);
        }

        // This is the export map that we ultimately return.  We declare it here
        // so it can be used within resolveSymbol.  We resolve symbols against
        // this local symbol map in the case there they are not present on the
        // global Module object.  We need this fallback because Modules sometime
        // need to import their own symbols
        var moduleExports;

        function resolveSymbol(sym) {
          var resolved = resolveGlobalSymbol(sym).sym;
          if (!resolved && localScope) {
            resolved = localScope[sym];
          }
          if (!resolved) {
            resolved = moduleExports[sym];
          }
          return resolved;
        }

        // TODO kill ↓↓↓ (except "symbols local to this module", it will likely be
        // not needed if we require that if A wants symbols from B it has to link
        // to B explicitly: similarly to -Wl,--no-undefined)
        //
        // wasm dynamic libraries are pure wasm, so they cannot assist in
        // their own loading. When side module A wants to import something
        // provided by a side module B that is loaded later, we need to
        // add a layer of indirection, but worse, we can't even tell what
        // to add the indirection for, without inspecting what A's imports
        // are. To do that here, we use a JS proxy (another option would
        // be to inspect the binary directly).
        var proxyHandler = {
          get(stubs, prop) {
            // symbols that should be local to this module
            switch (prop) {
              case '__memory_base':
                return memoryBase;
              case '__table_base':
                return tableBase;
            }
            if (prop in wasmImports && !wasmImports[prop].stub) {
              // No stub needed, symbol already exists in symbol table
              return wasmImports[prop];
            }
            // Return a stub function that will resolve the symbol
            // when first called.
            if (!(prop in stubs)) {
              var resolved;
              stubs[prop] = (...args) => {
                resolved ||= resolveSymbol(prop);
                return resolved(...args);
              };
            }
            return stubs[prop];
          }
        };
        var proxy = new Proxy({}, proxyHandler);
        var info = {
          'GOT.mem': new Proxy({}, GOTHandler),
          'GOT.func': new Proxy({}, GOTHandler),
          'env': proxy,
          'wasi_snapshot_preview1': proxy,
        };

        function postInstantiation(module, instance) {
          // add new entries to functionsInTableMap
          updateTableMap(tableBase, metadata.tableSize);
          moduleExports = relocateExports(instance.exports, memoryBase);
          if (!flags.allowUndefined) {
            reportUndefinedSymbols();
          }

          function addEmAsm(addr, body) {
            var args = [];
            var arity = 0;
            for (; arity < 16; arity++) {
              if (body.indexOf('$' + arity) != -1) {
                args.push('$' + arity);
              } else {
                break;
              }
            }
            args = args.join(',');
            var func = `(${args}) => { ${body} };`;
            ASM_CONSTS[start] = eval(func);
          }

          // Add any EM_ASM function that exist in the side module
          if ('__start_em_asm' in moduleExports) {
            var start = moduleExports['__start_em_asm'];
            var stop = moduleExports['__stop_em_asm'];


            while (start < stop) {
              var jsString = UTF8ToString(start);
              addEmAsm(start, jsString);
              start = HEAPU8.indexOf(0, start) + 1;
            }
          }

          function addEmJs(name, cSig, body) {
            // The signature here is a C signature (e.g. "(int foo, char* bar)").
            // See `create_em_js` in emcc.py` for the build-time version of this
            // code.
            var jsArgs = [];
            cSig = cSig.slice(1, -1)
            if (cSig != 'void') {
              cSig = cSig.split(',');
              for (var i in cSig) {
                var jsArg = cSig[i].split(' ').pop();
                jsArgs.push(jsArg.replaceAll('*', ''));
              }
            }
            var func = `(${jsArgs}) => ${body};`;
            moduleExports[name] = eval(func);
          }

          for (var name in moduleExports) {
            if (name.startsWith('__em_js__')) {
              var start = moduleExports[name]
              var jsString = UTF8ToString(start);
              // EM_JS strings are stored in the data section in the form
              // SIG<::>BODY.
              var parts = jsString.split('<::>');
              addEmJs(name.replace('__em_js__', ''), parts[0], parts[1]);
              delete moduleExports[name];
            }
          }

          // initialize the module
            var applyRelocs = moduleExports['__wasm_apply_data_relocs'];
            if (applyRelocs) {
              if (runtimeInitialized) {
                applyRelocs();
              } else {
                __RELOC_FUNCS__.push(applyRelocs);
              }
            }
            var init = moduleExports['__wasm_call_ctors'];
            if (init) {
              if (runtimeInitialized) {
                init();
              } else {
                // we aren't ready to run compiled code yet
                __ATINIT__.push(init);
              }
            }
          return moduleExports;
        }

        if (flags.loadAsync) {
          if (binary instanceof WebAssembly.Module) {
            var instance = new WebAssembly.Instance(binary, info);
            return Promise.resolve(postInstantiation(binary, instance));
          }
          return WebAssembly.instantiate(binary, info).then(
            (result) => postInstantiation(result.module, result.instance)
          );
        }

        var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
        var instance = new WebAssembly.Instance(module, info);
        return postInstantiation(module, instance);
      }

      // now load needed libraries and the module itself.
      if (flags.loadAsync) {
        return metadata.neededDynlibs
          .reduce((chain, dynNeeded) => chain.then(() =>
            loadDynamicLibrary(dynNeeded, flags, localScope)
          ), Promise.resolve())
          .then(loadModule);
      }

      metadata.neededDynlibs.forEach((needed) => loadDynamicLibrary(needed, flags, localScope));
      return loadModule();
    };


  var mergeLibSymbols = (exports, libName) => {
      // add symbols into global namespace TODO: weak linking etc.
      for (var [sym, exp] of Object.entries(exports)) {

        // When RTLD_GLOBAL is enabled, the symbols defined by this shared object
        // will be made available for symbol resolution of subsequently loaded
        // shared objects.
        //
        // We should copy the symbols (which include methods and variables) from
        // SIDE_MODULE to MAIN_MODULE.
        const setImport = (target) => {
          if (!isSymbolDefined(target)) {
            wasmImports[target] = exp;
          }
        }
        setImport(sym);

        // Special case for handling of main symbol:  If a side module exports
        // `main` that also acts a definition for `__main_argc_argv` and vice
        // versa.
        const main_alias = '__main_argc_argv';
        if (sym == 'main') {
          setImport(main_alias)
        }
        if (sym == main_alias) {
          setImport('main')
        }

        if (sym.startsWith('dynCall_') && !Module.hasOwnProperty(sym)) {
          Module[sym] = exp;
        }
      }
    };


  /** @param {boolean=} noRunDep */
  var asyncLoad = (url, onload, onerror, noRunDep) => {
      var dep = !noRunDep ? getUniqueRunDependency(`al ${url}`) : '';
      readAsync(url).then(
        (arrayBuffer) => {
          onload(new Uint8Array(arrayBuffer));
          if (dep) removeRunDependency(dep);
        },
        (err) => {
          if (onerror) {
            onerror();
          } else {
            throw `Loading data file "${url}" failed.`;
          }
        }
      );
      if (dep) addRunDependency(dep);
    };

  var preloadPlugins = Module['preloadPlugins'] || [];
  var registerWasmPlugin = () => {
      // Use string keys here to avoid minification since the plugin consumer
      // also uses string keys.
      var wasmPlugin = {
        'promiseChainEnd': Promise.resolve(),
        'canHandle': (name) => {
          return !Module['noWasmDecoding'] && name.endsWith('.so')
        },
        'handle': (byteArray, name, onload, onerror) => {
          // loadWebAssemblyModule can not load modules out-of-order, so rather
          // than just running the promises in parallel, this makes a chain of
          // promises to run in series.
          wasmPlugin['promiseChainEnd'] = wasmPlugin['promiseChainEnd'].then(
            () => loadWebAssemblyModule(byteArray, {loadAsync: true, nodelete: true}, name, {})).then(
              (exports) => {
                preloadedWasm[name] = exports;
                onload(byteArray);
              },
              (error) => {
                err(`failed to instantiate wasm: ${name}: ${error}`);
                onerror();
              });
        }
      };
      preloadPlugins.push(wasmPlugin);
    };
  var preloadedWasm = {
  };

      /**
       * @param {number=} handle
       * @param {Object=} localScope
       */
  function loadDynamicLibrary(libName, flags = {global: true, nodelete: true}, localScope, handle) {
      // when loadDynamicLibrary did not have flags, libraries were loaded
      // globally & permanently

      var dso = LDSO.loadedLibsByName[libName];
      if (dso) {
        // the library is being loaded or has been loaded already.
        if (!flags.global) {
          if (localScope) {
            Object.assign(localScope, dso.exports);
          }
        } else if (!dso.global) {
          // The library was previously loaded only locally but not
          // we have a request with global=true.
          dso.global = true;
          mergeLibSymbols(dso.exports, libName)
        }
        // same for "nodelete"
        if (flags.nodelete && dso.refcount !== Infinity) {
          dso.refcount = Infinity;
        }
        dso.refcount++
        if (handle) {
          LDSO.loadedLibsByHandle[handle] = dso;
        }
        return flags.loadAsync ? Promise.resolve(true) : true;
      }

      // allocate new DSO
      dso = newDSO(libName, handle, 'loading');
      dso.refcount = flags.nodelete ? Infinity : 1;
      dso.global = flags.global;

      // libName -> libData
      function loadLibData() {

        // for wasm, we can use fetch for async, but for fs mode we can only imitate it
        if (handle) {
          var data = HEAPU32[(((handle)+(28))>>2)];
          var dataSize = HEAPU32[(((handle)+(32))>>2)];
          if (data && dataSize) {
            var libData = HEAP8.slice(data, data + dataSize);
            return flags.loadAsync ? Promise.resolve(libData) : libData;
          }
        }

        var libFile = locateFile(libName);
        if (flags.loadAsync) {
          return new Promise((resolve, reject) => asyncLoad(libFile, resolve, reject));
        }

        // load the binary synchronously
        if (!readBinary) {
          throw new Error(`${libFile}: file not found, and synchronous loading of external files is not available`);
        }
        return readBinary(libFile);
      }

      // libName -> exports
      function getExports() {
        // lookup preloaded cache first
        var preloaded = preloadedWasm[libName];
        if (preloaded) {
          return flags.loadAsync ? Promise.resolve(preloaded) : preloaded;
        }

        // module not preloaded - load lib data and create new module from it
        if (flags.loadAsync) {
          return loadLibData().then((libData) => loadWebAssemblyModule(libData, flags, libName, localScope, handle));
        }

        return loadWebAssemblyModule(loadLibData(), flags, libName, localScope, handle);
      }

      // module for lib is loaded - update the dso & global namespace
      function moduleLoaded(exports) {
        if (dso.global) {
          mergeLibSymbols(exports, libName);
        } else if (localScope) {
          Object.assign(localScope, exports);
        }
        dso.exports = exports;
      }

      if (flags.loadAsync) {
        return getExports().then((exports) => {
          moduleLoaded(exports);
          return true;
        });
      }

      moduleLoaded(getExports());
      return true;
    }


  var reportUndefinedSymbols = () => {
      for (var [symName, entry] of Object.entries(GOT)) {
        if (entry.value == 0) {
          var value = resolveGlobalSymbol(symName, true).sym;
          if (!value && !entry.required) {
            // Ignore undefined symbols that are imported as weak.
            continue;
          }
          if (typeof value == 'function') {
            /** @suppress {checkTypes} */
            entry.value = addFunction(value, value.sig);
          } else if (typeof value == 'number') {
            entry.value = value;
          } else {
            throw new Error(`bad export type for '${symName}': ${typeof value}`);
          }
        }
      }
    };
  var loadDylibs = () => {
      if (!dynamicLibraries.length) {
        reportUndefinedSymbols();
        return;
      }

      // Load binaries asynchronously
      addRunDependency('loadDylibs');
      dynamicLibraries
        .reduce((chain, lib) => chain.then(() =>
          loadDynamicLibrary(lib, {loadAsync: true, global: true, nodelete: true, allowUndefined: true})
        ), Promise.resolve())
        .then(() => {
          // we got them all, wonderful
          reportUndefinedSymbols();
          removeRunDependency('loadDylibs');
        });
    };


  var noExitRuntime = Module['noExitRuntime'] || true;




    /**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */
  function setValue(ptr, value, type = 'i8') {
    if (type.endsWith('*')) type = '*';
    switch (type) {
      case 'i1': HEAP8[ptr] = value; break;
      case 'i8': HEAP8[ptr] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': HEAP64[((ptr)>>3)] = BigInt(value); break;
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      case '*': HEAPU32[((ptr)>>2)] = value; break;
      default: abort(`invalid type for setValue: ${type}`);
    }
  }



  var ___assert_fail = (condition, filename, line, func) => {
      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    };
  ___assert_fail.sig = 'vppip';

  var ___call_sighandler = (fp, sig) => getWasmTableEntry(fp)(sig);
  ___call_sighandler.sig = 'vpi';


  var ___memory_base = new WebAssembly.Global({'value': 'i32', 'mutable': false}, 67108864);

  var ___stack_pointer = new WebAssembly.Global({'value': 'i32', 'mutable': true}, 73463792);

  var PATH = {
  isAbs:(path) => path.charAt(0) === '/',
  splitPath:(filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
  normalizeArray:(parts, allowAboveRoot) => {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },
  normalize:(path) => {
        var isAbsolute = PATH.isAbs(path),
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },
  dirname:(path) => {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },
  basename:(path) => {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },
  join:(...paths) => PATH.normalize(paths.join('/')),
  join2:(l, r) => PATH.normalize(l + '/' + r),
  };

  var initRandomFill = () => {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        // for modern web browsers
        return (view) => crypto.getRandomValues(view);
      } else
      if (ENVIRONMENT_IS_NODE) {
        // for nodejs with or without crypto support included
        try {
          var crypto_module = require('crypto');
          var randomFillSync = crypto_module['randomFillSync'];
          if (randomFillSync) {
            // nodejs with LTS crypto support
            return (view) => crypto_module['randomFillSync'](view);
          }
          // very old nodejs with the original crypto API
          var randomBytes = crypto_module['randomBytes'];
          return (view) => (
            view.set(randomBytes(view.byteLength)),
            // Return the original view to match modern native implementations.
            view
          );
        } catch (e) {
          // nodejs doesn't have crypto support
        }
      }
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      abort('initRandomDevice');
    };
  var randomFill = (view) => {
      // Lazily init on the first invocation.
      return (randomFill = initRandomFill())(view);
    };



  var PATH_FS = {
  resolve:(...args) => {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? args[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },
  relative:(from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      },
  };



  var FS_stdin_getChar_buffer = [];

  var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var c = str.charCodeAt(i); // possibly a lead surrogate
        if (c <= 0x7F) {
          len++;
        } else if (c <= 0x7FF) {
          len += 2;
        } else if (c >= 0xD800 && c <= 0xDFFF) {
          len += 4; ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };

  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
      // undefined and false each don't write out any bytes.
      if (!(maxBytesToWrite > 0))
        return 0;

      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
        // and https://www.ietf.org/rfc/rfc2279.txt
        // and https://tools.ietf.org/html/rfc3629
        var u = str.charCodeAt(i); // possibly a lead surrogate
        if (u >= 0xD800 && u <= 0xDFFF) {
          var u1 = str.charCodeAt(++i);
          u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
        }
        if (u <= 0x7F) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 0x7FF) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 0xC0 | (u >> 6);
          heap[outIdx++] = 0x80 | (u & 63);
        } else if (u <= 0xFFFF) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 0xE0 | (u >> 12);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 0xF0 | (u >> 18);
          heap[outIdx++] = 0x80 | ((u >> 12) & 63);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        }
      }
      // Null-terminate the pointer to the buffer.
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
  /** @type {function(string, boolean=, number=)} */
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array;
  }
  var FS_stdin_getChar = () => {
      if (!FS_stdin_getChar_buffer.length) {
        var result = null;
        if (ENVIRONMENT_IS_NODE) {
          // we will read data by chunks of BUFSIZE
          var BUFSIZE = 256;
          var buf = Buffer.alloc(BUFSIZE);
          var bytesRead = 0;

          // For some reason we must suppress a closure warning here, even though
          // fd definitely exists on process.stdin, and is even the proper way to
          // get the fd of stdin,
          // https://github.com/nodejs/help/issues/2136#issuecomment-523649904
          // This started to happen after moving this logic out of library_tty.js,
          // so it is related to the surrounding code in some unclear manner.
          /** @suppress {missingProperties} */
          var fd = process.stdin.fd;

          try {
            bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
          } catch(e) {
            // Cross-platform differences: on Windows, reading EOF throws an
            // exception, but on other OSes, reading EOF returns 0. Uniformize
            // behavior by treating the EOF exception to return 0.
            if (e.toString().includes('EOF')) bytesRead = 0;
            else throw e;
          }

          if (bytesRead > 0) {
            result = buf.slice(0, bytesRead).toString('utf-8');
          }
        } else
        if (typeof window != 'undefined' &&
          typeof window.prompt == 'function') {
          // Browser.
          result = window.prompt('Input: ');  // returns null on cancel
          if (result !== null) {
            result += '\n';
          }
        } else
        {}
        if (!result) {
          return null;
        }
        FS_stdin_getChar_buffer = intArrayFromString(result, true);
      }
      return FS_stdin_getChar_buffer.shift();
    };
  var TTY = {
  ttys:[],
  init() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process.stdin.setEncoding('utf8');
        // }
      },
  shutdown() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process.stdin.pause();
        // }
      },
  register(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
  stream_ops:{
  open(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
  close(stream) {
          // flush any pending line data
          stream.tty.ops.fsync(stream.tty);
        },
  fsync(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
  read(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },
  write(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        },
  },
  default_tty_ops:{
  get_char(tty) {
          return FS_stdin_getChar();
        },
  put_char(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },
  fsync(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
  ioctl_tcgets(tty) {
          // typical setting
          return {
            c_iflag: 25856,
            c_oflag: 5,
            c_cflag: 191,
            c_lflag: 35387,
            c_cc: [
              0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00,
              0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ]
          };
        },
  ioctl_tcsets(tty, optional_actions, data) {
          // currently just ignore
          return 0;
        },
  ioctl_tiocgwinsz(tty) {
          return [24, 80];
        },
  },
  default_tty1_ops:{
  put_char(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
  fsync(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        },
  },
  };



  var mmapAlloc = (size) => {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (!ptr) return 0;
      return zeroMemory(ptr, size);
    };
  var MEMFS = {
  ops_table:null,
  mount(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },
  createNode(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        MEMFS.ops_table ||= {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },
  getFileDataAsTypedArray(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },
  expandFileStorage(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },
  resizeFileStorage(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },
  node_ops:{
  getattr(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
  setattr(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
  lookup(parent, name) {
          throw FS.genericErrors[44];
        },
  mknod(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
  rename(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
        },
  unlink(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
  rmdir(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },
  readdir(node) {
          var entries = ['.', '..'];
          for (var key of Object.keys(node.contents)) {
            entries.push(key);
          }
          return entries;
        },
  symlink(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },
  readlink(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        },
  },
  stream_ops:{
  read(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },
  write(stream, buffer, offset, length, position, canOwn) {
          // If the buffer is located in main memory (HEAP), and if
          // memory can grow, we can't hold on to references of the
          // memory buffer, as they may get invalidated. That means we
          // need to do copy its contents.
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }

          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();

          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }

          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
  llseek(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
  allocate(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },
  mmap(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the
            // buffer we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            if (contents) {
              // Try to avoid unnecessary slices.
              if (position > 0 || position + length < contents.length) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(contents, position, position + length);
                }
              }
              HEAP8.set(contents, ptr);
            }
          }
          return { ptr, allocated };
        },
  msync(stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        },
  },
  };



  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
    };

  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
      // Ensure plugins are ready.
      if (typeof Browser != 'undefined') Browser.init();

      var handled = false;
      preloadPlugins.forEach((plugin) => {
        if (handled) return;
        if (plugin['canHandle'](fullname)) {
          plugin['handle'](byteArray, fullname, finish, onerror);
          handled = true;
        }
      });
      return handled;
    };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
      // TODO we should allow people to just pass in a complete filename instead
      // of parent and name being that we just join them anyways
      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
      var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname
      function processData(byteArray) {
        function finish(byteArray) {
          preFinish?.();
          if (!dontCreateFile) {
            FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
          }
          onload?.();
          removeRunDependency(dep);
        }
        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
          onerror?.();
          removeRunDependency(dep);
        })) {
          return;
        }
        finish(byteArray);
      }
      addRunDependency(dep);
      if (typeof url == 'string') {
        asyncLoad(url, processData, onerror);
      } else {
        processData(url);
      }
    };

  var FS_modeStringToFlags = (str) => {
      var flagModes = {
        'r': 0,
        'r+': 2,
        'w': 512 | 64 | 1,
        'w+': 512 | 64 | 2,
        'a': 1024 | 64 | 1,
        'a+': 1024 | 64 | 2,
      };
      var flags = flagModes[str];
      if (typeof flags == 'undefined') {
        throw new Error(`Unknown file open mode: ${str}`);
      }
      return flags;
    };

  var FS_getMode = (canRead, canWrite) => {
      var mode = 0;
      if (canRead) mode |= 292 | 73;
      if (canWrite) mode |= 146;
      return mode;
    };






  var IDBFS = {
  dbs:{
  },
  indexedDB:() => {
        if (typeof indexedDB != 'undefined') return indexedDB;
        var ret = null;
        if (typeof window == 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        return ret;
      },
  DB_VERSION:21,
  DB_STORE_NAME:"FILE_DATA",
  queuePersist:(mount) => {
        function onPersistComplete() {
          if (mount.idbPersistState === 'again') startPersist(); // If a new sync request has appeared in between, kick off a new sync
          else mount.idbPersistState = 0; // Otherwise reset sync state back to idle to wait for a new sync later
        }
        function startPersist() {
          mount.idbPersistState = 'idb'; // Mark that we are currently running a sync operation
          IDBFS.syncfs(mount, /*populate:*/false, onPersistComplete);
        }

        if (!mount.idbPersistState) {
          // Programs typically write/copy/move multiple files in the in-memory
          // filesystem within a single app frame, so when a filesystem sync
          // command is triggered, do not start it immediately, but only after
          // the current frame is finished. This way all the modified files
          // inside the main loop tick will be batched up to the same sync.
          mount.idbPersistState = setTimeout(startPersist, 0);
        } else if (mount.idbPersistState === 'idb') {
          // There is an active IndexedDB sync operation in-flight, but we now
          // have accumulated more files to sync. We should therefore queue up
          // a new sync after the current one finishes so that all writes
          // will be properly persisted.
          mount.idbPersistState = 'again';
        }
      },
  mount:(mount) => {
        // reuse core MEMFS functionality
        var mnt = MEMFS.mount(mount);
        // If the automatic IDBFS persistence option has been selected, then automatically persist
        // all modifications to the filesystem as they occur.
        if (mount?.opts?.autoPersist) {
          mnt.idbPersistState = 0; // IndexedDB sync starts in idle state
          var memfs_node_ops = mnt.node_ops;
          mnt.node_ops = Object.assign({}, mnt.node_ops); // Clone node_ops to inject write tracking
          mnt.node_ops.mknod = (parent, name, mode, dev) => {
            var node = memfs_node_ops.mknod(parent, name, mode, dev);
            // Propagate injected node_ops to the newly created child node
            node.node_ops = mnt.node_ops;
            // Remember for each IDBFS node which IDBFS mount point they came from so we know which mount to persist on modification.
            node.idbfs_mount = mnt.mount;
            // Remember original MEMFS stream_ops for this node
            node.memfs_stream_ops = node.stream_ops;
            // Clone stream_ops to inject write tracking
            node.stream_ops = Object.assign({}, node.stream_ops);

            // Track all file writes
            node.stream_ops.write = (stream, buffer, offset, length, position, canOwn) => {
              // This file has been modified, we must persist IndexedDB when this file closes
              stream.node.isModified = true;
              return node.memfs_stream_ops.write(stream, buffer, offset, length, position, canOwn);
            };

            // Persist IndexedDB on file close
            node.stream_ops.close = (stream) => {
              var n = stream.node;
              if (n.isModified) {
                IDBFS.queuePersist(n.idbfs_mount);
                n.isModified = false;
              }
              if (n.memfs_stream_ops.close) return n.memfs_stream_ops.close(stream);
            };

            return node;
          };
          // Also kick off persisting the filesystem on other operations that modify the filesystem.
          mnt.node_ops.mkdir   = (...args) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.mkdir(...args));
          mnt.node_ops.rmdir   = (...args) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.rmdir(...args));
          mnt.node_ops.symlink = (...args) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.symlink(...args));
          mnt.node_ops.unlink  = (...args) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.unlink(...args));
          mnt.node_ops.rename  = (...args) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.rename(...args));
        }
        return mnt;
      },
  syncfs:(mount, populate, callback) => {
        IDBFS.getLocalSet(mount, (err, local) => {
          if (err) return callback(err);

          IDBFS.getRemoteSet(mount, (err, remote) => {
            if (err) return callback(err);

            var src = populate ? remote : local;
            var dst = populate ? local : remote;

            IDBFS.reconcile(src, dst, callback);
          });
        });
      },
  quit:() => {
        Object.values(IDBFS.dbs).forEach((value) => value.close());
        IDBFS.dbs = {};
      },
  getDB:(name, callback) => {
        // check the cache first
        var db = IDBFS.dbs[name];
        if (db) {
          return callback(null, db);
        }

        var req;
        try {
          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
        } catch (e) {
          return callback(e);
        }
        if (!req) {
          return callback("Unable to connect to IndexedDB");
        }
        req.onupgradeneeded = (e) => {
          var db = /** @type {IDBDatabase} */ (e.target.result);
          var transaction = e.target.transaction;

          var fileStore;

          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
          } else {
            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
          }

          if (!fileStore.indexNames.contains('timestamp')) {
            fileStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
        req.onsuccess = () => {
          db = /** @type {IDBDatabase} */ (req.result);

          // add to the cache
          IDBFS.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = (e) => {
          callback(e.target.error);
          e.preventDefault();
        };
      },
  getLocalSet:(mount, callback) => {
        var entries = {};

        function isRealDir(p) {
          return p !== '.' && p !== '..';
        };
        function toAbsolute(root) {
          return (p) => PATH.join2(root, p);
        };

        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));

        while (check.length) {
          var path = check.pop();
          var stat;

          try {
            stat = FS.stat(path);
          } catch (e) {
            return callback(e);
          }

          if (FS.isDir(stat.mode)) {
            check.push(...FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
          }

          entries[path] = { 'timestamp': stat.mtime };
        }

        return callback(null, { type: 'local', entries: entries });
      },
  getRemoteSet:(mount, callback) => {
        var entries = {};

        IDBFS.getDB(mount.mountpoint, (err, db) => {
          if (err) return callback(err);

          try {
            var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');
            transaction.onerror = (e) => {
              callback(e.target.error);
              e.preventDefault();
            };

            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
            var index = store.index('timestamp');

            index.openKeyCursor().onsuccess = (event) => {
              var cursor = event.target.result;

              if (!cursor) {
                return callback(null, { type: 'remote', db, entries });
              }

              entries[cursor.primaryKey] = { 'timestamp': cursor.key };

              cursor.continue();
            };
          } catch (e) {
            return callback(e);
          }
        });
      },
  loadLocalEntry:(path, callback) => {
        var stat, node;

        try {
          var lookup = FS.lookupPath(path);
          node = lookup.node;
          stat = FS.stat(path);
        } catch (e) {
          return callback(e);
        }

        if (FS.isDir(stat.mode)) {
          return callback(null, { 'timestamp': stat.mtime, 'mode': stat.mode });
        } else if (FS.isFile(stat.mode)) {
          // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.
          // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.
          node.contents = MEMFS.getFileDataAsTypedArray(node);
          return callback(null, { 'timestamp': stat.mtime, 'mode': stat.mode, 'contents': node.contents });
        } else {
          return callback(new Error('node type not supported'));
        }
      },
  storeLocalEntry:(path, entry, callback) => {
        try {
          if (FS.isDir(entry['mode'])) {
            FS.mkdirTree(path, entry['mode']);
          } else if (FS.isFile(entry['mode'])) {
            FS.writeFile(path, entry['contents'], { canOwn: true });
          } else {
            return callback(new Error('node type not supported'));
          }

          FS.chmod(path, entry['mode']);
          FS.utime(path, entry['timestamp'], entry['timestamp']);
        } catch (e) {
          return callback(e);
        }

        callback(null);
      },
  removeLocalEntry:(path, callback) => {
        try {
          var stat = FS.stat(path);

          if (FS.isDir(stat.mode)) {
            FS.rmdir(path);
          } else if (FS.isFile(stat.mode)) {
            FS.unlink(path);
          }
        } catch (e) {
          return callback(e);
        }

        callback(null);
      },
  loadRemoteEntry:(store, path, callback) => {
        var req = store.get(path);
        req.onsuccess = (event) => callback(null, event.target.result);
        req.onerror = (e) => {
          callback(e.target.error);
          e.preventDefault();
        };
      },
  storeRemoteEntry:(store, path, entry, callback) => {
        try {
          var req = store.put(entry, path);
        } catch (e) {
          callback(e);
          return;
        }
        req.onsuccess = (event) => callback();
        req.onerror = (e) => {
          callback(e.target.error);
          e.preventDefault();
        };
      },
  removeRemoteEntry:(store, path, callback) => {
        var req = store.delete(path);
        req.onsuccess = (event) => callback();
        req.onerror = (e) => {
          callback(e.target.error);
          e.preventDefault();
        };
      },
  reconcile:(src, dst, callback) => {
        var total = 0;

        var create = [];
        Object.keys(src.entries).forEach((key) => {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e['timestamp'].getTime() != e2['timestamp'].getTime()) {
            create.push(key);
            total++;
          }
        });

        var remove = [];
        Object.keys(dst.entries).forEach((key) => {
          if (!src.entries[key]) {
            remove.push(key);
            total++;
          }
        });

        if (!total) {
          return callback(null);
        }

        var errored = false;
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);

        function done(err) {
          if (err && !errored) {
            errored = true;
            return callback(err);
          }
        };

        // transaction may abort if (for example) there is a QuotaExceededError
        transaction.onerror = transaction.onabort = (e) => {
          done(e.target.error);
          e.preventDefault();
        };

        transaction.oncomplete = (e) => {
          if (!errored) {
            callback(null);
          }
        };

        // sort paths in ascending order so directory entries are created
        // before the files inside them
        create.sort().forEach((path) => {
          if (dst.type === 'local') {
            IDBFS.loadRemoteEntry(store, path, (err, entry) => {
              if (err) return done(err);
              IDBFS.storeLocalEntry(path, entry, done);
            });
          } else {
            IDBFS.loadLocalEntry(path, (err, entry) => {
              if (err) return done(err);
              IDBFS.storeRemoteEntry(store, path, entry, done);
            });
          }
        });

        // sort paths in descending order so files are deleted before their
        // parent directories
        remove.sort().reverse().forEach((path) => {
          if (dst.type === 'local') {
            IDBFS.removeLocalEntry(path, done);
          } else {
            IDBFS.removeRemoteEntry(store, path, done);
          }
        });
      },
  };



  var ERRNO_CODES = {
      'EPERM': 63,
      'ENOENT': 44,
      'ESRCH': 71,
      'EINTR': 27,
      'EIO': 29,
      'ENXIO': 60,
      'E2BIG': 1,
      'ENOEXEC': 45,
      'EBADF': 8,
      'ECHILD': 12,
      'EAGAIN': 6,
      'EWOULDBLOCK': 6,
      'ENOMEM': 48,
      'EACCES': 2,
      'EFAULT': 21,
      'ENOTBLK': 105,
      'EBUSY': 10,
      'EEXIST': 20,
      'EXDEV': 75,
      'ENODEV': 43,
      'ENOTDIR': 54,
      'EISDIR': 31,
      'EINVAL': 28,
      'ENFILE': 41,
      'EMFILE': 33,
      'ENOTTY': 59,
      'ETXTBSY': 74,
      'EFBIG': 22,
      'ENOSPC': 51,
      'ESPIPE': 70,
      'EROFS': 69,
      'EMLINK': 34,
      'EPIPE': 64,
      'EDOM': 18,
      'ERANGE': 68,
      'ENOMSG': 49,
      'EIDRM': 24,
      'ECHRNG': 106,
      'EL2NSYNC': 156,
      'EL3HLT': 107,
      'EL3RST': 108,
      'ELNRNG': 109,
      'EUNATCH': 110,
      'ENOCSI': 111,
      'EL2HLT': 112,
      'EDEADLK': 16,
      'ENOLCK': 46,
      'EBADE': 113,
      'EBADR': 114,
      'EXFULL': 115,
      'ENOANO': 104,
      'EBADRQC': 103,
      'EBADSLT': 102,
      'EDEADLOCK': 16,
      'EBFONT': 101,
      'ENOSTR': 100,
      'ENODATA': 116,
      'ETIME': 117,
      'ENOSR': 118,
      'ENONET': 119,
      'ENOPKG': 120,
      'EREMOTE': 121,
      'ENOLINK': 47,
      'EADV': 122,
      'ESRMNT': 123,
      'ECOMM': 124,
      'EPROTO': 65,
      'EMULTIHOP': 36,
      'EDOTDOT': 125,
      'EBADMSG': 9,
      'ENOTUNIQ': 126,
      'EBADFD': 127,
      'EREMCHG': 128,
      'ELIBACC': 129,
      'ELIBBAD': 130,
      'ELIBSCN': 131,
      'ELIBMAX': 132,
      'ELIBEXEC': 133,
      'ENOSYS': 52,
      'ENOTEMPTY': 55,
      'ENAMETOOLONG': 37,
      'ELOOP': 32,
      'EOPNOTSUPP': 138,
      'EPFNOSUPPORT': 139,
      'ECONNRESET': 15,
      'ENOBUFS': 42,
      'EAFNOSUPPORT': 5,
      'EPROTOTYPE': 67,
      'ENOTSOCK': 57,
      'ENOPROTOOPT': 50,
      'ESHUTDOWN': 140,
      'ECONNREFUSED': 14,
      'EADDRINUSE': 3,
      'ECONNABORTED': 13,
      'ENETUNREACH': 40,
      'ENETDOWN': 38,
      'ETIMEDOUT': 73,
      'EHOSTDOWN': 142,
      'EHOSTUNREACH': 23,
      'EINPROGRESS': 26,
      'EALREADY': 7,
      'EDESTADDRREQ': 17,
      'EMSGSIZE': 35,
      'EPROTONOSUPPORT': 66,
      'ESOCKTNOSUPPORT': 137,
      'EADDRNOTAVAIL': 4,
      'ENETRESET': 39,
      'EISCONN': 30,
      'ENOTCONN': 53,
      'ETOOMANYREFS': 141,
      'EUSERS': 136,
      'EDQUOT': 19,
      'ESTALE': 72,
      'ENOTSUP': 138,
      'ENOMEDIUM': 148,
      'EILSEQ': 25,
      'EOVERFLOW': 61,
      'ECANCELED': 11,
      'ENOTRECOVERABLE': 56,
      'EOWNERDEAD': 62,
      'ESTRPIPE': 135,
    };

  var NODEFS = {
  isWindows:false,
  staticInit() {
        NODEFS.isWindows = !!process.platform.match(/^win/);
        var flags = process.binding("constants");
        // Node.js 4 compatibility: it has no namespaces for constants
        if (flags["fs"]) {
          flags = flags["fs"];
        }
        NODEFS.flagsForNodeMap = {
          "1024": flags["O_APPEND"],
          "64": flags["O_CREAT"],
          "128": flags["O_EXCL"],
          "256": flags["O_NOCTTY"],
          "0": flags["O_RDONLY"],
          "2": flags["O_RDWR"],
          "4096": flags["O_SYNC"],
          "512": flags["O_TRUNC"],
          "1": flags["O_WRONLY"],
          "131072": flags["O_NOFOLLOW"],
        };
      },
  convertNodeCode(e) {
        var code = e.code;
        return ERRNO_CODES[code];
      },
  tryFSOperation(f) {
        try {
          return f();
        } catch (e) {
          if (!e.code) throw e;
          // node under windows can return code 'UNKNOWN' here:
          // https://github.com/emscripten-core/emscripten/issues/15468
          if (e.code === 'UNKNOWN') throw new FS.ErrnoError(28);
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
      },
  mount(mount) {
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);
      },
  createNode(parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(28);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },
  getMode(path) {
        var stat;
        return NODEFS.tryFSOperation(() => {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            // Node.js on Windows never represents permission bit 'x', so
            // propagate read bits to execute bits
            stat.mode |= (stat.mode & 292) >> 2;
          }
          return stat.mode;
        });
      },
  realPath(node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join(...parts);
      },
  flagsForNode(flags) {
        flags &= ~2097152; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~2048; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~32768; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~524288; // Some applications may pass it; it makes no sense for a single process.
        flags &= ~65536; // Node.js doesn't need this passed in, it errors.
        var newFlags = 0;
        for (var k in NODEFS.flagsForNodeMap) {
          if (flags & k) {
            newFlags |= NODEFS.flagsForNodeMap[k];
            flags ^= k;
          }
        }
        if (flags) {
          throw new FS.ErrnoError(28);
        }
        return newFlags;
      },
  node_ops:{
  getattr(node) {
          var path = NODEFS.realPath(node);
          var stat;
          NODEFS.tryFSOperation(() => stat = fs.lstatSync(path));
          if (NODEFS.isWindows) {
            // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake
            // them with default blksize of 4096.
            // See http://support.microsoft.com/kb/140365
            if (!stat.blksize) {
              stat.blksize = 4096;
            }
            if (!stat.blocks) {
              stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
            }
            // Node.js on Windows never represents permission bit 'x', so
            // propagate read bits to execute bits.
            stat.mode |= (stat.mode & 292) >> 2;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },
  setattr(node, attr) {
          var path = NODEFS.realPath(node);
          NODEFS.tryFSOperation(() => {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          });
        },
  lookup(parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },
  mknod(parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = NODEFS.realPath(node);
          NODEFS.tryFSOperation(() => {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          });
          return node;
        },
  rename(oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          NODEFS.tryFSOperation(() => fs.renameSync(oldPath, newPath));
          oldNode.name = newName;
        },
  unlink(parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          NODEFS.tryFSOperation(() => fs.unlinkSync(path));
        },
  rmdir(parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          NODEFS.tryFSOperation(() => fs.rmdirSync(path));
        },
  readdir(node) {
          var path = NODEFS.realPath(node);
          return NODEFS.tryFSOperation(() => fs.readdirSync(path));
        },
  symlink(parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          NODEFS.tryFSOperation(() => fs.symlinkSync(oldPath, newPath));
        },
  readlink(node) {
          var path = NODEFS.realPath(node);
          return NODEFS.tryFSOperation(() => fs.readlinkSync(path));
        },
  },
  stream_ops:{
  open(stream) {
          var path = NODEFS.realPath(stream.node);
          NODEFS.tryFSOperation(() => {
            if (FS.isFile(stream.node.mode)) {
              stream.shared.refcount = 1;
              stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
            }
          });
        },
  close(stream) {
          NODEFS.tryFSOperation(() => {
            if (FS.isFile(stream.node.mode) && stream.nfd && --stream.shared.refcount === 0) {
              fs.closeSync(stream.nfd);
            }
          });
        },
  dup(stream) {
          stream.shared.refcount++;
        },
  read(stream, buffer, offset, length, position) {
          // Node.js < 6 compatibility: node errors on 0 length reads
          if (length === 0) return 0;
          return NODEFS.tryFSOperation(() =>
            fs.readSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position)
          );
        },
  write(stream, buffer, offset, length, position) {
          return NODEFS.tryFSOperation(() =>
            fs.writeSync(stream.nfd, new Int8Array(buffer.buffer, offset, length), 0, length, position)
          );
        },
  llseek(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              NODEFS.tryFSOperation(() => {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              });
            }
          }

          if (position < 0) {
            throw new FS.ErrnoError(28);
          }

          return position;
        },
  mmap(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }

          var ptr = mmapAlloc(length);

          NODEFS.stream_ops.read(stream, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        },
  msync(stream, buffer, offset, length, mmapFlags) {
          NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        },
  },
  };
  var FS = {
  root:null,
  mounts:[],
  devices:{
  },
  streams:[],
  nextInode:1,
  nameTable:null,
  currentPath:"/",
  initialized:false,
  ignorePermissions:true,
  ErrnoError:class {
        // We set the `name` property to be able to identify `FS.ErrnoError`
        // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
        // - when using PROXYFS, an error can come from an underlying FS
        // as different FS objects have their own FS.ErrnoError each,
        // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
        // we'll use the reliable test `err.name == "ErrnoError"` instead
        constructor(errno) {
          // TODO(sbc): Use the inline member declaration syntax once we
          // support it in acorn and closure.
          this.name = 'ErrnoError';
          this.errno = errno;
        }
      },
  genericErrors:{
  },
  filesystems:null,
  syncFSRequests:0,
  FSStream:class {
        constructor() {
          // TODO(https://github.com/emscripten-core/emscripten/issues/21414):
          // Use inline field declarations.
          this.shared = {};
        }
        get object() {
          return this.node;
        }
        set object(val) {
          this.node = val;
        }
        get isRead() {
          return (this.flags & 2097155) !== 1;
        }
        get isWrite() {
          return (this.flags & 2097155) !== 0;
        }
        get isAppend() {
          return (this.flags & 1024);
        }
        get flags() {
          return this.shared.flags;
        }
        set flags(val) {
          this.shared.flags = val;
        }
        get position() {
          return this.shared.position;
        }
        set position(val) {
          this.shared.position = val;
        }
      },
  FSNode:class {
        constructor(parent, name, mode, rdev) {
          if (!parent) {
            parent = this;  // root node sets parent to itself
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
          this.readMode = 292 | 73;
          this.writeMode = 146;
        }
        get read() {
          return (this.mode & this.readMode) === this.readMode;
        }
        set read(val) {
          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
        }
        get write() {
          return (this.mode & this.writeMode) === this.writeMode;
        }
        set write(val) {
          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
        }
        get isFolder() {
          return FS.isDir(this.mode);
        }
        get isDevice() {
          return FS.isChrdev(this.mode);
        }
      },
  lookupPath(path, opts = {}) {
        path = PATH_FS.resolve(path);

        if (!path) return { path: '', node: null };

        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)

        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }

        // split the absolute path
        var parts = path.split('/').filter((p) => !!p);

        // start at the root
        var current = FS.root;
        var current_path = '/';

        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }

          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);

          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }

          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);

              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;

              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }

        return { path: current_path, node: current };
      },
  getPath(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? `${mount}/${path}` : mount + path;
          }
          path = path ? `${node.name}/${path}` : node.name;
          node = node.parent;
        }
      },
  hashName(parentid, name) {
        var hash = 0;

        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },
  hashAddNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
  hashRemoveNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
  lookupNode(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },
  createNode(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);

        FS.hashAddNode(node);

        return node;
      },
  destroyNode(node) {
        FS.hashRemoveNode(node);
      },
  isRoot(node) {
        return node === node.parent;
      },
  isMountpoint(node) {
        return !!node.mounted;
      },
  isFile(mode) {
        return (mode & 61440) === 32768;
      },
  isDir(mode) {
        return (mode & 61440) === 16384;
      },
  isLink(mode) {
        return (mode & 61440) === 40960;
      },
  isChrdev(mode) {
        return (mode & 61440) === 8192;
      },
  isBlkdev(mode) {
        return (mode & 61440) === 24576;
      },
  isFIFO(mode) {
        return (mode & 61440) === 4096;
      },
  isSocket(mode) {
        return (mode & 49152) === 49152;
      },
  flagsToPermissionString(flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },
  nodePermissions(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
  mayLookup(dir) {
        if (!FS.isDir(dir.mode)) return 54;
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },
  mayCreate(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },
  mayDelete(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
  mayOpen(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
  MAX_OPEN_FDS:4096,
  nextfd() {
        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
  getStreamChecked(fd) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        return stream;
      },
  getStream:(fd) => FS.streams[fd],
  createStream(stream, fd = -1) {

        // clone it, so we can return an instance of FSStream
        stream = Object.assign(new FS.FSStream(), stream);
        if (fd == -1) {
          fd = FS.nextfd();
        }
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
  closeStream(fd) {
        FS.streams[fd] = null;
      },
  dupStream(origStream, fd = -1) {
        var stream = FS.createStream(origStream, fd);
        stream.stream_ops?.dup?.(stream);
        return stream;
      },
  chrdev_stream_ops:{
  open(stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          stream.stream_ops.open?.(stream);
        },
  llseek() {
          throw new FS.ErrnoError(70);
        },
  },
  major:(dev) => ((dev) >> 8),
  minor:(dev) => ((dev) & 0xff),
  makedev:(ma, mi) => ((ma) << 8 | (mi)),
  registerDevice(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },
  getDevice:(dev) => FS.devices[dev],
  getMounts(mount) {
        var mounts = [];
        var check = [mount];

        while (check.length) {
          var m = check.pop();

          mounts.push(m);

          check.push(...m.mounts);
        }

        return mounts;
      },
  syncfs(populate, callback) {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }

        FS.syncFSRequests++;

        if (FS.syncFSRequests > 1) {
          err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
        }

        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;

        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }

        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };

        // sync all mounts
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
  mount(type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;

        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;

          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }

          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }

        var mount = {
          type,
          opts,
          mountpoint,
          mounts: []
        };

        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;

        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;

          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }

        return mountRoot;
      },
  unmount(mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }

        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);

        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];

          while (current) {
            var next = current.name_next;

            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }

            current = next;
          }
        });

        // no longer a mountpoint
        node.mounted = null;

        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
  lookup(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },
  mknod(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
  create(path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },
  mkdir(path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },
  mkdirTree(path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },
  mkdev(path, mode, dev) {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },
  symlink(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
  rename(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;

        // let the errors from non existent directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;

        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
          // update old node (we do this here to avoid each backend
          // needing to)
          old_node.parent = new_dir;
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },
  rmdir(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
  readdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },
  unlink(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
  readlink(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },
  stat(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },
  lstat(path) {
        return FS.stat(path, true);
      },
  chmod(path, mode, dontFollow) {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },
  lchmod(path, mode) {
        FS.chmod(path, mode, true);
      },
  fchmod(fd, mode) {
        var stream = FS.getStreamChecked(fd);
        FS.chmod(stream.node, mode);
      },
  chown(path, uid, gid, dontFollow) {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },
  lchown(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },
  fchown(fd, uid, gid) {
        var stream = FS.getStreamChecked(fd);
        FS.chown(stream.node, uid, gid);
      },
  truncate(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },
  ftruncate(fd, len) {
        var stream = FS.getStreamChecked(fd);
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },
  utime(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },
  open(path, flags, mode) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;
        if ((flags & 64)) {
          mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512) && !created) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);

        // register the stream with the filesystem
        var stream = FS.createStream({
          node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        });
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },
  close(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
  isClosed(stream) {
        return stream.fd === null;
      },
  llseek(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
  read(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },
  write(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },
  allocate(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
  mmap(stream, length, position, prot, flags) {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        if (!length) {
          throw new FS.ErrnoError(28);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
  msync(stream, buffer, offset, length, mmapFlags) {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },
  ioctl(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
  readFile(path, opts = {}) {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error(`Invalid encoding type "${opts.encoding}"`);
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
  writeFile(path, data, opts = {}) {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },
  cwd:() => FS.currentPath,
  chdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
  createDefaultDirectories() {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },
  createDefaultDevices() {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        // use a buffer to avoid overhead of individual crypto calls per byte
        var randomBuffer = new Uint8Array(1024), randomLeft = 0;
        var randomByte = () => {
          if (randomLeft === 0) {
            randomLeft = randomFill(randomBuffer).byteLength;
          }
          return randomBuffer[--randomLeft];
        };
        FS.createDevice('/dev', 'random', randomByte);
        FS.createDevice('/dev', 'urandom', randomByte);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },
  createSpecialDirectories() {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount() {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },
  createStandardStreams(input, output, error) {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops

        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (input) {
          FS.createDevice('/dev', 'stdin', input);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (output) {
          FS.createDevice('/dev', 'stdout', null, output);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (error) {
          FS.createDevice('/dev', 'stderr', null, error);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }

        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },
  staticInit() {
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });

        FS.nameTable = new Array(4096);

        FS.mount(MEMFS, {}, '/');

        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();

        FS.filesystems = {
          'MEMFS': MEMFS,
          'IDBFS': IDBFS,
          'NODEFS': NODEFS,
        };
      },
  init(input, output, error) {
        FS.initialized = true;

        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        input ??= Module['stdin'];
        output ??= Module['stdout'];
        error ??= Module['stderr'];

        FS.createStandardStreams(input, output, error);
      },
  quit() {
        FS.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        _fflush(0);
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
  findObject(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
  analyzePath(path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },
  createPath(parent, path, canRead, canWrite) {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },
  createFile(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS_getMode(canRead, canWrite);
        return FS.create(path, mode);
      },
  createDataFile(parent, name, data, canRead, canWrite, canOwn) {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS_getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
      },
  createDevice(parent, name, input, output) {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS_getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open(stream) {
            stream.seekable = false;
          },
          close(stream) {
            // flush any pending line data
            if (output?.buffer?.length) {
              output(10);
            }
          },
          read(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },
  forceLoadFile(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else { // Command-line.
          try {
            obj.contents = readBinary(obj.url);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
      },
  createLazyFile(parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array).
        // Actual getting is abstracted away for eventual reuse.
        class LazyUint8Array {
          constructor() {
            this.lengthKnown = false;
            this.chunks = []; // Loaded chunks. Index is the chunk number
          }
          get(idx) {
            if (idx > this.length-1 || idx < 0) {
              return undefined;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = (idx / this.chunkSize)|0;
            return this.getter(chunkNum)[chunkOffset];
          }
          setDataGetter(getter) {
            this.getter = getter;
          }
          cacheLength() {
            // Find length
            var xhr = new XMLHttpRequest();
            xhr.open('HEAD', url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";

            var chunkSize = 1024*1024; // Chunk size in bytes

            if (!hasByteServing) chunkSize = datalength;

            // Function to get a range from the remote URL.
            var doXHR = (from, to) => {
              if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");

              // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, false);
              if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);

              // Some hints to the browser that we want binary data.
              xhr.responseType = 'arraybuffer';
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType('text/plain; charset=x-user-defined');
              }

              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              if (xhr.response !== undefined) {
                return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
              }
              return intArrayFromString(xhr.responseText || '', true);
            };
            var lazyArray = this;
            lazyArray.setDataGetter((chunkNum) => {
              var start = chunkNum * chunkSize;
              var end = (chunkNum+1) * chunkSize - 1; // including this byte
              end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
                lazyArray.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
              return lazyArray.chunks[chunkNum];
            });

            if (usesGzip || !datalength) {
              // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
              chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }

            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          }
          get length() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }
          get chunkSize() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }
        }

        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }

        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = (...args) => {
            FS.forceLoadFile(node);
            return fn(...args);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }
        // use a custom read function
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position)
        };
        // use a custom mmap function
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },
  };

  var SYSCALLS = {
  DEFAULT_POLLMASK:5,
  calculateAt(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },
  doStat(func, path, buf) {
        var stat = func(path);
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = stat.mode;
        HEAPU32[(((buf)+(8))>>2)] = stat.nlink;
        HEAP32[(((buf)+(12))>>2)] = stat.uid;
        HEAP32[(((buf)+(16))>>2)] = stat.gid;
        HEAP32[(((buf)+(20))>>2)] = stat.rdev;
        HEAP64[(((buf)+(24))>>3)] = BigInt(stat.size);
        HEAP32[(((buf)+(32))>>2)] = 4096;
        HEAP32[(((buf)+(36))>>2)] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        HEAP64[(((buf)+(40))>>3)] = BigInt(Math.floor(atime / 1000));
        HEAPU32[(((buf)+(48))>>2)] = (atime % 1000) * 1000 * 1000;
        HEAP64[(((buf)+(56))>>3)] = BigInt(Math.floor(mtime / 1000));
        HEAPU32[(((buf)+(64))>>2)] = (mtime % 1000) * 1000 * 1000;
        HEAP64[(((buf)+(72))>>3)] = BigInt(Math.floor(ctime / 1000));
        HEAPU32[(((buf)+(80))>>2)] = (ctime % 1000) * 1000 * 1000;
        HEAP64[(((buf)+(88))>>3)] = BigInt(stat.ino);
        return 0;
      },
  doMsync(addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          // MAP_PRIVATE calls need not to be synced back to underlying fs
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },
  getStreamFromFD(fd) {
        var stream = FS.getStreamChecked(fd);
        return stream;
      },
  varargs:undefined,
  getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
  };
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
  try {

      // readfds are supported,
      // writefds checks socket open status
      // exceptfds are supported, although on web, such exceptional conditions never arise in web sockets
      //                          and so the exceptfds list will always return empty.
      // timeout is supported, although on SOCKFS and PIPEFS these are ignored and always treated as 0 - fully async

      var total = 0;

      var srcReadLow = (readfds ? HEAP32[((readfds)>>2)] : 0),
          srcReadHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0);
      var srcWriteLow = (writefds ? HEAP32[((writefds)>>2)] : 0),
          srcWriteHigh = (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0);
      var srcExceptLow = (exceptfds ? HEAP32[((exceptfds)>>2)] : 0),
          srcExceptHigh = (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);

      var dstReadLow = 0,
          dstReadHigh = 0;
      var dstWriteLow = 0,
          dstWriteHigh = 0;
      var dstExceptLow = 0,
          dstExceptHigh = 0;

      var allLow = (readfds ? HEAP32[((readfds)>>2)] : 0) |
                   (writefds ? HEAP32[((writefds)>>2)] : 0) |
                   (exceptfds ? HEAP32[((exceptfds)>>2)] : 0);
      var allHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0) |
                    (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0) |
                    (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);

      var check = function(fd, low, high, val) {
        return (fd < 32 ? (low & val) : (high & val));
      };

      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << (fd % 32);
        if (!(check(fd, allLow, allHigh, mask))) {
          continue;  // index isn't in the set
        }

        var stream = SYSCALLS.getStreamFromFD(fd);

        var flags = SYSCALLS.DEFAULT_POLLMASK;

        if (stream.stream_ops.poll) {
          var timeoutInMillis = -1;
          if (timeout) {
            // select(2) is declared to accept "struct timeval { time_t tv_sec; suseconds_t tv_usec; }".
            // However, musl passes the two values to the syscall as an array of long values.
            // Note that sizeof(time_t) != sizeof(long) in wasm32. The former is 8, while the latter is 4.
            // This means using "C_STRUCTS.timeval.tv_usec" leads to a wrong offset.
            // So, instead, we use POINTER_SIZE.
            var tv_sec = (readfds ? HEAP32[((timeout)>>2)] : 0),
                tv_usec = (readfds ? HEAP32[(((timeout)+(4))>>2)] : 0);
            timeoutInMillis = (tv_sec + tv_usec / 1000000) * 1000;
          }
          flags = stream.stream_ops.poll(stream, timeoutInMillis);
        }

        if ((flags & 1) && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? (dstReadLow = dstReadLow | mask) : (dstReadHigh = dstReadHigh | mask);
          total++;
        }
        if ((flags & 4) && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? (dstWriteLow = dstWriteLow | mask) : (dstWriteHigh = dstWriteHigh | mask);
          total++;
        }
        if ((flags & 2) && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? (dstExceptLow = dstExceptLow | mask) : (dstExceptHigh = dstExceptHigh | mask);
          total++;
        }
      }

      if (readfds) {
        HEAP32[((readfds)>>2)] = dstReadLow;
        HEAP32[(((readfds)+(4))>>2)] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[((writefds)>>2)] = dstWriteLow;
        HEAP32[(((writefds)+(4))>>2)] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[((exceptfds)>>2)] = dstExceptLow;
        HEAP32[(((exceptfds)+(4))>>2)] = dstExceptHigh;
      }

      return total;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall__newselect.sig = 'iipppp';

  var SOCKFS = {
  mount(mount) {
        // If Module['websocket'] has already been defined (e.g. for configuring
        // the subprotocol/url) use that, if not initialise it to a new object.
        Module['websocket'] = (Module['websocket'] &&
                               ('object' === typeof Module['websocket'])) ? Module['websocket'] : {};

        // Add the Event registration mechanism to the exported websocket configuration
        // object so we can register network callbacks from native JavaScript too.
        // For more documentation see system/include/emscripten/emscripten.h
        Module['websocket']._callbacks = {};
        Module['websocket']['on'] = /** @this{Object} */ function(event, callback) {
          if ('function' === typeof callback) {
            this._callbacks[event] = callback;
          }
          return this;
        };

        Module['websocket'].emit = /** @this{Object} */ function(event, param) {
          if ('function' === typeof this._callbacks[event]) {
            this._callbacks[event].call(this, param);
          }
        };

        // If debug is enabled register simple default logging callbacks for each Event.

        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },
  createSocket(family, type, protocol) {
        type &= ~526336; // Some applications may pass it; it makes no sense for a single process.
        var streaming = type == 1;
        if (streaming && protocol && protocol != 6) {
          throw new FS.ErrnoError(66); // if SOCK_STREAM, must be tcp or 0.
        }

        // create our internal socket structure
        var sock = {
          family,
          type,
          protocol,
          server: null,
          error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };

        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;

        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node,
          flags: 2,
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });

        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;

        return sock;
      },
  getSocket(fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },
  stream_ops:{
  poll(stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },
  ioctl(stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },
  read(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },
  write(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },
  close(stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        },
  },
  nextname() {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },
  websocket_sock_ops:{
  createPeer(sock, addr, port) {
          var ws;

          if (typeof addr == 'object') {
            ws = addr;
            addr = null;
            port = null;
          }

          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // runtimeConfig gets set to true if WebSocket runtime configuration is available.
              var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));

              // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
              var url = 'ws:#'.replace('#', '//');

              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['url']) {
                  url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
                }
              }

              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                var parts = addr.split('/');
                url = url + parts[0] + ":" + port + "/" + parts.slice(1).join('/');
              }

              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'

              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['subprotocol']) {
                  subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
                }
              }

              // The default WebSocket options
              var opts = undefined;

              if (subProtocols !== 'null') {
                // The regex trims the string (removes spaces at the beginning and end, then splits the string by
                // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
                subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);

                opts = subProtocols;
              }

              // some webservers (azure) does not support subprotocol header
              if (runtimeConfig && null === Module['websocket']['subprotocol']) {
                subProtocols = 'null';
                opts = undefined;
              }

              // If node we use the ws library.
              var WebSocketConstructor;
              if (ENVIRONMENT_IS_NODE) {
                WebSocketConstructor = /** @type{(typeof WebSocket)} */(require('ws'));
              } else
              {
                WebSocketConstructor = WebSocket;
              }
              ws = new WebSocketConstructor(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(23);
            }
          }

          var peer = {
            addr,
            port,
            socket: ws,
            dgram_send_queue: []
          };

          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);

          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport != 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }

          return peer;
        },
  getPeer(sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },
  addPeer(sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },
  removePeer(sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },
  handlePeerEvents(sock, peer) {
          var first = true;

          var handleOpen = function () {

            Module['websocket'].emit('open', sock.stream.fd);

            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };

          function handleMessage(data) {
            if (typeof data == 'string') {
              var encoder = new TextEncoder(); // should be utf-8
              data = encoder.encode(data); // make a typed array from the string
            } else {
              assert(data.byteLength !== undefined); // must receive an ArrayBuffer
              if (data.byteLength == 0) {
                // An empty ArrayBuffer will emit a pseudo disconnect event
                // as recv/recvmsg will return zero which indicates that a socket
                // has performed a shutdown although the connection has not been disconnected yet.
                return;
              }
              data = new Uint8Array(data); // make a typed array view on the array buffer
            }

            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }

            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
            Module['websocket'].emit('message', sock.stream.fd);
          };

          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, isBinary) {
              if (!isBinary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer); // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('close', function() {
              Module['websocket'].emit('close', sock.stream.fd);
            });
            peer.socket.on('error', function(error) {
              // Although the ws library may pass errors that may be more descriptive than
              // ECONNREFUSED they are not necessarily the expected error code e.g.
              // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
              // is still probably the most useful thing to do.
              sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onclose = function() {
              Module['websocket'].emit('close', sock.stream.fd);
            };
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
            peer.socket.onerror = function(error) {
              // The WebSocket spec only allows a 'simple event' to be thrown on error,
              // so we only really know as much as ECONNREFUSED.
              sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
            };
          }
        },
  poll(sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }

          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;

          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }

          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }

          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }

          return mask;
        },
  ioctl(sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)] = bytes;
              return 0;
            default:
              return 28;
          }
        },
  close(sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },
  bind(sock, addr, port) {
          if (typeof sock.saddr != 'undefined' || typeof sock.sport != 'undefined') {
            throw new FS.ErrnoError(28);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port;
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e.name === 'ErrnoError')) throw e;
              if (e.errno !== 138) throw e;
            }
          }
        },
  connect(sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(138);
          }

          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }

          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr != 'undefined' && typeof sock.dport != 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(7);
              } else {
                throw new FS.ErrnoError(30);
              }
            }
          }

          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;

          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(26);
        },
  listen(sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(138);
          }
          if (sock.server) {
             throw new FS.ErrnoError(28);  // already listening
          }
          var WebSocketServer = require('ws').Server;
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host,
            port: sock.sport
            // TODO support backlog
          });
          Module['websocket'].emit('listen', sock.stream.fd); // Send Event with listen fd.

          sock.server.on('connection', function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);

              // create a peer on the new socket
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;

              // push to queue for accept to pick up
              sock.pending.push(newsock);
              Module['websocket'].emit('connection', newsock.stream.fd);
            } else {
              // create a peer on the listen socket so calling sendto
              // with the listen socket and an address will resolve
              // to the correct client
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
              Module['websocket'].emit('connection', sock.stream.fd);
            }
          });
          sock.server.on('close', function() {
            Module['websocket'].emit('close', sock.stream.fd);
            sock.server = null;
          });
          sock.server.on('error', function(error) {
            // Although the ws library may pass errors that may be more descriptive than
            // ECONNREFUSED they are not necessarily the expected error code e.g.
            // ENOTFOUND on getaddrinfo seems to be node.js specific, so using EHOSTUNREACH
            // is still probably the most useful thing to do. This error shouldn't
            // occur in a well written app as errors should get trapped in the compiled
            // app's own getaddrinfo call.
            sock.error = 23; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
            Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'EHOSTUNREACH: Host is unreachable']);
            // don't throw
          });
        },
  accept(listensock) {
          if (!listensock.server || !listensock.pending.length) {
            throw new FS.ErrnoError(28);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },
  getname(sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(53);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr, port };
        },
  sendmsg(sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(17);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }

          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);

          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(53);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(6);
            }
          }

          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          if (ArrayBuffer.isView(buffer)) {
            offset += buffer.byteOffset;
            buffer = buffer.buffer;
          }

          var data;
            data = buffer.slice(offset, offset + length);

          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }

          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(28);
          }
        },
  recvmsg(sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(53);
          }

          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);

              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(53);
              }
              if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              // else, our socket is in a valid state but truly has nothing available
              throw new FS.ErrnoError(6);
            }
            throw new FS.ErrnoError(6);
          }

          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };

          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }

          return res;
        },
  },
  };

  var getSocketFromFD = (fd) => {
      var socket = SOCKFS.getSocket(fd);
      if (!socket) throw new FS.ErrnoError(8);
      return socket;
    };

  var Sockets = {
  BUFFER_SIZE:10240,
  MAX_BUFFER_SIZE:10485760,
  nextFd:1,
  fds:{
  },
  nextport:1,
  maxport:65535,
  peer:null,
  connections:{
  },
  portmap:{
  },
  localAddr:4261412874,
  addrPool:[33554442,50331658,67108874,83886090,100663306,117440522,134217738,150994954,167772170,184549386,201326602,218103818,234881034],
  };

  var inetNtop4 = (addr) => {
      return (addr & 0xff) + '.' + ((addr >> 8) & 0xff) + '.' + ((addr >> 16) & 0xff) + '.' + ((addr >> 24) & 0xff)
    };


  var inetNtop6 = (ints) => {
      //  ref:  http://www.ietf.org/rfc/rfc2373.txt - section 2.5.4
      //  Format for IPv4 compatible and mapped  128-bit IPv6 Addresses
      //  128-bits are split into eight 16-bit words
      //  stored in network byte order (big-endian)
      //  |                80 bits               | 16 |      32 bits        |
      //  +-----------------------------------------------------------------+
      //  |               10 bytes               |  2 |      4 bytes        |
      //  +--------------------------------------+--------------------------+
      //  +               5 words                |  1 |      2 words        |
      //  +--------------------------------------+--------------------------+
      //  |0000..............................0000|0000|    IPv4 ADDRESS     | (compatible)
      //  +--------------------------------------+----+---------------------+
      //  |0000..............................0000|FFFF|    IPv4 ADDRESS     | (mapped)
      //  +--------------------------------------+----+---------------------+
      var str = "";
      var word = 0;
      var longest = 0;
      var lastzero = 0;
      var zstart = 0;
      var len = 0;
      var i = 0;
      var parts = [
        ints[0] & 0xffff,
        (ints[0] >> 16),
        ints[1] & 0xffff,
        (ints[1] >> 16),
        ints[2] & 0xffff,
        (ints[2] >> 16),
        ints[3] & 0xffff,
        (ints[3] >> 16)
      ];

      // Handle IPv4-compatible, IPv4-mapped, loopback and any/unspecified addresses

      var hasipv4 = true;
      var v4part = "";
      // check if the 10 high-order bytes are all zeros (first 5 words)
      for (i = 0; i < 5; i++) {
        if (parts[i] !== 0) { hasipv4 = false; break; }
      }

      if (hasipv4) {
        // low-order 32-bits store an IPv4 address (bytes 13 to 16) (last 2 words)
        v4part = inetNtop4(parts[6] | (parts[7] << 16));
        // IPv4-mapped IPv6 address if 16-bit value (bytes 11 and 12) == 0xFFFF (6th word)
        if (parts[5] === -1) {
          str = "::ffff:";
          str += v4part;
          return str;
        }
        // IPv4-compatible IPv6 address if 16-bit value (bytes 11 and 12) == 0x0000 (6th word)
        if (parts[5] === 0) {
          str = "::";
          //special case IPv6 addresses
          if (v4part === "0.0.0.0") v4part = ""; // any/unspecified address
          if (v4part === "0.0.0.1") v4part = "1";// loopback address
          str += v4part;
          return str;
        }
      }

      // Handle all other IPv6 addresses

      // first run to find the longest contiguous zero words
      for (word = 0; word < 8; word++) {
        if (parts[word] === 0) {
          if (word - lastzero > 1) {
            len = 0;
          }
          lastzero = word;
          len++;
        }
        if (len > longest) {
          longest = len;
          zstart = word - longest + 1;
        }
      }

      for (word = 0; word < 8; word++) {
        if (longest > 1) {
          // compress contiguous zeros - to produce "::"
          if (parts[word] === 0 && word >= zstart && word < (zstart + longest) ) {
            if (word === zstart) {
              str += ":";
              if (zstart === 0) str += ":"; //leading zeros case
            }
            continue;
          }
        }
        // converts 16-bit words from big-endian to little-endian before converting to hex string
        str += Number(_ntohs(parts[word] & 0xffff)).toString(16);
        str += word < 7 ? ":" : "";
      }
      return str;
    };

  var readSockaddr = (sa, salen) => {
      // family / port offsets are common to both sockaddr_in and sockaddr_in6
      var family = HEAP16[((sa)>>1)];
      var port = _ntohs(HEAPU16[(((sa)+(2))>>1)]);
      var addr;

      switch (family) {
        case 2:
          if (salen !== 16) {
            return { errno: 28 };
          }
          addr = HEAP32[(((sa)+(4))>>2)];
          addr = inetNtop4(addr);
          break;
        case 10:
          if (salen !== 28) {
            return { errno: 28 };
          }
          addr = [
            HEAP32[(((sa)+(8))>>2)],
            HEAP32[(((sa)+(12))>>2)],
            HEAP32[(((sa)+(16))>>2)],
            HEAP32[(((sa)+(20))>>2)]
          ];
          addr = inetNtop6(addr);
          break;
        default:
          return { errno: 5 };
      }

      return { family: family, addr: addr, port: port };
    };


  var inetPton4 = (str) => {
      var b = str.split('.');
      for (var i = 0; i < 4; i++) {
        var tmp = Number(b[i]);
        if (isNaN(tmp)) return null;
        b[i] = tmp;
      }
      return (b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)) >>> 0;
    };


  /** @suppress {checkTypes} */
  var jstoi_q = (str) => parseInt(str);
  var inetPton6 = (str) => {
      var words;
      var w, offset, z, i;
      /* http://home.deds.nl/~aeron/regex/ */
      var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i
      var parts = [];
      if (!valid6regx.test(str)) {
        return null;
      }
      if (str === "::") {
        return [0, 0, 0, 0, 0, 0, 0, 0];
      }
      // Z placeholder to keep track of zeros when splitting the string on ":"
      if (str.startsWith("::")) {
        str = str.replace("::", "Z:"); // leading zeros case
      } else {
        str = str.replace("::", ":Z:");
      }

      if (str.indexOf(".") > 0) {
        // parse IPv4 embedded stress
        str = str.replace(new RegExp('[.]', 'g'), ":");
        words = str.split(":");
        words[words.length-4] = jstoi_q(words[words.length-4]) + jstoi_q(words[words.length-3])*256;
        words[words.length-3] = jstoi_q(words[words.length-2]) + jstoi_q(words[words.length-1])*256;
        words = words.slice(0, words.length-2);
      } else {
        words = str.split(":");
      }

      offset = 0; z = 0;
      for (w=0; w < words.length; w++) {
        if (typeof words[w] == 'string') {
          if (words[w] === 'Z') {
            // compressed zeros - write appropriate number of zero words
            for (z = 0; z < (8 - words.length+1); z++) {
              parts[w+z] = 0;
            }
            offset = z-1;
          } else {
            // parse hex to field to 16-bit value and write it in network byte-order
            parts[w+offset] = _htons(parseInt(words[w],16));
          }
        } else {
          // parsed IPv4 words
          parts[w+offset] = words[w];
        }
      }
      return [
        (parts[1] << 16) | parts[0],
        (parts[3] << 16) | parts[2],
        (parts[5] << 16) | parts[4],
        (parts[7] << 16) | parts[6]
      ];
    };
  var DNS = {
  address_map:{
  id:1,
  addrs:{
  },
  names:{
  },
  },
  lookup_name(name) {
        // If the name is already a valid ipv4 / ipv6 address, don't generate a fake one.
        var res = inetPton4(name);
        if (res !== null) {
          return name;
        }
        res = inetPton6(name);
        if (res !== null) {
          return name;
        }

        // See if this name is already mapped.
        var addr;

        if (DNS.address_map.addrs[name]) {
          addr = DNS.address_map.addrs[name];
        } else {
          var id = DNS.address_map.id++;
          assert(id < 65535, 'exceeded max address mappings of 65535');

          addr = '172.29.' + (id & 0xff) + '.' + (id & 0xff00);

          DNS.address_map.names[addr] = name;
          DNS.address_map.addrs[name] = addr;
        }

        return addr;
      },
  lookup_addr(addr) {
        if (DNS.address_map.names[addr]) {
          return DNS.address_map.names[addr];
        }

        return null;
      },
  };
  /** @param {boolean=} allowNull */
  var getSocketAddress = (addrp, addrlen, allowNull) => {
      if (allowNull && addrp === 0) return null;
      var info = readSockaddr(addrp, addrlen);
      if (info.errno) throw new FS.ErrnoError(info.errno);
      info.addr = DNS.lookup_addr(info.addr) || info.addr;
      return info;
    };
  function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
  try {

      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_bind.sig = 'iippiii';

  function ___syscall_chdir(path) {
  try {

      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_chdir.sig = 'ip';

  function ___syscall_chmod(path, mode) {
  try {

      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_chmod.sig = 'ipi';


  function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
  try {

      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_connect.sig = 'iippiii';

  function ___syscall_dup(fd) {
  try {

      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.dupStream(old).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_dup.sig = 'ii';

  function ___syscall_dup3(fd, newfd, flags) {
  try {

      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === newfd) return -28;
      // Check newfd is within range of valid open file descriptors.
      if (newfd < 0 || newfd >= FS.MAX_OPEN_FDS) return -8;
      var existing = FS.getStream(newfd);
      if (existing) FS.close(existing);
      return FS.dupStream(old, newfd).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_dup3.sig = 'iiii';

  function ___syscall_faccessat(dirfd, path, amode, flags) {
  try {

      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        // need a valid mode
        return -28;
      }
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node) {
        return -44;
      }
      var perms = '';
      if (amode & 4) perms += 'r';
      if (amode & 2) perms += 'w';
      if (amode & 1) perms += 'x';
      if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_faccessat.sig = 'iipii';

  var ___syscall_fadvise64 = (fd, offset, len, advice) => {
      return 0; // your advice is important to us (but we can't use it)
    };
  ___syscall_fadvise64.sig = 'iijji';


  var INT53_MAX = 9007199254740992;

  var INT53_MIN = -9007199254740992;
  var bigintToI53Checked = (num) => (num < INT53_MIN || num > INT53_MAX) ? NaN : Number(num);
  function ___syscall_fallocate(fd, mode, offset, len) {
    offset = bigintToI53Checked(offset);
    len = bigintToI53Checked(len);


  try {

      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd)
      FS.allocate(stream, offset, len);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  ___syscall_fallocate.sig = 'iiijj';

  /** @suppress {duplicate } */
  function syscallGetVarargI() {
      // the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.
      var ret = HEAP32[((+SYSCALLS.varargs)>>2)];
      SYSCALLS.varargs += 4;
      return ret;
    }
  var syscallGetVarargP = syscallGetVarargI;


  function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {

      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = syscallGetVarargI();
          if (arg < 0) {
            return -28;
          }
          while (FS.streams[arg]) {
            arg++;
          }
          var newStream;
          newStream = FS.dupStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = syscallGetVarargI();
          stream.flags |= arg;
          return 0;
        }
        case 12: {
          var arg = syscallGetVarargP();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 13:
        case 14:
          return 0; // Pretend that the locking is successful.
      }
      return -28;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fcntl64.sig = 'iiip';

  function ___syscall_fdatasync(fd) {
  try {

      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0; // we can't do anything synchronously; the in-memory FS is already synced to
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fdatasync.sig = 'ii';

  function ___syscall_fstat64(fd, buf) {
  try {

      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_fstat64.sig = 'iip';

  function ___syscall_ftruncate64(fd, length) {
    length = bigintToI53Checked(length);


  try {

      if (isNaN(length)) return 61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  ___syscall_ftruncate64.sig = 'iij';


  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
  function ___syscall_getcwd(buf, size) {
  try {

      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes) return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_getcwd.sig = 'ipp';


  function ___syscall_getdents64(fd, dirp, count) {
  try {

      var stream = SYSCALLS.getStreamFromFD(fd)
      stream.getdents ||= FS.readdir(stream.path);

      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);

      var idx = Math.floor(off / struct_size);

      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === '.') {
          id = stream.node.id;
          type = 4; // DT_DIR
        }
        else if (name === '..') {
          var lookup = FS.lookupPath(stream.path, { parent: true });
          id = lookup.node.id;
          type = 4; // DT_DIR
        }
        else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 :  // DT_CHR, character device.
                 FS.isDir(child.mode) ? 4 :     // DT_DIR, directory.
                 FS.isLink(child.mode) ? 10 :   // DT_LNK, symbolic link.
                 8;                             // DT_REG, regular file.
        }
        HEAP64[((dirp + pos)>>3)] = BigInt(id);
        HEAP64[(((dirp + pos)+(8))>>3)] = BigInt((idx + 1) * struct_size);
        HEAP16[(((dirp + pos)+(16))>>1)] = 280;
        HEAP8[(dirp + pos)+(18)] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_getdents64.sig = 'iipp';






  /** @param {number=} addrlen */
  var writeSockaddr = (sa, family, addr, port, addrlen) => {
      switch (family) {
        case 2:
          addr = inetPton4(addr);
          zeroMemory(sa, 16);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 16;
          }
          HEAP16[((sa)>>1)] = family;
          HEAP32[(((sa)+(4))>>2)] = addr;
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          break;
        case 10:
          addr = inetPton6(addr);
          zeroMemory(sa, 28);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 28;
          }
          HEAP32[((sa)>>2)] = family;
          HEAP32[(((sa)+(8))>>2)] = addr[0];
          HEAP32[(((sa)+(12))>>2)] = addr[1];
          HEAP32[(((sa)+(16))>>2)] = addr[2];
          HEAP32[(((sa)+(20))>>2)] = addr[3];
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          break;
        default:
          return 5;
      }
      return 0;
    };

  function ___syscall_getsockname(fd, addr, addrlen, d1, d2, d3) {
  try {

      var sock = getSocketFromFD(fd);
      // TODO: sock.saddr should never be undefined, see TODO in websocket_sock_ops.getname
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || '0.0.0.0'), sock.sport, addrlen);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_getsockname.sig = 'iippiii';

  function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
  try {

      var sock = getSocketFromFD(fd);
      // Minimal getsockopt aimed at resolving https://github.com/emscripten-core/emscripten/issues/2211
      // so only supports SOL_SOCKET with SO_ERROR.
      if (level === 1) {
        if (optname === 4) {
          HEAP32[((optval)>>2)] = sock.error;
          HEAP32[((optlen)>>2)] = 4;
          sock.error = null; // Clear the error (The SO_ERROR option obtains and then clears this field).
          return 0;
        }
      }
      return -50; // The option is unknown at the level indicated.
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_getsockopt.sig = 'iiiippi';


  function ___syscall_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {

      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21505: {
          if (!stream.tty) return -59;
          if (stream.tty.ops.ioctl_tcgets) {
            var termios = stream.tty.ops.ioctl_tcgets(stream);
            var argp = syscallGetVarargP();
            HEAP32[((argp)>>2)] = termios.c_iflag || 0;
            HEAP32[(((argp)+(4))>>2)] = termios.c_oflag || 0;
            HEAP32[(((argp)+(8))>>2)] = termios.c_cflag || 0;
            HEAP32[(((argp)+(12))>>2)] = termios.c_lflag || 0;
            for (var i = 0; i < 32; i++) {
              HEAP8[(argp + i)+(17)] = termios.c_cc[i] || 0;
            }
            return 0;
          }
          return 0;
        }
        case 21510:
        case 21511:
        case 21512: {
          if (!stream.tty) return -59;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          if (stream.tty.ops.ioctl_tcsets) {
            var argp = syscallGetVarargP();
            var c_iflag = HEAP32[((argp)>>2)];
            var c_oflag = HEAP32[(((argp)+(4))>>2)];
            var c_cflag = HEAP32[(((argp)+(8))>>2)];
            var c_lflag = HEAP32[(((argp)+(12))>>2)];
            var c_cc = []
            for (var i = 0; i < 32; i++) {
              c_cc.push(HEAP8[(argp + i)+(17)]);
            }
            return stream.tty.ops.ioctl_tcsets(stream.tty, op, { c_iflag, c_oflag, c_cflag, c_lflag, c_cc });
          }
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = syscallGetVarargP();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; // not supported
        }
        case 21531: {
          var argp = syscallGetVarargP();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          // TODO: in theory we should write to the winsize struct that gets
          // passed in, but for now musl doesn't read anything on it
          if (!stream.tty) return -59;
          if (stream.tty.ops && stream.tty.ops.ioctl_tiocgwinsz) {
            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
            var argp = syscallGetVarargP();
            HEAP16[((argp)>>1)] = winsize[0];
            HEAP16[(((argp)+(2))>>1)] = winsize[1];
          }
          return 0;
        }
        case 21524: {
          // TODO: technically, this ioctl call should change the window size.
          // but, since emscripten doesn't have any concept of a terminal window
          // yet, we'll just silently throw it away as we do TIOCGWINSZ
          if (!stream.tty) return -59;
          return 0;
        }
        case 21515: {
          if (!stream.tty) return -59;
          return 0;
        }
        default: return -28; // not supported
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_ioctl.sig = 'iiip';

  function ___syscall_lstat64(path, buf) {
  try {

      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_lstat64.sig = 'ipp';

  function ___syscall_mkdirat(dirfd, path, mode) {
  try {

      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      // remove a trailing slash, if one - /a/b/ has basename of '', but
      // we want to create b in the context of this function
      path = PATH.normalize(path);
      if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_mkdirat.sig = 'iipi';

  function ___syscall_newfstatat(dirfd, path, buf, flags) {
  try {

      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & (~6400);
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_newfstatat.sig = 'iippi';


  function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {

      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? syscallGetVarargI() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_openat.sig = 'iipip';

  var PIPEFS = {
  BUCKET_BUFFER_SIZE:8192,
  mount(mount) {
        // Do not pollute the real root directory or its child nodes with pipes
        // Looks like it is OK to create another pseudo-root node not linked to the FS.root hierarchy this way
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },
  createPipe() {
        var pipe = {
          buckets: [],
          // refcnt 2 because pipe has a read end and a write end. We need to be
          // able to read from the read end after write end is closed.
          refcnt : 2,
        };

        pipe.buckets.push({
          buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
          offset: 0,
          roffset: 0
        });

        var rName = PIPEFS.nextname();
        var wName = PIPEFS.nextname();
        var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
        var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);

        rNode.pipe = pipe;
        wNode.pipe = pipe;

        var readableStream = FS.createStream({
          path: rName,
          node: rNode,
          flags: 0,
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        rNode.stream = readableStream;

        var writableStream = FS.createStream({
          path: wName,
          node: wNode,
          flags: 1,
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        wNode.stream = writableStream;

        return {
          readable_fd: readableStream.fd,
          writable_fd: writableStream.fd
        };
      },
  stream_ops:{
  poll(stream) {
          var pipe = stream.node.pipe;

          if ((stream.flags & 2097155) === 1) {
            return (256 | 4);
          }
          if (pipe.buckets.length > 0) {
            for (var i = 0; i < pipe.buckets.length; i++) {
              var bucket = pipe.buckets[i];
              if (bucket.offset - bucket.roffset > 0) {
                return (64 | 1);
              }
            }
          }

          return 0;
        },
  ioctl(stream, request, varargs) {
          return 28;
        },
  fsync(stream) {
          return 28;
        },
  read(stream, buffer, offset, length, position /* ignored */) {
          var pipe = stream.node.pipe;
          var currentLength = 0;

          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            currentLength += bucket.offset - bucket.roffset;
          }

          var data = buffer.subarray(offset, offset + length);

          if (length <= 0) {
            return 0;
          }
          if (currentLength == 0) {
            // Behave as if the read end is always non-blocking
            throw new FS.ErrnoError(6);
          }
          var toRead = Math.min(currentLength, length);

          var totalRead = toRead;
          var toRemove = 0;

          for (var i = 0; i < pipe.buckets.length; i++) {
            var currBucket = pipe.buckets[i];
            var bucketSize = currBucket.offset - currBucket.roffset;

            if (toRead <= bucketSize) {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              if (toRead < bucketSize) {
                tmpSlice = tmpSlice.subarray(0, toRead);
                currBucket.roffset += toRead;
              } else {
                toRemove++;
              }
              data.set(tmpSlice);
              break;
            } else {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              data.set(tmpSlice);
              data = data.subarray(tmpSlice.byteLength);
              toRead -= tmpSlice.byteLength;
              toRemove++;
            }
          }

          if (toRemove && toRemove == pipe.buckets.length) {
            // Do not generate excessive garbage in use cases such as
            // write several bytes, read everything, write several bytes, read everything...
            toRemove--;
            pipe.buckets[toRemove].offset = 0;
            pipe.buckets[toRemove].roffset = 0;
          }

          pipe.buckets.splice(0, toRemove);

          return totalRead;
        },
  write(stream, buffer, offset, length, position /* ignored */) {
          var pipe = stream.node.pipe;

          var data = buffer.subarray(offset, offset + length);

          var dataLen = data.byteLength;
          if (dataLen <= 0) {
            return 0;
          }

          var currBucket = null;

          if (pipe.buckets.length == 0) {
            currBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: 0,
              roffset: 0
            };
            pipe.buckets.push(currBucket);
          } else {
            currBucket = pipe.buckets[pipe.buckets.length - 1];
          }

          assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);

          var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
          if (freeBytesInCurrBuffer >= dataLen) {
            currBucket.buffer.set(data, currBucket.offset);
            currBucket.offset += dataLen;
            return dataLen;
          } else if (freeBytesInCurrBuffer > 0) {
            currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
            currBucket.offset += freeBytesInCurrBuffer;
            data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
          }

          var numBuckets = (data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE) | 0;
          var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;

          for (var i = 0; i < numBuckets; i++) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: PIPEFS.BUCKET_BUFFER_SIZE,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
            data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
          }

          if (remElements > 0) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: data.byteLength,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data);
          }

          return dataLen;
        },
  close(stream) {
          var pipe = stream.node.pipe;
          pipe.refcnt--;
          if (pipe.refcnt === 0) {
            pipe.buckets = null;
          }
        },
  },
  nextname() {
        if (!PIPEFS.nextname.current) {
          PIPEFS.nextname.current = 0;
        }
        return 'pipe[' + (PIPEFS.nextname.current++) + ']';
      },
  };
  function ___syscall_pipe(fdPtr) {
  try {

      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }

      var res = PIPEFS.createPipe();

      HEAP32[((fdPtr)>>2)] = res.readable_fd;
      HEAP32[(((fdPtr)+(4))>>2)] = res.writable_fd;

      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_pipe.sig = 'ip';

  function ___syscall_poll(fds, nfds, timeout) {
  try {

      var nonzero = 0;
      for (var i = 0; i < nfds; i++) {
        var pollfd = fds + 8 * i;
        var fd = HEAP32[((pollfd)>>2)];
        var events = HEAP16[(((pollfd)+(4))>>1)];
        var mask = 32;
        var stream = FS.getStream(fd);
        if (stream) {
          mask = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops.poll) {
            mask = stream.stream_ops.poll(stream, -1);
          }
        }
        mask &= events | 8 | 16;
        if (mask) nonzero++;
        HEAP16[(((pollfd)+(6))>>1)] = mask;
      }
      return nonzero;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_poll.sig = 'ipii';



  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
  try {

      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0) return -28;
      var ret = FS.readlink(path);

      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf+len];
      stringToUTF8(ret, buf, bufsize+1);
      // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
      // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
      HEAP8[buf+len] = endChar;
      return len;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_readlinkat.sig = 'iippp';



  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
  try {

      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len);
      if (!msg) return 0; // socket is closed
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_recvfrom.sig = 'iippipp';

  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
  try {

      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_renameat.sig = 'iipip';

  function ___syscall_rmdir(path) {
  try {

      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_rmdir.sig = 'ip';


  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
  try {

      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        // send, no address provided
        return FS.write(sock.stream, HEAP8, message, length);
      }
      // sendto an address
      return sock.sock_ops.sendmsg(sock, HEAP8, message, length, dest.addr, dest.port);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_sendto.sig = 'iippipp';

  function ___syscall_socket(domain, type, protocol) {
  try {

      var sock = SOCKFS.createSocket(domain, type, protocol);
      return sock.stream.fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_socket.sig = 'iiiiiii';

  function ___syscall_stat64(path, buf) {
  try {

      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_stat64.sig = 'ipp';

  function ___syscall_symlink(target, linkpath) {
  try {

      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_symlink.sig = 'ipp';


  function ___syscall_truncate64(path, length) {
    length = bigintToI53Checked(length);


  try {

      if (isNaN(length)) return 61;
      path = SYSCALLS.getStr(path);
      FS.truncate(path, length);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  ___syscall_truncate64.sig = 'ipj';

  function ___syscall_unlinkat(dirfd, path, flags) {
  try {

      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort('Invalid flags passed to unlinkat');
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  }
  ___syscall_unlinkat.sig = 'iipi';

  var ___table_base = new WebAssembly.Global({'value': 'i32', 'mutable': false}, 1);

  var __abort_js = () => {
      abort('');
    };
  __abort_js.sig = 'v';

  var ENV = {
  };




  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str, ret, size);
      return ret;
    };


  var dlSetError = (msg) => {
      var sp = stackSave();
      var cmsg = stringToUTF8OnStack(msg);
      ___dl_seterr(cmsg, 0);
      stackRestore(sp);
    };


  var dlopenInternal = (handle, jsflags) => {
      // void *dlopen(const char *file, int mode);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlopen.html
      var filename = UTF8ToString(handle + 36);
      var flags = HEAP32[(((handle)+(4))>>2)];
      filename = PATH.normalize(filename);
      var searchpaths = [];

      var global = Boolean(flags & 256);
      var localScope = global ? null : {};

      // We don't care about RTLD_NOW and RTLD_LAZY.
      var combinedFlags = {
        global,
        nodelete:  Boolean(flags & 4096),
        loadAsync: jsflags.loadAsync,
      }

      if (jsflags.loadAsync) {
        return loadDynamicLibrary(filename, combinedFlags, localScope, handle);
      }

      try {
        return loadDynamicLibrary(filename, combinedFlags, localScope, handle)
      } catch (e) {
        dlSetError(`Could not load dynamic lib: ${filename}\n${e}`);
        return 0;
      }
    };
  var __dlopen_js = (handle) => {
      return dlopenInternal(handle, { loadAsync: false });
    };
  __dlopen_js.sig = 'pp';




  var __dlsym_js = (handle, symbol, symbolIndex) => {
      // void *dlsym(void *restrict handle, const char *restrict name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html
      symbol = UTF8ToString(symbol);
      var result;
      var newSymIndex;

      var lib = LDSO.loadedLibsByHandle[handle];
      if (!lib.exports.hasOwnProperty(symbol) || lib.exports[symbol].stub) {
        dlSetError(`Tried to lookup unknown symbol "${symbol}" in dynamic lib: ${lib.name}`)
        return 0;
      }
      newSymIndex = Object.keys(lib.exports).indexOf(symbol);
      result = lib.exports[symbol];

      if (typeof result == 'function') {

        var addr = getFunctionAddress(result);
        if (addr) {
          result = addr;
        } else {
          // Insert the function into the wasm table.  If its a direct wasm
          // function the second argument will not be needed.  If its a JS
          // function we rely on the `sig` attribute being set based on the
          // `<func>__sig` specified in library JS file.
          result = addFunction(result, result.sig);
          HEAPU32[((symbolIndex)>>2)] = newSymIndex;
        }
      }
      return result;
    };
  __dlsym_js.sig = 'pppp';

  var nowIsMonotonic = 1;
  var __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
  __emscripten_get_now_is_monotonic.sig = 'i';

  var __emscripten_runtime_keepalive_clear = () => {
      noExitRuntime = false;
      runtimeKeepaliveCounter = 0;
    };
  __emscripten_runtime_keepalive_clear.sig = 'v';

  var __emscripten_system = (command) => {
      if (ENVIRONMENT_IS_NODE) {
        if (!command) return 1; // shell is available

        var cmdstr = UTF8ToString(command);
        if (!cmdstr.length) return 0; // this is what glibc seems to do (shell works test?)

        var cp = require('child_process');
        var ret = cp.spawnSync(cmdstr, [], {shell:true, stdio:'inherit'});

        var _W_EXITCODE = (ret, sig) => ((ret) << 8 | (sig));

        // this really only can happen if process is killed by signal
        if (ret.status === null) {
          // sadly node doesn't expose such function
          var signalToNumber = (sig) => {
            // implement only the most common ones, and fallback to SIGINT
            switch (sig) {
              case 'SIGHUP': return 1;
              case 'SIGQUIT': return 3;
              case 'SIGFPE': return 8;
              case 'SIGKILL': return 9;
              case 'SIGALRM': return 14;
              case 'SIGTERM': return 15;
              default: return 2;
            }
          }
          return _W_EXITCODE(0, signalToNumber(ret.signal));
        }

        return _W_EXITCODE(ret.status, 0);
      }
      // int system(const char *command);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/system.html
      // Can't call external programs.
      if (!command) return 0; // no shell available
      return -52;
    };
  __emscripten_system.sig = 'ip';

  var __emscripten_throw_longjmp = () => {
      throw Infinity;
    };
  __emscripten_throw_longjmp.sig = 'v';

  function __gmtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);


      var date = new Date(time * 1000);
      HEAP32[((tmPtr)>>2)] = date.getUTCSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getUTCMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getUTCHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getUTCDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getUTCMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getUTCFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
    ;
  }
  __gmtime_js.sig = 'vjp';

  var isLeapYear = (year) => year%4 === 0 && (year%100 !== 0 || year%400 === 0);

  var MONTH_DAYS_LEAP_CUMULATIVE = [0,31,60,91,121,152,182,213,244,274,305,335];

  var MONTH_DAYS_REGULAR_CUMULATIVE = [0,31,59,90,120,151,181,212,243,273,304,334];
  var ydayFromDate = (date) => {
      var leap = isLeapYear(date.getFullYear());
      var monthDaysCumulative = (leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE);
      var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1; // -1 since it's days since Jan 1

      return yday;
    };

  function __localtime_js(time, tmPtr) {
    time = bigintToI53Checked(time);


      var date = new Date(time*1000);
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();

      var yday = ydayFromDate(date)|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);

      // Attention: DST is in December in South, and some regions don't have DST at all.
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)] = dst;
    ;
  }
  __localtime_js.sig = 'vjp';






  function __mmap_js(len, prot, flags, fd, offset, allocated, addr) {
    offset = bigintToI53Checked(offset);


  try {

      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, offset, prot, flags);
      var ptr = res.ptr;
      HEAP32[((allocated)>>2)] = res.allocated;
      HEAPU32[((addr)>>2)] = ptr;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  __mmap_js.sig = 'ipiiijpp';


  function __munmap_js(addr, len, prot, flags, fd, offset) {
    offset = bigintToI53Checked(offset);


  try {

      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return -e.errno;
  }
  ;
  }
  __munmap_js.sig = 'ippiiij';

  var timers = {
  };

  var handleException = (e) => {
      // Certain exception types we do not treat as errors since they are used for
      // internal control flow.
      // 1. ExitStatus, which is thrown by exit()
      // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
      //    that wish to return to JS event loop.
      if (e instanceof ExitStatus || e == 'unwind') {
        return EXITSTATUS;
      }
      quit_(1, e);
    };


  var runtimeKeepaliveCounter = 0;
  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;
  var _proc_exit = (code) => {
      EXITSTATUS = code;
      if (!keepRuntimeAlive()) {
        Module['onExit']?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    };
  _proc_exit.sig = 'vi';
  /** @suppress {duplicate } */
  /** @param {boolean|number=} implicit */
  var exitJS = (status, implicit) => {
      EXITSTATUS = status;

      _proc_exit(status);
    };
  var _exit = exitJS;
  _exit.sig = 'vi';


  var maybeExit = () => {
      if (!keepRuntimeAlive()) {
        try {
          _exit(EXITSTATUS);
        } catch (e) {
          handleException(e);
        }
      }
    };
  var callUserCallback = (func) => {
      if (ABORT) {
        return;
      }
      try {
        func();
        maybeExit();
      } catch (e) {
        handleException(e);
      }
    };


  var _emscripten_get_now;
      // Modern environment where performance.now() is supported:
      // N.B. a shorter form "_emscripten_get_now = performance.now;" is
      // unfortunately not allowed even in current browsers (e.g. FF Nightly 75).
      _emscripten_get_now = () => performance.now();
  ;
  _emscripten_get_now.sig = 'd';
  var __setitimer_js = (which, timeout_ms) => {
      // First, clear any existing timer.
      if (timers[which]) {
        clearTimeout(timers[which].id);
        delete timers[which];
      }

      // A timeout of zero simply cancels the current timeout so we have nothing
      // more to do.
      if (!timeout_ms) return 0;

      var id = setTimeout(() => {
        delete timers[which];
        callUserCallback(() => __emscripten_timeout(which, _emscripten_get_now()));
      }, timeout_ms);
      timers[which] = { id, timeout_ms };
      return 0;
    };
  __setitimer_js.sig = 'iid';

  var __tzset_js = (timezone, daylight, std_name, dst_name) => {
      // TODO: Use (malleable) environment variables instead of system settings.
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();

      // Local standard timezone offset. Local standard time is not adjusted for
      // daylight savings.  This code uses the fact that getTimezoneOffset returns
      // a greater value during Standard Time versus Daylight Saving Time (DST).
      // Thus it determines the expected output during Standard Time, and it
      // compares whether the output of the given date the same (Standard) or less
      // (DST).
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);

      // timezone is specified as seconds west of UTC ("The external variable
      // `timezone` shall be set to the difference, in seconds, between
      // Coordinated Universal Time (UTC) and local standard time."), the same
      // as returned by stdTimezoneOffset.
      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
      HEAPU32[((timezone)>>2)] = stdTimezoneOffset * 60;

      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);

      var extractZone = (timezoneOffset) => {
        // Why inverse sign?
        // Read here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset
        var sign = timezoneOffset >= 0 ? "-" : "+";

        var absOffset = Math.abs(timezoneOffset)
        var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
        var minutes = String(absOffset % 60).padStart(2, "0");

        return `UTC${sign}${hours}${minutes}`;
      }

      var winterName = extractZone(winterOffset);
      var summerName = extractZone(summerOffset);
      if (summerOffset < winterOffset) {
        // Northern hemisphere
        stringToUTF8(winterName, std_name, 17);
        stringToUTF8(summerName, dst_name, 17);
      } else {
        stringToUTF8(winterName, dst_name, 17);
        stringToUTF8(summerName, std_name, 17);
      }
    };
  __tzset_js.sig = 'vpppp';

  var readEmAsmArgsArray = [];
  var readEmAsmArgs = (sigPtr, buf) => {
      readEmAsmArgsArray.length = 0;
      var ch;
      // Most arguments are i32s, so shift the buffer pointer so it is a plain
      // index into HEAP32.
      while (ch = HEAPU8[sigPtr++]) {
        // Floats are always passed as doubles, so all types except for 'i'
        // are 8 bytes and require alignment.
        var wide = (ch != 105);
        wide &= (ch != 112);
        buf += wide && (buf % 8) ? 4 : 0;
        readEmAsmArgsArray.push(
          // Special case for pointers under wasm64 or CAN_ADDRESS_2GB mode.
          ch == 112 ? HEAPU32[((buf)>>2)] :
          ch == 106 ? HEAP64[((buf)>>3)] :
          ch == 105 ?
            HEAP32[((buf)>>2)] :
            HEAPF64[((buf)>>3)]
        );
        buf += wide ? 8 : 4;
      }
      return readEmAsmArgsArray;
    };
  var runEmAsmFunction = (code, sigPtr, argbuf) => {
      var args = readEmAsmArgs(sigPtr, argbuf);
      return ASM_CONSTS[code](...args);
    };
  var _emscripten_asm_const_int = (code, sigPtr, argbuf) => {
      return runEmAsmFunction(code, sigPtr, argbuf);
    };
  _emscripten_asm_const_int.sig = 'ippp';

  var _emscripten_date_now = () => Date.now();
  _emscripten_date_now.sig = 'd';



  var _emscripten_force_exit = (status) => {
      __emscripten_runtime_keepalive_clear();
      _exit(status);
    };
  _emscripten_force_exit.sig = 'vi';


  var getHeapMax = () =>
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      2147483648;


  var growMemory = (size) => {
      var b = wasmMemory.buffer;
      var pages = (size - b.byteLength + 65535) / 65536;
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size
        updateMemoryViews();
        return 1 /*success*/;
      } catch(e) {
      }
      // implicit 0 return to save code size (caller will cast "undefined" into 0
      // anyhow)
    };
  var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      requestedSize >>>= 0;
      // With multithreaded builds, races can happen (another thread might increase the size
      // in between), so return a failure, and let the caller retry.

      // Memory resize rules:
      // 1.  Always increase heap size to at least the requested size, rounded up
      //     to next page multiple.
      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
      //     geometrically: increase the heap size according to
      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
      //     linearly: increase the heap size by at least
      //     MEMORY_GROWTH_LINEAR_STEP bytes.
      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 4.  If we were unable to allocate as much memory, it may be due to
      //     over-eager decision to excessively reserve due to (3) above.
      //     Hence if an allocation fails, cut down on the amount of excess
      //     growth, in an attempt to succeed to perform a smaller allocation.

      // A limit is set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }

      // Loop through potential heap size increases. If we attempt a too eager
      // reservation that fails, cut down on the attempted size and reserve a
      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );

        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));

        var replacement = growMemory(newSize);
        if (replacement) {

          return true;
        }
      }
      return false;
    };
  _emscripten_resize_heap.sig = 'ip';



  /** @param {number=} timeout */
  var safeSetTimeout = (func, timeout) => {

      return setTimeout(() => {

        callUserCallback(func);
      }, timeout);
    };

  var warnOnce = (text) => {
      warnOnce.shown ||= {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;
        err(text);
      }
    };




  var Browser = {
  mainLoop:{
  running:false,
  scheduler:null,
  method:"",
  currentlyRunningMainloop:0,
  func:null,
  arg:0,
  timingMode:0,
  timingValue:0,
  currentFrameNumber:0,
  queue:[],
  pause() {
          Browser.mainLoop.scheduler = null;
          // Incrementing this signals the previous main loop that it's now become old, and it must return.
          Browser.mainLoop.currentlyRunningMainloop++;
        },
  resume() {
          Browser.mainLoop.currentlyRunningMainloop++;
          var timingMode = Browser.mainLoop.timingMode;
          var timingValue = Browser.mainLoop.timingValue;
          var func = Browser.mainLoop.func;
          Browser.mainLoop.func = null;
          // do not set timing and call scheduler, we will do it on the next lines
          setMainLoop(func, 0, false, Browser.mainLoop.arg, true);
          _emscripten_set_main_loop_timing(timingMode, timingValue);
          Browser.mainLoop.scheduler();
        },
  updateStatus() {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](`{message} ({expected - remaining}/{expected})`);
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        },
  runIter(func) {
          if (ABORT) return;
          if (Module['preMainLoop']) {
            var preRet = Module['preMainLoop']();
            if (preRet === false) {
              return; // |return false| skips a frame
            }
          }
          callUserCallback(func);
          Module['postMainLoop']?.();
        },
  },
  useWebGL:false,
  isFullscreen:false,
  pointerLock:false,
  moduleContextCreatedCallbacks:[],
  workers:[],
  init() {
        if (Browser.initted) return;
        Browser.initted = true;

        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).

        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module['noImageDecoding'] && /\.(jpg|jpeg|png|bmp|webp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
          if (b.size !== byteArray.length) { // Safari bug #118630
            // Safari's Blob can only take an ArrayBuffer
            b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
          }
          var url = URL.createObjectURL(b);
          var img = new Image();
          img.onload = () => {
            var canvas = /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            preloadedImages[name] = canvas;
            URL.revokeObjectURL(url);
            onload?.(byteArray);
          };
          img.onerror = (event) => {
            err(`Image ${url} could not be decoded`);
            onerror?.();
          };
          img.src = url;
        };
        preloadPlugins.push(imagePlugin);

        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module['noAudioDecoding'] && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            preloadedAudios[name] = audio;
            onload?.(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            preloadedAudios[name] = new Audio(); // empty shim
            onerror?.();
          }
          var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
          var url = URL.createObjectURL(b); // XXX we never revoke this!
          var audio = new Audio();
          audio.addEventListener('canplaythrough', () => finish(audio), false); // use addEventListener due to chromium bug 124926
          audio.onerror = function audio_onerror(event) {
            if (done) return;
            err(`warning: browser could not fully decode audio ${name}, trying slower base64 approach`);
            function encode64(data) {
              var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
              var PAD = '=';
              var ret = '';
              var leftchar = 0;
              var leftbits = 0;
              for (var i = 0; i < data.length; i++) {
                leftchar = (leftchar << 8) | data[i];
                leftbits += 8;
                while (leftbits >= 6) {
                  var curr = (leftchar >> (leftbits-6)) & 0x3f;
                  leftbits -= 6;
                  ret += BASE[curr];
                }
              }
              if (leftbits == 2) {
                ret += BASE[(leftchar&3) << 4];
                ret += PAD + PAD;
              } else if (leftbits == 4) {
                ret += BASE[(leftchar&0xf) << 2];
                ret += PAD;
              }
              return ret;
            }
            audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
            finish(audio); // we don't wait for confirmation this worked - but it's worth trying
          };
          audio.src = url;
          // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
          safeSetTimeout(() => {
            finish(audio); // try to use it even though it is not necessarily ready to play
          }, 10000);
        };
        preloadPlugins.push(audioPlugin);

        // Canvas event setup

        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === Module['canvas'] ||
                                document['mozPointerLockElement'] === Module['canvas'] ||
                                document['webkitPointerLockElement'] === Module['canvas'] ||
                                document['msPointerLockElement'] === Module['canvas'];
        }
        var canvas = Module['canvas'];
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;

          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      (() => {});
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   (() => {}); // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);

          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);

          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", (ev) => {
              if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
                Module['canvas'].requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },
  createContext(/** @type {HTMLCanvasElement} */ canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.

        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false,
            majorVersion: 1,
          };

          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }

          // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
          // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
          // Browser.createContext() should not even be emitted.
          if (typeof GL != 'undefined') {
            contextHandle = GL.createContext(canvas, contextAttributes);
            if (contextHandle) {
              ctx = GL.getContext(contextHandle).GLctx;
            }
          }
        } else {
          ctx = canvas.getContext('2d');
        }

        if (!ctx) return null;

        if (setInModule) {
          Module.ctx = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Browser.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach((callback) => callback());
          Browser.init();
        }
        return ctx;
      },
  fullscreenHandlersInstalled:false,
  lockPointer:undefined,
  resizeCanvas:undefined,
  requestFullscreen(lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer == 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas == 'undefined') Browser.resizeCanvas = false;

        var canvas = Module['canvas'];
        function fullscreenChange() {
          Browser.isFullscreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||
               document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.exitFullscreen = Browser.exitFullscreen;
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullscreen = true;
            if (Browser.resizeCanvas) {
              Browser.setFullscreenCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          } else {
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);

            if (Browser.resizeCanvas) {
              Browser.setWindowedCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          }
          Module['onFullScreen']?.(Browser.isFullscreen);
          Module['onFullscreen']?.(Browser.isFullscreen);
        }

        if (!Browser.fullscreenHandlersInstalled) {
          Browser.fullscreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullscreenChange, false);
          document.addEventListener('mozfullscreenchange', fullscreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
          document.addEventListener('MSFullscreenChange', fullscreenChange, false);
        }

        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);

        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullscreen'] ? () => canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) : null) ||
                                           (canvasContainer['webkitRequestFullScreen'] ? () => canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) : null);

        canvasContainer.requestFullscreen();
      },
  exitFullscreen() {
        // This is workaround for chrome. Trying to exit from fullscreen
        // not in fullscreen state will cause "TypeError: Document not active"
        // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
        if (!Browser.isFullscreen) {
          return false;
        }

        var CFS = document['exitFullscreen'] ||
                  document['cancelFullScreen'] ||
                  document['mozCancelFullScreen'] ||
                  document['msExitFullscreen'] ||
                  document['webkitCancelFullScreen'] ||
            (() => {});
        CFS.apply(document, []);
        return true;
      },
  nextRAF:0,
  fakeRequestAnimationFrame(func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            Browser.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func, delay);
      },
  requestAnimationFrame(func) {
        if (typeof requestAnimationFrame == 'function') {
          requestAnimationFrame(func);
          return;
        }
        var RAF = Browser.fakeRequestAnimationFrame;
        RAF(func);
      },
  safeSetTimeout(func, timeout) {
        // Legacy function, this is used by the SDL2 port so we need to keep it
        // around at least until that is updated.
        // See https://github.com/libsdl-org/SDL/pull/6304
        return safeSetTimeout(func, timeout);
      },
  safeRequestAnimationFrame(func) {

        return Browser.requestAnimationFrame(() => {

          callUserCallback(func);
        });
      },
  getMimetype(name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },
  getUserMedia(func) {
        window.getUserMedia ||= navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        window.getUserMedia(func);
      },
  getMovementX(event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },
  getMovementY(event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },
  getMouseWheelDelta(event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll':
            // 3 lines make up a step
            delta = event.detail / 3;
            break;
          case 'mousewheel':
            // 120 units make up a step
            delta = event.wheelDelta / 120;
            break;
          case 'wheel':
            delta = event.deltaY
            switch (event.deltaMode) {
              case 0:
                // DOM_DELTA_PIXEL: 100 pixels make up a step
                delta /= 100;
                break;
              case 1:
                // DOM_DELTA_LINE: 3 lines make up a step
                delta /= 3;
                break;
              case 2:
                // DOM_DELTA_PAGE: A page makes up 80 steps
                delta *= 80;
                break;
              default:
                throw 'unrecognized mouse wheel delta mode: ' + event.deltaMode;
            }
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },
  mouseX:0,
  mouseY:0,
  mouseMovementX:0,
  mouseMovementY:0,
  touches:{
  },
  lastTouches:{
  },
  calculateMouseCoords(pageX, pageY) {
        // Calculate the movement based on the changes
        // in the coordinates.
        var rect = Module["canvas"].getBoundingClientRect();
        var cw = Module["canvas"].width;
        var ch = Module["canvas"].height;

        // Neither .scrollX or .pageXOffset are defined in a spec, but
        // we prefer .scrollX because it is currently in a spec draft.
        // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
        var scrollX = ((typeof window.scrollX != 'undefined') ? window.scrollX : window.pageXOffset);
        var scrollY = ((typeof window.scrollY != 'undefined') ? window.scrollY : window.pageYOffset);
        var adjustedX = pageX - (scrollX + rect.left);
        var adjustedY = pageY - (scrollY + rect.top);

        // the canvas might be CSS-scaled compared to its backbuffer;
        // SDL-using content will want mouse coordinates in terms
        // of backbuffer units.
        adjustedX = adjustedX * (cw / rect.width);
        adjustedY = adjustedY * (ch / rect.height);

        return { x: adjustedX, y: adjustedY };
      },
  setMouseCoords(pageX, pageY) {
        const {x, y} = Browser.calculateMouseCoords(pageX, pageY);
        Browser.mouseMovementX = x - Browser.mouseX;
        Browser.mouseMovementY = y - Browser.mouseY;
        Browser.mouseX = x;
        Browser.mouseY = y;
      },
  calculateMouseEvent(event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }

          // add the mouse delta to the current absolute mouse position
          Browser.mouseX += Browser.mouseMovementX;
          Browser.mouseY += Browser.mouseMovementY;
        } else {
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL

            }
            var coords = Browser.calculateMouseCoords(touch.pageX, touch.pageY);

            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              var last = Browser.touches[touch.identifier];
              last ||= coords;
              Browser.lastTouches[touch.identifier] = last;
              Browser.touches[touch.identifier] = coords;
            }
            return;
          }

          Browser.setMouseCoords(event.pageX, event.pageY);
        }
      },
  resizeListeners:[],
  updateResizeListeners() {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach((listener) => listener(canvas.width, canvas.height));
      },
  setCanvasSize(width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },
  windowedWidth:0,
  windowedHeight:0,
  setFullscreenCanvasSize() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)] = flags;
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },
  setWindowedCanvasSize() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)] = flags;
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },
  updateCanvasDimensions(canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||
             document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      },
  };
  var _emscripten_set_main_loop_timing = (mode, value) => {
      Browser.mainLoop.timingMode = mode;
      Browser.mainLoop.timingValue = value;

      if (!Browser.mainLoop.func) {
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }

      if (!Browser.mainLoop.running) {

        Browser.mainLoop.running = true;
      }
      if (mode == 0) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
          var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now())|0;
          setTimeout(Browser.mainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else if (mode == 1) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      } else if (mode == 2) {
        if (typeof Browser.setImmediate == 'undefined') {
          if (typeof setImmediate == 'undefined') {
            // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
            var setImmediates = [];
            var emscriptenMainLoopMessageId = 'setimmediate';
            /** @param {Event} event */
            var Browser_setImmediate_messageHandler = (event) => {
              // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
              // so check for both cases.
              if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {
                event.stopPropagation();
                setImmediates.shift()();
              }
            };
            addEventListener("message", Browser_setImmediate_messageHandler, true);
            Browser.setImmediate = /** @type{function(function(): ?, ...?): number} */((func) => {
              setImmediates.push(func);
              if (ENVIRONMENT_IS_WORKER) {
                Module['setImmediates'] ??= [];
                Module['setImmediates'].push(func);
                postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js
              } else postMessage(emscriptenMainLoopMessageId, "*"); // On the main thread, can just send the message to itself.
            });
          } else {
            Browser.setImmediate = setImmediate;
          }
        }
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
          Browser.setImmediate(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'immediate';
      }
      return 0;
    };
  _emscripten_set_main_loop_timing.sig = 'iii';




    /**
     * @param {number=} arg
     * @param {boolean=} noSetTiming
     */
  var setMainLoop = (browserIterationFunc, fps, simulateInfiniteLoop, arg, noSetTiming) => {
      Browser.mainLoop.func = browserIterationFunc;
      Browser.mainLoop.arg = arg;

      // Closure compiler bug(?): Closure does not see that the assignment
      //   var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop
      // is a value copy of a number (even with the JSDoc @type annotation)
      // but optimizeis the code as if the assignment was a reference assignment,
      // which results in Browser.mainLoop.pause() not working. Hence use a
      // workaround to make Closure believe this is a value copy that should occur:
      // (TODO: Minimize this down to a small test case and report - was unable
      // to reproduce in a small written test case)
      /** @type{number} */
      var thisMainLoopId = (() => Browser.mainLoop.currentlyRunningMainloop)();
      function checkIsRunning() {
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) {

          maybeExit();
          return false;
        }
        return true;
      }

      // We create the loop runner here but it is not actually running until
      // _emscripten_set_main_loop_timing is called (which might happen a
      // later time).  This member signifies that the current runner has not
      // yet been started so that we can call runtimeKeepalivePush when it
      // gets it timing set for the first time.
      Browser.mainLoop.running = false;
      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          Browser.mainLoop.updateStatus();

          // catches pause/resume main loop from blocker execution
          if (!checkIsRunning()) return;

          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }

        // catch pauses from non-main loop sources
        if (!checkIsRunning()) return;

        // Implement very basic swap interval control
        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
        if (Browser.mainLoop.timingMode == 1 && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          Browser.mainLoop.scheduler();
          return;
        } else if (Browser.mainLoop.timingMode == 0) {
          Browser.mainLoop.tickStartTime = _emscripten_get_now();
        }

        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.

        Browser.mainLoop.runIter(browserIterationFunc);

        // catch pauses from the main loop itself
        if (!checkIsRunning()) return;

        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof SDL == 'object') SDL.audio?.queueNewAudioData?.();

        Browser.mainLoop.scheduler();
      }

      if (!noSetTiming) {
        if (fps && fps > 0) {
          _emscripten_set_main_loop_timing(0, 1000.0 / fps);
        } else {
          // Do rAF by rendering each frame (no decimating)
          _emscripten_set_main_loop_timing(1, 1);
        }

        Browser.mainLoop.scheduler();
      }

      if (simulateInfiniteLoop) {
        throw 'unwind';
      }
    };


  var _emscripten_set_main_loop = (func, fps, simulateInfiniteLoop) => {
      var browserIterationFunc = getWasmTableEntry(func);
      setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop);
    };
  _emscripten_set_main_loop.sig = 'vpii';


  var getExecutableName = () => {
      return thisProgram || './this.program';
    };
  var getEnvStrings = () => {
      if (!getEnvStrings.strings) {
        // Default values.
        // Browser language detection #8751
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        // Apply the user-provided values, if any.
        for (var x in ENV) {
          // x is a key in ENV; if ENV[x] is undefined, that means it was
          // explicitly set to be so. We allow user code to do that to
          // force variables with default values to remain unset.
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(`${x}=${env[x]}`);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    };

  var stringToAscii = (str, buffer) => {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer++] = str.charCodeAt(i);
      }
      // Null-terminate the string
      HEAP8[buffer] = 0;
    };
  var _environ_get = (__environ, environ_buf) => {
      var bufSize = 0;
      getEnvStrings().forEach((string, i) => {
        var ptr = environ_buf + bufSize;
        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;
        stringToAscii(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    };
  _environ_get.sig = 'ipp';

  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
      var strings = getEnvStrings();
      HEAPU32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach((string) => bufSize += string.length + 1);
      HEAPU32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    };
  _environ_sizes_get.sig = 'ipp';


  function _fd_close(fd) {
  try {

      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _fd_close.sig = 'ii';

  function _fd_fdstat_get(fd, pbuf) {
  try {

      var rightsBase = 0;
      var rightsInheriting = 0;
      var flags = 0;
      {
        var stream = SYSCALLS.getStreamFromFD(fd);
        // All character devices are terminals (other things a Linux system would
        // assume is a character device, like the mouse, we have special APIs for).
        var type = stream.tty ? 2 :
                   FS.isDir(stream.mode) ? 3 :
                   FS.isLink(stream.mode) ? 7 :
                   4;
      }
      HEAP8[pbuf] = type;
      HEAP16[(((pbuf)+(2))>>1)] = flags;
      HEAP64[(((pbuf)+(8))>>3)] = BigInt(rightsBase);
      HEAP64[(((pbuf)+(16))>>3)] = BigInt(rightsInheriting);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _fd_fdstat_get.sig = 'iip';

  /** @param {number=} offset */
  var doReadv = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break; // nothing more to read
        if (typeof offset != 'undefined') {
          offset += curr;
        }
      }
      return ret;
    };


  function _fd_pread(fd, iov, iovcnt, offset, pnum) {
    offset = bigintToI53Checked(offset);


  try {

      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd)
      var num = doReadv(stream, iov, iovcnt, offset);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  ;
  }
  _fd_pread.sig = 'iippjp';

  /** @param {number=} offset */
  var doWritev = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) {
          // No more space to write.
          break;
        }
        if (typeof offset != 'undefined') {
          offset += curr;
        }
      }
      return ret;
    };


  function _fd_pwrite(fd, iov, iovcnt, offset, pnum) {
    offset = bigintToI53Checked(offset);


  try {

      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd)
      var num = doWritev(stream, iov, iovcnt, offset);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  ;
  }
  _fd_pwrite.sig = 'iippjp';


  function _fd_read(fd, iov, iovcnt, pnum) {
  try {

      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _fd_read.sig = 'iippp';


  function _fd_seek(fd, offset, whence, newOffset) {
    offset = bigintToI53Checked(offset);


  try {

      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      HEAP64[((newOffset)>>3)] = BigInt(stream.position);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  ;
  }
  _fd_seek.sig = 'iijip';

  function _fd_sync(fd) {
  try {

      var stream = SYSCALLS.getStreamFromFD(fd);
      if (stream.stream_ops?.fsync) {
        return stream.stream_ops.fsync(stream);
      }
      return 0; // we can't do anything synchronously; the in-memory FS is already synced to
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _fd_sync.sig = 'ii';


  function _fd_write(fd, iov, iovcnt, pnum) {
  try {

      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }
  _fd_write.sig = 'iippp';










  var _getaddrinfo = (node, service, hint, out) => {
      // Note getaddrinfo currently only returns a single addrinfo with ai_next defaulting to NULL. When NULL
      // hints are specified or ai_family set to AF_UNSPEC or ai_socktype or ai_protocol set to 0 then we
      // really should provide a linked list of suitable addrinfo values.
      var addrs = [];
      var canon = null;
      var addr = 0;
      var port = 0;
      var flags = 0;
      var family = 0;
      var type = 0;
      var proto = 0;
      var ai, last;

      function allocaddrinfo(family, type, proto, canon, addr, port) {
        var sa, salen, ai;
        var errno;

        salen = family === 10 ?
          28 :
          16;
        addr = family === 10 ?
          inetNtop6(addr) :
          inetNtop4(addr);
        sa = _malloc(salen);
        errno = writeSockaddr(sa, family, addr, port);
        assert(!errno);

        ai = _malloc(32);
        HEAP32[(((ai)+(4))>>2)] = family;
        HEAP32[(((ai)+(8))>>2)] = type;
        HEAP32[(((ai)+(12))>>2)] = proto;
        HEAPU32[(((ai)+(24))>>2)] = canon;
        HEAPU32[(((ai)+(20))>>2)] = sa;
        if (family === 10) {
          HEAP32[(((ai)+(16))>>2)] = 28;
        } else {
          HEAP32[(((ai)+(16))>>2)] = 16;
        }
        HEAP32[(((ai)+(28))>>2)] = 0;

        return ai;
      }

      if (hint) {
        flags = HEAP32[((hint)>>2)];
        family = HEAP32[(((hint)+(4))>>2)];
        type = HEAP32[(((hint)+(8))>>2)];
        proto = HEAP32[(((hint)+(12))>>2)];
      }
      if (type && !proto) {
        proto = type === 2 ? 17 : 6;
      }
      if (!type && proto) {
        type = proto === 17 ? 2 : 1;
      }

      // If type or proto are set to zero in hints we should really be returning multiple addrinfo values, but for
      // now default to a TCP STREAM socket so we can at least return a sensible addrinfo given NULL hints.
      if (proto === 0) {
        proto = 6;
      }
      if (type === 0) {
        type = 1;
      }

      if (!node && !service) {
        return -2;
      }
      if (flags & ~(1|2|4|
          1024|8|16|32)) {
        return -1;
      }
      if (hint !== 0 && (HEAP32[((hint)>>2)] & 2) && !node) {
        return -1;
      }
      if (flags & 32) {
        // TODO
        return -2;
      }
      if (type !== 0 && type !== 1 && type !== 2) {
        return -7;
      }
      if (family !== 0 && family !== 2 && family !== 10) {
        return -6;
      }

      if (service) {
        service = UTF8ToString(service);
        port = parseInt(service, 10);

        if (isNaN(port)) {
          if (flags & 1024) {
            return -2;
          }
          // TODO support resolving well-known service names from:
          // http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt
          return -8;
        }
      }

      if (!node) {
        if (family === 0) {
          family = 2;
        }
        if ((flags & 1) === 0) {
          if (family === 2) {
            addr = _htonl(2130706433);
          } else {
            addr = [0, 0, 0, 1];
          }
        }
        ai = allocaddrinfo(family, type, proto, null, addr, port);
        HEAPU32[((out)>>2)] = ai;
        return 0;
      }

      //
      // try as a numeric address
      //
      node = UTF8ToString(node);
      addr = inetPton4(node);
      if (addr !== null) {
        // incoming node is a valid ipv4 address
        if (family === 0 || family === 2) {
          family = 2;
        }
        else if (family === 10 && (flags & 8)) {
          addr = [0, 0, _htonl(0xffff), addr];
          family = 10;
        } else {
          return -2;
        }
      } else {
        addr = inetPton6(node);
        if (addr !== null) {
          // incoming node is a valid ipv6 address
          if (family === 0 || family === 10) {
            family = 10;
          } else {
            return -2;
          }
        }
      }
      if (addr != null) {
        ai = allocaddrinfo(family, type, proto, node, addr, port);
        HEAPU32[((out)>>2)] = ai;
        return 0;
      }
      if (flags & 4) {
        return -2;
      }

      //
      // try as a hostname
      //
      // resolve the hostname to a temporary fake address
      node = DNS.lookup_name(node);
      addr = inetPton4(node);
      if (family === 0) {
        family = 2;
      } else if (family === 10) {
        addr = [0, 0, _htonl(0xffff), addr];
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAPU32[((out)>>2)] = ai;
      return 0;
    };
  _getaddrinfo.sig = 'ipppp';




  var _getnameinfo = (sa, salen, node, nodelen, serv, servlen, flags) => {
      var info = readSockaddr(sa, salen);
      if (info.errno) {
        return -6;
      }
      var port = info.port;
      var addr = info.addr;

      var overflowed = false;

      if (node && nodelen) {
        var lookup;
        if ((flags & 1) || !(lookup = DNS.lookup_addr(addr))) {
          if (flags & 8) {
            return -2;
          }
        } else {
          addr = lookup;
        }
        var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);

        if (numBytesWrittenExclNull+1 >= nodelen) {
          overflowed = true;
        }
      }

      if (serv && servlen) {
        port = '' + port;
        var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);

        if (numBytesWrittenExclNull+1 >= servlen) {
          overflowed = true;
        }
      }

      if (overflowed) {
        // Note: even when we overflow, getnameinfo() is specced to write out the truncated results.
        return -12;
      }

      return 0;
    };
  _getnameinfo.sig = 'ipipipii';













  var stringToNewUTF8 = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret) stringToUTF8(str, ret, size);
      return ret;
    };


  var getCFunc = (ident) => {
      var func = Module['_' + ident]; // closure exported function
      return func;
    };

  var writeArrayToMemory = (array, buffer) => {
      HEAP8.set(array, buffer);
    };






    /**
     * @param {string|null=} returnType
     * @param {Array=} argTypes
     * @param {Arguments|Array=} args
     * @param {Object=} opts
     */
  var ccall = (ident, returnType, argTypes, args, opts) => {
      // For fast lookup of conversion functions
      var toC = {
        'string': (str) => {
          var ret = 0;
          if (str !== null && str !== undefined && str !== 0) { // null string
            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
            ret = stringToUTF8OnStack(str);
          }
          return ret;
        },
        'array': (arr) => {
          var ret = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret);
          return ret;
        }
      };

      function convertReturnValue(ret) {
        if (returnType === 'string') {
          return UTF8ToString(ret);
        }
        if (returnType === 'boolean') return Boolean(ret);
        return ret;
      }

      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0) stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func(...cArgs);
      function onDone(ret) {
        if (stack !== 0) stackRestore(stack);
        return convertReturnValue(ret);
      }

      ret = onDone(ret);
      return ret;
    };



    /**
     * @param {string=} returnType
     * @param {Array=} argTypes
     * @param {Object=} opts
     */
  var cwrap = (ident, returnType, argTypes, opts) => {
      // When the function takes numbers and returns a number, we can just return
      // the original function
      var numericArgs = !argTypes || argTypes.every((type) => type === 'number' || type === 'boolean');
      var numericRet = returnType !== 'string';
      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }
      return (...args) => ccall(ident, returnType, argTypes, args, opts);
    };

  var FS_createPath = FS.createPath;



  var FS_unlink = (path) => FS.unlink(path);

  var FS_createLazyFile = FS.createLazyFile;

  var FS_createDevice = FS.createDevice;

  /** @suppress {duplicate } */
  var setTempRet0 = (val) => __emscripten_tempret_set(val);
  var _setTempRet0 = setTempRet0;
  Module['_setTempRet0'] = _setTempRet0;

  /** @suppress {duplicate } */
  var getTempRet0 = (val) => __emscripten_tempret_get();
  var _getTempRet0 = getTempRet0;
  Module['_getTempRet0'] = _getTempRet0;


      registerWasmPlugin();
      ;

  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  // Set module methods based on EXPORTED_RUNTIME_METHODS
  Module["FS_createPath"] = FS.createPath;
  Module["FS_createDataFile"] = FS.createDataFile;
  Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
  Module["FS_unlink"] = FS.unlink;
  Module["FS_createLazyFile"] = FS.createLazyFile;
  Module["FS_createDevice"] = FS.createDevice;
  ;
if (ENVIRONMENT_IS_NODE) { NODEFS.staticInit(); };

      // exports
      Module["requestFullscreen"] = Browser.requestFullscreen;
      Module["requestAnimationFrame"] = Browser.requestAnimationFrame;
      Module["setCanvasSize"] = Browser.setCanvasSize;
      Module["pauseMainLoop"] = Browser.mainLoop.pause;
      Module["resumeMainLoop"] = Browser.mainLoop.resume;
      Module["getUserMedia"] = Browser.getUserMedia;
      Module["createContext"] = Browser.createContext;
      var preloadedImages = {};
      var preloadedAudios = {};;
var wasmImports = {
  /** @export */
  __assert_fail: ___assert_fail,
  /** @export */
  __call_sighandler: ___call_sighandler,
  /** @export */
  __heap_base: ___heap_base,
  /** @export */
  __indirect_function_table: wasmTable,
  /** @export */
  __memory_base: ___memory_base,
  /** @export */
  __stack_pointer: ___stack_pointer,
  /** @export */
  __syscall__newselect: ___syscall__newselect,
  /** @export */
  __syscall_bind: ___syscall_bind,
  /** @export */
  __syscall_chdir: ___syscall_chdir,
  /** @export */
  __syscall_chmod: ___syscall_chmod,
  /** @export */
  __syscall_connect: ___syscall_connect,
  /** @export */
  __syscall_dup: ___syscall_dup,
  /** @export */
  __syscall_dup3: ___syscall_dup3,
  /** @export */
  __syscall_faccessat: ___syscall_faccessat,
  /** @export */
  __syscall_fadvise64: ___syscall_fadvise64,
  /** @export */
  __syscall_fallocate: ___syscall_fallocate,
  /** @export */
  __syscall_fcntl64: ___syscall_fcntl64,
  /** @export */
  __syscall_fdatasync: ___syscall_fdatasync,
  /** @export */
  __syscall_fstat64: ___syscall_fstat64,
  /** @export */
  __syscall_ftruncate64: ___syscall_ftruncate64,
  /** @export */
  __syscall_getcwd: ___syscall_getcwd,
  /** @export */
  __syscall_getdents64: ___syscall_getdents64,
  /** @export */
  __syscall_getsockname: ___syscall_getsockname,
  /** @export */
  __syscall_getsockopt: ___syscall_getsockopt,
  /** @export */
  __syscall_ioctl: ___syscall_ioctl,
  /** @export */
  __syscall_lstat64: ___syscall_lstat64,
  /** @export */
  __syscall_mkdirat: ___syscall_mkdirat,
  /** @export */
  __syscall_newfstatat: ___syscall_newfstatat,
  /** @export */
  __syscall_openat: ___syscall_openat,
  /** @export */
  __syscall_pipe: ___syscall_pipe,
  /** @export */
  __syscall_poll: ___syscall_poll,
  /** @export */
  __syscall_readlinkat: ___syscall_readlinkat,
  /** @export */
  __syscall_recvfrom: ___syscall_recvfrom,
  /** @export */
  __syscall_renameat: ___syscall_renameat,
  /** @export */
  __syscall_rmdir: ___syscall_rmdir,
  /** @export */
  __syscall_sendto: ___syscall_sendto,
  /** @export */
  __syscall_socket: ___syscall_socket,
  /** @export */
  __syscall_stat64: ___syscall_stat64,
  /** @export */
  __syscall_symlink: ___syscall_symlink,
  /** @export */
  __syscall_truncate64: ___syscall_truncate64,
  /** @export */
  __syscall_unlinkat: ___syscall_unlinkat,
  /** @export */
  __table_base: ___table_base,
  /** @export */
  _abort_js: __abort_js,
  /** @export */
  _dlopen_js: __dlopen_js,
  /** @export */
  _dlsym_js: __dlsym_js,
  /** @export */
  _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
  /** @export */
  _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear,
  /** @export */
  _emscripten_system: __emscripten_system,
  /** @export */
  _emscripten_throw_longjmp: __emscripten_throw_longjmp,
  /** @export */
  _gmtime_js: __gmtime_js,
  /** @export */
  _localtime_js: __localtime_js,
  /** @export */
  _mmap_js: __mmap_js,
  /** @export */
  _munmap_js: __munmap_js,
  /** @export */
  _setitimer_js: __setitimer_js,
  /** @export */
  _tzset_js: __tzset_js,
  /** @export */
  emscripten_asm_const_int: _emscripten_asm_const_int,
  /** @export */
  emscripten_date_now: _emscripten_date_now,
  /** @export */
  emscripten_force_exit: _emscripten_force_exit,
  /** @export */
  emscripten_get_now: _emscripten_get_now,
  /** @export */
  emscripten_resize_heap: _emscripten_resize_heap,
  /** @export */
  emscripten_set_main_loop: _emscripten_set_main_loop,
  /** @export */
  environ_get: _environ_get,
  /** @export */
  environ_sizes_get: _environ_sizes_get,
  /** @export */
  exit: _exit,
  /** @export */
  fd_close: _fd_close,
  /** @export */
  fd_fdstat_get: _fd_fdstat_get,
  /** @export */
  fd_pread: _fd_pread,
  /** @export */
  fd_pwrite: _fd_pwrite,
  /** @export */
  fd_read: _fd_read,
  /** @export */
  fd_seek: _fd_seek,
  /** @export */
  fd_sync: _fd_sync,
  /** @export */
  fd_write: _fd_write,
  /** @export */
  getTempRet0: _getTempRet0,
  /** @export */
  getaddrinfo: _getaddrinfo,
  /** @export */
  getnameinfo: _getnameinfo,
  /** @export */
  invoke_di,
  /** @export */
  invoke_i,
  /** @export */
  invoke_id,
  /** @export */
  invoke_ii,
  /** @export */
  invoke_iii,
  /** @export */
  invoke_iiii,
  /** @export */
  invoke_iiiii,
  /** @export */
  invoke_iiiiii,
  /** @export */
  invoke_iiiiiii,
  /** @export */
  invoke_iiiiiiii,
  /** @export */
  invoke_iiiiiiiii,
  /** @export */
  invoke_iiiiiiiiii,
  /** @export */
  invoke_iiiiiiiiiiiiiiiii,
  /** @export */
  invoke_iiiiiji,
  /** @export */
  invoke_iiiij,
  /** @export */
  invoke_iiiijii,
  /** @export */
  invoke_iiij,
  /** @export */
  invoke_iiji,
  /** @export */
  invoke_ij,
  /** @export */
  invoke_ijiiiii,
  /** @export */
  invoke_ijiiiiii,
  /** @export */
  invoke_ji,
  /** @export */
  invoke_jii,
  /** @export */
  invoke_jiiii,
  /** @export */
  invoke_jiiiii,
  /** @export */
  invoke_jiiiiiiii,
  /** @export */
  invoke_v,
  /** @export */
  invoke_vi,
  /** @export */
  invoke_vid,
  /** @export */
  invoke_vii,
  /** @export */
  invoke_viii,
  /** @export */
  invoke_viiii,
  /** @export */
  invoke_viiiii,
  /** @export */
  invoke_viiiiii,
  /** @export */
  invoke_viiiiiii,
  /** @export */
  invoke_viiiiiiii,
  /** @export */
  invoke_viiiiiiiii,
  /** @export */
  invoke_viiiiiiiiiiii,
  /** @export */
  invoke_viiij,
  /** @export */
  invoke_viij,
  /** @export */
  invoke_viiji,
  /** @export */
  invoke_viijii,
  /** @export */
  invoke_viijiiii,
  /** @export */
  invoke_vij,
  /** @export */
  invoke_viji,
  /** @export */
  invoke_vijiji,
  /** @export */
  invoke_vj,
  /** @export */
  invoke_vji,
  /** @export */
  is_web_env,
  /** @export */
  memory: wasmMemory,
  /** @export */
  proc_exit: _proc_exit,
  /** @export */
  setTempRet0: _setTempRet0
};
var wasmExports = createWasm();
var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports['__wasm_call_ctors'])();
var ___wasm_apply_data_relocs = () => (___wasm_apply_data_relocs = wasmExports['__wasm_apply_data_relocs'])();
var _ScanKeywordLookup = Module['_ScanKeywordLookup'] = (a0, a1) => (_ScanKeywordLookup = Module['_ScanKeywordLookup'] = wasmExports['ScanKeywordLookup'])(a0, a1);
var _pg_snprintf = Module['_pg_snprintf'] = (a0, a1, a2, a3) => (_pg_snprintf = Module['_pg_snprintf'] = wasmExports['pg_snprintf'])(a0, a1, a2, a3);
var _strlen = Module['_strlen'] = (a0) => (_strlen = Module['_strlen'] = wasmExports['strlen'])(a0);
var _memset = Module['_memset'] = (a0, a1, a2) => (_memset = Module['_memset'] = wasmExports['memset'])(a0, a1, a2);
var _strchr = Module['_strchr'] = (a0, a1) => (_strchr = Module['_strchr'] = wasmExports['strchr'])(a0, a1);
var _PQserverVersion = Module['_PQserverVersion'] = (a0) => (_PQserverVersion = Module['_PQserverVersion'] = wasmExports['PQserverVersion'])(a0);
var _strstr = Module['_strstr'] = (a0, a1) => (_strstr = Module['_strstr'] = wasmExports['strstr'])(a0, a1);
var _pg_fprintf = Module['_pg_fprintf'] = (a0, a1, a2) => (_pg_fprintf = Module['_pg_fprintf'] = wasmExports['pg_fprintf'])(a0, a1, a2);
var _strspn = Module['_strspn'] = (a0, a1) => (_strspn = Module['_strspn'] = wasmExports['strspn'])(a0, a1);
var _malloc = Module['_malloc'] = (a0) => (_malloc = Module['_malloc'] = wasmExports['malloc'])(a0);
var _pg_strcasecmp = Module['_pg_strcasecmp'] = (a0, a1) => (_pg_strcasecmp = Module['_pg_strcasecmp'] = wasmExports['pg_strcasecmp'])(a0, a1);
var _strcmp = Module['_strcmp'] = (a0, a1) => (_strcmp = Module['_strcmp'] = wasmExports['strcmp'])(a0, a1);
var _free = Module['_free'] = (a0) => (_free = Module['_free'] = wasmExports['free'])(a0);
var _pg_tolower = Module['_pg_tolower'] = (a0) => (_pg_tolower = Module['_pg_tolower'] = wasmExports['pg_tolower'])(a0);
var _memchr = Module['_memchr'] = (a0, a1, a2) => (_memchr = Module['_memchr'] = wasmExports['memchr'])(a0, a1, a2);
var _getenv = Module['_getenv'] = (a0) => (_getenv = Module['_getenv'] = wasmExports['getenv'])(a0);
var _fileno = Module['_fileno'] = (a0) => (_fileno = Module['_fileno'] = wasmExports['fileno'])(a0);
var _isatty = Module['_isatty'] = (a0) => (_isatty = Module['_isatty'] = wasmExports['isatty'])(a0);
var _strdup = Module['_strdup'] = (a0) => (_strdup = Module['_strdup'] = wasmExports['strdup'])(a0);
var ___errno_location = Module['___errno_location'] = () => (___errno_location = Module['___errno_location'] = wasmExports['__errno_location'])();
var _fflush = Module['_fflush'] = (a0) => (_fflush = Module['_fflush'] = wasmExports['fflush'])(a0);
var _pg_vsnprintf = Module['_pg_vsnprintf'] = (a0, a1, a2, a3) => (_pg_vsnprintf = Module['_pg_vsnprintf'] = wasmExports['pg_vsnprintf'])(a0, a1, a2, a3);
var _pg_malloc_extended = Module['_pg_malloc_extended'] = (a0, a1) => (_pg_malloc_extended = Module['_pg_malloc_extended'] = wasmExports['pg_malloc_extended'])(a0, a1);
var _palloc0 = Module['_palloc0'] = (a0) => (_palloc0 = Module['_palloc0'] = wasmExports['palloc0'])(a0);
var _pfree = Module['_pfree'] = (a0) => (_pfree = Module['_pfree'] = wasmExports['pfree'])(a0);
var _palloc = Module['_palloc'] = (a0) => (_palloc = Module['_palloc'] = wasmExports['palloc'])(a0);
var _memcmp = Module['_memcmp'] = (a0, a1, a2) => (_memcmp = Module['_memcmp'] = wasmExports['memcmp'])(a0, a1, a2);
var _repalloc = Module['_repalloc'] = (a0, a1) => (_repalloc = Module['_repalloc'] = wasmExports['repalloc'])(a0, a1);
var _memmove = Module['_memmove'] = (a0, a1, a2) => (_memmove = Module['_memmove'] = wasmExports['memmove'])(a0, a1, a2);
var _pg_detoast_datum_packed = Module['_pg_detoast_datum_packed'] = (a0) => (_pg_detoast_datum_packed = Module['_pg_detoast_datum_packed'] = wasmExports['pg_detoast_datum_packed'])(a0);
var _text_to_cstring = Module['_text_to_cstring'] = (a0) => (_text_to_cstring = Module['_text_to_cstring'] = wasmExports['text_to_cstring'])(a0);
var _errstart_cold = Module['_errstart_cold'] = (a0, a1) => (_errstart_cold = Module['_errstart_cold'] = wasmExports['errstart_cold'])(a0, a1);
var _errcode = Module['_errcode'] = (a0) => (_errcode = Module['_errcode'] = wasmExports['errcode'])(a0);
var _errmsg = Module['_errmsg'] = (a0, a1) => (_errmsg = Module['_errmsg'] = wasmExports['errmsg'])(a0, a1);
var _errfinish = Module['_errfinish'] = (a0, a1, a2) => (_errfinish = Module['_errfinish'] = wasmExports['errfinish'])(a0, a1, a2);
var _puts = Module['_puts'] = (a0) => (_puts = Module['_puts'] = wasmExports['puts'])(a0);
var _AllocSetContextCreateInternal = Module['_AllocSetContextCreateInternal'] = (a0, a1, a2, a3, a4) => (_AllocSetContextCreateInternal = Module['_AllocSetContextCreateInternal'] = wasmExports['AllocSetContextCreateInternal'])(a0, a1, a2, a3, a4);
var _MemoryContextReset = Module['_MemoryContextReset'] = (a0) => (_MemoryContextReset = Module['_MemoryContextReset'] = wasmExports['MemoryContextReset'])(a0);
var _makeStringInfo = Module['_makeStringInfo'] = () => (_makeStringInfo = Module['_makeStringInfo'] = wasmExports['makeStringInfo'])();
var _Int64GetDatum = Module['_Int64GetDatum'] = (a0) => (_Int64GetDatum = Module['_Int64GetDatum'] = wasmExports['Int64GetDatum'])(a0);
var _get_call_result_type = Module['_get_call_result_type'] = (a0, a1, a2) => (_get_call_result_type = Module['_get_call_result_type'] = wasmExports['get_call_result_type'])(a0, a1, a2);
var _errmsg_internal = Module['_errmsg_internal'] = (a0, a1) => (_errmsg_internal = Module['_errmsg_internal'] = wasmExports['errmsg_internal'])(a0, a1);
var _errhint = Module['_errhint'] = (a0, a1) => (_errhint = Module['_errhint'] = wasmExports['errhint'])(a0, a1);
var _cstring_to_text = Module['_cstring_to_text'] = (a0) => (_cstring_to_text = Module['_cstring_to_text'] = wasmExports['cstring_to_text'])(a0);
var _MemoryContextDelete = Module['_MemoryContextDelete'] = (a0) => (_MemoryContextDelete = Module['_MemoryContextDelete'] = wasmExports['MemoryContextDelete'])(a0);
var _heap_form_tuple = Module['_heap_form_tuple'] = (a0, a1, a2) => (_heap_form_tuple = Module['_heap_form_tuple'] = wasmExports['heap_form_tuple'])(a0, a1, a2);
var _HeapTupleHeaderGetDatum = Module['_HeapTupleHeaderGetDatum'] = (a0) => (_HeapTupleHeaderGetDatum = Module['_HeapTupleHeaderGetDatum'] = wasmExports['HeapTupleHeaderGetDatum'])(a0);
var _RecoveryInProgress = Module['_RecoveryInProgress'] = () => (_RecoveryInProgress = Module['_RecoveryInProgress'] = wasmExports['RecoveryInProgress'])();
var _GetFlushRecPtr = Module['_GetFlushRecPtr'] = (a0) => (_GetFlushRecPtr = Module['_GetFlushRecPtr'] = wasmExports['GetFlushRecPtr'])(a0);
var _GetXLogReplayRecPtr = Module['_GetXLogReplayRecPtr'] = (a0) => (_GetXLogReplayRecPtr = Module['_GetXLogReplayRecPtr'] = wasmExports['GetXLogReplayRecPtr'])(a0);
var _CreateTemplateTupleDesc = Module['_CreateTemplateTupleDesc'] = (a0) => (_CreateTemplateTupleDesc = Module['_CreateTemplateTupleDesc'] = wasmExports['CreateTemplateTupleDesc'])(a0);
var _TupleDescInitEntry = Module['_TupleDescInitEntry'] = (a0, a1, a2, a3, a4, a5) => (_TupleDescInitEntry = Module['_TupleDescInitEntry'] = wasmExports['TupleDescInitEntry'])(a0, a1, a2, a3, a4, a5);
var _BlessTupleDesc = Module['_BlessTupleDesc'] = (a0) => (_BlessTupleDesc = Module['_BlessTupleDesc'] = wasmExports['BlessTupleDesc'])(a0);
var _pstrdup = Module['_pstrdup'] = (a0) => (_pstrdup = Module['_pstrdup'] = wasmExports['pstrdup'])(a0);
var _sscanf = Module['_sscanf'] = (a0, a1, a2) => (_sscanf = Module['_sscanf'] = wasmExports['sscanf'])(a0, a1, a2);
var _numeric_in = Module['_numeric_in'] = (a0) => (_numeric_in = Module['_numeric_in'] = wasmExports['numeric_in'])(a0);
var _DirectFunctionCall3Coll = Module['_DirectFunctionCall3Coll'] = (a0, a1, a2, a3, a4) => (_DirectFunctionCall3Coll = Module['_DirectFunctionCall3Coll'] = wasmExports['DirectFunctionCall3Coll'])(a0, a1, a2, a3, a4);
var _DirectFunctionCall2Coll = Module['_DirectFunctionCall2Coll'] = (a0, a1, a2, a3) => (_DirectFunctionCall2Coll = Module['_DirectFunctionCall2Coll'] = wasmExports['DirectFunctionCall2Coll'])(a0, a1, a2, a3);
var _AllocateFile = Module['_AllocateFile'] = (a0, a1) => (_AllocateFile = Module['_AllocateFile'] = wasmExports['AllocateFile'])(a0, a1);
var _errcode_for_file_access = Module['_errcode_for_file_access'] = () => (_errcode_for_file_access = Module['_errcode_for_file_access'] = wasmExports['errcode_for_file_access'])();
var _FreeFile = Module['_FreeFile'] = (a0) => (_FreeFile = Module['_FreeFile'] = wasmExports['FreeFile'])(a0);
var _errstart = Module['_errstart'] = (a0, a1) => (_errstart = Module['_errstart'] = wasmExports['errstart'])(a0, a1);
var _unlink = Module['_unlink'] = (a0) => (_unlink = Module['_unlink'] = wasmExports['unlink'])(a0);
var _ResetLatch = Module['_ResetLatch'] = (a0) => (_ResetLatch = Module['_ResetLatch'] = wasmExports['ResetLatch'])(a0);
var _ProcessInterrupts = Module['_ProcessInterrupts'] = () => (_ProcessInterrupts = Module['_ProcessInterrupts'] = wasmExports['ProcessInterrupts'])();
var _WaitLatch = Module['_WaitLatch'] = (a0, a1, a2, a3) => (_WaitLatch = Module['_WaitLatch'] = wasmExports['WaitLatch'])(a0, a1, a2, a3);
var _errmsg_plural = Module['_errmsg_plural'] = (a0, a1, a2, a3) => (_errmsg_plural = Module['_errmsg_plural'] = wasmExports['errmsg_plural'])(a0, a1, a2, a3);
var _RmgrNotFound = Module['_RmgrNotFound'] = (a0) => (_RmgrNotFound = Module['_RmgrNotFound'] = wasmExports['RmgrNotFound'])(a0);
var _errdetail = Module['_errdetail'] = (a0, a1) => (_errdetail = Module['_errdetail'] = wasmExports['errdetail'])(a0, a1);
var _InitMaterializedSRF = Module['_InitMaterializedSRF'] = (a0, a1) => (_InitMaterializedSRF = Module['_InitMaterializedSRF'] = wasmExports['InitMaterializedSRF'])(a0, a1);
var _tuplestore_putvalues = Module['_tuplestore_putvalues'] = (a0, a1, a2, a3) => (_tuplestore_putvalues = Module['_tuplestore_putvalues'] = wasmExports['tuplestore_putvalues'])(a0, a1, a2, a3);
var _GenericXLogStart = Module['_GenericXLogStart'] = (a0) => (_GenericXLogStart = Module['_GenericXLogStart'] = wasmExports['GenericXLogStart'])(a0);
var _GenericXLogRegisterBuffer = Module['_GenericXLogRegisterBuffer'] = (a0, a1, a2) => (_GenericXLogRegisterBuffer = Module['_GenericXLogRegisterBuffer'] = wasmExports['GenericXLogRegisterBuffer'])(a0, a1, a2);
var _memcpy = Module['_memcpy'] = (a0, a1, a2) => (_memcpy = Module['_memcpy'] = wasmExports['memcpy'])(a0, a1, a2);
var _GenericXLogFinish = Module['_GenericXLogFinish'] = (a0) => (_GenericXLogFinish = Module['_GenericXLogFinish'] = wasmExports['GenericXLogFinish'])(a0);
var _XLogBeginInsert = Module['_XLogBeginInsert'] = () => (_XLogBeginInsert = Module['_XLogBeginInsert'] = wasmExports['XLogBeginInsert'])();
var _MarkBufferDirty = Module['_MarkBufferDirty'] = (a0) => (_MarkBufferDirty = Module['_MarkBufferDirty'] = wasmExports['MarkBufferDirty'])(a0);
var _XLogInsert = Module['_XLogInsert'] = (a0, a1) => (_XLogInsert = Module['_XLogInsert'] = wasmExports['XLogInsert'])(a0, a1);
var _GenericXLogAbort = Module['_GenericXLogAbort'] = (a0) => (_GenericXLogAbort = Module['_GenericXLogAbort'] = wasmExports['GenericXLogAbort'])(a0);
var _UnlockReleaseBuffer = Module['_UnlockReleaseBuffer'] = (a0) => (_UnlockReleaseBuffer = Module['_UnlockReleaseBuffer'] = wasmExports['UnlockReleaseBuffer'])(a0);
var _XLogRegisterData = Module['_XLogRegisterData'] = (a0, a1) => (_XLogRegisterData = Module['_XLogRegisterData'] = wasmExports['XLogRegisterData'])(a0, a1);
var _GetCurrentSubTransactionId = Module['_GetCurrentSubTransactionId'] = () => (_GetCurrentSubTransactionId = Module['_GetCurrentSubTransactionId'] = wasmExports['GetCurrentSubTransactionId'])();
var _GetCurrentCommandId = Module['_GetCurrentCommandId'] = (a0) => (_GetCurrentCommandId = Module['_GetCurrentCommandId'] = wasmExports['GetCurrentCommandId'])(a0);
var _GetCurrentTimestamp = Module['_GetCurrentTimestamp'] = () => (_GetCurrentTimestamp = Module['_GetCurrentTimestamp'] = wasmExports['GetCurrentTimestamp'])();
var _GetCurrentTransactionNestLevel = Module['_GetCurrentTransactionNestLevel'] = () => (_GetCurrentTransactionNestLevel = Module['_GetCurrentTransactionNestLevel'] = wasmExports['GetCurrentTransactionNestLevel'])();
var _TransactionIdIsCurrentTransactionId = Module['_TransactionIdIsCurrentTransactionId'] = (a0) => (_TransactionIdIsCurrentTransactionId = Module['_TransactionIdIsCurrentTransactionId'] = wasmExports['TransactionIdIsCurrentTransactionId'])(a0);
var _TransactionIdPrecedes = Module['_TransactionIdPrecedes'] = (a0, a1) => (_TransactionIdPrecedes = Module['_TransactionIdPrecedes'] = wasmExports['TransactionIdPrecedes'])(a0, a1);
var _EnterParallelMode = Module['_EnterParallelMode'] = () => (_EnterParallelMode = Module['_EnterParallelMode'] = wasmExports['EnterParallelMode'])();
var _ExitParallelMode = Module['_ExitParallelMode'] = () => (_ExitParallelMode = Module['_ExitParallelMode'] = wasmExports['ExitParallelMode'])();
var _CommandCounterIncrement = Module['_CommandCounterIncrement'] = () => (_CommandCounterIncrement = Module['_CommandCounterIncrement'] = wasmExports['CommandCounterIncrement'])();
var _StartTransactionCommand = Module['_StartTransactionCommand'] = () => (_StartTransactionCommand = Module['_StartTransactionCommand'] = wasmExports['StartTransactionCommand'])();
var _pg_prng_double = Module['_pg_prng_double'] = (a0) => (_pg_prng_double = Module['_pg_prng_double'] = wasmExports['pg_prng_double'])(a0);
var _GetUserIdAndSecContext = Module['_GetUserIdAndSecContext'] = (a0, a1) => (_GetUserIdAndSecContext = Module['_GetUserIdAndSecContext'] = wasmExports['GetUserIdAndSecContext'])(a0, a1);
var _ResourceOwnerCreate = Module['_ResourceOwnerCreate'] = (a0, a1) => (_ResourceOwnerCreate = Module['_ResourceOwnerCreate'] = wasmExports['ResourceOwnerCreate'])(a0, a1);
var _CommitTransactionCommand = Module['_CommitTransactionCommand'] = () => (_CommitTransactionCommand = Module['_CommitTransactionCommand'] = wasmExports['CommitTransactionCommand'])();
var _AtEOXact_GUC = Module['_AtEOXact_GUC'] = (a0, a1) => (_AtEOXact_GUC = Module['_AtEOXact_GUC'] = wasmExports['AtEOXact_GUC'])(a0, a1);
var _ResourceOwnerDelete = Module['_ResourceOwnerDelete'] = (a0) => (_ResourceOwnerDelete = Module['_ResourceOwnerDelete'] = wasmExports['ResourceOwnerDelete'])(a0);
var _ConditionVariableCancelSleep = Module['_ConditionVariableCancelSleep'] = () => (_ConditionVariableCancelSleep = Module['_ConditionVariableCancelSleep'] = wasmExports['ConditionVariableCancelSleep'])();
var _SetUserIdAndSecContext = Module['_SetUserIdAndSecContext'] = (a0, a1) => (_SetUserIdAndSecContext = Module['_SetUserIdAndSecContext'] = wasmExports['SetUserIdAndSecContext'])(a0, a1);
var _GetUserId = Module['_GetUserId'] = () => (_GetUserId = Module['_GetUserId'] = wasmExports['GetUserId'])();
var _MemoryContextAlloc = Module['_MemoryContextAlloc'] = (a0, a1) => (_MemoryContextAlloc = Module['_MemoryContextAlloc'] = wasmExports['MemoryContextAlloc'])(a0, a1);
var _AtEOSubXact_Files = Module['_AtEOSubXact_Files'] = (a0, a1, a2) => (_AtEOSubXact_Files = Module['_AtEOSubXact_Files'] = wasmExports['AtEOSubXact_Files'])(a0, a1, a2);
var _MemoryContextStrdup = Module['_MemoryContextStrdup'] = (a0, a1) => (_MemoryContextStrdup = Module['_MemoryContextStrdup'] = wasmExports['MemoryContextStrdup'])(a0, a1);
var _RegisterXactCallback = Module['_RegisterXactCallback'] = (a0, a1) => (_RegisterXactCallback = Module['_RegisterXactCallback'] = wasmExports['RegisterXactCallback'])(a0, a1);
var _RegisterSubXactCallback = Module['_RegisterSubXactCallback'] = (a0, a1) => (_RegisterSubXactCallback = Module['_RegisterSubXactCallback'] = wasmExports['RegisterSubXactCallback'])(a0, a1);
var _MemoryContextAllocZero = Module['_MemoryContextAllocZero'] = (a0, a1) => (_MemoryContextAllocZero = Module['_MemoryContextAllocZero'] = wasmExports['MemoryContextAllocZero'])(a0, a1);
var _NewGUCNestLevel = Module['_NewGUCNestLevel'] = () => (_NewGUCNestLevel = Module['_NewGUCNestLevel'] = wasmExports['NewGUCNestLevel'])();
var _BeginInternalSubTransaction = Module['_BeginInternalSubTransaction'] = (a0) => (_BeginInternalSubTransaction = Module['_BeginInternalSubTransaction'] = wasmExports['BeginInternalSubTransaction'])(a0);
var _ReleaseCurrentSubTransaction = Module['_ReleaseCurrentSubTransaction'] = () => (_ReleaseCurrentSubTransaction = Module['_ReleaseCurrentSubTransaction'] = wasmExports['ReleaseCurrentSubTransaction'])();
var _RollbackAndReleaseCurrentSubTransaction = Module['_RollbackAndReleaseCurrentSubTransaction'] = () => (_RollbackAndReleaseCurrentSubTransaction = Module['_RollbackAndReleaseCurrentSubTransaction'] = wasmExports['RollbackAndReleaseCurrentSubTransaction'])();
var _add_size = Module['_add_size'] = (a0, a1) => (_add_size = Module['_add_size'] = wasmExports['add_size'])(a0, a1);
var _pg_qsort = Module['_pg_qsort'] = (a0, a1, a2, a3) => (_pg_qsort = Module['_pg_qsort'] = wasmExports['pg_qsort'])(a0, a1, a2, a3);
var _LWLockAcquire = Module['_LWLockAcquire'] = (a0, a1) => (_LWLockAcquire = Module['_LWLockAcquire'] = wasmExports['LWLockAcquire'])(a0, a1);
var _LWLockRelease = Module['_LWLockRelease'] = (a0) => (_LWLockRelease = Module['_LWLockRelease'] = wasmExports['LWLockRelease'])(a0);
var _initStringInfo = Module['_initStringInfo'] = (a0) => (_initStringInfo = Module['_initStringInfo'] = wasmExports['initStringInfo'])(a0);
var _appendStringInfo = Module['_appendStringInfo'] = (a0, a1, a2) => (_appendStringInfo = Module['_appendStringInfo'] = wasmExports['appendStringInfo'])(a0, a1, a2);
var _TransactionIdDidCommit = Module['_TransactionIdDidCommit'] = (a0) => (_TransactionIdDidCommit = Module['_TransactionIdDidCommit'] = wasmExports['TransactionIdDidCommit'])(a0);
var _errdetail_internal = Module['_errdetail_internal'] = (a0, a1) => (_errdetail_internal = Module['_errdetail_internal'] = wasmExports['errdetail_internal'])(a0, a1);
var _log_newpage_buffer = Module['_log_newpage_buffer'] = (a0, a1) => (_log_newpage_buffer = Module['_log_newpage_buffer'] = wasmExports['log_newpage_buffer'])(a0, a1);
var _log_newpage_range = Module['_log_newpage_range'] = (a0, a1, a2, a3, a4) => (_log_newpage_range = Module['_log_newpage_range'] = wasmExports['log_newpage_range'])(a0, a1, a2, a3, a4);
var _ReadBufferExtended = Module['_ReadBufferExtended'] = (a0, a1, a2, a3, a4) => (_ReadBufferExtended = Module['_ReadBufferExtended'] = wasmExports['ReadBufferExtended'])(a0, a1, a2, a3, a4);
var _LockBuffer = Module['_LockBuffer'] = (a0, a1) => (_LockBuffer = Module['_LockBuffer'] = wasmExports['LockBuffer'])(a0, a1);
var _stat = Module['_stat'] = (a0, a1) => (_stat = Module['_stat'] = wasmExports['stat'])(a0, a1);
var _strcpy = Module['_strcpy'] = (a0, a1) => (_strcpy = Module['_strcpy'] = wasmExports['strcpy'])(a0, a1);
var _wait_result_to_str = Module['_wait_result_to_str'] = (a0) => (_wait_result_to_str = Module['_wait_result_to_str'] = wasmExports['wait_result_to_str'])(a0);
var _replace_percent_placeholders = Module['_replace_percent_placeholders'] = (a0, a1, a2, a3) => (_replace_percent_placeholders = Module['_replace_percent_placeholders'] = wasmExports['replace_percent_placeholders'])(a0, a1, a2, a3);
var _strlcpy = Module['_strlcpy'] = (a0, a1, a2) => (_strlcpy = Module['_strlcpy'] = wasmExports['strlcpy'])(a0, a1, a2);
var _fd_durable_rename = Module['_fd_durable_rename'] = (a0, a1, a2) => (_fd_durable_rename = Module['_fd_durable_rename'] = wasmExports['fd_durable_rename'])(a0, a1, a2);
var _CreateParallelContext = Module['_CreateParallelContext'] = (a0, a1, a2) => (_CreateParallelContext = Module['_CreateParallelContext'] = wasmExports['CreateParallelContext'])(a0, a1, a2);
var _InitializeParallelDSM = Module['_InitializeParallelDSM'] = (a0) => (_InitializeParallelDSM = Module['_InitializeParallelDSM'] = wasmExports['InitializeParallelDSM'])(a0);
var _GetTransactionSnapshot = Module['_GetTransactionSnapshot'] = () => (_GetTransactionSnapshot = Module['_GetTransactionSnapshot'] = wasmExports['GetTransactionSnapshot'])();
var _GetActiveSnapshot = Module['_GetActiveSnapshot'] = () => (_GetActiveSnapshot = Module['_GetActiveSnapshot'] = wasmExports['GetActiveSnapshot'])();
var _dsm_create = Module['_dsm_create'] = (a0, a1) => (_dsm_create = Module['_dsm_create'] = wasmExports['dsm_create'])(a0, a1);
var _dsm_segment_address = Module['_dsm_segment_address'] = (a0) => (_dsm_segment_address = Module['_dsm_segment_address'] = wasmExports['dsm_segment_address'])(a0);
var _shm_toc_allocate = Module['_shm_toc_allocate'] = (a0, a1) => (_shm_toc_allocate = Module['_shm_toc_allocate'] = wasmExports['shm_toc_allocate'])(a0, a1);
var _s_init_lock_sema = Module['_s_init_lock_sema'] = (a0, a1) => (_s_init_lock_sema = Module['_s_init_lock_sema'] = wasmExports['s_init_lock_sema'])(a0, a1);
var _shm_toc_insert = Module['_shm_toc_insert'] = (a0, a1, a2) => (_shm_toc_insert = Module['_shm_toc_insert'] = wasmExports['shm_toc_insert'])(a0, a1, a2);
var _WaitForParallelWorkersToFinish = Module['_WaitForParallelWorkersToFinish'] = (a0) => (_WaitForParallelWorkersToFinish = Module['_WaitForParallelWorkersToFinish'] = wasmExports['WaitForParallelWorkersToFinish'])(a0);
var _shm_toc_lookup = Module['_shm_toc_lookup'] = (a0, a1, a2) => (_shm_toc_lookup = Module['_shm_toc_lookup'] = wasmExports['shm_toc_lookup'])(a0, a1, a2);
var _WaitForBackgroundWorkerShutdown = Module['_WaitForBackgroundWorkerShutdown'] = (a0) => (_WaitForBackgroundWorkerShutdown = Module['_WaitForBackgroundWorkerShutdown'] = wasmExports['WaitForBackgroundWorkerShutdown'])(a0);
var _LaunchParallelWorkers = Module['_LaunchParallelWorkers'] = (a0) => (_LaunchParallelWorkers = Module['_LaunchParallelWorkers'] = wasmExports['LaunchParallelWorkers'])(a0);
var _pg_sprintf = Module['_pg_sprintf'] = (a0, a1, a2) => (_pg_sprintf = Module['_pg_sprintf'] = wasmExports['pg_sprintf'])(a0, a1, a2);
var _dsm_segment_handle = Module['_dsm_segment_handle'] = (a0) => (_dsm_segment_handle = Module['_dsm_segment_handle'] = wasmExports['dsm_segment_handle'])(a0);
var _RegisterDynamicBackgroundWorker = Module['_RegisterDynamicBackgroundWorker'] = (a0, a1) => (_RegisterDynamicBackgroundWorker = Module['_RegisterDynamicBackgroundWorker'] = wasmExports['RegisterDynamicBackgroundWorker'])(a0, a1);
var _WaitForParallelWorkersToAttach = Module['_WaitForParallelWorkersToAttach'] = (a0) => (_WaitForParallelWorkersToAttach = Module['_WaitForParallelWorkersToAttach'] = wasmExports['WaitForParallelWorkersToAttach'])(a0);
var _DestroyParallelContext = Module['_DestroyParallelContext'] = (a0) => (_DestroyParallelContext = Module['_DestroyParallelContext'] = wasmExports['DestroyParallelContext'])(a0);
var _dsm_detach = Module['_dsm_detach'] = (a0) => (_dsm_detach = Module['_dsm_detach'] = wasmExports['dsm_detach'])(a0);
var _appendBinaryStringInfo = Module['_appendBinaryStringInfo'] = (a0, a1, a2) => (_appendBinaryStringInfo = Module['_appendBinaryStringInfo'] = wasmExports['appendBinaryStringInfo'])(a0, a1, a2);
var _psprintf = Module['_psprintf'] = (a0, a1) => (_psprintf = Module['_psprintf'] = wasmExports['psprintf'])(a0, a1);
var _pq_getmsgint = Module['_pq_getmsgint'] = (a0, a1) => (_pq_getmsgint = Module['_pq_getmsgint'] = wasmExports['pq_getmsgint'])(a0, a1);
var _die = Module['_die'] = (a0) => (_die = Module['_die'] = wasmExports['die'])(a0);
var _pqsignal = Module['_pqsignal'] = (a0, a1) => (_pqsignal = Module['_pqsignal'] = wasmExports['pqsignal'])(a0, a1);
var _BackgroundWorkerUnblockSignals = Module['_BackgroundWorkerUnblockSignals'] = () => (_BackgroundWorkerUnblockSignals = Module['_BackgroundWorkerUnblockSignals'] = wasmExports['BackgroundWorkerUnblockSignals'])();
var _dsm_attach = Module['_dsm_attach'] = (a0) => (_dsm_attach = Module['_dsm_attach'] = wasmExports['dsm_attach'])(a0);
var _before_shmem_exit = Module['_before_shmem_exit'] = (a0, a1) => (_before_shmem_exit = Module['_before_shmem_exit'] = wasmExports['before_shmem_exit'])(a0, a1);
var _enlargeStringInfo = Module['_enlargeStringInfo'] = (a0, a1) => (_enlargeStringInfo = Module['_enlargeStringInfo'] = wasmExports['enlargeStringInfo'])(a0, a1);
var _BackgroundWorkerInitializeConnectionByOid = Module['_BackgroundWorkerInitializeConnectionByOid'] = (a0, a1, a2) => (_BackgroundWorkerInitializeConnectionByOid = Module['_BackgroundWorkerInitializeConnectionByOid'] = wasmExports['BackgroundWorkerInitializeConnectionByOid'])(a0, a1, a2);
var _GetDatabaseEncoding = Module['_GetDatabaseEncoding'] = () => (_GetDatabaseEncoding = Module['_GetDatabaseEncoding'] = wasmExports['GetDatabaseEncoding'])();
var _PushActiveSnapshot = Module['_PushActiveSnapshot'] = (a0) => (_PushActiveSnapshot = Module['_PushActiveSnapshot'] = wasmExports['PushActiveSnapshot'])(a0);
var _PopActiveSnapshot = Module['_PopActiveSnapshot'] = () => (_PopActiveSnapshot = Module['_PopActiveSnapshot'] = wasmExports['PopActiveSnapshot'])();
var _tas_sema = Module['_tas_sema'] = (a0) => (_tas_sema = Module['_tas_sema'] = wasmExports['tas_sema'])(a0);
var _s_lock = Module['_s_lock'] = (a0, a1, a2, a3) => (_s_lock = Module['_s_lock'] = wasmExports['s_lock'])(a0, a1, a2, a3);
var _s_unlock_sema = Module['_s_unlock_sema'] = (a0) => (_s_unlock_sema = Module['_s_unlock_sema'] = wasmExports['s_unlock_sema'])(a0);
var _SearchSysCacheExists = Module['_SearchSysCacheExists'] = (a0, a1, a2, a3, a4) => (_SearchSysCacheExists = Module['_SearchSysCacheExists'] = wasmExports['SearchSysCacheExists'])(a0, a1, a2, a3, a4);
var _pg_usleep = Module['_pg_usleep'] = (a0) => (_pg_usleep = Module['_pg_usleep'] = wasmExports['pg_usleep'])(a0);
var _clock_gettime = Module['_clock_gettime'] = (a0, a1) => (_clock_gettime = Module['_clock_gettime'] = wasmExports['clock_gettime'])(a0, a1);
var _pwrite = Module['_pwrite'] = (a0, a1, a2, a3) => (_pwrite = Module['_pwrite'] = wasmExports['pwrite'])(a0, a1, a2, a3);
var _time = Module['_time'] = (a0) => (_time = Module['_time'] = wasmExports['time'])(a0);
var _close = Module['_close'] = (a0) => (_close = Module['_close'] = wasmExports['close'])(a0);
var _ReleaseExternalFD = Module['_ReleaseExternalFD'] = () => (_ReleaseExternalFD = Module['_ReleaseExternalFD'] = wasmExports['ReleaseExternalFD'])();
var _getpid = Module['_getpid'] = () => (_getpid = Module['_getpid'] = wasmExports['getpid'])();
var _AllocateDir = Module['_AllocateDir'] = (a0) => (_AllocateDir = Module['_AllocateDir'] = wasmExports['AllocateDir'])(a0);
var _ReadDir = Module['_ReadDir'] = (a0, a1) => (_ReadDir = Module['_ReadDir'] = wasmExports['ReadDir'])(a0, a1);
var _strncmp = Module['_strncmp'] = (a0, a1, a2) => (_strncmp = Module['_strncmp'] = wasmExports['strncmp'])(a0, a1, a2);
var _FreeDir = Module['_FreeDir'] = (a0) => (_FreeDir = Module['_FreeDir'] = wasmExports['FreeDir'])(a0);
var _SplitIdentifierString = Module['_SplitIdentifierString'] = (a0, a1, a2) => (_SplitIdentifierString = Module['_SplitIdentifierString'] = wasmExports['SplitIdentifierString'])(a0, a1, a2);
var _pre_format_elog_string = Module['_pre_format_elog_string'] = (a0, a1) => (_pre_format_elog_string = Module['_pre_format_elog_string'] = wasmExports['pre_format_elog_string'])(a0, a1);
var _format_elog_string = Module['_format_elog_string'] = (a0, a1) => (_format_elog_string = Module['_format_elog_string'] = wasmExports['format_elog_string'])(a0, a1);
var _list_free = Module['_list_free'] = (a0) => (_list_free = Module['_list_free'] = wasmExports['list_free'])(a0);
var _guc_malloc = Module['_guc_malloc'] = (a0, a1) => (_guc_malloc = Module['_guc_malloc'] = wasmExports['guc_malloc'])(a0, a1);
var _read = Module['_read'] = (a0, a1, a2) => (_read = Module['_read'] = wasmExports['read'])(a0, a1, a2);
var _SetConfigOption = Module['_SetConfigOption'] = (a0, a1, a2, a3) => (_SetConfigOption = Module['_SetConfigOption'] = wasmExports['SetConfigOption'])(a0, a1, a2, a3);
var _ShmemInitStruct = Module['_ShmemInitStruct'] = (a0, a1, a2) => (_ShmemInitStruct = Module['_ShmemInitStruct'] = wasmExports['ShmemInitStruct'])(a0, a1, a2);
var _LWLockInitialize = Module['_LWLockInitialize'] = (a0, a1) => (_LWLockInitialize = Module['_LWLockInitialize'] = wasmExports['LWLockInitialize'])(a0, a1);
var _gettimeofday = Module['_gettimeofday'] = (a0, a1) => (_gettimeofday = Module['_gettimeofday'] = wasmExports['gettimeofday'])(a0, a1);
var _write = Module['_write'] = (a0, a1, a2) => (_write = Module['_write'] = wasmExports['write'])(a0, a1, a2);
var _pg_strong_random = Module['_pg_strong_random'] = (a0, a1) => (_pg_strong_random = Module['_pg_strong_random'] = wasmExports['pg_strong_random'])(a0, a1);
var _OpenTransientFile = Module['_OpenTransientFile'] = (a0, a1) => (_OpenTransientFile = Module['_OpenTransientFile'] = wasmExports['OpenTransientFile'])(a0, a1);
var _CloseTransientFile = Module['_CloseTransientFile'] = (a0) => (_CloseTransientFile = Module['_CloseTransientFile'] = wasmExports['CloseTransientFile'])(a0);
var _timestamptz_to_str = Module['_timestamptz_to_str'] = (a0) => (_timestamptz_to_str = Module['_timestamptz_to_str'] = wasmExports['timestamptz_to_str'])(a0);
var _TimestampDifferenceMilliseconds = Module['_TimestampDifferenceMilliseconds'] = (a0, a1) => (_TimestampDifferenceMilliseconds = Module['_TimestampDifferenceMilliseconds'] = wasmExports['TimestampDifferenceMilliseconds'])(a0, a1);
var ___wasm_setjmp_test = Module['___wasm_setjmp_test'] = (a0, a1) => (___wasm_setjmp_test = Module['___wasm_setjmp_test'] = wasmExports['__wasm_setjmp_test'])(a0, a1);
var ___wasm_setjmp = Module['___wasm_setjmp'] = (a0, a1, a2) => (___wasm_setjmp = Module['___wasm_setjmp'] = wasmExports['__wasm_setjmp'])(a0, a1, a2);
var _appendStringInfoChar = Module['_appendStringInfoChar'] = (a0, a1) => (_appendStringInfoChar = Module['_appendStringInfoChar'] = wasmExports['appendStringInfoChar'])(a0, a1);
var _lappend = Module['_lappend'] = (a0, a1) => (_lappend = Module['_lappend'] = wasmExports['lappend'])(a0, a1);
var _cancel_before_shmem_exit = Module['_cancel_before_shmem_exit'] = (a0, a1) => (_cancel_before_shmem_exit = Module['_cancel_before_shmem_exit'] = wasmExports['cancel_before_shmem_exit'])(a0, a1);
var _pg_re_throw = Module['_pg_re_throw'] = () => (_pg_re_throw = Module['_pg_re_throw'] = wasmExports['pg_re_throw'])();
var _emscripten_longjmp = Module['_emscripten_longjmp'] = (a0, a1) => (_emscripten_longjmp = Module['_emscripten_longjmp'] = wasmExports['emscripten_longjmp'])(a0, a1);
var _ferror = Module['_ferror'] = (a0) => (_ferror = Module['_ferror'] = wasmExports['ferror'])(a0);
var _XLogRecStoreStats = Module['_XLogRecStoreStats'] = (a0, a1) => (_XLogRecStoreStats = Module['_XLogRecStoreStats'] = wasmExports['XLogRecStoreStats'])(a0, a1);
var _init_MultiFuncCall = Module['_init_MultiFuncCall'] = (a0) => (_init_MultiFuncCall = Module['_init_MultiFuncCall'] = wasmExports['init_MultiFuncCall'])(a0);
var _per_MultiFuncCall = Module['_per_MultiFuncCall'] = (a0) => (_per_MultiFuncCall = Module['_per_MultiFuncCall'] = wasmExports['per_MultiFuncCall'])(a0);
var _end_MultiFuncCall = Module['_end_MultiFuncCall'] = (a0, a1) => (_end_MultiFuncCall = Module['_end_MultiFuncCall'] = wasmExports['end_MultiFuncCall'])(a0, a1);
var _fstat = Module['_fstat'] = (a0, a1) => (_fstat = Module['_fstat'] = wasmExports['fstat'])(a0, a1);
var _superuser_arg = Module['_superuser_arg'] = (a0) => (_superuser_arg = Module['_superuser_arg'] = wasmExports['superuser_arg'])(a0);
var _wal_segment_close = Module['_wal_segment_close'] = (a0) => (_wal_segment_close = Module['_wal_segment_close'] = wasmExports['wal_segment_close'])(a0);
var _wal_segment_open = Module['_wal_segment_open'] = (a0, a1, a2) => (_wal_segment_open = Module['_wal_segment_open'] = wasmExports['wal_segment_open'])(a0, a1, a2);
var _XLogReaderAllocate = Module['_XLogReaderAllocate'] = (a0, a1, a2, a3) => (_XLogReaderAllocate = Module['_XLogReaderAllocate'] = wasmExports['XLogReaderAllocate'])(a0, a1, a2, a3);
var _XLogReadRecord = Module['_XLogReadRecord'] = (a0, a1) => (_XLogReadRecord = Module['_XLogReadRecord'] = wasmExports['XLogReadRecord'])(a0, a1);
var _XLogReaderFree = Module['_XLogReaderFree'] = (a0) => (_XLogReaderFree = Module['_XLogReaderFree'] = wasmExports['XLogReaderFree'])(a0);
var _fd_fsync_fname = Module['_fd_fsync_fname'] = (a0, a1) => (_fd_fsync_fname = Module['_fd_fsync_fname'] = wasmExports['fd_fsync_fname'])(a0, a1);
var _strtoul = Module['_strtoul'] = (a0, a1, a2) => (_strtoul = Module['_strtoul'] = wasmExports['strtoul'])(a0, a1, a2);
var _access = Module['_access'] = (a0, a1) => (_access = Module['_access'] = wasmExports['access'])(a0, a1);
var _palloc_extended = Module['_palloc_extended'] = (a0, a1) => (_palloc_extended = Module['_palloc_extended'] = wasmExports['palloc_extended'])(a0, a1);
var _XLogFindNextRecord = Module['_XLogFindNextRecord'] = (a0, a1) => (_XLogFindNextRecord = Module['_XLogFindNextRecord'] = wasmExports['XLogFindNextRecord'])(a0, a1);
var _XLogRecGetBlockTagExtended = Module['_XLogRecGetBlockTagExtended'] = (a0, a1, a2, a3, a4, a5) => (_XLogRecGetBlockTagExtended = Module['_XLogRecGetBlockTagExtended'] = wasmExports['XLogRecGetBlockTagExtended'])(a0, a1, a2, a3, a4, a5);
var _RestoreBlockImage = Module['_RestoreBlockImage'] = (a0, a1, a2) => (_RestoreBlockImage = Module['_RestoreBlockImage'] = wasmExports['RestoreBlockImage'])(a0, a1, a2);
var _lseek = Module['_lseek'] = (a0, a1, a2) => (_lseek = Module['_lseek'] = wasmExports['lseek'])(a0, a1, a2);
var _strtol = Module['_strtol'] = (a0, a1, a2) => (_strtol = Module['_strtol'] = wasmExports['strtol'])(a0, a1, a2);
var _hash_get_num_entries = Module['_hash_get_num_entries'] = (a0) => (_hash_get_num_entries = Module['_hash_get_num_entries'] = wasmExports['hash_get_num_entries'])(a0);
var _hash_seq_init = Module['_hash_seq_init'] = (a0, a1) => (_hash_seq_init = Module['_hash_seq_init'] = wasmExports['hash_seq_init'])(a0, a1);
var _hash_seq_search = Module['_hash_seq_search'] = (a0) => (_hash_seq_search = Module['_hash_seq_search'] = wasmExports['hash_seq_search'])(a0);
var _hash_destroy = Module['_hash_destroy'] = (a0) => (_hash_destroy = Module['_hash_destroy'] = wasmExports['hash_destroy'])(a0);
var _LockBufferForCleanup = Module['_LockBufferForCleanup'] = (a0) => (_LockBufferForCleanup = Module['_LockBufferForCleanup'] = wasmExports['LockBufferForCleanup'])(a0);
var _smgropen = Module['_smgropen'] = (a0, a1) => (_smgropen = Module['_smgropen'] = wasmExports['smgropen'])(a0, a1);
var _ReleaseBuffer = Module['_ReleaseBuffer'] = (a0) => (_ReleaseBuffer = Module['_ReleaseBuffer'] = wasmExports['ReleaseBuffer'])(a0);
var _hash_create = Module['_hash_create'] = (a0, a1, a2, a3) => (_hash_create = Module['_hash_create'] = wasmExports['hash_create'])(a0, a1, a2, a3);
var _hash_search = Module['_hash_search'] = (a0, a1, a2, a3) => (_hash_search = Module['_hash_search'] = wasmExports['hash_search'])(a0, a1, a2, a3);
var _list_free_deep = Module['_list_free_deep'] = (a0) => (_list_free_deep = Module['_list_free_deep'] = wasmExports['list_free_deep'])(a0);
var _read_local_xlog_page_no_wait = Module['_read_local_xlog_page_no_wait'] = (a0, a1, a2, a3, a4) => (_read_local_xlog_page_no_wait = Module['_read_local_xlog_page_no_wait'] = wasmExports['read_local_xlog_page_no_wait'])(a0, a1, a2, a3, a4);
var _ConditionVariableInit = Module['_ConditionVariableInit'] = (a0) => (_ConditionVariableInit = Module['_ConditionVariableInit'] = wasmExports['ConditionVariableInit'])(a0);
var _timestamptz_in = Module['_timestamptz_in'] = (a0) => (_timestamptz_in = Module['_timestamptz_in'] = wasmExports['timestamptz_in'])(a0);
var _fscanf = Module['_fscanf'] = (a0, a1, a2) => (_fscanf = Module['_fscanf'] = wasmExports['fscanf'])(a0, a1, a2);
var _appendStringInfoString = Module['_appendStringInfoString'] = (a0, a1) => (_appendStringInfoString = Module['_appendStringInfoString'] = wasmExports['appendStringInfoString'])(a0, a1);
var _ParseDateTime = Module['_ParseDateTime'] = (a0, a1, a2, a3, a4, a5, a6) => (_ParseDateTime = Module['_ParseDateTime'] = wasmExports['ParseDateTime'])(a0, a1, a2, a3, a4, a5, a6);
var _DecodeDateTime = Module['_DecodeDateTime'] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_DecodeDateTime = Module['_DecodeDateTime'] = wasmExports['DecodeDateTime'])(a0, a1, a2, a3, a4, a5, a6, a7);
var _set_errcontext_domain = Module['_set_errcontext_domain'] = (a0) => (_set_errcontext_domain = Module['_set_errcontext_domain'] = wasmExports['set_errcontext_domain'])(a0);
var _errcontext_msg = Module['_errcontext_msg'] = (a0, a1) => (_errcontext_msg = Module['_errcontext_msg'] = wasmExports['errcontext_msg'])(a0, a1);
var _smgrexists = Module['_smgrexists'] = (a0, a1) => (_smgrexists = Module['_smgrexists'] = wasmExports['smgrexists'])(a0, a1);
var _GetMultiXactIdMembers = Module['_GetMultiXactIdMembers'] = (a0, a1, a2, a3) => (_GetMultiXactIdMembers = Module['_GetMultiXactIdMembers'] = wasmExports['GetMultiXactIdMembers'])(a0, a1, a2, a3);
var _TransactionIdIsInProgress = Module['_TransactionIdIsInProgress'] = (a0) => (_TransactionIdIsInProgress = Module['_TransactionIdIsInProgress'] = wasmExports['TransactionIdIsInProgress'])(a0);
var _ReadMultiXactIdRange = Module['_ReadMultiXactIdRange'] = (a0, a1) => (_ReadMultiXactIdRange = Module['_ReadMultiXactIdRange'] = wasmExports['ReadMultiXactIdRange'])(a0, a1);
var _MultiXactIdPrecedes = Module['_MultiXactIdPrecedes'] = (a0, a1) => (_MultiXactIdPrecedes = Module['_MultiXactIdPrecedes'] = wasmExports['MultiXactIdPrecedes'])(a0, a1);
var _MultiXactIdPrecedesOrEquals = Module['_MultiXactIdPrecedesOrEquals'] = (a0, a1) => (_MultiXactIdPrecedesOrEquals = Module['_MultiXactIdPrecedesOrEquals'] = wasmExports['MultiXactIdPrecedesOrEquals'])(a0, a1);
var _TupleDescGetAttInMetadata = Module['_TupleDescGetAttInMetadata'] = (a0) => (_TupleDescGetAttInMetadata = Module['_TupleDescGetAttInMetadata'] = wasmExports['TupleDescGetAttInMetadata'])(a0);
var _BuildTupleFromCStrings = Module['_BuildTupleFromCStrings'] = (a0, a1) => (_BuildTupleFromCStrings = Module['_BuildTupleFromCStrings'] = wasmExports['BuildTupleFromCStrings'])(a0, a1);
var _list_make1_impl = Module['_list_make1_impl'] = (a0, a1) => (_list_make1_impl = Module['_list_make1_impl'] = wasmExports['list_make1_impl'])(a0, a1);
var _fgets = Module['_fgets'] = (a0, a1, a2) => (_fgets = Module['_fgets'] = wasmExports['fgets'])(a0, a1, a2);
var _strncpy = Module['_strncpy'] = (a0, a1, a2) => (_strncpy = Module['_strncpy'] = wasmExports['strncpy'])(a0, a1, a2);
var _XLogRecGetBlockRefInfo = Module['_XLogRecGetBlockRefInfo'] = (a0, a1, a2, a3, a4) => (_XLogRecGetBlockRefInfo = Module['_XLogRecGetBlockRefInfo'] = wasmExports['XLogRecGetBlockRefInfo'])(a0, a1, a2, a3, a4);
var _RelationGetNumberOfBlocksInFork = Module['_RelationGetNumberOfBlocksInFork'] = (a0, a1) => (_RelationGetNumberOfBlocksInFork = Module['_RelationGetNumberOfBlocksInFork'] = wasmExports['RelationGetNumberOfBlocksInFork'])(a0, a1);
var _LockRelationForExtension = Module['_LockRelationForExtension'] = (a0, a1) => (_LockRelationForExtension = Module['_LockRelationForExtension'] = wasmExports['LockRelationForExtension'])(a0, a1);
var _UnlockRelationForExtension = Module['_UnlockRelationForExtension'] = (a0, a1) => (_UnlockRelationForExtension = Module['_UnlockRelationForExtension'] = wasmExports['UnlockRelationForExtension'])(a0, a1);
var _vacuum_delay_point = Module['_vacuum_delay_point'] = () => (_vacuum_delay_point = Module['_vacuum_delay_point'] = wasmExports['vacuum_delay_point'])();
var _PageIndexMultiDelete = Module['_PageIndexMultiDelete'] = (a0, a1, a2) => (_PageIndexMultiDelete = Module['_PageIndexMultiDelete'] = wasmExports['PageIndexMultiDelete'])(a0, a1, a2);
var _RecordFreeIndexPage = Module['_RecordFreeIndexPage'] = (a0, a1) => (_RecordFreeIndexPage = Module['_RecordFreeIndexPage'] = wasmExports['RecordFreeIndexPage'])(a0, a1);
var _ItemPointerEquals = Module['_ItemPointerEquals'] = (a0, a1) => (_ItemPointerEquals = Module['_ItemPointerEquals'] = wasmExports['ItemPointerEquals'])(a0, a1);
var _IndexFreeSpaceMapVacuum = Module['_IndexFreeSpaceMapVacuum'] = (a0) => (_IndexFreeSpaceMapVacuum = Module['_IndexFreeSpaceMapVacuum'] = wasmExports['IndexFreeSpaceMapVacuum'])(a0);
var _BufferGetBlockNumber = Module['_BufferGetBlockNumber'] = (a0) => (_BufferGetBlockNumber = Module['_BufferGetBlockNumber'] = wasmExports['BufferGetBlockNumber'])(a0);
var _PageAddItemExtended = Module['_PageAddItemExtended'] = (a0, a1, a2, a3, a4) => (_PageAddItemExtended = Module['_PageAddItemExtended'] = wasmExports['PageAddItemExtended'])(a0, a1, a2, a3, a4);
var _index_getprocinfo = Module['_index_getprocinfo'] = (a0, a1, a2) => (_index_getprocinfo = Module['_index_getprocinfo'] = wasmExports['index_getprocinfo'])(a0, a1, a2);
var _index_getprocid = Module['_index_getprocid'] = (a0, a1, a2) => (_index_getprocid = Module['_index_getprocid'] = wasmExports['index_getprocid'])(a0, a1, a2);
var _FunctionCall1Coll = Module['_FunctionCall1Coll'] = (a0, a1, a2) => (_FunctionCall1Coll = Module['_FunctionCall1Coll'] = wasmExports['FunctionCall1Coll'])(a0, a1, a2);
var _pg_detoast_datum = Module['_pg_detoast_datum'] = (a0) => (_pg_detoast_datum = Module['_pg_detoast_datum'] = wasmExports['pg_detoast_datum'])(a0);
var _ReadBuffer = Module['_ReadBuffer'] = (a0, a1) => (_ReadBuffer = Module['_ReadBuffer'] = wasmExports['ReadBuffer'])(a0, a1);
var _ConditionalLockBuffer = Module['_ConditionalLockBuffer'] = (a0) => (_ConditionalLockBuffer = Module['_ConditionalLockBuffer'] = wasmExports['ConditionalLockBuffer'])(a0);
var _PageGetExactFreeSpace = Module['_PageGetExactFreeSpace'] = (a0) => (_PageGetExactFreeSpace = Module['_PageGetExactFreeSpace'] = wasmExports['PageGetExactFreeSpace'])(a0);
var _FunctionCall2Coll = Module['_FunctionCall2Coll'] = (a0, a1, a2, a3) => (_FunctionCall2Coll = Module['_FunctionCall2Coll'] = wasmExports['FunctionCall2Coll'])(a0, a1, a2, a3);
var _pg_prng_uint64_range = Module['_pg_prng_uint64_range'] = (a0, a1, a2) => (_pg_prng_uint64_range = Module['_pg_prng_uint64_range'] = wasmExports['pg_prng_uint64_range'])(a0, a1, a2);
var _SearchSysCache1 = Module['_SearchSysCache1'] = (a0, a1) => (_SearchSysCache1 = Module['_SearchSysCache1'] = wasmExports['SearchSysCache1'])(a0, a1);
var _SearchSysCacheList = Module['_SearchSysCacheList'] = (a0, a1, a2, a3, a4) => (_SearchSysCacheList = Module['_SearchSysCacheList'] = wasmExports['SearchSysCacheList'])(a0, a1, a2, a3, a4);
var _identify_opfamily_groups = Module['_identify_opfamily_groups'] = (a0, a1) => (_identify_opfamily_groups = Module['_identify_opfamily_groups'] = wasmExports['identify_opfamily_groups'])(a0, a1);
var _format_procedure = Module['_format_procedure'] = (a0) => (_format_procedure = Module['_format_procedure'] = wasmExports['format_procedure'])(a0);
var _check_amproc_signature = Module['_check_amproc_signature'] = (a0, a1, a2, a3, a4, a5) => (_check_amproc_signature = Module['_check_amproc_signature'] = wasmExports['check_amproc_signature'])(a0, a1, a2, a3, a4, a5);
var _format_type_be = Module['_format_type_be'] = (a0) => (_format_type_be = Module['_format_type_be'] = wasmExports['format_type_be'])(a0);
var _check_amoptsproc_signature = Module['_check_amoptsproc_signature'] = (a0) => (_check_amoptsproc_signature = Module['_check_amoptsproc_signature'] = wasmExports['check_amoptsproc_signature'])(a0);
var _format_operator = Module['_format_operator'] = (a0) => (_format_operator = Module['_format_operator'] = wasmExports['format_operator'])(a0);
var _check_amop_signature = Module['_check_amop_signature'] = (a0, a1, a2, a3) => (_check_amop_signature = Module['_check_amop_signature'] = wasmExports['check_amop_signature'])(a0, a1, a2, a3);
var _ReleaseCatCacheList = Module['_ReleaseCatCacheList'] = (a0) => (_ReleaseCatCacheList = Module['_ReleaseCatCacheList'] = wasmExports['ReleaseCatCacheList'])(a0);
var _ReleaseSysCache = Module['_ReleaseSysCache'] = (a0) => (_ReleaseSysCache = Module['_ReleaseSysCache'] = wasmExports['ReleaseSysCache'])(a0);
var _RelationGetIndexScan = Module['_RelationGetIndexScan'] = (a0, a1, a2) => (_RelationGetIndexScan = Module['_RelationGetIndexScan'] = wasmExports['RelationGetIndexScan'])(a0, a1, a2);
var _fmgr_info_copy = Module['_fmgr_info_copy'] = (a0, a1, a2) => (_fmgr_info_copy = Module['_fmgr_info_copy'] = wasmExports['fmgr_info_copy'])(a0, a1, a2);
var _pairingheap_allocate = Module['_pairingheap_allocate'] = (a0, a1) => (_pairingheap_allocate = Module['_pairingheap_allocate'] = wasmExports['pairingheap_allocate'])(a0, a1);
var _pairingheap_add = Module['_pairingheap_add'] = (a0, a1) => (_pairingheap_add = Module['_pairingheap_add'] = wasmExports['pairingheap_add'])(a0, a1);
var _pgstat_assoc_relation = Module['_pgstat_assoc_relation'] = (a0) => (_pgstat_assoc_relation = Module['_pgstat_assoc_relation'] = wasmExports['pgstat_assoc_relation'])(a0);
var _pairingheap_remove_first = Module['_pairingheap_remove_first'] = (a0) => (_pairingheap_remove_first = Module['_pairingheap_remove_first'] = wasmExports['pairingheap_remove_first'])(a0);
var _TestForOldSnapshot_impl = Module['_TestForOldSnapshot_impl'] = (a0, a1) => (_TestForOldSnapshot_impl = Module['_TestForOldSnapshot_impl'] = wasmExports['TestForOldSnapshot_impl'])(a0, a1);
var _datumCopy = Module['_datumCopy'] = (a0, a1, a2) => (_datumCopy = Module['_datumCopy'] = wasmExports['datumCopy'])(a0, a1, a2);
var _tbm_add_tuples = Module['_tbm_add_tuples'] = (a0, a1, a2, a3) => (_tbm_add_tuples = Module['_tbm_add_tuples'] = wasmExports['tbm_add_tuples'])(a0, a1, a2, a3);
var _MemoryContextAllocZeroAligned = Module['_MemoryContextAllocZeroAligned'] = (a0, a1) => (_MemoryContextAllocZeroAligned = Module['_MemoryContextAllocZeroAligned'] = wasmExports['MemoryContextAllocZeroAligned'])(a0, a1);
var _build_reloptions = Module['_build_reloptions'] = (a0, a1, a2, a3, a4, a5) => (_build_reloptions = Module['_build_reloptions'] = wasmExports['build_reloptions'])(a0, a1, a2, a3, a4, a5);
var _exprType = Module['_exprType'] = (a0) => (_exprType = Module['_exprType'] = wasmExports['exprType'])(a0);
var _CreateTupleDescCopy = Module['_CreateTupleDescCopy'] = (a0) => (_CreateTupleDescCopy = Module['_CreateTupleDescCopy'] = wasmExports['CreateTupleDescCopy'])(a0);
var _GetFreeIndexPage = Module['_GetFreeIndexPage'] = (a0) => (_GetFreeIndexPage = Module['_GetFreeIndexPage'] = wasmExports['GetFreeIndexPage'])(a0);
var _ExtendBufferedRel = Module['_ExtendBufferedRel'] = (a0, a1, a2, a3) => (_ExtendBufferedRel = Module['_ExtendBufferedRel'] = wasmExports['ExtendBufferedRel'])(a0, a1, a2, a3);
var _PageInit = Module['_PageInit'] = (a0, a1, a2) => (_PageInit = Module['_PageInit'] = wasmExports['PageInit'])(a0, a1, a2);
var _varstr_cmp = Module['_varstr_cmp'] = (a0, a1, a2, a3, a4) => (_varstr_cmp = Module['_varstr_cmp'] = wasmExports['varstr_cmp'])(a0, a1, a2, a3, a4);
var _Float8GetDatum = Module['_Float8GetDatum'] = (a0) => (_Float8GetDatum = Module['_Float8GetDatum'] = wasmExports['Float8GetDatum'])(a0);
var _estimate_expression_value = Module['_estimate_expression_value'] = (a0, a1) => (_estimate_expression_value = Module['_estimate_expression_value'] = wasmExports['estimate_expression_value'])(a0, a1);
var _clamp_row_est = Module['_clamp_row_est'] = (a0) => (_clamp_row_est = Module['_clamp_row_est'] = wasmExports['clamp_row_est'])(a0);
var _hash_bytes = Module['_hash_bytes'] = (a0, a1) => (_hash_bytes = Module['_hash_bytes'] = wasmExports['hash_bytes'])(a0, a1);
var _FunctionCall4Coll = Module['_FunctionCall4Coll'] = (a0, a1, a2, a3, a4, a5) => (_FunctionCall4Coll = Module['_FunctionCall4Coll'] = wasmExports['FunctionCall4Coll'])(a0, a1, a2, a3, a4, a5);
var _qsort_arg = Module['_qsort_arg'] = (a0, a1, a2, a3, a4) => (_qsort_arg = Module['_qsort_arg'] = wasmExports['qsort_arg'])(a0, a1, a2, a3, a4);
var _ginPostingListDecode = Module['_ginPostingListDecode'] = (a0, a1) => (_ginPostingListDecode = Module['_ginPostingListDecode'] = wasmExports['ginPostingListDecode'])(a0, a1);
var _LockPage = Module['_LockPage'] = (a0, a1, a2) => (_LockPage = Module['_LockPage'] = wasmExports['LockPage'])(a0, a1, a2);
var _UnlockPage = Module['_UnlockPage'] = (a0, a1, a2) => (_UnlockPage = Module['_UnlockPage'] = wasmExports['UnlockPage'])(a0, a1, a2);
var _index_open = Module['_index_open'] = (a0, a1) => (_index_open = Module['_index_open'] = wasmExports['index_open'])(a0, a1);
var _object_ownercheck = Module['_object_ownercheck'] = (a0, a1, a2) => (_object_ownercheck = Module['_object_ownercheck'] = wasmExports['object_ownercheck'])(a0, a1, a2);
var _aclcheck_error = Module['_aclcheck_error'] = (a0, a1, a2) => (_aclcheck_error = Module['_aclcheck_error'] = wasmExports['aclcheck_error'])(a0, a1, a2);
var _index_close = Module['_index_close'] = (a0, a1) => (_index_close = Module['_index_close'] = wasmExports['index_close'])(a0, a1);
var _ItemPointerCompare = Module['_ItemPointerCompare'] = (a0, a1) => (_ItemPointerCompare = Module['_ItemPointerCompare'] = wasmExports['ItemPointerCompare'])(a0, a1);
var _index_form_tuple = Module['_index_form_tuple'] = (a0, a1, a2) => (_index_form_tuple = Module['_index_form_tuple'] = wasmExports['index_form_tuple'])(a0, a1, a2);
var _PageGetFreeSpace = Module['_PageGetFreeSpace'] = (a0) => (_PageGetFreeSpace = Module['_PageGetFreeSpace'] = wasmExports['PageGetFreeSpace'])(a0);
var _TupleDescInitEntryCollation = Module['_TupleDescInitEntryCollation'] = (a0, a1, a2) => (_TupleDescInitEntryCollation = Module['_TupleDescInitEntryCollation'] = wasmExports['TupleDescInitEntryCollation'])(a0, a1, a2);
var _lookup_type_cache = Module['_lookup_type_cache'] = (a0, a1) => (_lookup_type_cache = Module['_lookup_type_cache'] = wasmExports['lookup_type_cache'])(a0, a1);
var _nocache_index_getattr = Module['_nocache_index_getattr'] = (a0, a1, a2) => (_nocache_index_getattr = Module['_nocache_index_getattr'] = wasmExports['nocache_index_getattr'])(a0, a1, a2);
var _pg_detoast_datum_copy = Module['_pg_detoast_datum_copy'] = (a0) => (_pg_detoast_datum_copy = Module['_pg_detoast_datum_copy'] = wasmExports['pg_detoast_datum_copy'])(a0);
var _get_typlenbyvalalign = Module['_get_typlenbyvalalign'] = (a0, a1, a2, a3) => (_get_typlenbyvalalign = Module['_get_typlenbyvalalign'] = wasmExports['get_typlenbyvalalign'])(a0, a1, a2, a3);
var _deconstruct_array = Module['_deconstruct_array'] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_deconstruct_array = Module['_deconstruct_array'] = wasmExports['deconstruct_array'])(a0, a1, a2, a3, a4, a5, a6, a7);
var _tuplesort_performsort = Module['_tuplesort_performsort'] = (a0) => (_tuplesort_performsort = Module['_tuplesort_performsort'] = wasmExports['tuplesort_performsort'])(a0);
var _smgrsetowner = Module['_smgrsetowner'] = (a0, a1) => (_smgrsetowner = Module['_smgrsetowner'] = wasmExports['smgrsetowner'])(a0, a1);
var _tuplesort_end = Module['_tuplesort_end'] = (a0) => (_tuplesort_end = Module['_tuplesort_end'] = wasmExports['tuplesort_end'])(a0);
var _pow = Module['_pow'] = (a0, a1) => (_pow = Module['_pow'] = wasmExports['pow'])(a0, a1);
var _gistcheckpage = Module['_gistcheckpage'] = (a0, a1) => (_gistcheckpage = Module['_gistcheckpage'] = wasmExports['gistcheckpage'])(a0, a1);
var _GenerationContextCreate = Module['_GenerationContextCreate'] = (a0, a1, a2, a3, a4) => (_GenerationContextCreate = Module['_GenerationContextCreate'] = wasmExports['GenerationContextCreate'])(a0, a1, a2, a3, a4);
var _float_overflow_error = Module['_float_overflow_error'] = () => (_float_overflow_error = Module['_float_overflow_error'] = wasmExports['float_overflow_error'])();
var _float_underflow_error = Module['_float_underflow_error'] = () => (_float_underflow_error = Module['_float_underflow_error'] = wasmExports['float_underflow_error'])();
var _DirectFunctionCall5Coll = Module['_DirectFunctionCall5Coll'] = (a0, a1, a2, a3, a4, a5, a6) => (_DirectFunctionCall5Coll = Module['_DirectFunctionCall5Coll'] = wasmExports['DirectFunctionCall5Coll'])(a0, a1, a2, a3, a4, a5, a6);
var _CreateTupleDescCopyConstr = Module['_CreateTupleDescCopyConstr'] = (a0) => (_CreateTupleDescCopyConstr = Module['_CreateTupleDescCopyConstr'] = wasmExports['CreateTupleDescCopyConstr'])(a0);
var _PageIndexTupleOverwrite = Module['_PageIndexTupleOverwrite'] = (a0, a1, a2, a3) => (_PageIndexTupleOverwrite = Module['_PageIndexTupleOverwrite'] = wasmExports['PageIndexTupleOverwrite'])(a0, a1, a2, a3);
var _check_stack_depth = Module['_check_stack_depth'] = () => (_check_stack_depth = Module['_check_stack_depth'] = wasmExports['check_stack_depth'])();
var _relation_open = Module['_relation_open'] = (a0, a1) => (_relation_open = Module['_relation_open'] = wasmExports['relation_open'])(a0, a1);
var _try_relation_open = Module['_try_relation_open'] = (a0, a1) => (_try_relation_open = Module['_try_relation_open'] = wasmExports['try_relation_open'])(a0, a1);
var _RelationClose = Module['_RelationClose'] = (a0) => (_RelationClose = Module['_RelationClose'] = wasmExports['RelationClose'])(a0);
var _UnregisterSnapshot = Module['_UnregisterSnapshot'] = (a0) => (_UnregisterSnapshot = Module['_UnregisterSnapshot'] = wasmExports['UnregisterSnapshot'])(a0);
var _RegisterSnapshot = Module['_RegisterSnapshot'] = (a0) => (_RegisterSnapshot = Module['_RegisterSnapshot'] = wasmExports['RegisterSnapshot'])(a0);
var _fmgr_info_cxt = Module['_fmgr_info_cxt'] = (a0, a1, a2) => (_fmgr_info_cxt = Module['_fmgr_info_cxt'] = wasmExports['fmgr_info_cxt'])(a0, a1, a2);
var _SysCacheGetAttrNotNull = Module['_SysCacheGetAttrNotNull'] = (a0, a1, a2) => (_SysCacheGetAttrNotNull = Module['_SysCacheGetAttrNotNull'] = wasmExports['SysCacheGetAttrNotNull'])(a0, a1, a2);
var _init_local_reloptions = Module['_init_local_reloptions'] = (a0, a1) => (_init_local_reloptions = Module['_init_local_reloptions'] = wasmExports['init_local_reloptions'])(a0, a1);
var _pg_class_aclcheck = Module['_pg_class_aclcheck'] = (a0, a1, a2) => (_pg_class_aclcheck = Module['_pg_class_aclcheck'] = wasmExports['pg_class_aclcheck'])(a0, a1, a2);
var _getTypeOutputInfo = Module['_getTypeOutputInfo'] = (a0, a1, a2) => (_getTypeOutputInfo = Module['_getTypeOutputInfo'] = wasmExports['getTypeOutputInfo'])(a0, a1, a2);
var _OidOutputFunctionCall = Module['_OidOutputFunctionCall'] = (a0, a1) => (_OidOutputFunctionCall = Module['_OidOutputFunctionCall'] = wasmExports['OidOutputFunctionCall'])(a0, a1);
var _systable_beginscan = Module['_systable_beginscan'] = (a0, a1, a2, a3, a4, a5) => (_systable_beginscan = Module['_systable_beginscan'] = wasmExports['systable_beginscan'])(a0, a1, a2, a3, a4, a5);
var _systable_getnext = Module['_systable_getnext'] = (a0) => (_systable_getnext = Module['_systable_getnext'] = wasmExports['systable_getnext'])(a0);
var _ExecFetchSlotHeapTuple = Module['_ExecFetchSlotHeapTuple'] = (a0, a1, a2) => (_ExecFetchSlotHeapTuple = Module['_ExecFetchSlotHeapTuple'] = wasmExports['ExecFetchSlotHeapTuple'])(a0, a1, a2);
var _systable_endscan = Module['_systable_endscan'] = (a0) => (_systable_endscan = Module['_systable_endscan'] = wasmExports['systable_endscan'])(a0);
var _ExecDropSingleTupleTableSlot = Module['_ExecDropSingleTupleTableSlot'] = (a0) => (_ExecDropSingleTupleTableSlot = Module['_ExecDropSingleTupleTableSlot'] = wasmExports['ExecDropSingleTupleTableSlot'])(a0);
var _systable_beginscan_ordered = Module['_systable_beginscan_ordered'] = (a0, a1, a2, a3, a4) => (_systable_beginscan_ordered = Module['_systable_beginscan_ordered'] = wasmExports['systable_beginscan_ordered'])(a0, a1, a2, a3, a4);
var _systable_getnext_ordered = Module['_systable_getnext_ordered'] = (a0, a1) => (_systable_getnext_ordered = Module['_systable_getnext_ordered'] = wasmExports['systable_getnext_ordered'])(a0, a1);
var _systable_endscan_ordered = Module['_systable_endscan_ordered'] = (a0) => (_systable_endscan_ordered = Module['_systable_endscan_ordered'] = wasmExports['systable_endscan_ordered'])(a0);
var _getmissingattr = Module['_getmissingattr'] = (a0, a1, a2) => (_getmissingattr = Module['_getmissingattr'] = wasmExports['getmissingattr'])(a0, a1, a2);
var _DatumGetEOHP = Module['_DatumGetEOHP'] = (a0) => (_DatumGetEOHP = Module['_DatumGetEOHP'] = wasmExports['DatumGetEOHP'])(a0);
var _EOH_get_flat_size = Module['_EOH_get_flat_size'] = (a0) => (_EOH_get_flat_size = Module['_EOH_get_flat_size'] = wasmExports['EOH_get_flat_size'])(a0);
var _EOH_flatten_into = Module['_EOH_flatten_into'] = (a0, a1, a2) => (_EOH_flatten_into = Module['_EOH_flatten_into'] = wasmExports['EOH_flatten_into'])(a0, a1, a2);
var _nocachegetattr = Module['_nocachegetattr'] = (a0, a1, a2) => (_nocachegetattr = Module['_nocachegetattr'] = wasmExports['nocachegetattr'])(a0, a1, a2);
var _heap_deform_tuple = Module['_heap_deform_tuple'] = (a0, a1, a2, a3) => (_heap_deform_tuple = Module['_heap_deform_tuple'] = wasmExports['heap_deform_tuple'])(a0, a1, a2, a3);
var _heap_modify_tuple_by_cols = Module['_heap_modify_tuple_by_cols'] = (a0, a1, a2, a3, a4, a5) => (_heap_modify_tuple_by_cols = Module['_heap_modify_tuple_by_cols'] = wasmExports['heap_modify_tuple_by_cols'])(a0, a1, a2, a3, a4, a5);
var _heap_freetuple = Module['_heap_freetuple'] = (a0) => (_heap_freetuple = Module['_heap_freetuple'] = wasmExports['heap_freetuple'])(a0);
var _RelationIdGetRelation = Module['_RelationIdGetRelation'] = (a0) => (_RelationIdGetRelation = Module['_RelationIdGetRelation'] = wasmExports['RelationIdGetRelation'])(a0);
var _relation_openrv = Module['_relation_openrv'] = (a0, a1) => (_relation_openrv = Module['_relation_openrv'] = wasmExports['relation_openrv'])(a0, a1);
var _RangeVarGetRelidExtended = Module['_RangeVarGetRelidExtended'] = (a0, a1, a2, a3, a4) => (_RangeVarGetRelidExtended = Module['_RangeVarGetRelidExtended'] = wasmExports['RangeVarGetRelidExtended'])(a0, a1, a2, a3, a4);
var _relation_close = Module['_relation_close'] = (a0, a1) => (_relation_close = Module['_relation_close'] = wasmExports['relation_close'])(a0, a1);
var _add_reloption_kind = Module['_add_reloption_kind'] = () => (_add_reloption_kind = Module['_add_reloption_kind'] = wasmExports['add_reloption_kind'])();
var _register_reloptions_validator = Module['_register_reloptions_validator'] = (a0, a1) => (_register_reloptions_validator = Module['_register_reloptions_validator'] = wasmExports['register_reloptions_validator'])(a0, a1);
var _add_int_reloption = Module['_add_int_reloption'] = (a0, a1, a2, a3, a4, a5, a6) => (_add_int_reloption = Module['_add_int_reloption'] = wasmExports['add_int_reloption'])(a0, a1, a2, a3, a4, a5, a6);
var _add_local_int_reloption = Module['_add_local_int_reloption'] = (a0, a1, a2, a3, a4, a5, a6) => (_add_local_int_reloption = Module['_add_local_int_reloption'] = wasmExports['add_local_int_reloption'])(a0, a1, a2, a3, a4, a5, a6);
var _deconstruct_array_builtin = Module['_deconstruct_array_builtin'] = (a0, a1, a2, a3, a4) => (_deconstruct_array_builtin = Module['_deconstruct_array_builtin'] = wasmExports['deconstruct_array_builtin'])(a0, a1, a2, a3, a4);
var _accumArrayResult = Module['_accumArrayResult'] = (a0, a1, a2, a3, a4) => (_accumArrayResult = Module['_accumArrayResult'] = wasmExports['accumArrayResult'])(a0, a1, a2, a3, a4);
var _defGetString = Module['_defGetString'] = (a0) => (_defGetString = Module['_defGetString'] = wasmExports['defGetString'])(a0);
var _defGetBoolean = Module['_defGetBoolean'] = (a0) => (_defGetBoolean = Module['_defGetBoolean'] = wasmExports['defGetBoolean'])(a0);
var _makeArrayResult = Module['_makeArrayResult'] = (a0, a1) => (_makeArrayResult = Module['_makeArrayResult'] = wasmExports['makeArrayResult'])(a0, a1);
var _untransformRelOptions = Module['_untransformRelOptions'] = (a0) => (_untransformRelOptions = Module['_untransformRelOptions'] = wasmExports['untransformRelOptions'])(a0);
var _makeString = Module['_makeString'] = (a0) => (_makeString = Module['_makeString'] = wasmExports['makeString'])(a0);
var _makeDefElem = Module['_makeDefElem'] = (a0, a1, a2) => (_makeDefElem = Module['_makeDefElem'] = wasmExports['makeDefElem'])(a0, a1, a2);
var _parse_bool = Module['_parse_bool'] = (a0, a1) => (_parse_bool = Module['_parse_bool'] = wasmExports['parse_bool'])(a0, a1);
var _parse_int = Module['_parse_int'] = (a0, a1, a2, a3) => (_parse_int = Module['_parse_int'] = wasmExports['parse_int'])(a0, a1, a2, a3);
var _parse_real = Module['_parse_real'] = (a0, a1, a2, a3) => (_parse_real = Module['_parse_real'] = wasmExports['parse_real'])(a0, a1, a2, a3);
var _detoast_external_attr = Module['_detoast_external_attr'] = (a0) => (_detoast_external_attr = Module['_detoast_external_attr'] = wasmExports['detoast_external_attr'])(a0);
var _index_deform_tuple = Module['_index_deform_tuple'] = (a0, a1, a2, a3) => (_index_deform_tuple = Module['_index_deform_tuple'] = wasmExports['index_deform_tuple'])(a0, a1, a2, a3);
var _fmgr_info = Module['_fmgr_info'] = (a0, a1) => (_fmgr_info = Module['_fmgr_info'] = wasmExports['fmgr_info'])(a0, a1);
var _ScanKeyInit = Module['_ScanKeyInit'] = (a0, a1, a2, a3, a4) => (_ScanKeyInit = Module['_ScanKeyInit'] = wasmExports['ScanKeyInit'])(a0, a1, a2, a3, a4);
var _DecrTupleDescRefCount = Module['_DecrTupleDescRefCount'] = (a0) => (_DecrTupleDescRefCount = Module['_DecrTupleDescRefCount'] = wasmExports['DecrTupleDescRefCount'])(a0);
var _datumIsEqual = Module['_datumIsEqual'] = (a0, a1, a2, a3) => (_datumIsEqual = Module['_datumIsEqual'] = wasmExports['datumIsEqual'])(a0, a1, a2, a3);
var _typenameTypeIdAndMod = Module['_typenameTypeIdAndMod'] = (a0, a1, a2, a3) => (_typenameTypeIdAndMod = Module['_typenameTypeIdAndMod'] = wasmExports['typenameTypeIdAndMod'])(a0, a1, a2, a3);
var _object_aclcheck = Module['_object_aclcheck'] = (a0, a1, a2, a3) => (_object_aclcheck = Module['_object_aclcheck'] = wasmExports['object_aclcheck'])(a0, a1, a2, a3);
var _table_open = Module['_table_open'] = (a0, a1) => (_table_open = Module['_table_open'] = wasmExports['table_open'])(a0, a1);
var _table_close = Module['_table_close'] = (a0, a1) => (_table_close = Module['_table_close'] = wasmExports['table_close'])(a0, a1);
var _convert_tuples_by_position = Module['_convert_tuples_by_position'] = (a0, a1, a2) => (_convert_tuples_by_position = Module['_convert_tuples_by_position'] = wasmExports['convert_tuples_by_position'])(a0, a1, a2);
var _build_attrmap_by_name_if_req = Module['_build_attrmap_by_name_if_req'] = (a0, a1, a2) => (_build_attrmap_by_name_if_req = Module['_build_attrmap_by_name_if_req'] = wasmExports['build_attrmap_by_name_if_req'])(a0, a1, a2);
var _execute_attr_map_tuple = Module['_execute_attr_map_tuple'] = (a0, a1) => (_execute_attr_map_tuple = Module['_execute_attr_map_tuple'] = wasmExports['execute_attr_map_tuple'])(a0, a1);
var _execute_attr_map_slot = Module['_execute_attr_map_slot'] = (a0, a1, a2) => (_execute_attr_map_slot = Module['_execute_attr_map_slot'] = wasmExports['execute_attr_map_slot'])(a0, a1, a2);
var _slot_getsomeattrs_int = Module['_slot_getsomeattrs_int'] = (a0, a1) => (_slot_getsomeattrs_int = Module['_slot_getsomeattrs_int'] = wasmExports['slot_getsomeattrs_int'])(a0, a1);
var _ExecStoreVirtualTuple = Module['_ExecStoreVirtualTuple'] = (a0) => (_ExecStoreVirtualTuple = Module['_ExecStoreVirtualTuple'] = wasmExports['ExecStoreVirtualTuple'])(a0);
var _bms_is_member = Module['_bms_is_member'] = (a0, a1) => (_bms_is_member = Module['_bms_is_member'] = wasmExports['bms_is_member'])(a0, a1);
var _bms_add_member = Module['_bms_add_member'] = (a0, a1) => (_bms_add_member = Module['_bms_add_member'] = wasmExports['bms_add_member'])(a0, a1);
var _free_attrmap = Module['_free_attrmap'] = (a0) => (_free_attrmap = Module['_free_attrmap'] = wasmExports['free_attrmap'])(a0);
var _toast_open_indexes = Module['_toast_open_indexes'] = (a0, a1, a2, a3) => (_toast_open_indexes = Module['_toast_open_indexes'] = wasmExports['toast_open_indexes'])(a0, a1, a2, a3);
var _RelationGetIndexList = Module['_RelationGetIndexList'] = (a0) => (_RelationGetIndexList = Module['_RelationGetIndexList'] = wasmExports['RelationGetIndexList'])(a0);
var _toast_close_indexes = Module['_toast_close_indexes'] = (a0, a1, a2) => (_toast_close_indexes = Module['_toast_close_indexes'] = wasmExports['toast_close_indexes'])(a0, a1, a2);
var _init_toast_snapshot = Module['_init_toast_snapshot'] = (a0) => (_init_toast_snapshot = Module['_init_toast_snapshot'] = wasmExports['init_toast_snapshot'])(a0);
var _OutputFunctionCall = Module['_OutputFunctionCall'] = (a0, a1) => (_OutputFunctionCall = Module['_OutputFunctionCall'] = wasmExports['OutputFunctionCall'])(a0, a1);
var _pg_printf = Module['_pg_printf'] = (a0, a1) => (_pg_printf = Module['_pg_printf'] = wasmExports['pg_printf'])(a0, a1);
var _pg_ltoa = Module['_pg_ltoa'] = (a0, a1) => (_pg_ltoa = Module['_pg_ltoa'] = wasmExports['pg_ltoa'])(a0, a1);
var _format_type_with_typemod = Module['_format_type_with_typemod'] = (a0, a1) => (_format_type_with_typemod = Module['_format_type_with_typemod'] = wasmExports['format_type_with_typemod'])(a0, a1);
var __bt_search = Module['__bt_search'] = (a0, a1, a2, a3, a4, a5) => (__bt_search = Module['__bt_search'] = wasmExports['_bt_search'])(a0, a1, a2, a3, a4, a5);
var __bt_compare = Module['__bt_compare'] = (a0, a1, a2, a3) => (__bt_compare = Module['__bt_compare'] = wasmExports['_bt_compare'])(a0, a1, a2, a3);
var __bt_relbuf = Module['__bt_relbuf'] = (a0, a1) => (__bt_relbuf = Module['__bt_relbuf'] = wasmExports['_bt_relbuf'])(a0, a1);
var __bt_binsrch_insert = Module['__bt_binsrch_insert'] = (a0, a1) => (__bt_binsrch_insert = Module['__bt_binsrch_insert'] = wasmExports['_bt_binsrch_insert'])(a0, a1);
var __bt_metaversion = Module['__bt_metaversion'] = (a0, a1, a2) => (__bt_metaversion = Module['__bt_metaversion'] = wasmExports['_bt_metaversion'])(a0, a1, a2);
var __bt_freestack = Module['__bt_freestack'] = (a0) => (__bt_freestack = Module['__bt_freestack'] = wasmExports['_bt_freestack'])(a0);
var __bt_allequalimage = Module['__bt_allequalimage'] = (a0, a1) => (__bt_allequalimage = Module['__bt_allequalimage'] = wasmExports['_bt_allequalimage'])(a0, a1);
var _ConditionVariableSleep = Module['_ConditionVariableSleep'] = (a0, a1) => (_ConditionVariableSleep = Module['_ConditionVariableSleep'] = wasmExports['ConditionVariableSleep'])(a0, a1);
var _ConditionVariableSignal = Module['_ConditionVariableSignal'] = (a0) => (_ConditionVariableSignal = Module['_ConditionVariableSignal'] = wasmExports['ConditionVariableSignal'])(a0);
var _pgstat_progress_update_param = Module['_pgstat_progress_update_param'] = (a0, a1) => (_pgstat_progress_update_param = Module['_pgstat_progress_update_param'] = wasmExports['pgstat_progress_update_param'])(a0, a1);
var __bt_checkpage = Module['__bt_checkpage'] = (a0, a1) => (__bt_checkpage = Module['__bt_checkpage'] = wasmExports['_bt_checkpage'])(a0, a1);
var __bt_mkscankey = Module['__bt_mkscankey'] = (a0, a1) => (__bt_mkscankey = Module['__bt_mkscankey'] = wasmExports['_bt_mkscankey'])(a0, a1);
var _pg_prng_uint32 = Module['_pg_prng_uint32'] = (a0) => (_pg_prng_uint32 = Module['_pg_prng_uint32'] = wasmExports['pg_prng_uint32'])(a0);
var _bsearch = Module['_bsearch'] = (a0, a1, a2, a3, a4) => (_bsearch = Module['_bsearch'] = wasmExports['bsearch'])(a0, a1, a2, a3, a4);
var _table_parallelscan_estimate = Module['_table_parallelscan_estimate'] = (a0, a1) => (_table_parallelscan_estimate = Module['_table_parallelscan_estimate'] = wasmExports['table_parallelscan_estimate'])(a0, a1);
var _tuplesort_estimate_shared = Module['_tuplesort_estimate_shared'] = (a0) => (_tuplesort_estimate_shared = Module['_tuplesort_estimate_shared'] = wasmExports['tuplesort_estimate_shared'])(a0);
var _table_parallelscan_initialize = Module['_table_parallelscan_initialize'] = (a0, a1, a2) => (_table_parallelscan_initialize = Module['_table_parallelscan_initialize'] = wasmExports['table_parallelscan_initialize'])(a0, a1, a2);
var _tuplesort_initialize_shared = Module['_tuplesort_initialize_shared'] = (a0, a1, a2) => (_tuplesort_initialize_shared = Module['_tuplesort_initialize_shared'] = wasmExports['tuplesort_initialize_shared'])(a0, a1, a2);
var _pgstat_report_activity = Module['_pgstat_report_activity'] = (a0, a1) => (_pgstat_report_activity = Module['_pgstat_report_activity'] = wasmExports['pgstat_report_activity'])(a0, a1);
var _tuplesort_attach_shared = Module['_tuplesort_attach_shared'] = (a0, a1) => (_tuplesort_attach_shared = Module['_tuplesort_attach_shared'] = wasmExports['tuplesort_attach_shared'])(a0, a1);
var _BuildIndexInfo = Module['_BuildIndexInfo'] = (a0) => (_BuildIndexInfo = Module['_BuildIndexInfo'] = wasmExports['BuildIndexInfo'])(a0);
var _table_beginscan_parallel = Module['_table_beginscan_parallel'] = (a0, a1) => (_table_beginscan_parallel = Module['_table_beginscan_parallel'] = wasmExports['table_beginscan_parallel'])(a0, a1);
var __bt_form_posting = Module['__bt_form_posting'] = (a0, a1, a2) => (__bt_form_posting = Module['__bt_form_posting'] = wasmExports['_bt_form_posting'])(a0, a1, a2);
var _GetOldestNonRemovableTransactionId = Module['_GetOldestNonRemovableTransactionId'] = (a0) => (_GetOldestNonRemovableTransactionId = Module['_GetOldestNonRemovableTransactionId'] = wasmExports['GetOldestNonRemovableTransactionId'])(a0);
var _btboolcmp = Module['_btboolcmp'] = (a0) => (_btboolcmp = Module['_btboolcmp'] = wasmExports['btboolcmp'])(a0);
var _btint2cmp = Module['_btint2cmp'] = (a0) => (_btint2cmp = Module['_btint2cmp'] = wasmExports['btint2cmp'])(a0);
var _btint4cmp = Module['_btint4cmp'] = (a0) => (_btint4cmp = Module['_btint4cmp'] = wasmExports['btint4cmp'])(a0);
var _btint8cmp = Module['_btint8cmp'] = (a0) => (_btint8cmp = Module['_btint8cmp'] = wasmExports['btint8cmp'])(a0);
var _btoidcmp = Module['_btoidcmp'] = (a0) => (_btoidcmp = Module['_btoidcmp'] = wasmExports['btoidcmp'])(a0);
var _btcharcmp = Module['_btcharcmp'] = (a0) => (_btcharcmp = Module['_btcharcmp'] = wasmExports['btcharcmp'])(a0);
var _get_opfamily_member = Module['_get_opfamily_member'] = (a0, a1, a2, a3) => (_get_opfamily_member = Module['_get_opfamily_member'] = wasmExports['get_opfamily_member'])(a0, a1, a2, a3);
var __bt_check_natts = Module['__bt_check_natts'] = (a0, a1, a2, a3) => (__bt_check_natts = Module['__bt_check_natts'] = wasmExports['_bt_check_natts'])(a0, a1, a2, a3);
var _PageGetHeapFreeSpace = Module['_PageGetHeapFreeSpace'] = (a0) => (_PageGetHeapFreeSpace = Module['_PageGetHeapFreeSpace'] = wasmExports['PageGetHeapFreeSpace'])(a0);
var _HeapTupleGetUpdateXid = Module['_HeapTupleGetUpdateXid'] = (a0) => (_HeapTupleGetUpdateXid = Module['_HeapTupleGetUpdateXid'] = wasmExports['HeapTupleGetUpdateXid'])(a0);
var _ftruncate = Module['_ftruncate'] = (a0, a1) => (_ftruncate = Module['_ftruncate'] = wasmExports['ftruncate'])(a0, a1);
var _HeapTupleSatisfiesVisibility = Module['_HeapTupleSatisfiesVisibility'] = (a0, a1, a2) => (_HeapTupleSatisfiesVisibility = Module['_HeapTupleSatisfiesVisibility'] = wasmExports['HeapTupleSatisfiesVisibility'])(a0, a1, a2);
var _HeapTupleSatisfiesVacuum = Module['_HeapTupleSatisfiesVacuum'] = (a0, a1, a2) => (_HeapTupleSatisfiesVacuum = Module['_HeapTupleSatisfiesVacuum'] = wasmExports['HeapTupleSatisfiesVacuum'])(a0, a1, a2);
var _CreateExecutorState = Module['_CreateExecutorState'] = () => (_CreateExecutorState = Module['_CreateExecutorState'] = wasmExports['CreateExecutorState'])();
var _MakePerTupleExprContext = Module['_MakePerTupleExprContext'] = (a0) => (_MakePerTupleExprContext = Module['_MakePerTupleExprContext'] = wasmExports['MakePerTupleExprContext'])(a0);
var _heap_getnext = Module['_heap_getnext'] = (a0, a1) => (_heap_getnext = Module['_heap_getnext'] = wasmExports['heap_getnext'])(a0, a1);
var _FreeExecutorState = Module['_FreeExecutorState'] = (a0) => (_FreeExecutorState = Module['_FreeExecutorState'] = wasmExports['FreeExecutorState'])(a0);
var _MakeSingleTupleTableSlot = Module['_MakeSingleTupleTableSlot'] = (a0, a1) => (_MakeSingleTupleTableSlot = Module['_MakeSingleTupleTableSlot'] = wasmExports['MakeSingleTupleTableSlot'])(a0, a1);
var _ExecStoreHeapTuple = Module['_ExecStoreHeapTuple'] = (a0, a1, a2) => (_ExecStoreHeapTuple = Module['_ExecStoreHeapTuple'] = wasmExports['ExecStoreHeapTuple'])(a0, a1, a2);
var _get_namespace_name = Module['_get_namespace_name'] = (a0) => (_get_namespace_name = Module['_get_namespace_name'] = wasmExports['get_namespace_name'])(a0);
var _visibilitymap_get_status = Module['_visibilitymap_get_status'] = (a0, a1, a2) => (_visibilitymap_get_status = Module['_visibilitymap_get_status'] = wasmExports['visibilitymap_get_status'])(a0, a1, a2);
var _visibilitymap_pin = Module['_visibilitymap_pin'] = (a0, a1, a2) => (_visibilitymap_pin = Module['_visibilitymap_pin'] = wasmExports['visibilitymap_pin'])(a0, a1, a2);
var _visibilitymap_clear = Module['_visibilitymap_clear'] = (a0, a1, a2, a3) => (_visibilitymap_clear = Module['_visibilitymap_clear'] = wasmExports['visibilitymap_clear'])(a0, a1, a2, a3);
var _vac_estimate_reltuples = Module['_vac_estimate_reltuples'] = (a0, a1, a2, a3) => (_vac_estimate_reltuples = Module['_vac_estimate_reltuples'] = wasmExports['vac_estimate_reltuples'])(a0, a1, a2, a3);
var _PrefetchBuffer = Module['_PrefetchBuffer'] = (a0, a1, a2, a3) => (_PrefetchBuffer = Module['_PrefetchBuffer'] = wasmExports['PrefetchBuffer'])(a0, a1, a2, a3);
var _WalUsageAccumDiff = Module['_WalUsageAccumDiff'] = (a0, a1, a2) => (_WalUsageAccumDiff = Module['_WalUsageAccumDiff'] = wasmExports['WalUsageAccumDiff'])(a0, a1, a2);
var _BufferUsageAccumDiff = Module['_BufferUsageAccumDiff'] = (a0, a1, a2) => (_BufferUsageAccumDiff = Module['_BufferUsageAccumDiff'] = wasmExports['BufferUsageAccumDiff'])(a0, a1, a2);
var _GetRecordedFreeSpace = Module['_GetRecordedFreeSpace'] = (a0, a1) => (_GetRecordedFreeSpace = Module['_GetRecordedFreeSpace'] = wasmExports['GetRecordedFreeSpace'])(a0, a1);
var _heap_tuple_needs_eventual_freeze = Module['_heap_tuple_needs_eventual_freeze'] = (a0) => (_heap_tuple_needs_eventual_freeze = Module['_heap_tuple_needs_eventual_freeze'] = wasmExports['heap_tuple_needs_eventual_freeze'])(a0);
var _GetAccessStrategy = Module['_GetAccessStrategy'] = (a0) => (_GetAccessStrategy = Module['_GetAccessStrategy'] = wasmExports['GetAccessStrategy'])(a0);
var _FreeAccessStrategy = Module['_FreeAccessStrategy'] = (a0) => (_FreeAccessStrategy = Module['_FreeAccessStrategy'] = wasmExports['FreeAccessStrategy'])(a0);
var _HeapTupleSatisfiesUpdate = Module['_HeapTupleSatisfiesUpdate'] = (a0, a1, a2) => (_HeapTupleSatisfiesUpdate = Module['_HeapTupleSatisfiesUpdate'] = wasmExports['HeapTupleSatisfiesUpdate'])(a0, a1, a2);
var _bms_free = Module['_bms_free'] = (a0) => (_bms_free = Module['_bms_free'] = wasmExports['bms_free'])(a0);
var _bms_add_members = Module['_bms_add_members'] = (a0, a1) => (_bms_add_members = Module['_bms_add_members'] = wasmExports['bms_add_members'])(a0, a1);
var _bms_next_member = Module['_bms_next_member'] = (a0, a1) => (_bms_next_member = Module['_bms_next_member'] = wasmExports['bms_next_member'])(a0, a1);
var _bms_overlap = Module['_bms_overlap'] = (a0, a1) => (_bms_overlap = Module['_bms_overlap'] = wasmExports['bms_overlap'])(a0, a1);
var _visibilitymap_prepare_truncate = Module['_visibilitymap_prepare_truncate'] = (a0, a1) => (_visibilitymap_prepare_truncate = Module['_visibilitymap_prepare_truncate'] = wasmExports['visibilitymap_prepare_truncate'])(a0, a1);
var __hash_getbuf = Module['__hash_getbuf'] = (a0, a1, a2, a3) => (__hash_getbuf = Module['__hash_getbuf'] = wasmExports['_hash_getbuf'])(a0, a1, a2, a3);
var __hash_relbuf = Module['__hash_relbuf'] = (a0, a1) => (__hash_relbuf = Module['__hash_relbuf'] = wasmExports['_hash_relbuf'])(a0, a1);
var __hash_get_indextuple_hashkey = Module['__hash_get_indextuple_hashkey'] = (a0) => (__hash_get_indextuple_hashkey = Module['__hash_get_indextuple_hashkey'] = wasmExports['_hash_get_indextuple_hashkey'])(a0);
var __hash_ovflblkno_to_bitno = Module['__hash_ovflblkno_to_bitno'] = (a0, a1) => (__hash_ovflblkno_to_bitno = Module['__hash_ovflblkno_to_bitno'] = wasmExports['_hash_ovflblkno_to_bitno'])(a0, a1);
var __hash_getbuf_with_strategy = Module['__hash_getbuf_with_strategy'] = (a0, a1, a2, a3, a4) => (__hash_getbuf_with_strategy = Module['__hash_getbuf_with_strategy'] = wasmExports['_hash_getbuf_with_strategy'])(a0, a1, a2, a3, a4);
var _hash_bytes_extended = Module['_hash_bytes_extended'] = (a0, a1, a2) => (_hash_bytes_extended = Module['_hash_bytes_extended'] = wasmExports['hash_bytes_extended'])(a0, a1, a2);
var _list_member_oid = Module['_list_member_oid'] = (a0, a1) => (_list_member_oid = Module['_list_member_oid'] = wasmExports['list_member_oid'])(a0, a1);
var _errdetail_relkind_not_supported = Module['_errdetail_relkind_not_supported'] = (a0) => (_errdetail_relkind_not_supported = Module['_errdetail_relkind_not_supported'] = wasmExports['errdetail_relkind_not_supported'])(a0);
var _table_openrv = Module['_table_openrv'] = (a0, a1) => (_table_openrv = Module['_table_openrv'] = wasmExports['table_openrv'])(a0, a1);
var _numeric_sub = Module['_numeric_sub'] = (a0) => (_numeric_sub = Module['_numeric_sub'] = wasmExports['numeric_sub'])(a0);
var _DirectFunctionCall1Coll = Module['_DirectFunctionCall1Coll'] = (a0, a1, a2) => (_DirectFunctionCall1Coll = Module['_DirectFunctionCall1Coll'] = wasmExports['DirectFunctionCall1Coll'])(a0, a1, a2);
var _get_fn_opclass_options = Module['_get_fn_opclass_options'] = (a0) => (_get_fn_opclass_options = Module['_get_fn_opclass_options'] = wasmExports['get_fn_opclass_options'])(a0);
var _cstring_to_text_with_len = Module['_cstring_to_text_with_len'] = (a0, a1) => (_cstring_to_text_with_len = Module['_cstring_to_text_with_len'] = wasmExports['cstring_to_text_with_len'])(a0, a1);
var _brin_build_desc = Module['_brin_build_desc'] = (a0) => (_brin_build_desc = Module['_brin_build_desc'] = wasmExports['brin_build_desc'])(a0);
var _brin_deform_tuple = Module['_brin_deform_tuple'] = (a0, a1, a2) => (_brin_deform_tuple = Module['_brin_deform_tuple'] = wasmExports['brin_deform_tuple'])(a0, a1, a2);
var _IndexGetRelation = Module['_IndexGetRelation'] = (a0, a1) => (_IndexGetRelation = Module['_IndexGetRelation'] = wasmExports['IndexGetRelation'])(a0, a1);
var _brin_free_desc = Module['_brin_free_desc'] = (a0) => (_brin_free_desc = Module['_brin_free_desc'] = wasmExports['brin_free_desc'])(a0);
var _log = Module['_log'] = (a0) => (_log = Module['_log'] = wasmExports['log'])(a0);
var _pg_popcount = Module['_pg_popcount'] = (a0, a1) => (_pg_popcount = Module['_pg_popcount'] = wasmExports['pg_popcount'])(a0, a1);
var _pg_initdb = Module['_pg_initdb'] = () => (_pg_initdb = Module['_pg_initdb'] = wasmExports['pg_initdb'])();
var _pg_initdb_main = Module['_pg_initdb_main'] = () => (_pg_initdb_main = Module['_pg_initdb_main'] = wasmExports['pg_initdb_main'])();
var _dup = Module['_dup'] = (a0) => (_dup = Module['_dup'] = wasmExports['dup'])(a0);
var _fclose = Module['_fclose'] = (a0) => (_fclose = Module['_fclose'] = wasmExports['fclose'])(a0);
var ___cxa_throw = Module['___cxa_throw'] = (a0, a1, a2) => (___cxa_throw = Module['___cxa_throw'] = wasmExports['__cxa_throw'])(a0, a1, a2);
var _main_repl = Module['_main_repl'] = () => (_main_repl = Module['_main_repl'] = wasmExports['main_repl'])();
var _mkdir = Module['_mkdir'] = (a0, a1) => (_mkdir = Module['_mkdir'] = wasmExports['mkdir'])(a0, a1);
var _fwrite = Module['_fwrite'] = (a0, a1, a2, a3) => (_fwrite = Module['_fwrite'] = wasmExports['fwrite'])(a0, a1, a2, a3);
var _main = Module['_main'] = (a0, a1) => (_main = Module['_main'] = wasmExports['__main_argc_argv'])(a0, a1);
var _setenv = Module['_setenv'] = (a0, a1, a2) => (_setenv = Module['_setenv'] = wasmExports['setenv'])(a0, a1, a2);
var _pg_repl_raf = Module['_pg_repl_raf'] = () => (_pg_repl_raf = Module['_pg_repl_raf'] = wasmExports['pg_repl_raf'])();
var _truncate_identifier = Module['_truncate_identifier'] = (a0, a1, a2) => (_truncate_identifier = Module['_truncate_identifier'] = wasmExports['truncate_identifier'])(a0, a1, a2);
var _downcase_truncate_identifier = Module['_downcase_truncate_identifier'] = (a0, a1, a2) => (_downcase_truncate_identifier = Module['_downcase_truncate_identifier'] = wasmExports['downcase_truncate_identifier'])(a0, a1, a2);
var _realloc = Module['_realloc'] = (a0, a1) => (_realloc = Module['_realloc'] = wasmExports['realloc'])(a0, a1);
var _getc = Module['_getc'] = (a0) => (_getc = Module['_getc'] = wasmExports['getc'])(a0);
var _fread = Module['_fread'] = (a0, a1, a2, a3) => (_fread = Module['_fread'] = wasmExports['fread'])(a0, a1, a2, a3);
var _clearerr = Module['_clearerr'] = (a0) => (_clearerr = Module['_clearerr'] = wasmExports['clearerr'])(a0);
var _atoi = Module['_atoi'] = (a0) => (_atoi = Module['_atoi'] = wasmExports['atoi'])(a0);
var _on_shmem_exit = Module['_on_shmem_exit'] = (a0, a1) => (_on_shmem_exit = Module['_on_shmem_exit'] = wasmExports['on_shmem_exit'])(a0, a1);
var _CreateDestReceiver = Module['_CreateDestReceiver'] = (a0) => (_CreateDestReceiver = Module['_CreateDestReceiver'] = wasmExports['CreateDestReceiver'])(a0);
var _SignalHandlerForConfigReload = Module['_SignalHandlerForConfigReload'] = (a0) => (_SignalHandlerForConfigReload = Module['_SignalHandlerForConfigReload'] = wasmExports['SignalHandlerForConfigReload'])(a0);
var _procsignal_sigusr1_handler = Module['_procsignal_sigusr1_handler'] = (a0) => (_procsignal_sigusr1_handler = Module['_procsignal_sigusr1_handler'] = wasmExports['procsignal_sigusr1_handler'])(a0);
var _has_privs_of_role = Module['_has_privs_of_role'] = (a0, a1) => (_has_privs_of_role = Module['_has_privs_of_role'] = wasmExports['has_privs_of_role'])(a0, a1);
var _ProcessConfigFile = Module['_ProcessConfigFile'] = (a0) => (_ProcessConfigFile = Module['_ProcessConfigFile'] = wasmExports['ProcessConfigFile'])(a0);
var _resetStringInfo = Module['_resetStringInfo'] = (a0) => (_resetStringInfo = Module['_resetStringInfo'] = wasmExports['resetStringInfo'])(a0);
var _rename = Module['_rename'] = (a0, a1) => (_rename = Module['_rename'] = wasmExports['rename'])(a0, a1);
var _ExecInitExpr = Module['_ExecInitExpr'] = (a0, a1) => (_ExecInitExpr = Module['_ExecInitExpr'] = wasmExports['ExecInitExpr'])(a0, a1);
var _lappend_oid = Module['_lappend_oid'] = (a0, a1) => (_lappend_oid = Module['_lappend_oid'] = wasmExports['lappend_oid'])(a0, a1);
var _equal = Module['_equal'] = (a0, a1) => (_equal = Module['_equal'] = wasmExports['equal'])(a0, a1);
var _CacheRegisterSyscacheCallback = Module['_CacheRegisterSyscacheCallback'] = (a0, a1, a2) => (_CacheRegisterSyscacheCallback = Module['_CacheRegisterSyscacheCallback'] = wasmExports['CacheRegisterSyscacheCallback'])(a0, a1, a2);
var _get_rel_name = Module['_get_rel_name'] = (a0) => (_get_rel_name = Module['_get_rel_name'] = wasmExports['get_rel_name'])(a0);
var _WaitLatchOrSocket = Module['_WaitLatchOrSocket'] = (a0, a1, a2, a3, a4) => (_WaitLatchOrSocket = Module['_WaitLatchOrSocket'] = wasmExports['WaitLatchOrSocket'])(a0, a1, a2, a3, a4);
var _addRTEPermissionInfo = Module['_addRTEPermissionInfo'] = (a0, a1) => (_addRTEPermissionInfo = Module['_addRTEPermissionInfo'] = wasmExports['addRTEPermissionInfo'])(a0, a1);
var _ExecInitRangeTable = Module['_ExecInitRangeTable'] = (a0, a1, a2) => (_ExecInitRangeTable = Module['_ExecInitRangeTable'] = wasmExports['ExecInitRangeTable'])(a0, a1, a2);
var _getTypeInputInfo = Module['_getTypeInputInfo'] = (a0, a1, a2) => (_getTypeInputInfo = Module['_getTypeInputInfo'] = wasmExports['getTypeInputInfo'])(a0, a1, a2);
var _get_relkind_objtype = Module['_get_relkind_objtype'] = (a0) => (_get_relkind_objtype = Module['_get_relkind_objtype'] = wasmExports['get_relkind_objtype'])(a0);
var _GetUserNameFromId = Module['_GetUserNameFromId'] = (a0, a1) => (_GetUserNameFromId = Module['_GetUserNameFromId'] = wasmExports['GetUserNameFromId'])(a0, a1);
var _EmitErrorReport = Module['_EmitErrorReport'] = () => (_EmitErrorReport = Module['_EmitErrorReport'] = wasmExports['EmitErrorReport'])();
var _FlushErrorState = Module['_FlushErrorState'] = () => (_FlushErrorState = Module['_FlushErrorState'] = wasmExports['FlushErrorState'])();
var _CacheRegisterRelcacheCallback = Module['_CacheRegisterRelcacheCallback'] = (a0, a1) => (_CacheRegisterRelcacheCallback = Module['_CacheRegisterRelcacheCallback'] = wasmExports['CacheRegisterRelcacheCallback'])(a0, a1);
var _makeRangeVar = Module['_makeRangeVar'] = (a0, a1, a2) => (_makeRangeVar = Module['_makeRangeVar'] = wasmExports['makeRangeVar'])(a0, a1, a2);
var _bms_del_member = Module['_bms_del_member'] = (a0, a1) => (_bms_del_member = Module['_bms_del_member'] = wasmExports['bms_del_member'])(a0, a1);
var _hash_seq_term = Module['_hash_seq_term'] = (a0) => (_hash_seq_term = Module['_hash_seq_term'] = wasmExports['hash_seq_term'])(a0);
var _OutputPluginPrepareWrite = Module['_OutputPluginPrepareWrite'] = (a0, a1) => (_OutputPluginPrepareWrite = Module['_OutputPluginPrepareWrite'] = wasmExports['OutputPluginPrepareWrite'])(a0, a1);
var _OutputPluginWrite = Module['_OutputPluginWrite'] = (a0, a1) => (_OutputPluginWrite = Module['_OutputPluginWrite'] = wasmExports['OutputPluginWrite'])(a0, a1);
var _OutputPluginUpdateProgress = Module['_OutputPluginUpdateProgress'] = (a0, a1) => (_OutputPluginUpdateProgress = Module['_OutputPluginUpdateProgress'] = wasmExports['OutputPluginUpdateProgress'])(a0, a1);
var _list_sort = Module['_list_sort'] = (a0, a1) => (_list_sort = Module['_list_sort'] = wasmExports['list_sort'])(a0, a1);
var _CopyErrorData = Module['_CopyErrorData'] = () => (_CopyErrorData = Module['_CopyErrorData'] = wasmExports['CopyErrorData'])();
var _FreeErrorData = Module['_FreeErrorData'] = (a0) => (_FreeErrorData = Module['_FreeErrorData'] = wasmExports['FreeErrorData'])(a0);
var _RelidByRelfilenumber = Module['_RelidByRelfilenumber'] = (a0, a1) => (_RelidByRelfilenumber = Module['_RelidByRelfilenumber'] = wasmExports['RelidByRelfilenumber'])(a0, a1);
var _RegisterBackgroundWorker = Module['_RegisterBackgroundWorker'] = (a0) => (_RegisterBackgroundWorker = Module['_RegisterBackgroundWorker'] = wasmExports['RegisterBackgroundWorker'])(a0);
var _array_contains_nulls = Module['_array_contains_nulls'] = (a0) => (_array_contains_nulls = Module['_array_contains_nulls'] = wasmExports['array_contains_nulls'])(a0);
var _replorigin_by_oid = Module['_replorigin_by_oid'] = (a0, a1, a2) => (_replorigin_by_oid = Module['_replorigin_by_oid'] = wasmExports['replorigin_by_oid'])(a0, a1, a2);
var _logicalrep_write_begin = Module['_logicalrep_write_begin'] = (a0, a1) => (_logicalrep_write_begin = Module['_logicalrep_write_begin'] = wasmExports['logicalrep_write_begin'])(a0, a1);
var _logicalrep_write_commit = Module['_logicalrep_write_commit'] = (a0, a1, a2) => (_logicalrep_write_commit = Module['_logicalrep_write_commit'] = wasmExports['logicalrep_write_commit'])(a0, a1, a2);
var _logicalrep_write_begin_prepare = Module['_logicalrep_write_begin_prepare'] = (a0, a1) => (_logicalrep_write_begin_prepare = Module['_logicalrep_write_begin_prepare'] = wasmExports['logicalrep_write_begin_prepare'])(a0, a1);
var _logicalrep_write_prepare = Module['_logicalrep_write_prepare'] = (a0, a1, a2) => (_logicalrep_write_prepare = Module['_logicalrep_write_prepare'] = wasmExports['logicalrep_write_prepare'])(a0, a1, a2);
var _logicalrep_write_commit_prepared = Module['_logicalrep_write_commit_prepared'] = (a0, a1, a2) => (_logicalrep_write_commit_prepared = Module['_logicalrep_write_commit_prepared'] = wasmExports['logicalrep_write_commit_prepared'])(a0, a1, a2);
var _logicalrep_write_rollback_prepared = Module['_logicalrep_write_rollback_prepared'] = (a0, a1, a2, a3) => (_logicalrep_write_rollback_prepared = Module['_logicalrep_write_rollback_prepared'] = wasmExports['logicalrep_write_rollback_prepared'])(a0, a1, a2, a3);
var _logicalrep_write_stream_prepare = Module['_logicalrep_write_stream_prepare'] = (a0, a1, a2) => (_logicalrep_write_stream_prepare = Module['_logicalrep_write_stream_prepare'] = wasmExports['logicalrep_write_stream_prepare'])(a0, a1, a2);
var _logicalrep_write_origin = Module['_logicalrep_write_origin'] = (a0, a1, a2) => (_logicalrep_write_origin = Module['_logicalrep_write_origin'] = wasmExports['logicalrep_write_origin'])(a0, a1, a2);
var _logicalrep_write_insert = Module['_logicalrep_write_insert'] = (a0, a1, a2, a3, a4, a5) => (_logicalrep_write_insert = Module['_logicalrep_write_insert'] = wasmExports['logicalrep_write_insert'])(a0, a1, a2, a3, a4, a5);
var _logicalrep_write_update = Module['_logicalrep_write_update'] = (a0, a1, a2, a3, a4, a5, a6) => (_logicalrep_write_update = Module['_logicalrep_write_update'] = wasmExports['logicalrep_write_update'])(a0, a1, a2, a3, a4, a5, a6);
var _logicalrep_write_delete = Module['_logicalrep_write_delete'] = (a0, a1, a2, a3, a4, a5) => (_logicalrep_write_delete = Module['_logicalrep_write_delete'] = wasmExports['logicalrep_write_delete'])(a0, a1, a2, a3, a4, a5);
var _logicalrep_write_truncate = Module['_logicalrep_write_truncate'] = (a0, a1, a2, a3, a4, a5) => (_logicalrep_write_truncate = Module['_logicalrep_write_truncate'] = wasmExports['logicalrep_write_truncate'])(a0, a1, a2, a3, a4, a5);
var _logicalrep_write_message = Module['_logicalrep_write_message'] = (a0, a1, a2, a3, a4, a5, a6) => (_logicalrep_write_message = Module['_logicalrep_write_message'] = wasmExports['logicalrep_write_message'])(a0, a1, a2, a3, a4, a5, a6);
var _logicalrep_write_rel = Module['_logicalrep_write_rel'] = (a0, a1, a2, a3) => (_logicalrep_write_rel = Module['_logicalrep_write_rel'] = wasmExports['logicalrep_write_rel'])(a0, a1, a2, a3);
var _logicalrep_write_typ = Module['_logicalrep_write_typ'] = (a0, a1, a2) => (_logicalrep_write_typ = Module['_logicalrep_write_typ'] = wasmExports['logicalrep_write_typ'])(a0, a1, a2);
var _logicalrep_write_stream_start = Module['_logicalrep_write_stream_start'] = (a0, a1, a2) => (_logicalrep_write_stream_start = Module['_logicalrep_write_stream_start'] = wasmExports['logicalrep_write_stream_start'])(a0, a1, a2);
var _logicalrep_write_stream_stop = Module['_logicalrep_write_stream_stop'] = (a0) => (_logicalrep_write_stream_stop = Module['_logicalrep_write_stream_stop'] = wasmExports['logicalrep_write_stream_stop'])(a0);
var _logicalrep_write_stream_commit = Module['_logicalrep_write_stream_commit'] = (a0, a1, a2) => (_logicalrep_write_stream_commit = Module['_logicalrep_write_stream_commit'] = wasmExports['logicalrep_write_stream_commit'])(a0, a1, a2);
var _logicalrep_write_stream_abort = Module['_logicalrep_write_stream_abort'] = (a0, a1, a2, a3, a4, a5) => (_logicalrep_write_stream_abort = Module['_logicalrep_write_stream_abort'] = wasmExports['logicalrep_write_stream_abort'])(a0, a1, a2, a3, a4, a5);
var _SignalHandlerForShutdownRequest = Module['_SignalHandlerForShutdownRequest'] = (a0) => (_SignalHandlerForShutdownRequest = Module['_SignalHandlerForShutdownRequest'] = wasmExports['SignalHandlerForShutdownRequest'])(a0);
var _list_member_xid = Module['_list_member_xid'] = (a0, a1) => (_list_member_xid = Module['_list_member_xid'] = wasmExports['list_member_xid'])(a0, a1);
var _lappend_xid = Module['_lappend_xid'] = (a0, a1) => (_lappend_xid = Module['_lappend_xid'] = wasmExports['lappend_xid'])(a0, a1);
var _tuplestore_end = Module['_tuplestore_end'] = (a0) => (_tuplestore_end = Module['_tuplestore_end'] = wasmExports['tuplestore_end'])(a0);
var _quote_literal_cstr = Module['_quote_literal_cstr'] = (a0) => (_quote_literal_cstr = Module['_quote_literal_cstr'] = wasmExports['quote_literal_cstr'])(a0);
var _tuplestore_tuple_count = Module['_tuplestore_tuple_count'] = (a0) => (_tuplestore_tuple_count = Module['_tuplestore_tuple_count'] = wasmExports['tuplestore_tuple_count'])(a0);
var _quote_qualified_identifier = Module['_quote_qualified_identifier'] = (a0, a1) => (_quote_qualified_identifier = Module['_quote_qualified_identifier'] = wasmExports['quote_qualified_identifier'])(a0, a1);
var _quote_identifier = Module['_quote_identifier'] = (a0) => (_quote_identifier = Module['_quote_identifier'] = wasmExports['quote_identifier'])(a0);
var _BeginCopyFrom = Module['_BeginCopyFrom'] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_BeginCopyFrom = Module['_BeginCopyFrom'] = wasmExports['BeginCopyFrom'])(a0, a1, a2, a3, a4, a5, a6, a7);
var _ProcessWalRcvInterrupts = Module['_ProcessWalRcvInterrupts'] = () => (_ProcessWalRcvInterrupts = Module['_ProcessWalRcvInterrupts'] = wasmExports['ProcessWalRcvInterrupts'])();
var _makeBoolean = Module['_makeBoolean'] = (a0) => (_makeBoolean = Module['_makeBoolean'] = wasmExports['makeBoolean'])(a0);
var _makeInteger = Module['_makeInteger'] = (a0) => (_makeInteger = Module['_makeInteger'] = wasmExports['makeInteger'])(a0);
var _GetDatabaseEncodingName = Module['_GetDatabaseEncodingName'] = () => (_GetDatabaseEncodingName = Module['_GetDatabaseEncodingName'] = wasmExports['GetDatabaseEncodingName'])();
var _PQconnectStartParams = Module['_PQconnectStartParams'] = (a0, a1, a2) => (_PQconnectStartParams = Module['_PQconnectStartParams'] = wasmExports['PQconnectStartParams'])(a0, a1, a2);
var _PQstatus = Module['_PQstatus'] = (a0) => (_PQstatus = Module['_PQstatus'] = wasmExports['PQstatus'])(a0);
var _PQsocket = Module['_PQsocket'] = (a0) => (_PQsocket = Module['_PQsocket'] = wasmExports['PQsocket'])(a0);
var _PQconnectPoll = Module['_PQconnectPoll'] = (a0) => (_PQconnectPoll = Module['_PQconnectPoll'] = wasmExports['PQconnectPoll'])(a0);
var _PQconnectionUsedPassword = Module['_PQconnectionUsedPassword'] = (a0) => (_PQconnectionUsedPassword = Module['_PQconnectionUsedPassword'] = wasmExports['PQconnectionUsedPassword'])(a0);
var _PQfinish = Module['_PQfinish'] = (a0) => (_PQfinish = Module['_PQfinish'] = wasmExports['PQfinish'])(a0);
var _PQresultStatus = Module['_PQresultStatus'] = (a0) => (_PQresultStatus = Module['_PQresultStatus'] = wasmExports['PQresultStatus'])(a0);
var _PQclear = Module['_PQclear'] = (a0) => (_PQclear = Module['_PQclear'] = wasmExports['PQclear'])(a0);
var _PQerrorMessage = Module['_PQerrorMessage'] = (a0) => (_PQerrorMessage = Module['_PQerrorMessage'] = wasmExports['PQerrorMessage'])(a0);
var _pchomp = Module['_pchomp'] = (a0) => (_pchomp = Module['_pchomp'] = wasmExports['pchomp'])(a0);
var _PQnfields = Module['_PQnfields'] = (a0) => (_PQnfields = Module['_PQnfields'] = wasmExports['PQnfields'])(a0);
var _PQntuples = Module['_PQntuples'] = (a0) => (_PQntuples = Module['_PQntuples'] = wasmExports['PQntuples'])(a0);
var _PQgetvalue = Module['_PQgetvalue'] = (a0, a1, a2) => (_PQgetvalue = Module['_PQgetvalue'] = wasmExports['PQgetvalue'])(a0, a1, a2);
var _pg_strtoint32 = Module['_pg_strtoint32'] = (a0) => (_pg_strtoint32 = Module['_pg_strtoint32'] = wasmExports['pg_strtoint32'])(a0);
var _PQconsumeInput = Module['_PQconsumeInput'] = (a0) => (_PQconsumeInput = Module['_PQconsumeInput'] = wasmExports['PQconsumeInput'])(a0);
var _pg_lsn_in = Module['_pg_lsn_in'] = (a0) => (_pg_lsn_in = Module['_pg_lsn_in'] = wasmExports['pg_lsn_in'])(a0);
var _PQgetisnull = Module['_PQgetisnull'] = (a0, a1, a2) => (_PQgetisnull = Module['_PQgetisnull'] = wasmExports['PQgetisnull'])(a0, a1, a2);
var _tuplestore_begin_heap = Module['_tuplestore_begin_heap'] = (a0, a1, a2) => (_tuplestore_begin_heap = Module['_tuplestore_begin_heap'] = wasmExports['tuplestore_begin_heap'])(a0, a1, a2);
var _tuplestore_puttuple = Module['_tuplestore_puttuple'] = (a0, a1) => (_tuplestore_puttuple = Module['_tuplestore_puttuple'] = wasmExports['tuplestore_puttuple'])(a0, a1);
var _PQresultErrorField = Module['_PQresultErrorField'] = (a0, a1) => (_PQresultErrorField = Module['_PQresultErrorField'] = wasmExports['PQresultErrorField'])(a0, a1);
var _PQsendQuery = Module['_PQsendQuery'] = (a0, a1) => (_PQsendQuery = Module['_PQsendQuery'] = wasmExports['PQsendQuery'])(a0, a1);
var _PQisBusy = Module['_PQisBusy'] = (a0) => (_PQisBusy = Module['_PQisBusy'] = wasmExports['PQisBusy'])(a0);
var _PQgetResult = Module['_PQgetResult'] = (a0) => (_PQgetResult = Module['_PQgetResult'] = wasmExports['PQgetResult'])(a0);
var _GetForeignDataWrapper = Module['_GetForeignDataWrapper'] = (a0) => (_GetForeignDataWrapper = Module['_GetForeignDataWrapper'] = wasmExports['GetForeignDataWrapper'])(a0);
var _SysCacheGetAttr = Module['_SysCacheGetAttr'] = (a0, a1, a2, a3) => (_SysCacheGetAttr = Module['_SysCacheGetAttr'] = wasmExports['SysCacheGetAttr'])(a0, a1, a2, a3);
var _GetSysCacheOid = Module['_GetSysCacheOid'] = (a0, a1, a2, a3, a4, a5) => (_GetSysCacheOid = Module['_GetSysCacheOid'] = wasmExports['GetSysCacheOid'])(a0, a1, a2, a3, a4, a5);
var _GetForeignServer = Module['_GetForeignServer'] = (a0) => (_GetForeignServer = Module['_GetForeignServer'] = wasmExports['GetForeignServer'])(a0);
var _GetForeignServerExtended = Module['_GetForeignServerExtended'] = (a0, a1) => (_GetForeignServerExtended = Module['_GetForeignServerExtended'] = wasmExports['GetForeignServerExtended'])(a0, a1);
var _GetForeignServerByName = Module['_GetForeignServerByName'] = (a0, a1) => (_GetForeignServerByName = Module['_GetForeignServerByName'] = wasmExports['GetForeignServerByName'])(a0, a1);
var _GetUserMapping = Module['_GetUserMapping'] = (a0, a1) => (_GetUserMapping = Module['_GetUserMapping'] = wasmExports['GetUserMapping'])(a0, a1);
var _SearchSysCache2 = Module['_SearchSysCache2'] = (a0, a1, a2) => (_SearchSysCache2 = Module['_SearchSysCache2'] = wasmExports['SearchSysCache2'])(a0, a1, a2);
var _GetForeignTable = Module['_GetForeignTable'] = (a0) => (_GetForeignTable = Module['_GetForeignTable'] = wasmExports['GetForeignTable'])(a0);
var _GetForeignColumnOptions = Module['_GetForeignColumnOptions'] = (a0, a1) => (_GetForeignColumnOptions = Module['_GetForeignColumnOptions'] = wasmExports['GetForeignColumnOptions'])(a0, a1);
var _initClosestMatch = Module['_initClosestMatch'] = (a0, a1, a2) => (_initClosestMatch = Module['_initClosestMatch'] = wasmExports['initClosestMatch'])(a0, a1, a2);
var _updateClosestMatch = Module['_updateClosestMatch'] = (a0, a1) => (_updateClosestMatch = Module['_updateClosestMatch'] = wasmExports['updateClosestMatch'])(a0, a1);
var _getClosestMatch = Module['_getClosestMatch'] = (a0) => (_getClosestMatch = Module['_getClosestMatch'] = wasmExports['getClosestMatch'])(a0);
var _GetExistingLocalJoinPath = Module['_GetExistingLocalJoinPath'] = (a0) => (_GetExistingLocalJoinPath = Module['_GetExistingLocalJoinPath'] = wasmExports['GetExistingLocalJoinPath'])(a0);
var _copyObjectImpl = Module['_copyObjectImpl'] = (a0) => (_copyObjectImpl = Module['_copyObjectImpl'] = wasmExports['copyObjectImpl'])(a0);
var _list_member = Module['_list_member'] = (a0, a1) => (_list_member = Module['_list_member'] = wasmExports['list_member'])(a0, a1);
var _contain_mutable_functions = Module['_contain_mutable_functions'] = (a0) => (_contain_mutable_functions = Module['_contain_mutable_functions'] = wasmExports['contain_mutable_functions'])(a0);
var _list_member_int = Module['_list_member_int'] = (a0, a1) => (_list_member_int = Module['_list_member_int'] = wasmExports['list_member_int'])(a0, a1);
var _list_concat = Module['_list_concat'] = (a0, a1) => (_list_concat = Module['_list_concat'] = wasmExports['list_concat'])(a0, a1);
var _bms_make_singleton = Module['_bms_make_singleton'] = (a0) => (_bms_make_singleton = Module['_bms_make_singleton'] = wasmExports['bms_make_singleton'])(a0);
var _bms_membership = Module['_bms_membership'] = (a0) => (_bms_membership = Module['_bms_membership'] = wasmExports['bms_membership'])(a0);
var _bms_num_members = Module['_bms_num_members'] = (a0) => (_bms_num_members = Module['_bms_num_members'] = wasmExports['bms_num_members'])(a0);
var _get_typlenbyval = Module['_get_typlenbyval'] = (a0, a1, a2) => (_get_typlenbyval = Module['_get_typlenbyval'] = wasmExports['get_typlenbyval'])(a0, a1, a2);
var _exprTypmod = Module['_exprTypmod'] = (a0) => (_exprTypmod = Module['_exprTypmod'] = wasmExports['exprTypmod'])(a0);
var _make_orclause = Module['_make_orclause'] = (a0) => (_make_orclause = Module['_make_orclause'] = wasmExports['make_orclause'])(a0);
var _list_make3_impl = Module['_list_make3_impl'] = (a0, a1, a2, a3) => (_list_make3_impl = Module['_list_make3_impl'] = wasmExports['list_make3_impl'])(a0, a1, a2, a3);
var _makeVar = Module['_makeVar'] = (a0, a1, a2, a3, a4, a5) => (_makeVar = Module['_makeVar'] = wasmExports['makeVar'])(a0, a1, a2, a3, a4, a5);
var _ArrayGetNItems = Module['_ArrayGetNItems'] = (a0, a1) => (_ArrayGetNItems = Module['_ArrayGetNItems'] = wasmExports['ArrayGetNItems'])(a0, a1);
var _stringToNode = Module['_stringToNode'] = (a0) => (_stringToNode = Module['_stringToNode'] = wasmExports['stringToNode'])(a0);
var _geterrposition = Module['_geterrposition'] = () => (_geterrposition = Module['_geterrposition'] = wasmExports['geterrposition'])();
var _errposition = Module['_errposition'] = (a0) => (_errposition = Module['_errposition'] = wasmExports['errposition'])(a0);
var _internalerrposition = Module['_internalerrposition'] = (a0) => (_internalerrposition = Module['_internalerrposition'] = wasmExports['internalerrposition'])(a0);
var _internalerrquery = Module['_internalerrquery'] = (a0) => (_internalerrquery = Module['_internalerrquery'] = wasmExports['internalerrquery'])(a0);
var _cost_qual_eval = Module['_cost_qual_eval'] = (a0, a1, a2) => (_cost_qual_eval = Module['_cost_qual_eval'] = wasmExports['cost_qual_eval'])(a0, a1, a2);
var _list_delete_last = Module['_list_delete_last'] = (a0) => (_list_delete_last = Module['_list_delete_last'] = wasmExports['list_delete_last'])(a0);
var _list_copy = Module['_list_copy'] = (a0) => (_list_copy = Module['_list_copy'] = wasmExports['list_copy'])(a0);
var _lookup_rowtype_tupdesc_domain = Module['_lookup_rowtype_tupdesc_domain'] = (a0, a1, a2) => (_lookup_rowtype_tupdesc_domain = Module['_lookup_rowtype_tupdesc_domain'] = wasmExports['lookup_rowtype_tupdesc_domain'])(a0, a1, a2);
var _find_base_rel = Module['_find_base_rel'] = (a0, a1) => (_find_base_rel = Module['_find_base_rel'] = wasmExports['find_base_rel'])(a0, a1);
var _find_join_rel = Module['_find_join_rel'] = (a0, a1) => (_find_join_rel = Module['_find_join_rel'] = wasmExports['find_join_rel'])(a0, a1);
var _bms_equal = Module['_bms_equal'] = (a0, a1) => (_bms_equal = Module['_bms_equal'] = wasmExports['bms_equal'])(a0, a1);
var _bms_union = Module['_bms_union'] = (a0, a1) => (_bms_union = Module['_bms_union'] = wasmExports['bms_union'])(a0, a1);
var _bms_is_subset = Module['_bms_is_subset'] = (a0, a1) => (_bms_is_subset = Module['_bms_is_subset'] = wasmExports['bms_is_subset'])(a0, a1);
var _list_append_unique_ptr = Module['_list_append_unique_ptr'] = (a0, a1) => (_list_append_unique_ptr = Module['_list_append_unique_ptr'] = wasmExports['list_append_unique_ptr'])(a0, a1);
var _bms_nonempty_difference = Module['_bms_nonempty_difference'] = (a0, a1) => (_bms_nonempty_difference = Module['_bms_nonempty_difference'] = wasmExports['bms_nonempty_difference'])(a0, a1);
var _list_make2_impl = Module['_list_make2_impl'] = (a0, a1, a2) => (_list_make2_impl = Module['_list_make2_impl'] = wasmExports['list_make2_impl'])(a0, a1, a2);
var _get_baserel_parampathinfo = Module['_get_baserel_parampathinfo'] = (a0, a1, a2) => (_get_baserel_parampathinfo = Module['_get_baserel_parampathinfo'] = wasmExports['get_baserel_parampathinfo'])(a0, a1, a2);
var _pull_var_clause = Module['_pull_var_clause'] = (a0, a1) => (_pull_var_clause = Module['_pull_var_clause'] = wasmExports['pull_var_clause'])(a0, a1);
var _get_plan_rowmark = Module['_get_plan_rowmark'] = (a0, a1) => (_get_plan_rowmark = Module['_get_plan_rowmark'] = wasmExports['get_plan_rowmark'])(a0, a1);
var _makeTargetEntry = Module['_makeTargetEntry'] = (a0, a1, a2, a3) => (_makeTargetEntry = Module['_makeTargetEntry'] = wasmExports['makeTargetEntry'])(a0, a1, a2, a3);
var _add_row_identity_var = Module['_add_row_identity_var'] = (a0, a1, a2, a3) => (_add_row_identity_var = Module['_add_row_identity_var'] = wasmExports['add_row_identity_var'])(a0, a1, a2, a3);
var _get_rel_all_updated_cols = Module['_get_rel_all_updated_cols'] = (a0, a1) => (_get_rel_all_updated_cols = Module['_get_rel_all_updated_cols'] = wasmExports['get_rel_all_updated_cols'])(a0, a1);
var _make_restrictinfo = Module['_make_restrictinfo'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_make_restrictinfo = Module['_make_restrictinfo'] = wasmExports['make_restrictinfo'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
var _extract_actual_clauses = Module['_extract_actual_clauses'] = (a0, a1) => (_extract_actual_clauses = Module['_extract_actual_clauses'] = wasmExports['extract_actual_clauses'])(a0, a1);
var _join_clause_is_movable_to = Module['_join_clause_is_movable_to'] = (a0, a1) => (_join_clause_is_movable_to = Module['_join_clause_is_movable_to'] = wasmExports['join_clause_is_movable_to'])(a0, a1);
var _add_path = Module['_add_path'] = (a0, a1) => (_add_path = Module['_add_path'] = wasmExports['add_path'])(a0, a1);
var _list_delete_cell = Module['_list_delete_cell'] = (a0, a1) => (_list_delete_cell = Module['_list_delete_cell'] = wasmExports['list_delete_cell'])(a0, a1);
var _pathkeys_contained_in = Module['_pathkeys_contained_in'] = (a0, a1) => (_pathkeys_contained_in = Module['_pathkeys_contained_in'] = wasmExports['pathkeys_contained_in'])(a0, a1);
var _cost_sort = Module['_cost_sort'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_cost_sort = Module['_cost_sort'] = wasmExports['cost_sort'])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
var _lappend_int = Module['_lappend_int'] = (a0, a1) => (_lappend_int = Module['_lappend_int'] = wasmExports['lappend_int'])(a0, a1);
var _estimate_num_groups = Module['_estimate_num_groups'] = (a0, a1, a2, a3, a4) => (_estimate_num_groups = Module['_estimate_num_groups'] = wasmExports['estimate_num_groups'])(a0, a1, a2, a3, a4);
var _create_foreignscan_path = Module['_create_foreignscan_path'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_create_foreignscan_path = Module['_create_foreignscan_path'] = wasmExports['create_foreignscan_path'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
var _create_foreign_join_path = Module['_create_foreign_join_path'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_create_foreign_join_path = Module['_create_foreign_join_path'] = wasmExports['create_foreign_join_path'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
var _create_foreign_upper_path = Module['_create_foreign_upper_path'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_create_foreign_upper_path = Module['_create_foreign_upper_path'] = wasmExports['create_foreign_upper_path'])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
var _create_projection_path = Module['_create_projection_path'] = (a0, a1, a2, a3) => (_create_projection_path = Module['_create_projection_path'] = wasmExports['create_projection_path'])(a0, a1, a2, a3);
var _create_sort_path = Module['_create_sort_path'] = (a0, a1, a2, a3, a4) => (_create_sort_path = Module['_create_sort_path'] = wasmExports['create_sort_path'])(a0, a1, a2, a3, a4);
var _adjust_limit_rows_costs = Module['_adjust_limit_rows_costs'] = (a0, a1, a2, a3, a4) => (_adjust_limit_rows_costs = Module['_adjust_limit_rows_costs'] = wasmExports['adjust_limit_rows_costs'])(a0, a1, a2, a3, a4);
var _copy_pathtarget = Module['_copy_pathtarget'] = (a0) => (_copy_pathtarget = Module['_copy_pathtarget'] = wasmExports['copy_pathtarget'])(a0);
var _tlist_member = Module['_tlist_member'] = (a0, a1) => (_tlist_member = Module['_tlist_member'] = wasmExports['tlist_member'])(a0, a1);
var _add_to_flat_tlist = Module['_add_to_flat_tlist'] = (a0, a1) => (_add_to_flat_tlist = Module['_add_to_flat_tlist'] = wasmExports['add_to_flat_tlist'])(a0, a1);
var _get_sortgroupref_tle = Module['_get_sortgroupref_tle'] = (a0, a1) => (_get_sortgroupref_tle = Module['_get_sortgroupref_tle'] = wasmExports['get_sortgroupref_tle'])(a0, a1);
var _get_sortgrouplist_exprs = Module['_get_sortgrouplist_exprs'] = (a0, a1) => (_get_sortgrouplist_exprs = Module['_get_sortgrouplist_exprs'] = wasmExports['get_sortgrouplist_exprs'])(a0, a1);
var _get_sortgroupref_clause_noerr = Module['_get_sortgroupref_clause_noerr'] = (a0, a1) => (_get_sortgroupref_clause_noerr = Module['_get_sortgroupref_clause_noerr'] = wasmExports['get_sortgroupref_clause_noerr'])(a0, a1);
var _grouping_is_sortable = Module['_grouping_is_sortable'] = (a0) => (_grouping_is_sortable = Module['_grouping_is_sortable'] = wasmExports['grouping_is_sortable'])(a0);
var _add_new_columns_to_pathtarget = Module['_add_new_columns_to_pathtarget'] = (a0, a1) => (_add_new_columns_to_pathtarget = Module['_add_new_columns_to_pathtarget'] = wasmExports['add_new_columns_to_pathtarget'])(a0, a1);
var _pull_varattnos = Module['_pull_varattnos'] = (a0, a1, a2) => (_pull_varattnos = Module['_pull_varattnos'] = wasmExports['pull_varattnos'])(a0, a1, a2);
var _SearchSysCacheAttName = Module['_SearchSysCacheAttName'] = (a0, a1) => (_SearchSysCacheAttName = Module['_SearchSysCacheAttName'] = wasmExports['SearchSysCacheAttName'])(a0, a1);
var _get_translated_update_targetlist = Module['_get_translated_update_targetlist'] = (a0, a1, a2, a3) => (_get_translated_update_targetlist = Module['_get_translated_update_targetlist'] = wasmExports['get_translated_update_targetlist'])(a0, a1, a2, a3);
var _generate_implied_equalities_for_column = Module['_generate_implied_equalities_for_column'] = (a0, a1, a2, a3, a4) => (_generate_implied_equalities_for_column = Module['_generate_implied_equalities_for_column'] = wasmExports['generate_implied_equalities_for_column'])(a0, a1, a2, a3, a4);
var _get_tablespace_page_costs = Module['_get_tablespace_page_costs'] = (a0, a1, a2) => (_get_tablespace_page_costs = Module['_get_tablespace_page_costs'] = wasmExports['get_tablespace_page_costs'])(a0, a1, a2);
var _clauselist_selectivity = Module['_clauselist_selectivity'] = (a0, a1, a2, a3, a4) => (_clauselist_selectivity = Module['_clauselist_selectivity'] = wasmExports['clauselist_selectivity'])(a0, a1, a2, a3, a4);
var _set_baserel_size_estimates = Module['_set_baserel_size_estimates'] = (a0, a1) => (_set_baserel_size_estimates = Module['_set_baserel_size_estimates'] = wasmExports['set_baserel_size_estimates'])(a0, a1);
var _list_member_ptr = Module['_list_member_ptr'] = (a0, a1) => (_list_member_ptr = Module['_list_member_ptr'] = wasmExports['list_member_ptr'])(a0, a1);
var _update_mergeclause_eclasses = Module['_update_mergeclause_eclasses'] = (a0, a1) => (_update_mergeclause_eclasses = Module['_update_mergeclause_eclasses'] = wasmExports['update_mergeclause_eclasses'])(a0, a1);
var _make_canonical_pathkey = Module['_make_canonical_pathkey'] = (a0, a1, a2, a3, a4) => (_make_canonical_pathkey = Module['_make_canonical_pathkey'] = wasmExports['make_canonical_pathkey'])(a0, a1, a2, a3, a4);
var _eclass_useful_for_merging = Module['_eclass_useful_for_merging'] = (a0, a1, a2) => (_eclass_useful_for_merging = Module['_eclass_useful_for_merging'] = wasmExports['eclass_useful_for_merging'])(a0, a1, a2);
var _change_plan_targetlist = Module['_change_plan_targetlist'] = (a0, a1, a2) => (_change_plan_targetlist = Module['_change_plan_targetlist'] = wasmExports['change_plan_targetlist'])(a0, a1, a2);
var _make_foreignscan = Module['_make_foreignscan'] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_make_foreignscan = Module['_make_foreignscan'] = wasmExports['make_foreignscan'])(a0, a1, a2, a3, a4, a5, a6, a7);
var _type_is_rowtype = Module['_type_is_rowtype'] = (a0) => (_type_is_rowtype = Module['_type_is_rowtype'] = wasmExports['type_is_rowtype'])(a0);
var _GetSysCacheHashValue = Module['_GetSysCacheHashValue'] = (a0, a1, a2, a3, a4) => (_GetSysCacheHashValue = Module['_GetSysCacheHashValue'] = wasmExports['GetSysCacheHashValue'])(a0, a1, a2, a3, a4);
var _standard_planner = Module['_standard_planner'] = (a0, a1, a2, a3) => (_standard_planner = Module['_standard_planner'] = wasmExports['standard_planner'])(a0, a1, a2, a3);
var _get_agg_clause_costs = Module['_get_agg_clause_costs'] = (a0, a1, a2) => (_get_agg_clause_costs = Module['_get_agg_clause_costs'] = wasmExports['get_agg_clause_costs'])(a0, a1, a2);
var _plan_create_index_workers = Module['_plan_create_index_workers'] = (a0, a1) => (_plan_create_index_workers = Module['_plan_create_index_workers'] = wasmExports['plan_create_index_workers'])(a0, a1);
var _makeParamList = Module['_makeParamList'] = (a0) => (_makeParamList = Module['_makeParamList'] = wasmExports['makeParamList'])(a0);
var _appendStringInfoStringQuoted = Module['_appendStringInfoStringQuoted'] = (a0, a1, a2) => (_appendStringInfoStringQuoted = Module['_appendStringInfoStringQuoted'] = wasmExports['appendStringInfoStringQuoted'])(a0, a1, a2);
var _get_typcollation = Module['_get_typcollation'] = (a0) => (_get_typcollation = Module['_get_typcollation'] = wasmExports['get_typcollation'])(a0);
var _MemoryContextAllocExtended = Module['_MemoryContextAllocExtended'] = (a0, a1, a2) => (_MemoryContextAllocExtended = Module['_MemoryContextAllocExtended'] = wasmExports['MemoryContextAllocExtended'])(a0, a1, a2);
var _CleanQuerytext = Module['_CleanQuerytext'] = (a0, a1, a2) => (_CleanQuerytext = Module['_CleanQuerytext'] = wasmExports['CleanQuerytext'])(a0, a1, a2);
var _scanner_isspace = Module['_scanner_isspace'] = (a0) => (_scanner_isspace = Module['_scanner_isspace'] = wasmExports['scanner_isspace'])(a0);
var _EnableQueryId = Module['_EnableQueryId'] = () => (_EnableQueryId = Module['_EnableQueryId'] = wasmExports['EnableQueryId'])();
var _get_rel_type_id = Module['_get_rel_type_id'] = (a0) => (_get_rel_type_id = Module['_get_rel_type_id'] = wasmExports['get_rel_type_id'])(a0);
var _makeTypeName = Module['_makeTypeName'] = (a0) => (_makeTypeName = Module['_makeTypeName'] = wasmExports['makeTypeName'])(a0);
var _makeTypeNameFromNameList = Module['_makeTypeNameFromNameList'] = (a0) => (_makeTypeNameFromNameList = Module['_makeTypeNameFromNameList'] = wasmExports['makeTypeNameFromNameList'])(a0);
var _list_make4_impl = Module['_list_make4_impl'] = (a0, a1, a2, a3, a4) => (_list_make4_impl = Module['_list_make4_impl'] = wasmExports['list_make4_impl'])(a0, a1, a2, a3, a4);
var _list_make5_impl = Module['_list_make5_impl'] = (a0, a1, a2, a3, a4, a5) => (_list_make5_impl = Module['_list_make5_impl'] = wasmExports['list_make5_impl'])(a0, a1, a2, a3, a4, a5);
var _list_delete = Module['_list_delete'] = (a0, a1) => (_list_delete = Module['_list_delete'] = wasmExports['list_delete'])(a0, a1);
var _exprIsLengthCoercion = Module['_exprIsLengthCoercion'] = (a0, a1) => (_exprIsLengthCoercion = Module['_exprIsLengthCoercion'] = wasmExports['exprIsLengthCoercion'])(a0, a1);
var _strip_implicit_coercions = Module['_strip_implicit_coercions'] = (a0) => (_strip_implicit_coercions = Module['_strip_implicit_coercions'] = wasmExports['strip_implicit_coercions'])(a0);
var _exprLocation = Module['_exprLocation'] = (a0) => (_exprLocation = Module['_exprLocation'] = wasmExports['exprLocation'])(a0);
var _ExecInitExprList = Module['_ExecInitExprList'] = (a0, a1) => (_ExecInitExprList = Module['_ExecInitExprList'] = wasmExports['ExecInitExprList'])(a0, a1);
var _ExecForceStoreHeapTuple = Module['_ExecForceStoreHeapTuple'] = (a0, a1, a2) => (_ExecForceStoreHeapTuple = Module['_ExecForceStoreHeapTuple'] = wasmExports['ExecForceStoreHeapTuple'])(a0, a1, a2);
var _tuplesort_begin_heap = Module['_tuplesort_begin_heap'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_tuplesort_begin_heap = Module['_tuplesort_begin_heap'] = wasmExports['tuplesort_begin_heap'])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
var _ExecReScan = Module['_ExecReScan'] = (a0) => (_ExecReScan = Module['_ExecReScan'] = wasmExports['ExecReScan'])(a0);
var _MemoryContextMemAllocated = Module['_MemoryContextMemAllocated'] = (a0, a1) => (_MemoryContextMemAllocated = Module['_MemoryContextMemAllocated'] = wasmExports['MemoryContextMemAllocated'])(a0, a1);
var _tuplesort_gettupleslot = Module['_tuplesort_gettupleslot'] = (a0, a1, a2, a3, a4) => (_tuplesort_gettupleslot = Module['_tuplesort_gettupleslot'] = wasmExports['tuplesort_gettupleslot'])(a0, a1, a2, a3, a4);
var _tuplesort_puttupleslot = Module['_tuplesort_puttupleslot'] = (a0, a1) => (_tuplesort_puttupleslot = Module['_tuplesort_puttupleslot'] = wasmExports['tuplesort_puttupleslot'])(a0, a1);
var _ExecStoreAllNullTuple = Module['_ExecStoreAllNullTuple'] = (a0) => (_ExecStoreAllNullTuple = Module['_ExecStoreAllNullTuple'] = wasmExports['ExecStoreAllNullTuple'])(a0);
var _MakeExpandedObjectReadOnlyInternal = Module['_MakeExpandedObjectReadOnlyInternal'] = (a0) => (_MakeExpandedObjectReadOnlyInternal = Module['_MakeExpandedObjectReadOnlyInternal'] = wasmExports['MakeExpandedObjectReadOnlyInternal'])(a0);
var _FreeExprContext = Module['_FreeExprContext'] = (a0, a1) => (_FreeExprContext = Module['_FreeExprContext'] = wasmExports['FreeExprContext'])(a0, a1);
var _CreateExprContext = Module['_CreateExprContext'] = (a0) => (_CreateExprContext = Module['_CreateExprContext'] = wasmExports['CreateExprContext'])(a0);
var _ExecOpenScanRelation = Module['_ExecOpenScanRelation'] = (a0, a1, a2) => (_ExecOpenScanRelation = Module['_ExecOpenScanRelation'] = wasmExports['ExecOpenScanRelation'])(a0, a1, a2);
var _pg_mbstrlen_with_len = Module['_pg_mbstrlen_with_len'] = (a0, a1) => (_pg_mbstrlen_with_len = Module['_pg_mbstrlen_with_len'] = wasmExports['pg_mbstrlen_with_len'])(a0, a1);
var _lookup_rowtype_tupdesc = Module['_lookup_rowtype_tupdesc'] = (a0, a1) => (_lookup_rowtype_tupdesc = Module['_lookup_rowtype_tupdesc'] = wasmExports['lookup_rowtype_tupdesc'])(a0, a1);
var _ExecGetReturningSlot = Module['_ExecGetReturningSlot'] = (a0, a1) => (_ExecGetReturningSlot = Module['_ExecGetReturningSlot'] = wasmExports['ExecGetReturningSlot'])(a0, a1);
var _ExecGetResultRelCheckAsUser = Module['_ExecGetResultRelCheckAsUser'] = (a0, a1) => (_ExecGetResultRelCheckAsUser = Module['_ExecGetResultRelCheckAsUser'] = wasmExports['ExecGetResultRelCheckAsUser'])(a0, a1);
var _ExecAsyncResponse = Module['_ExecAsyncResponse'] = (a0) => (_ExecAsyncResponse = Module['_ExecAsyncResponse'] = wasmExports['ExecAsyncResponse'])(a0);
var _ExecAsyncRequestDone = Module['_ExecAsyncRequestDone'] = (a0, a1) => (_ExecAsyncRequestDone = Module['_ExecAsyncRequestDone'] = wasmExports['ExecAsyncRequestDone'])(a0, a1);
var _ExecAsyncRequestPending = Module['_ExecAsyncRequestPending'] = (a0) => (_ExecAsyncRequestPending = Module['_ExecAsyncRequestPending'] = wasmExports['ExecAsyncRequestPending'])(a0);
var _ExecFindJunkAttributeInTlist = Module['_ExecFindJunkAttributeInTlist'] = (a0, a1) => (_ExecFindJunkAttributeInTlist = Module['_ExecFindJunkAttributeInTlist'] = wasmExports['ExecFindJunkAttributeInTlist'])(a0, a1);
var _pairingheap_first = Module['_pairingheap_first'] = (a0) => (_pairingheap_first = Module['_pairingheap_first'] = wasmExports['pairingheap_first'])(a0);
var _InstrEndLoop = Module['_InstrEndLoop'] = (a0) => (_InstrEndLoop = Module['_InstrEndLoop'] = wasmExports['InstrEndLoop'])(a0);
var _MemoryContextGetParent = Module['_MemoryContextGetParent'] = (a0) => (_MemoryContextGetParent = Module['_MemoryContextGetParent'] = wasmExports['MemoryContextGetParent'])(a0);
var _DeleteExpandedObject = Module['_DeleteExpandedObject'] = (a0) => (_DeleteExpandedObject = Module['_DeleteExpandedObject'] = wasmExports['DeleteExpandedObject'])(a0);
var _SPI_connect = Module['_SPI_connect'] = () => (_SPI_connect = Module['_SPI_connect'] = wasmExports['SPI_connect'])();
var _SPI_connect_ext = Module['_SPI_connect_ext'] = (a0) => (_SPI_connect_ext = Module['_SPI_connect_ext'] = wasmExports['SPI_connect_ext'])(a0);
var _SPI_finish = Module['_SPI_finish'] = () => (_SPI_finish = Module['_SPI_finish'] = wasmExports['SPI_finish'])();
var _SPI_commit = Module['_SPI_commit'] = () => (_SPI_commit = Module['_SPI_commit'] = wasmExports['SPI_commit'])();
var _ReThrowError = Module['_ReThrowError'] = (a0) => (_ReThrowError = Module['_ReThrowError'] = wasmExports['ReThrowError'])(a0);
var _SPI_commit_and_chain = Module['_SPI_commit_and_chain'] = () => (_SPI_commit_and_chain = Module['_SPI_commit_and_chain'] = wasmExports['SPI_commit_and_chain'])();
var _SPI_rollback = Module['_SPI_rollback'] = () => (_SPI_rollback = Module['_SPI_rollback'] = wasmExports['SPI_rollback'])();
var _SPI_rollback_and_chain = Module['_SPI_rollback_and_chain'] = () => (_SPI_rollback_and_chain = Module['_SPI_rollback_and_chain'] = wasmExports['SPI_rollback_and_chain'])();
var _SPI_execute = Module['_SPI_execute'] = (a0, a1, a2) => (_SPI_execute = Module['_SPI_execute'] = wasmExports['SPI_execute'])(a0, a1, a2);
var _raw_parser = Module['_raw_parser'] = (a0, a1) => (_raw_parser = Module['_raw_parser'] = wasmExports['raw_parser'])(a0, a1);
var _GetCommandTagName = Module['_GetCommandTagName'] = (a0) => (_GetCommandTagName = Module['_GetCommandTagName'] = wasmExports['GetCommandTagName'])(a0);
var _EnsurePortalSnapshotExists = Module['_EnsurePortalSnapshotExists'] = () => (_EnsurePortalSnapshotExists = Module['_EnsurePortalSnapshotExists'] = wasmExports['EnsurePortalSnapshotExists'])();
var _SPI_freetuptable = Module['_SPI_freetuptable'] = (a0) => (_SPI_freetuptable = Module['_SPI_freetuptable'] = wasmExports['SPI_freetuptable'])(a0);
var _ReleaseCachedPlan = Module['_ReleaseCachedPlan'] = (a0, a1) => (_ReleaseCachedPlan = Module['_ReleaseCachedPlan'] = wasmExports['ReleaseCachedPlan'])(a0, a1);
var _SPI_exec = Module['_SPI_exec'] = (a0, a1) => (_SPI_exec = Module['_SPI_exec'] = wasmExports['SPI_exec'])(a0, a1);
var _SPI_execute_extended = Module['_SPI_execute_extended'] = (a0, a1) => (_SPI_execute_extended = Module['_SPI_execute_extended'] = wasmExports['SPI_execute_extended'])(a0, a1);
var _SPI_execp = Module['_SPI_execp'] = (a0, a1, a2, a3) => (_SPI_execp = Module['_SPI_execp'] = wasmExports['SPI_execp'])(a0, a1, a2, a3);
var _SPI_execute_plan_extended = Module['_SPI_execute_plan_extended'] = (a0, a1) => (_SPI_execute_plan_extended = Module['_SPI_execute_plan_extended'] = wasmExports['SPI_execute_plan_extended'])(a0, a1);
var _SPI_execute_plan_with_paramlist = Module['_SPI_execute_plan_with_paramlist'] = (a0, a1, a2, a3) => (_SPI_execute_plan_with_paramlist = Module['_SPI_execute_plan_with_paramlist'] = wasmExports['SPI_execute_plan_with_paramlist'])(a0, a1, a2, a3);
var _SPI_prepare = Module['_SPI_prepare'] = (a0, a1, a2) => (_SPI_prepare = Module['_SPI_prepare'] = wasmExports['SPI_prepare'])(a0, a1, a2);
var _SPI_prepare_extended = Module['_SPI_prepare_extended'] = (a0, a1) => (_SPI_prepare_extended = Module['_SPI_prepare_extended'] = wasmExports['SPI_prepare_extended'])(a0, a1);
var _SPI_keepplan = Module['_SPI_keepplan'] = (a0) => (_SPI_keepplan = Module['_SPI_keepplan'] = wasmExports['SPI_keepplan'])(a0);
var _MemoryContextSetParent = Module['_MemoryContextSetParent'] = (a0, a1) => (_MemoryContextSetParent = Module['_MemoryContextSetParent'] = wasmExports['MemoryContextSetParent'])(a0, a1);
var _SPI_freeplan = Module['_SPI_freeplan'] = (a0) => (_SPI_freeplan = Module['_SPI_freeplan'] = wasmExports['SPI_freeplan'])(a0);
var _SPI_copytuple = Module['_SPI_copytuple'] = (a0) => (_SPI_copytuple = Module['_SPI_copytuple'] = wasmExports['SPI_copytuple'])(a0);
var _SPI_returntuple = Module['_SPI_returntuple'] = (a0, a1) => (_SPI_returntuple = Module['_SPI_returntuple'] = wasmExports['SPI_returntuple'])(a0, a1);
var _SPI_fnumber = Module['_SPI_fnumber'] = (a0, a1) => (_SPI_fnumber = Module['_SPI_fnumber'] = wasmExports['SPI_fnumber'])(a0, a1);
var _SPI_fname = Module['_SPI_fname'] = (a0, a1) => (_SPI_fname = Module['_SPI_fname'] = wasmExports['SPI_fname'])(a0, a1);
var _SPI_getvalue = Module['_SPI_getvalue'] = (a0, a1, a2) => (_SPI_getvalue = Module['_SPI_getvalue'] = wasmExports['SPI_getvalue'])(a0, a1, a2);
var _SPI_getbinval = Module['_SPI_getbinval'] = (a0, a1, a2, a3) => (_SPI_getbinval = Module['_SPI_getbinval'] = wasmExports['SPI_getbinval'])(a0, a1, a2, a3);
var _SPI_gettype = Module['_SPI_gettype'] = (a0, a1) => (_SPI_gettype = Module['_SPI_gettype'] = wasmExports['SPI_gettype'])(a0, a1);
var _SPI_gettypeid = Module['_SPI_gettypeid'] = (a0, a1) => (_SPI_gettypeid = Module['_SPI_gettypeid'] = wasmExports['SPI_gettypeid'])(a0, a1);
var _SPI_getrelname = Module['_SPI_getrelname'] = (a0) => (_SPI_getrelname = Module['_SPI_getrelname'] = wasmExports['SPI_getrelname'])(a0);
var _SPI_palloc = Module['_SPI_palloc'] = (a0) => (_SPI_palloc = Module['_SPI_palloc'] = wasmExports['SPI_palloc'])(a0);
var _SPI_datumTransfer = Module['_SPI_datumTransfer'] = (a0, a1, a2) => (_SPI_datumTransfer = Module['_SPI_datumTransfer'] = wasmExports['SPI_datumTransfer'])(a0, a1, a2);
var _datumTransfer = Module['_datumTransfer'] = (a0, a1, a2) => (_datumTransfer = Module['_datumTransfer'] = wasmExports['datumTransfer'])(a0, a1, a2);
var _SPI_cursor_open_with_paramlist = Module['_SPI_cursor_open_with_paramlist'] = (a0, a1, a2, a3) => (_SPI_cursor_open_with_paramlist = Module['_SPI_cursor_open_with_paramlist'] = wasmExports['SPI_cursor_open_with_paramlist'])(a0, a1, a2, a3);
var _SPI_cursor_parse_open = Module['_SPI_cursor_parse_open'] = (a0, a1, a2) => (_SPI_cursor_parse_open = Module['_SPI_cursor_parse_open'] = wasmExports['SPI_cursor_parse_open'])(a0, a1, a2);
var _SPI_cursor_find = Module['_SPI_cursor_find'] = (a0) => (_SPI_cursor_find = Module['_SPI_cursor_find'] = wasmExports['SPI_cursor_find'])(a0);
var _SPI_cursor_fetch = Module['_SPI_cursor_fetch'] = (a0, a1, a2) => (_SPI_cursor_fetch = Module['_SPI_cursor_fetch'] = wasmExports['SPI_cursor_fetch'])(a0, a1, a2);
var _SPI_scroll_cursor_fetch = Module['_SPI_scroll_cursor_fetch'] = (a0, a1, a2) => (_SPI_scroll_cursor_fetch = Module['_SPI_scroll_cursor_fetch'] = wasmExports['SPI_scroll_cursor_fetch'])(a0, a1, a2);
var _SPI_scroll_cursor_move = Module['_SPI_scroll_cursor_move'] = (a0, a1, a2) => (_SPI_scroll_cursor_move = Module['_SPI_scroll_cursor_move'] = wasmExports['SPI_scroll_cursor_move'])(a0, a1, a2);
var _SPI_cursor_close = Module['_SPI_cursor_close'] = (a0) => (_SPI_cursor_close = Module['_SPI_cursor_close'] = wasmExports['SPI_cursor_close'])(a0);
var _SPI_result_code_string = Module['_SPI_result_code_string'] = (a0) => (_SPI_result_code_string = Module['_SPI_result_code_string'] = wasmExports['SPI_result_code_string'])(a0);
var _SPI_plan_get_plan_sources = Module['_SPI_plan_get_plan_sources'] = (a0) => (_SPI_plan_get_plan_sources = Module['_SPI_plan_get_plan_sources'] = wasmExports['SPI_plan_get_plan_sources'])(a0);
var _SPI_plan_get_cached_plan = Module['_SPI_plan_get_cached_plan'] = (a0) => (_SPI_plan_get_cached_plan = Module['_SPI_plan_get_cached_plan'] = wasmExports['SPI_plan_get_cached_plan'])(a0);
var _SPI_register_trigger_data = Module['_SPI_register_trigger_data'] = (a0) => (_SPI_register_trigger_data = Module['_SPI_register_trigger_data'] = wasmExports['SPI_register_trigger_data'])(a0);
var _AddWaitEventToSet = Module['_AddWaitEventToSet'] = (a0, a1, a2, a3, a4) => (_AddWaitEventToSet = Module['_AddWaitEventToSet'] = wasmExports['AddWaitEventToSet'])(a0, a1, a2, a3, a4);
var _GetNumRegisteredWaitEvents = Module['_GetNumRegisteredWaitEvents'] = (a0) => (_GetNumRegisteredWaitEvents = Module['_GetNumRegisteredWaitEvents'] = wasmExports['GetNumRegisteredWaitEvents'])(a0);
var _construct_md_array = Module['_construct_md_array'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_construct_md_array = Module['_construct_md_array'] = wasmExports['construct_md_array'])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
var _construct_empty_array = Module['_construct_empty_array'] = (a0) => (_construct_empty_array = Module['_construct_empty_array'] = wasmExports['construct_empty_array'])(a0);
var _expanded_record_fetch_tupdesc = Module['_expanded_record_fetch_tupdesc'] = (a0) => (_expanded_record_fetch_tupdesc = Module['_expanded_record_fetch_tupdesc'] = wasmExports['expanded_record_fetch_tupdesc'])(a0);
var _expanded_record_fetch_field = Module['_expanded_record_fetch_field'] = (a0, a1, a2) => (_expanded_record_fetch_field = Module['_expanded_record_fetch_field'] = wasmExports['expanded_record_fetch_field'])(a0, a1, a2);
var _InstrAlloc = Module['_InstrAlloc'] = (a0, a1, a2) => (_InstrAlloc = Module['_InstrAlloc'] = wasmExports['InstrAlloc'])(a0, a1, a2);
var _standard_ExecutorStart = Module['_standard_ExecutorStart'] = (a0, a1) => (_standard_ExecutorStart = Module['_standard_ExecutorStart'] = wasmExports['standard_ExecutorStart'])(a0, a1);
var _get_rel_namespace = Module['_get_rel_namespace'] = (a0) => (_get_rel_namespace = Module['_get_rel_namespace'] = wasmExports['get_rel_namespace'])(a0);
var _standard_ExecutorRun = Module['_standard_ExecutorRun'] = (a0, a1, a2, a3) => (_standard_ExecutorRun = Module['_standard_ExecutorRun'] = wasmExports['standard_ExecutorRun'])(a0, a1, a2, a3);
var _standard_ExecutorFinish = Module['_standard_ExecutorFinish'] = (a0) => (_standard_ExecutorFinish = Module['_standard_ExecutorFinish'] = wasmExports['standard_ExecutorFinish'])(a0);
var _standard_ExecutorEnd = Module['_standard_ExecutorEnd'] = (a0) => (_standard_ExecutorEnd = Module['_standard_ExecutorEnd'] = wasmExports['standard_ExecutorEnd'])(a0);
var _get_rel_relkind = Module['_get_rel_relkind'] = (a0) => (_get_rel_relkind = Module['_get_rel_relkind'] = wasmExports['get_rel_relkind'])(a0);
var _get_partition_ancestors = Module['_get_partition_ancestors'] = (a0) => (_get_partition_ancestors = Module['_get_partition_ancestors'] = wasmExports['get_partition_ancestors'])(a0);
var _MakeTupleTableSlot = Module['_MakeTupleTableSlot'] = (a0, a1) => (_MakeTupleTableSlot = Module['_MakeTupleTableSlot'] = wasmExports['MakeTupleTableSlot'])(a0, a1);
var _ExecPrepareExpr = Module['_ExecPrepareExpr'] = (a0, a1) => (_ExecPrepareExpr = Module['_ExecPrepareExpr'] = wasmExports['ExecPrepareExpr'])(a0, a1);
var _InputFunctionCall = Module['_InputFunctionCall'] = (a0, a1, a2, a3) => (_InputFunctionCall = Module['_InputFunctionCall'] = wasmExports['InputFunctionCall'])(a0, a1, a2, a3);
var _SetTuplestoreDestReceiverParams = Module['_SetTuplestoreDestReceiverParams'] = (a0, a1, a2, a3, a4, a5) => (_SetTuplestoreDestReceiverParams = Module['_SetTuplestoreDestReceiverParams'] = wasmExports['SetTuplestoreDestReceiverParams'])(a0, a1, a2, a3, a4, a5);
var _InstrUpdateTupleCount = Module['_InstrUpdateTupleCount'] = (a0, a1) => (_InstrUpdateTupleCount = Module['_InstrUpdateTupleCount'] = wasmExports['InstrUpdateTupleCount'])(a0, a1);
var _get_call_expr_argtype = Module['_get_call_expr_argtype'] = (a0, a1) => (_get_call_expr_argtype = Module['_get_call_expr_argtype'] = wasmExports['get_call_expr_argtype'])(a0, a1);
var _MemoryContextSetIdentifier = Module['_MemoryContextSetIdentifier'] = (a0, a1) => (_MemoryContextSetIdentifier = Module['_MemoryContextSetIdentifier'] = wasmExports['MemoryContextSetIdentifier'])(a0, a1);
var _get_typtype = Module['_get_typtype'] = (a0) => (_get_typtype = Module['_get_typtype'] = wasmExports['get_typtype'])(a0);
var _coerce_to_target_type = Module['_coerce_to_target_type'] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_coerce_to_target_type = Module['_coerce_to_target_type'] = wasmExports['coerce_to_target_type'])(a0, a1, a2, a3, a4, a5, a6, a7);
var _ExecInitExprWithParams = Module['_ExecInitExprWithParams'] = (a0, a1) => (_ExecInitExprWithParams = Module['_ExecInitExprWithParams'] = wasmExports['ExecInitExprWithParams'])(a0, a1);
var _tuplesort_reset = Module['_tuplesort_reset'] = (a0) => (_tuplesort_reset = Module['_tuplesort_reset'] = wasmExports['tuplesort_reset'])(a0);
var _get_attstatsslot = Module['_get_attstatsslot'] = (a0, a1, a2, a3, a4) => (_get_attstatsslot = Module['_get_attstatsslot'] = wasmExports['get_attstatsslot'])(a0, a1, a2, a3, a4);
var _free_attstatsslot = Module['_free_attstatsslot'] = (a0) => (_free_attstatsslot = Module['_free_attstatsslot'] = wasmExports['free_attstatsslot'])(a0);
var _ExprEvalPushStep = Module['_ExprEvalPushStep'] = (a0, a1) => (_ExprEvalPushStep = Module['_ExprEvalPushStep'] = wasmExports['ExprEvalPushStep'])(a0, a1);
var _get_element_type = Module['_get_element_type'] = (a0) => (_get_element_type = Module['_get_element_type'] = wasmExports['get_element_type'])(a0);
var _textToQualifiedNameList = Module['_textToQualifiedNameList'] = (a0) => (_textToQualifiedNameList = Module['_textToQualifiedNameList'] = wasmExports['textToQualifiedNameList'])(a0);
var _DirectFunctionCall4Coll = Module['_DirectFunctionCall4Coll'] = (a0, a1, a2, a3, a4, a5) => (_DirectFunctionCall4Coll = Module['_DirectFunctionCall4Coll'] = wasmExports['DirectFunctionCall4Coll'])(a0, a1, a2, a3, a4, a5);
var _lookup_ts_dictionary_cache = Module['_lookup_ts_dictionary_cache'] = (a0) => (_lookup_ts_dictionary_cache = Module['_lookup_ts_dictionary_cache'] = wasmExports['lookup_ts_dictionary_cache'])(a0);
var _construct_array_builtin = Module['_construct_array_builtin'] = (a0, a1, a2) => (_construct_array_builtin = Module['_construct_array_builtin'] = wasmExports['construct_array_builtin'])(a0, a1, a2);
var _tsearch_readline_begin = Module['_tsearch_readline_begin'] = (a0, a1) => (_tsearch_readline_begin = Module['_tsearch_readline_begin'] = wasmExports['tsearch_readline_begin'])(a0, a1);
var _tsearch_readline = Module['_tsearch_readline'] = (a0) => (_tsearch_readline = Module['_tsearch_readline'] = wasmExports['tsearch_readline'])(a0);
var _pg_mblen = Module['_pg_mblen'] = (a0) => (_pg_mblen = Module['_pg_mblen'] = wasmExports['pg_mblen'])(a0);
var _t_isspace = Module['_t_isspace'] = (a0) => (_t_isspace = Module['_t_isspace'] = wasmExports['t_isspace'])(a0);
var _lowerstr = Module['_lowerstr'] = (a0) => (_lowerstr = Module['_lowerstr'] = wasmExports['lowerstr'])(a0);
var _tsearch_readline_end = Module['_tsearch_readline_end'] = (a0) => (_tsearch_readline_end = Module['_tsearch_readline_end'] = wasmExports['tsearch_readline_end'])(a0);
var _pg_mb2wchar_with_len = Module['_pg_mb2wchar_with_len'] = (a0, a1, a2) => (_pg_mb2wchar_with_len = Module['_pg_mb2wchar_with_len'] = wasmExports['pg_mb2wchar_with_len'])(a0, a1, a2);
var _pg_regcomp = Module['_pg_regcomp'] = (a0, a1, a2, a3, a4) => (_pg_regcomp = Module['_pg_regcomp'] = wasmExports['pg_regcomp'])(a0, a1, a2, a3, a4);
var _pg_regerror = Module['_pg_regerror'] = (a0, a1, a2, a3) => (_pg_regerror = Module['_pg_regerror'] = wasmExports['pg_regerror'])(a0, a1, a2, a3);
var _t_isdigit = Module['_t_isdigit'] = (a0) => (_t_isdigit = Module['_t_isdigit'] = wasmExports['t_isdigit'])(a0);
var _pnstrdup = Module['_pnstrdup'] = (a0, a1) => (_pnstrdup = Module['_pnstrdup'] = wasmExports['pnstrdup'])(a0, a1);
var _strcat = Module['_strcat'] = (a0, a1) => (_strcat = Module['_strcat'] = wasmExports['strcat'])(a0, a1);
var _t_isalnum = Module['_t_isalnum'] = (a0) => (_t_isalnum = Module['_t_isalnum'] = wasmExports['t_isalnum'])(a0);
var _isalnum = Module['_isalnum'] = (a0) => (_isalnum = Module['_isalnum'] = wasmExports['isalnum'])(a0);
var _pg_any_to_server = Module['_pg_any_to_server'] = (a0, a1, a2) => (_pg_any_to_server = Module['_pg_any_to_server'] = wasmExports['pg_any_to_server'])(a0, a1, a2);
var _lowerstr_with_len = Module['_lowerstr_with_len'] = (a0, a1) => (_lowerstr_with_len = Module['_lowerstr_with_len'] = wasmExports['lowerstr_with_len'])(a0, a1);
var _pg_database_encoding_max_length = Module['_pg_database_encoding_max_length'] = () => (_pg_database_encoding_max_length = Module['_pg_database_encoding_max_length'] = wasmExports['pg_database_encoding_max_length'])();
var _tolower = Module['_tolower'] = (a0) => (_tolower = Module['_tolower'] = wasmExports['tolower'])(a0);
var _get_tsearch_config_filename = Module['_get_tsearch_config_filename'] = (a0, a1) => (_get_tsearch_config_filename = Module['_get_tsearch_config_filename'] = wasmExports['get_tsearch_config_filename'])(a0, a1);
var _readstoplist = Module['_readstoplist'] = (a0, a1, a2) => (_readstoplist = Module['_readstoplist'] = wasmExports['readstoplist'])(a0, a1, a2);
var _searchstoplist = Module['_searchstoplist'] = (a0, a1) => (_searchstoplist = Module['_searchstoplist'] = wasmExports['searchstoplist'])(a0, a1);
var _isxdigit = Module['_isxdigit'] = (a0) => (_isxdigit = Module['_isxdigit'] = wasmExports['isxdigit'])(a0);
var _get_restriction_variable = Module['_get_restriction_variable'] = (a0, a1, a2, a3, a4, a5) => (_get_restriction_variable = Module['_get_restriction_variable'] = wasmExports['get_restriction_variable'])(a0, a1, a2, a3, a4, a5);
var _parser_errposition = Module['_parser_errposition'] = (a0, a1) => (_parser_errposition = Module['_parser_errposition'] = wasmExports['parser_errposition'])(a0, a1);
var _bit_in = Module['_bit_in'] = (a0) => (_bit_in = Module['_bit_in'] = wasmExports['bit_in'])(a0);
var _transformExpr = Module['_transformExpr'] = (a0, a1, a2) => (_transformExpr = Module['_transformExpr'] = wasmExports['transformExpr'])(a0, a1, a2);
var _NameListToString = Module['_NameListToString'] = (a0) => (_NameListToString = Module['_NameListToString'] = wasmExports['NameListToString'])(a0);
var _get_base_element_type = Module['_get_base_element_type'] = (a0) => (_get_base_element_type = Module['_get_base_element_type'] = wasmExports['get_base_element_type'])(a0);
var _get_attname = Module['_get_attname'] = (a0, a1, a2) => (_get_attname = Module['_get_attname'] = wasmExports['get_attname'])(a0, a1, a2);
var _makeRangeVarFromNameList = Module['_makeRangeVarFromNameList'] = (a0) => (_makeRangeVarFromNameList = Module['_makeRangeVarFromNameList'] = wasmExports['makeRangeVarFromNameList'])(a0);
var _LookupTypeName = Module['_LookupTypeName'] = (a0, a1, a2, a3) => (_LookupTypeName = Module['_LookupTypeName'] = wasmExports['LookupTypeName'])(a0, a1, a2, a3);
var _get_collation_oid = Module['_get_collation_oid'] = (a0, a1) => (_get_collation_oid = Module['_get_collation_oid'] = wasmExports['get_collation_oid'])(a0, a1);
var _typeStringToTypeName = Module['_typeStringToTypeName'] = (a0, a1) => (_typeStringToTypeName = Module['_typeStringToTypeName'] = wasmExports['typeStringToTypeName'])(a0, a1);
var _errsave_start = Module['_errsave_start'] = (a0, a1) => (_errsave_start = Module['_errsave_start'] = wasmExports['errsave_start'])(a0, a1);
var _errsave_finish = Module['_errsave_finish'] = (a0, a1, a2, a3) => (_errsave_finish = Module['_errsave_finish'] = wasmExports['errsave_finish'])(a0, a1, a2, a3);
var _core_yylex = Module['_core_yylex'] = (a0, a1, a2) => (_core_yylex = Module['_core_yylex'] = wasmExports['core_yylex'])(a0, a1, a2);
var _scanner_init = Module['_scanner_init'] = (a0, a1, a2, a3) => (_scanner_init = Module['_scanner_init'] = wasmExports['scanner_init'])(a0, a1, a2, a3);
var _scanner_finish = Module['_scanner_finish'] = (a0) => (_scanner_finish = Module['_scanner_finish'] = wasmExports['scanner_finish'])(a0);
var _varstr_levenshtein_less_equal = Module['_varstr_levenshtein_less_equal'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_varstr_levenshtein_less_equal = Module['_varstr_levenshtein_less_equal'] = wasmExports['varstr_levenshtein_less_equal'])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
var _toupper = Module['_toupper'] = (a0) => (_toupper = Module['_toupper'] = wasmExports['toupper'])(a0);
var _pg_reg_getinitialstate = Module['_pg_reg_getinitialstate'] = (a0) => (_pg_reg_getinitialstate = Module['_pg_reg_getinitialstate'] = wasmExports['pg_reg_getinitialstate'])(a0);
var _pg_reg_getfinalstate = Module['_pg_reg_getfinalstate'] = (a0) => (_pg_reg_getfinalstate = Module['_pg_reg_getfinalstate'] = wasmExports['pg_reg_getfinalstate'])(a0);
var _pg_reg_getnumoutarcs = Module['_pg_reg_getnumoutarcs'] = (a0, a1) => (_pg_reg_getnumoutarcs = Module['_pg_reg_getnumoutarcs'] = wasmExports['pg_reg_getnumoutarcs'])(a0, a1);
var _pg_reg_getoutarcs = Module['_pg_reg_getoutarcs'] = (a0, a1, a2, a3) => (_pg_reg_getoutarcs = Module['_pg_reg_getoutarcs'] = wasmExports['pg_reg_getoutarcs'])(a0, a1, a2, a3);
var _pg_reg_getnumcolors = Module['_pg_reg_getnumcolors'] = (a0) => (_pg_reg_getnumcolors = Module['_pg_reg_getnumcolors'] = wasmExports['pg_reg_getnumcolors'])(a0);
var _pg_reg_colorisbegin = Module['_pg_reg_colorisbegin'] = (a0, a1) => (_pg_reg_colorisbegin = Module['_pg_reg_colorisbegin'] = wasmExports['pg_reg_colorisbegin'])(a0, a1);
var _pg_reg_colorisend = Module['_pg_reg_colorisend'] = (a0, a1) => (_pg_reg_colorisend = Module['_pg_reg_colorisend'] = wasmExports['pg_reg_colorisend'])(a0, a1);
var _pg_reg_getnumcharacters = Module['_pg_reg_getnumcharacters'] = (a0, a1) => (_pg_reg_getnumcharacters = Module['_pg_reg_getnumcharacters'] = wasmExports['pg_reg_getnumcharacters'])(a0, a1);
var _pg_reg_getcharacters = Module['_pg_reg_getcharacters'] = (a0, a1, a2, a3) => (_pg_reg_getcharacters = Module['_pg_reg_getcharacters'] = wasmExports['pg_reg_getcharacters'])(a0, a1, a2, a3);
var _superuser = Module['_superuser'] = () => (_superuser = Module['_superuser'] = wasmExports['superuser'])();
var _CheckFunctionValidatorAccess = Module['_CheckFunctionValidatorAccess'] = (a0, a1) => (_CheckFunctionValidatorAccess = Module['_CheckFunctionValidatorAccess'] = wasmExports['CheckFunctionValidatorAccess'])(a0, a1);
var _function_parse_error_transpose = Module['_function_parse_error_transpose'] = (a0) => (_function_parse_error_transpose = Module['_function_parse_error_transpose'] = wasmExports['function_parse_error_transpose'])(a0);
var _getinternalerrposition = Module['_getinternalerrposition'] = () => (_getinternalerrposition = Module['_getinternalerrposition'] = wasmExports['getinternalerrposition'])();
var _get_extension_oid = Module['_get_extension_oid'] = (a0, a1) => (_get_extension_oid = Module['_get_extension_oid'] = wasmExports['get_extension_oid'])(a0, a1);
var _get_role_oid = Module['_get_role_oid'] = (a0, a1) => (_get_role_oid = Module['_get_role_oid'] = wasmExports['get_role_oid'])(a0, a1);
var _GetPublicationByName = Module['_GetPublicationByName'] = (a0, a1) => (_GetPublicationByName = Module['_GetPublicationByName'] = wasmExports['GetPublicationByName'])(a0, a1);
var _format_type_extended = Module['_format_type_extended'] = (a0, a1, a2) => (_format_type_extended = Module['_format_type_extended'] = wasmExports['format_type_extended'])(a0, a1, a2);
var _RelationIsVisible = Module['_RelationIsVisible'] = (a0) => (_RelationIsVisible = Module['_RelationIsVisible'] = wasmExports['RelationIsVisible'])(a0);
var _get_namespace_name_or_temp = Module['_get_namespace_name_or_temp'] = (a0) => (_get_namespace_name_or_temp = Module['_get_namespace_name_or_temp'] = wasmExports['get_namespace_name_or_temp'])(a0);
var _getExtensionOfObject = Module['_getExtensionOfObject'] = (a0, a1) => (_getExtensionOfObject = Module['_getExtensionOfObject'] = wasmExports['getExtensionOfObject'])(a0, a1);
var _RelnameGetRelid = Module['_RelnameGetRelid'] = (a0) => (_RelnameGetRelid = Module['_RelnameGetRelid'] = wasmExports['RelnameGetRelid'])(a0);
var _get_func_arg_info = Module['_get_func_arg_info'] = (a0, a1, a2, a3) => (_get_func_arg_info = Module['_get_func_arg_info'] = wasmExports['get_func_arg_info'])(a0, a1, a2, a3);
var _pg_encoding_to_char_private = Module['_pg_encoding_to_char_private'] = (a0) => (_pg_encoding_to_char_private = Module['_pg_encoding_to_char_private'] = wasmExports['pg_encoding_to_char_private'])(a0);
var _is_publishable_relation = Module['_is_publishable_relation'] = (a0) => (_is_publishable_relation = Module['_is_publishable_relation'] = wasmExports['is_publishable_relation'])(a0);
var _GetTopMostAncestorInPublication = Module['_GetTopMostAncestorInPublication'] = (a0, a1, a2) => (_GetTopMostAncestorInPublication = Module['_GetTopMostAncestorInPublication'] = wasmExports['GetTopMostAncestorInPublication'])(a0, a1, a2);
var _GetRelationPublications = Module['_GetRelationPublications'] = (a0) => (_GetRelationPublications = Module['_GetRelationPublications'] = wasmExports['GetRelationPublications'])(a0);
var _GetSchemaPublications = Module['_GetSchemaPublications'] = (a0) => (_GetSchemaPublications = Module['_GetSchemaPublications'] = wasmExports['GetSchemaPublications'])(a0);
var _pub_collist_to_bitmapset = Module['_pub_collist_to_bitmapset'] = (a0, a1, a2) => (_pub_collist_to_bitmapset = Module['_pub_collist_to_bitmapset'] = wasmExports['pub_collist_to_bitmapset'])(a0, a1, a2);
var _get_rel_relispartition = Module['_get_rel_relispartition'] = (a0) => (_get_rel_relispartition = Module['_get_rel_relispartition'] = wasmExports['get_rel_relispartition'])(a0);
var _construct_array = Module['_construct_array'] = (a0, a1, a2, a3, a4, a5) => (_construct_array = Module['_construct_array'] = wasmExports['construct_array'])(a0, a1, a2, a3, a4, a5);
var _smgrtruncate = Module['_smgrtruncate'] = (a0, a1, a2, a3) => (_smgrtruncate = Module['_smgrtruncate'] = wasmExports['smgrtruncate'])(a0, a1, a2, a3);
var _smgrread = Module['_smgrread'] = (a0, a1, a2, a3) => (_smgrread = Module['_smgrread'] = wasmExports['smgrread'])(a0, a1, a2, a3);
var _pairingheap_free = Module['_pairingheap_free'] = (a0) => (_pairingheap_free = Module['_pairingheap_free'] = wasmExports['pairingheap_free'])(a0);
var _bloom_create = Module['_bloom_create'] = (a0, a1, a2) => (_bloom_create = Module['_bloom_create'] = wasmExports['bloom_create'])(a0, a1, a2);
var _bloom_free = Module['_bloom_free'] = (a0) => (_bloom_free = Module['_bloom_free'] = wasmExports['bloom_free'])(a0);
var _bloom_add_element = Module['_bloom_add_element'] = (a0, a1, a2) => (_bloom_add_element = Module['_bloom_add_element'] = wasmExports['bloom_add_element'])(a0, a1, a2);
var _bloom_lacks_element = Module['_bloom_lacks_element'] = (a0, a1, a2) => (_bloom_lacks_element = Module['_bloom_lacks_element'] = wasmExports['bloom_lacks_element'])(a0, a1, a2);
var _bloom_prop_bits_set = Module['_bloom_prop_bits_set'] = (a0) => (_bloom_prop_bits_set = Module['_bloom_prop_bits_set'] = wasmExports['bloom_prop_bits_set'])(a0);
var _pg_char_to_encoding_private = Module['_pg_char_to_encoding_private'] = (a0) => (_pg_char_to_encoding_private = Module['_pg_char_to_encoding_private'] = wasmExports['pg_char_to_encoding_private'])(a0);
var _EndCopyFrom = Module['_EndCopyFrom'] = (a0) => (_EndCopyFrom = Module['_EndCopyFrom'] = wasmExports['EndCopyFrom'])(a0);
var _ProcessCopyOptions = Module['_ProcessCopyOptions'] = (a0, a1, a2, a3) => (_ProcessCopyOptions = Module['_ProcessCopyOptions'] = wasmExports['ProcessCopyOptions'])(a0, a1, a2, a3);
var _namein = Module['_namein'] = (a0) => (_namein = Module['_namein'] = wasmExports['namein'])(a0);
var _canonicalize_path = Module['_canonicalize_path'] = (a0) => (_canonicalize_path = Module['_canonicalize_path'] = wasmExports['canonicalize_path'])(a0);
var _path_is_prefix_of_path = Module['_path_is_prefix_of_path'] = (a0, a1) => (_path_is_prefix_of_path = Module['_path_is_prefix_of_path'] = wasmExports['path_is_prefix_of_path'])(a0, a1);
var _BlockSampler_Init = Module['_BlockSampler_Init'] = (a0, a1, a2, a3) => (_BlockSampler_Init = Module['_BlockSampler_Init'] = wasmExports['BlockSampler_Init'])(a0, a1, a2, a3);
var _reservoir_init_selection_state = Module['_reservoir_init_selection_state'] = (a0, a1) => (_reservoir_init_selection_state = Module['_reservoir_init_selection_state'] = wasmExports['reservoir_init_selection_state'])(a0, a1);
var _BlockSampler_HasMore = Module['_BlockSampler_HasMore'] = (a0) => (_BlockSampler_HasMore = Module['_BlockSampler_HasMore'] = wasmExports['BlockSampler_HasMore'])(a0);
var _BlockSampler_Next = Module['_BlockSampler_Next'] = (a0) => (_BlockSampler_Next = Module['_BlockSampler_Next'] = wasmExports['BlockSampler_Next'])(a0);
var _reservoir_get_next_S = Module['_reservoir_get_next_S'] = (a0, a1, a2) => (_reservoir_get_next_S = Module['_reservoir_get_next_S'] = wasmExports['reservoir_get_next_S'])(a0, a1, a2);
var _sampler_random_fract = Module['_sampler_random_fract'] = (a0) => (_sampler_random_fract = Module['_sampler_random_fract'] = wasmExports['sampler_random_fract'])(a0);
var _wasm_OpenPipeStream = Module['_wasm_OpenPipeStream'] = (a0, a1) => (_wasm_OpenPipeStream = Module['_wasm_OpenPipeStream'] = wasmExports['wasm_OpenPipeStream'])(a0, a1);
var _pg_is_ascii = Module['_pg_is_ascii'] = (a0) => (_pg_is_ascii = Module['_pg_is_ascii'] = wasmExports['pg_is_ascii'])(a0);
var _pg_get_encoding_from_locale = Module['_pg_get_encoding_from_locale'] = (a0, a1) => (_pg_get_encoding_from_locale = Module['_pg_get_encoding_from_locale'] = wasmExports['pg_get_encoding_from_locale'])(a0, a1);
var _ClosePipeStream = Module['_ClosePipeStream'] = (a0) => (_ClosePipeStream = Module['_ClosePipeStream'] = wasmExports['ClosePipeStream'])(a0);
var _set_config_option = Module['_set_config_option'] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_set_config_option = Module['_set_config_option'] = wasmExports['set_config_option'])(a0, a1, a2, a3, a4, a5, a6, a7);
var _defGetStreamingMode = Module['_defGetStreamingMode'] = (a0) => (_defGetStreamingMode = Module['_defGetStreamingMode'] = wasmExports['defGetStreamingMode'])(a0);
var _Async_Notify = Module['_Async_Notify'] = (a0, a1) => (_Async_Notify = Module['_Async_Notify'] = wasmExports['Async_Notify'])(a0, a1);
var _strrchr = Module['_strrchr'] = (a0, a1) => (_strrchr = Module['_strrchr'] = wasmExports['strrchr'])(a0, a1);
var _plain_crypt_verify = Module['_plain_crypt_verify'] = (a0, a1, a2, a3) => (_plain_crypt_verify = Module['_plain_crypt_verify'] = wasmExports['plain_crypt_verify'])(a0, a1, a2, a3);
var _nextval = Module['_nextval'] = (a0) => (_nextval = Module['_nextval'] = wasmExports['nextval'])(a0);
var _CopyFromErrorCallback = Module['_CopyFromErrorCallback'] = (a0) => (_CopyFromErrorCallback = Module['_CopyFromErrorCallback'] = wasmExports['CopyFromErrorCallback'])(a0);
var _NextCopyFrom = Module['_NextCopyFrom'] = (a0, a1, a2, a3) => (_NextCopyFrom = Module['_NextCopyFrom'] = wasmExports['NextCopyFrom'])(a0, a1, a2, a3);
var _MemoryContextDeleteChildren = Module['_MemoryContextDeleteChildren'] = (a0) => (_MemoryContextDeleteChildren = Module['_MemoryContextDeleteChildren'] = wasmExports['MemoryContextDeleteChildren'])(a0);
var _ExplainBeginOutput = Module['_ExplainBeginOutput'] = (a0) => (_ExplainBeginOutput = Module['_ExplainBeginOutput'] = wasmExports['ExplainBeginOutput'])(a0);
var _NewExplainState = Module['_NewExplainState'] = () => (_NewExplainState = Module['_NewExplainState'] = wasmExports['NewExplainState'])();
var _ExplainEndOutput = Module['_ExplainEndOutput'] = (a0) => (_ExplainEndOutput = Module['_ExplainEndOutput'] = wasmExports['ExplainEndOutput'])(a0);
var _appendStringInfoSpaces = Module['_appendStringInfoSpaces'] = (a0, a1) => (_appendStringInfoSpaces = Module['_appendStringInfoSpaces'] = wasmExports['appendStringInfoSpaces'])(a0, a1);
var _escape_json = Module['_escape_json'] = (a0, a1) => (_escape_json = Module['_escape_json'] = wasmExports['escape_json'])(a0, a1);
var _ExplainPrintPlan = Module['_ExplainPrintPlan'] = (a0, a1) => (_ExplainPrintPlan = Module['_ExplainPrintPlan'] = wasmExports['ExplainPrintPlan'])(a0, a1);
var _ExplainPrintTriggers = Module['_ExplainPrintTriggers'] = (a0, a1) => (_ExplainPrintTriggers = Module['_ExplainPrintTriggers'] = wasmExports['ExplainPrintTriggers'])(a0, a1);
var _ExplainPrintJITSummary = Module['_ExplainPrintJITSummary'] = (a0, a1) => (_ExplainPrintJITSummary = Module['_ExplainPrintJITSummary'] = wasmExports['ExplainPrintJITSummary'])(a0, a1);
var _ExplainPropertyInteger = Module['_ExplainPropertyInteger'] = (a0, a1, a2, a3) => (_ExplainPropertyInteger = Module['_ExplainPropertyInteger'] = wasmExports['ExplainPropertyInteger'])(a0, a1, a2, a3);
var _ExplainQueryText = Module['_ExplainQueryText'] = (a0, a1) => (_ExplainQueryText = Module['_ExplainQueryText'] = wasmExports['ExplainQueryText'])(a0, a1);
var _ExplainPropertyText = Module['_ExplainPropertyText'] = (a0, a1, a2) => (_ExplainPropertyText = Module['_ExplainPropertyText'] = wasmExports['ExplainPropertyText'])(a0, a1, a2);
var _ExplainQueryParameters = Module['_ExplainQueryParameters'] = (a0, a1, a2) => (_ExplainQueryParameters = Module['_ExplainQueryParameters'] = wasmExports['ExplainQueryParameters'])(a0, a1, a2);
var _get_func_namespace = Module['_get_func_namespace'] = (a0) => (_get_func_namespace = Module['_get_func_namespace'] = wasmExports['get_func_namespace'])(a0);
var _strtod = Module['_strtod'] = (a0, a1) => (_strtod = Module['_strtod'] = wasmExports['strtod'])(a0, a1);
var _pg_server_to_any = Module['_pg_server_to_any'] = (a0, a1, a2) => (_pg_server_to_any = Module['_pg_server_to_any'] = wasmExports['pg_server_to_any'])(a0, a1, a2);
var _pg_encoding_mblen = Module['_pg_encoding_mblen'] = (a0, a1) => (_pg_encoding_mblen = Module['_pg_encoding_mblen'] = wasmExports['pg_encoding_mblen'])(a0, a1);
var _pg_encoding_max_length = Module['_pg_encoding_max_length'] = (a0) => (_pg_encoding_max_length = Module['_pg_encoding_max_length'] = wasmExports['pg_encoding_max_length'])(a0);
var _report_invalid_encoding = Module['_report_invalid_encoding'] = (a0, a1, a2) => (_report_invalid_encoding = Module['_report_invalid_encoding'] = wasmExports['report_invalid_encoding'])(a0, a1, a2);
var _get_fn_expr_argtype = Module['_get_fn_expr_argtype'] = (a0, a1) => (_get_fn_expr_argtype = Module['_get_fn_expr_argtype'] = wasmExports['get_fn_expr_argtype'])(a0, a1);
var _sigaddset = Module['_sigaddset'] = (a0, a1) => (_sigaddset = Module['_sigaddset'] = wasmExports['sigaddset'])(a0, a1);
var _fsync_pgdata = Module['_fsync_pgdata'] = (a0, a1) => (_fsync_pgdata = Module['_fsync_pgdata'] = wasmExports['fsync_pgdata'])(a0, a1);
var _get_restricted_token = Module['_get_restricted_token'] = () => (_get_restricted_token = Module['_get_restricted_token'] = wasmExports['get_restricted_token'])();
var _pg_malloc = Module['_pg_malloc'] = (a0) => (_pg_malloc = Module['_pg_malloc'] = wasmExports['pg_malloc'])(a0);
var _pg_realloc = Module['_pg_realloc'] = (a0, a1) => (_pg_realloc = Module['_pg_realloc'] = wasmExports['pg_realloc'])(a0, a1);
var _pg_strdup = Module['_pg_strdup'] = (a0) => (_pg_strdup = Module['_pg_strdup'] = wasmExports['pg_strdup'])(a0);
var _simple_prompt = Module['_simple_prompt'] = (a0, a1) => (_simple_prompt = Module['_simple_prompt'] = wasmExports['simple_prompt'])(a0, a1);
var _fopen = Module['_fopen'] = (a0, a1) => (_fopen = Module['_fopen'] = wasmExports['fopen'])(a0, a1);
var _interactive_file = Module['_interactive_file'] = () => (_interactive_file = Module['_interactive_file'] = wasmExports['interactive_file'])();
var _interactive_one = Module['_interactive_one'] = () => (_interactive_one = Module['_interactive_one'] = wasmExports['interactive_one'])();
var _pq_recvbuf_fill = Module['_pq_recvbuf_fill'] = (a0, a1) => (_pq_recvbuf_fill = Module['_pq_recvbuf_fill'] = wasmExports['pq_recvbuf_fill'])(a0, a1);
var _calloc = Module['_calloc'] = (a0, a1) => (_calloc = Module['_calloc'] = wasmExports['calloc'])(a0, a1);
var _pg_shutdown = Module['_pg_shutdown'] = () => (_pg_shutdown = Module['_pg_shutdown'] = wasmExports['pg_shutdown'])();
var _errhidestmt = Module['_errhidestmt'] = (a0) => (_errhidestmt = Module['_errhidestmt'] = wasmExports['errhidestmt'])(a0);
var _interactive_write = Module['_interactive_write'] = (a0) => (_interactive_write = Module['_interactive_write'] = wasmExports['interactive_write'])(a0);
var _interactive_read = Module['_interactive_read'] = () => (_interactive_read = Module['_interactive_read'] = wasmExports['interactive_read'])();
var _standard_ProcessUtility = Module['_standard_ProcessUtility'] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_standard_ProcessUtility = Module['_standard_ProcessUtility'] = wasmExports['standard_ProcessUtility'])(a0, a1, a2, a3, a4, a5, a6, a7);
var _hash_estimate_size = Module['_hash_estimate_size'] = (a0, a1) => (_hash_estimate_size = Module['_hash_estimate_size'] = wasmExports['hash_estimate_size'])(a0, a1);
var _ShmemInitHash = Module['_ShmemInitHash'] = (a0, a1, a2, a3, a4) => (_ShmemInitHash = Module['_ShmemInitHash'] = wasmExports['ShmemInitHash'])(a0, a1, a2, a3, a4);
var _have_free_buffer = Module['_have_free_buffer'] = () => (_have_free_buffer = Module['_have_free_buffer'] = wasmExports['have_free_buffer'])();
var _LockBufHdr = Module['_LockBufHdr'] = (a0) => (_LockBufHdr = Module['_LockBufHdr'] = wasmExports['LockBufHdr'])(a0);
var _fiprintf = Module['_fiprintf'] = (a0, a1, a2) => (_fiprintf = Module['_fiprintf'] = wasmExports['fiprintf'])(a0, a1, a2);
var _fsync_fname_ext = Module['_fsync_fname_ext'] = (a0, a1, a2, a3) => (_fsync_fname_ext = Module['_fsync_fname_ext'] = wasmExports['fsync_fname_ext'])(a0, a1, a2, a3);
var _open = Module['_open'] = (a0, a1, a2) => (_open = Module['_open'] = wasmExports['open'])(a0, a1, a2);
var _AcquireExternalFD = Module['_AcquireExternalFD'] = () => (_AcquireExternalFD = Module['_AcquireExternalFD'] = wasmExports['AcquireExternalFD'])();
var _pclose = Module['_pclose'] = (a0) => (_pclose = Module['_pclose'] = wasmExports['pclose'])(a0);
var _copy_file = Module['_copy_file'] = (a0, a1) => (_copy_file = Module['_copy_file'] = wasmExports['copy_file'])(a0, a1);
var _LWLockRegisterTranche = Module['_LWLockRegisterTranche'] = (a0, a1) => (_LWLockRegisterTranche = Module['_LWLockRegisterTranche'] = wasmExports['LWLockRegisterTranche'])(a0, a1);
var _GetNamedLWLockTranche = Module['_GetNamedLWLockTranche'] = (a0) => (_GetNamedLWLockTranche = Module['_GetNamedLWLockTranche'] = wasmExports['GetNamedLWLockTranche'])(a0);
var _LWLockNewTrancheId = Module['_LWLockNewTrancheId'] = () => (_LWLockNewTrancheId = Module['_LWLockNewTrancheId'] = wasmExports['LWLockNewTrancheId'])();
var _RequestNamedLWLockTranche = Module['_RequestNamedLWLockTranche'] = (a0, a1) => (_RequestNamedLWLockTranche = Module['_RequestNamedLWLockTranche'] = wasmExports['RequestNamedLWLockTranche'])(a0, a1);
var _pg_checksum_page = Module['_pg_checksum_page'] = (a0, a1) => (_pg_checksum_page = Module['_pg_checksum_page'] = wasmExports['pg_checksum_page'])(a0, a1);
var _BackendXidGetPid = Module['_BackendXidGetPid'] = (a0) => (_BackendXidGetPid = Module['_BackendXidGetPid'] = wasmExports['BackendXidGetPid'])(a0);
var _fcntl = Module['_fcntl'] = (a0, a1, a2) => (_fcntl = Module['_fcntl'] = wasmExports['fcntl'])(a0, a1, a2);
var _poll = Module['_poll'] = (a0, a1, a2) => (_poll = Module['_poll'] = wasmExports['poll'])(a0, a1, a2);
var _RequestAddinShmemSpace = Module['_RequestAddinShmemSpace'] = (a0) => (_RequestAddinShmemSpace = Module['_RequestAddinShmemSpace'] = wasmExports['RequestAddinShmemSpace'])(a0);
var _bbsink_forward_begin_archive = Module['_bbsink_forward_begin_archive'] = (a0, a1) => (_bbsink_forward_begin_archive = Module['_bbsink_forward_begin_archive'] = wasmExports['bbsink_forward_begin_archive'])(a0, a1);
var _bbsink_forward_archive_contents = Module['_bbsink_forward_archive_contents'] = (a0, a1) => (_bbsink_forward_archive_contents = Module['_bbsink_forward_archive_contents'] = wasmExports['bbsink_forward_archive_contents'])(a0, a1);
var _bbsink_forward_end_archive = Module['_bbsink_forward_end_archive'] = (a0) => (_bbsink_forward_end_archive = Module['_bbsink_forward_end_archive'] = wasmExports['bbsink_forward_end_archive'])(a0);
var _bbsink_forward_begin_manifest = Module['_bbsink_forward_begin_manifest'] = (a0) => (_bbsink_forward_begin_manifest = Module['_bbsink_forward_begin_manifest'] = wasmExports['bbsink_forward_begin_manifest'])(a0);
var _bbsink_forward_manifest_contents = Module['_bbsink_forward_manifest_contents'] = (a0, a1) => (_bbsink_forward_manifest_contents = Module['_bbsink_forward_manifest_contents'] = wasmExports['bbsink_forward_manifest_contents'])(a0, a1);
var _bbsink_forward_end_manifest = Module['_bbsink_forward_end_manifest'] = (a0) => (_bbsink_forward_end_manifest = Module['_bbsink_forward_end_manifest'] = wasmExports['bbsink_forward_end_manifest'])(a0);
var _bbsink_forward_begin_backup = Module['_bbsink_forward_begin_backup'] = (a0) => (_bbsink_forward_begin_backup = Module['_bbsink_forward_begin_backup'] = wasmExports['bbsink_forward_begin_backup'])(a0);
var _bbsink_forward_end_backup = Module['_bbsink_forward_end_backup'] = (a0, a1, a2) => (_bbsink_forward_end_backup = Module['_bbsink_forward_end_backup'] = wasmExports['bbsink_forward_end_backup'])(a0, a1, a2);
var _bbsink_forward_cleanup = Module['_bbsink_forward_cleanup'] = (a0) => (_bbsink_forward_cleanup = Module['_bbsink_forward_cleanup'] = wasmExports['bbsink_forward_cleanup'])(a0);
var _BaseBackupAddTarget = Module['_BaseBackupAddTarget'] = (a0, a1, a2) => (_BaseBackupAddTarget = Module['_BaseBackupAddTarget'] = wasmExports['BaseBackupAddTarget'])(a0, a1, a2);
var _geteuid = Module['_geteuid'] = () => (_geteuid = Module['_geteuid'] = wasmExports['geteuid'])();
var _sigemptyset = Module['_sigemptyset'] = (a0) => (_sigemptyset = Module['_sigemptyset'] = wasmExports['sigemptyset'])(a0);
var _pq_sendtext = Module['_pq_sendtext'] = (a0, a1, a2) => (_pq_sendtext = Module['_pq_sendtext'] = wasmExports['pq_sendtext'])(a0, a1, a2);
var _pq_sendfloat4 = Module['_pq_sendfloat4'] = (a0, a1) => (_pq_sendfloat4 = Module['_pq_sendfloat4'] = wasmExports['pq_sendfloat4'])(a0, a1);
var _pq_sendfloat8 = Module['_pq_sendfloat8'] = (a0, a1) => (_pq_sendfloat8 = Module['_pq_sendfloat8'] = wasmExports['pq_sendfloat8'])(a0, a1);
var _pq_begintypsend = Module['_pq_begintypsend'] = (a0) => (_pq_begintypsend = Module['_pq_begintypsend'] = wasmExports['pq_begintypsend'])(a0);
var _pq_endtypsend = Module['_pq_endtypsend'] = (a0) => (_pq_endtypsend = Module['_pq_endtypsend'] = wasmExports['pq_endtypsend'])(a0);
var _pq_getmsgfloat4 = Module['_pq_getmsgfloat4'] = (a0) => (_pq_getmsgfloat4 = Module['_pq_getmsgfloat4'] = wasmExports['pq_getmsgfloat4'])(a0);
var _pq_getmsgfloat8 = Module['_pq_getmsgfloat8'] = (a0) => (_pq_getmsgfloat8 = Module['_pq_getmsgfloat8'] = wasmExports['pq_getmsgfloat8'])(a0);
var _pq_getmsgtext = Module['_pq_getmsgtext'] = (a0, a1, a2) => (_pq_getmsgtext = Module['_pq_getmsgtext'] = wasmExports['pq_getmsgtext'])(a0, a1, a2);
var _pg_getaddrinfo_all = Module['_pg_getaddrinfo_all'] = (a0, a1, a2, a3) => (_pg_getaddrinfo_all = Module['_pg_getaddrinfo_all'] = wasmExports['pg_getaddrinfo_all'])(a0, a1, a2, a3);
var _pg_getnameinfo_all = Module['_pg_getnameinfo_all'] = (a0, a1, a2, a3, a4, a5, a6) => (_pg_getnameinfo_all = Module['_pg_getnameinfo_all'] = wasmExports['pg_getnameinfo_all'])(a0, a1, a2, a3, a4, a5, a6);
var _socket = Module['_socket'] = (a0, a1, a2) => (_socket = Module['_socket'] = wasmExports['socket'])(a0, a1, a2);
var _setsockopt = Module['_setsockopt'] = (a0, a1, a2, a3, a4) => (_setsockopt = Module['_setsockopt'] = wasmExports['setsockopt'])(a0, a1, a2, a3, a4);
var _pg_freeaddrinfo_all = Module['_pg_freeaddrinfo_all'] = (a0, a1) => (_pg_freeaddrinfo_all = Module['_pg_freeaddrinfo_all'] = wasmExports['pg_freeaddrinfo_all'])(a0, a1);
var _gai_strerror = Module['_gai_strerror'] = (a0) => (_gai_strerror = Module['_gai_strerror'] = wasmExports['gai_strerror'])(a0);
var _getsockname = Module['_getsockname'] = (a0, a1, a2) => (_getsockname = Module['_getsockname'] = wasmExports['getsockname'])(a0, a1, a2);
var _getsockopt = Module['_getsockopt'] = (a0, a1, a2, a3, a4) => (_getsockopt = Module['_getsockopt'] = wasmExports['getsockopt'])(a0, a1, a2, a3, a4);
var _feof = Module['_feof'] = (a0) => (_feof = Module['_feof'] = wasmExports['feof'])(a0);
var _pg_strip_crlf = Module['_pg_strip_crlf'] = (a0) => (_pg_strip_crlf = Module['_pg_strip_crlf'] = wasmExports['pg_strip_crlf'])(a0);
var _getpeereid = Module['_getpeereid'] = (a0, a1, a2) => (_getpeereid = Module['_getpeereid'] = wasmExports['getpeereid'])(a0, a1, a2);
var _connect = Module['_connect'] = (a0, a1, a2) => (_connect = Module['_connect'] = wasmExports['connect'])(a0, a1, a2);
var _send = Module['_send'] = (a0, a1, a2, a3) => (_send = Module['_send'] = wasmExports['send'])(a0, a1, a2, a3);
var _recv = Module['_recv'] = (a0, a1, a2, a3) => (_recv = Module['_recv'] = wasmExports['recv'])(a0, a1, a2, a3);
var _pg_b64_enc_len = Module['_pg_b64_enc_len'] = (a0) => (_pg_b64_enc_len = Module['_pg_b64_enc_len'] = wasmExports['pg_b64_enc_len'])(a0);
var _pg_b64_encode = Module['_pg_b64_encode'] = (a0, a1, a2, a3) => (_pg_b64_encode = Module['_pg_b64_encode'] = wasmExports['pg_b64_encode'])(a0, a1, a2, a3);
var _pg_b64_dec_len = Module['_pg_b64_dec_len'] = (a0) => (_pg_b64_dec_len = Module['_pg_b64_dec_len'] = wasmExports['pg_b64_dec_len'])(a0);
var _pg_b64_decode = Module['_pg_b64_decode'] = (a0, a1, a2, a3) => (_pg_b64_decode = Module['_pg_b64_decode'] = wasmExports['pg_b64_decode'])(a0, a1, a2, a3);
var _pg_hmac_create = Module['_pg_hmac_create'] = (a0) => (_pg_hmac_create = Module['_pg_hmac_create'] = wasmExports['pg_hmac_create'])(a0);
var _pg_hmac_init = Module['_pg_hmac_init'] = (a0, a1, a2) => (_pg_hmac_init = Module['_pg_hmac_init'] = wasmExports['pg_hmac_init'])(a0, a1, a2);
var _pg_hmac_update = Module['_pg_hmac_update'] = (a0, a1, a2) => (_pg_hmac_update = Module['_pg_hmac_update'] = wasmExports['pg_hmac_update'])(a0, a1, a2);
var _pg_hmac_final = Module['_pg_hmac_final'] = (a0, a1, a2) => (_pg_hmac_final = Module['_pg_hmac_final'] = wasmExports['pg_hmac_final'])(a0, a1, a2);
var _pg_hmac_error = Module['_pg_hmac_error'] = (a0) => (_pg_hmac_error = Module['_pg_hmac_error'] = wasmExports['pg_hmac_error'])(a0);
var _pg_hmac_free = Module['_pg_hmac_free'] = (a0) => (_pg_hmac_free = Module['_pg_hmac_free'] = wasmExports['pg_hmac_free'])(a0);
var _scram_H = Module['_scram_H'] = (a0, a1, a2, a3, a4) => (_scram_H = Module['_scram_H'] = wasmExports['scram_H'])(a0, a1, a2, a3, a4);
var _pg_saslprep = Module['_pg_saslprep'] = (a0, a1) => (_pg_saslprep = Module['_pg_saslprep'] = wasmExports['pg_saslprep'])(a0, a1);
var _scram_build_secret = Module['_scram_build_secret'] = (a0, a1, a2, a3, a4, a5, a6) => (_scram_build_secret = Module['_scram_build_secret'] = wasmExports['scram_build_secret'])(a0, a1, a2, a3, a4, a5, a6);
var _scram_SaltedPassword = Module['_scram_SaltedPassword'] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_scram_SaltedPassword = Module['_scram_SaltedPassword'] = wasmExports['scram_SaltedPassword'])(a0, a1, a2, a3, a4, a5, a6, a7);
var _scram_ServerKey = Module['_scram_ServerKey'] = (a0, a1, a2, a3, a4) => (_scram_ServerKey = Module['_scram_ServerKey'] = wasmExports['scram_ServerKey'])(a0, a1, a2, a3, a4);
var _pg_md5_encrypt = Module['_pg_md5_encrypt'] = (a0, a1, a2, a3, a4) => (_pg_md5_encrypt = Module['_pg_md5_encrypt'] = wasmExports['pg_md5_encrypt'])(a0, a1, a2, a3, a4);
var _explicit_bzero = Module['_explicit_bzero'] = (a0, a1) => (_explicit_bzero = Module['_explicit_bzero'] = wasmExports['explicit_bzero'])(a0, a1);
var _be_lo_unlink = Module['_be_lo_unlink'] = (a0) => (_be_lo_unlink = Module['_be_lo_unlink'] = wasmExports['be_lo_unlink'])(a0);
var _text_to_cstring_buffer = Module['_text_to_cstring_buffer'] = (a0, a1, a2) => (_text_to_cstring_buffer = Module['_text_to_cstring_buffer'] = wasmExports['text_to_cstring_buffer'])(a0, a1, a2);
var _pg_xml_init = Module['_pg_xml_init'] = (a0) => (_pg_xml_init = Module['_pg_xml_init'] = wasmExports['pg_xml_init'])(a0);
var _xmlInitParser = Module['_xmlInitParser'] = () => (_xmlInitParser = Module['_xmlInitParser'] = wasmExports['xmlInitParser'])();
var _xml_ereport = Module['_xml_ereport'] = (a0, a1, a2, a3) => (_xml_ereport = Module['_xml_ereport'] = wasmExports['xml_ereport'])(a0, a1, a2, a3);
var _pg_xml_done = Module['_pg_xml_done'] = (a0, a1) => (_pg_xml_done = Module['_pg_xml_done'] = wasmExports['pg_xml_done'])(a0, a1);
var _xmlXPathNewContext = Module['_xmlXPathNewContext'] = (a0) => (_xmlXPathNewContext = Module['_xmlXPathNewContext'] = wasmExports['xmlXPathNewContext'])(a0);
var _xmlXPathFreeContext = Module['_xmlXPathFreeContext'] = (a0) => (_xmlXPathFreeContext = Module['_xmlXPathFreeContext'] = wasmExports['xmlXPathFreeContext'])(a0);
var _xmlFreeDoc = Module['_xmlFreeDoc'] = (a0) => (_xmlFreeDoc = Module['_xmlFreeDoc'] = wasmExports['xmlFreeDoc'])(a0);
var _xmlXPathCompile = Module['_xmlXPathCompile'] = (a0) => (_xmlXPathCompile = Module['_xmlXPathCompile'] = wasmExports['xmlXPathCompile'])(a0);
var _xmlXPathCompiledEval = Module['_xmlXPathCompiledEval'] = (a0, a1) => (_xmlXPathCompiledEval = Module['_xmlXPathCompiledEval'] = wasmExports['xmlXPathCompiledEval'])(a0, a1);
var _xmlXPathFreeCompExpr = Module['_xmlXPathFreeCompExpr'] = (a0) => (_xmlXPathFreeCompExpr = Module['_xmlXPathFreeCompExpr'] = wasmExports['xmlXPathFreeCompExpr'])(a0);
var _pg_do_encoding_conversion = Module['_pg_do_encoding_conversion'] = (a0, a1, a2, a3) => (_pg_do_encoding_conversion = Module['_pg_do_encoding_conversion'] = wasmExports['pg_do_encoding_conversion'])(a0, a1, a2, a3);
var _xmlStrdup = Module['_xmlStrdup'] = (a0) => (_xmlStrdup = Module['_xmlStrdup'] = wasmExports['xmlStrdup'])(a0);
var _strnlen = Module['_strnlen'] = (a0, a1) => (_strnlen = Module['_strnlen'] = wasmExports['strnlen'])(a0, a1);
var _initArrayResult = Module['_initArrayResult'] = (a0, a1, a2) => (_initArrayResult = Module['_initArrayResult'] = wasmExports['initArrayResult'])(a0, a1, a2);
var _xmlXPathCastNodeToString = Module['_xmlXPathCastNodeToString'] = (a0) => (_xmlXPathCastNodeToString = Module['_xmlXPathCastNodeToString'] = wasmExports['xmlXPathCastNodeToString'])(a0);
var _array_create_iterator = Module['_array_create_iterator'] = (a0, a1, a2) => (_array_create_iterator = Module['_array_create_iterator'] = wasmExports['array_create_iterator'])(a0, a1, a2);
var _array_iterate = Module['_array_iterate'] = (a0, a1, a2) => (_array_iterate = Module['_array_iterate'] = wasmExports['array_iterate'])(a0, a1, a2);
var _str_tolower = Module['_str_tolower'] = (a0, a1, a2) => (_str_tolower = Module['_str_tolower'] = wasmExports['str_tolower'])(a0, a1, a2);
var _JsonbValueToJsonb = Module['_JsonbValueToJsonb'] = (a0) => (_JsonbValueToJsonb = Module['_JsonbValueToJsonb'] = wasmExports['JsonbValueToJsonb'])(a0);
var _pushJsonbValue = Module['_pushJsonbValue'] = (a0, a1, a2) => (_pushJsonbValue = Module['_pushJsonbValue'] = wasmExports['pushJsonbValue'])(a0, a1, a2);
var _domain_check = Module['_domain_check'] = (a0, a1, a2, a3, a4) => (_domain_check = Module['_domain_check'] = wasmExports['domain_check'])(a0, a1, a2, a3, a4);
var _arraycontsel = Module['_arraycontsel'] = (a0) => (_arraycontsel = Module['_arraycontsel'] = wasmExports['arraycontsel'])(a0);
var _arraycontjoinsel = Module['_arraycontjoinsel'] = (a0) => (_arraycontjoinsel = Module['_arraycontjoinsel'] = wasmExports['arraycontjoinsel'])(a0);
var _expand_array = Module['_expand_array'] = (a0, a1, a2) => (_expand_array = Module['_expand_array'] = wasmExports['expand_array'])(a0, a1, a2);
var _texteq = Module['_texteq'] = (a0) => (_texteq = Module['_texteq'] = wasmExports['texteq'])(a0);
var _text_lt = Module['_text_lt'] = (a0) => (_text_lt = Module['_text_lt'] = wasmExports['text_lt'])(a0);
var _text_le = Module['_text_le'] = (a0) => (_text_le = Module['_text_le'] = wasmExports['text_le'])(a0);
var _text_gt = Module['_text_gt'] = (a0) => (_text_gt = Module['_text_gt'] = wasmExports['text_gt'])(a0);
var _text_ge = Module['_text_ge'] = (a0) => (_text_ge = Module['_text_ge'] = wasmExports['text_ge'])(a0);
var _bttextcmp = Module['_bttextcmp'] = (a0) => (_bttextcmp = Module['_bttextcmp'] = wasmExports['bttextcmp'])(a0);
var _byteaeq = Module['_byteaeq'] = (a0) => (_byteaeq = Module['_byteaeq'] = wasmExports['byteaeq'])(a0);
var _bytealt = Module['_bytealt'] = (a0) => (_bytealt = Module['_bytealt'] = wasmExports['bytealt'])(a0);
var _byteale = Module['_byteale'] = (a0) => (_byteale = Module['_byteale'] = wasmExports['byteale'])(a0);
var _byteagt = Module['_byteagt'] = (a0) => (_byteagt = Module['_byteagt'] = wasmExports['byteagt'])(a0);
var _byteage = Module['_byteage'] = (a0) => (_byteage = Module['_byteage'] = wasmExports['byteage'])(a0);
var _byteacmp = Module['_byteacmp'] = (a0) => (_byteacmp = Module['_byteacmp'] = wasmExports['byteacmp'])(a0);
var _to_hex32 = Module['_to_hex32'] = (a0) => (_to_hex32 = Module['_to_hex32'] = wasmExports['to_hex32'])(a0);
var _varstr_levenshtein = Module['_varstr_levenshtein'] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_varstr_levenshtein = Module['_varstr_levenshtein'] = wasmExports['varstr_levenshtein'])(a0, a1, a2, a3, a4, a5, a6, a7);
var _utf8_to_unicode = Module['_utf8_to_unicode'] = (a0) => (_utf8_to_unicode = Module['_utf8_to_unicode'] = wasmExports['utf8_to_unicode'])(a0);
var _pg_utf_mblen = Module['_pg_utf_mblen'] = (a0) => (_pg_utf_mblen = Module['_pg_utf_mblen'] = wasmExports['pg_utf_mblen'])(a0);
var _ArrayGetIntegerTypmods = Module['_ArrayGetIntegerTypmods'] = (a0, a1) => (_ArrayGetIntegerTypmods = Module['_ArrayGetIntegerTypmods'] = wasmExports['ArrayGetIntegerTypmods'])(a0, a1);
var _timestamp_in = Module['_timestamp_in'] = (a0) => (_timestamp_in = Module['_timestamp_in'] = wasmExports['timestamp_in'])(a0);
var ___multi3 = Module['___multi3'] = (a0, a1, a2, a3, a4) => (___multi3 = Module['___multi3'] = wasmExports['__multi3'])(a0, a1, a2, a3, a4);
var _timestamp_eq = Module['_timestamp_eq'] = (a0) => (_timestamp_eq = Module['_timestamp_eq'] = wasmExports['timestamp_eq'])(a0);
var _timestamp_lt = Module['_timestamp_lt'] = (a0) => (_timestamp_lt = Module['_timestamp_lt'] = wasmExports['timestamp_lt'])(a0);
var _timestamp_gt = Module['_timestamp_gt'] = (a0) => (_timestamp_gt = Module['_timestamp_gt'] = wasmExports['timestamp_gt'])(a0);
var _timestamp_le = Module['_timestamp_le'] = (a0) => (_timestamp_le = Module['_timestamp_le'] = wasmExports['timestamp_le'])(a0);
var _timestamp_ge = Module['_timestamp_ge'] = (a0) => (_timestamp_ge = Module['_timestamp_ge'] = wasmExports['timestamp_ge'])(a0);
var _timestamp_cmp = Module['_timestamp_cmp'] = (a0) => (_timestamp_cmp = Module['_timestamp_cmp'] = wasmExports['timestamp_cmp'])(a0);
var _interval_eq = Module['_interval_eq'] = (a0) => (_interval_eq = Module['_interval_eq'] = wasmExports['interval_eq'])(a0);
var _interval_lt = Module['_interval_lt'] = (a0) => (_interval_lt = Module['_interval_lt'] = wasmExports['interval_lt'])(a0);
var _interval_gt = Module['_interval_gt'] = (a0) => (_interval_gt = Module['_interval_gt'] = wasmExports['interval_gt'])(a0);
var _interval_le = Module['_interval_le'] = (a0) => (_interval_le = Module['_interval_le'] = wasmExports['interval_le'])(a0);
var _interval_ge = Module['_interval_ge'] = (a0) => (_interval_ge = Module['_interval_ge'] = wasmExports['interval_ge'])(a0);
var _interval_cmp = Module['_interval_cmp'] = (a0) => (_interval_cmp = Module['_interval_cmp'] = wasmExports['interval_cmp'])(a0);
var _timestamp_mi = Module['_timestamp_mi'] = (a0) => (_timestamp_mi = Module['_timestamp_mi'] = wasmExports['timestamp_mi'])(a0);
var _interval_um = Module['_interval_um'] = (a0) => (_interval_um = Module['_interval_um'] = wasmExports['interval_um'])(a0);
var _interval_mi = Module['_interval_mi'] = (a0) => (_interval_mi = Module['_interval_mi'] = wasmExports['interval_mi'])(a0);
var _int64_to_numeric = Module['_int64_to_numeric'] = (a0) => (_int64_to_numeric = Module['_int64_to_numeric'] = wasmExports['int64_to_numeric'])(a0);
var _numeric_float4 = Module['_numeric_float4'] = (a0) => (_numeric_float4 = Module['_numeric_float4'] = wasmExports['numeric_float4'])(a0);
var _numeric_cmp = Module['_numeric_cmp'] = (a0) => (_numeric_cmp = Module['_numeric_cmp'] = wasmExports['numeric_cmp'])(a0);
var _numeric_eq = Module['_numeric_eq'] = (a0) => (_numeric_eq = Module['_numeric_eq'] = wasmExports['numeric_eq'])(a0);
var _forkname_to_number = Module['_forkname_to_number'] = (a0) => (_forkname_to_number = Module['_forkname_to_number'] = wasmExports['forkname_to_number'])(a0);
var _numeric_lt = Module['_numeric_lt'] = (a0) => (_numeric_lt = Module['_numeric_lt'] = wasmExports['numeric_lt'])(a0);
var _numeric_ge = Module['_numeric_ge'] = (a0) => (_numeric_ge = Module['_numeric_ge'] = wasmExports['numeric_ge'])(a0);
var _err_generic_string = Module['_err_generic_string'] = (a0, a1) => (_err_generic_string = Module['_err_generic_string'] = wasmExports['err_generic_string'])(a0, a1);
var _varbit_in = Module['_varbit_in'] = (a0) => (_varbit_in = Module['_varbit_in'] = wasmExports['varbit_in'])(a0);
var _biteq = Module['_biteq'] = (a0) => (_biteq = Module['_biteq'] = wasmExports['biteq'])(a0);
var _bitlt = Module['_bitlt'] = (a0) => (_bitlt = Module['_bitlt'] = wasmExports['bitlt'])(a0);
var _bitle = Module['_bitle'] = (a0) => (_bitle = Module['_bitle'] = wasmExports['bitle'])(a0);
var _bitgt = Module['_bitgt'] = (a0) => (_bitgt = Module['_bitgt'] = wasmExports['bitgt'])(a0);
var _bitge = Module['_bitge'] = (a0) => (_bitge = Module['_bitge'] = wasmExports['bitge'])(a0);
var _bitcmp = Module['_bitcmp'] = (a0) => (_bitcmp = Module['_bitcmp'] = wasmExports['bitcmp'])(a0);
var _numeric_is_nan = Module['_numeric_is_nan'] = (a0) => (_numeric_is_nan = Module['_numeric_is_nan'] = wasmExports['numeric_is_nan'])(a0);
var _log10 = Module['_log10'] = (a0) => (_log10 = Module['_log10'] = wasmExports['log10'])(a0);
var _numeric_gt = Module['_numeric_gt'] = (a0) => (_numeric_gt = Module['_numeric_gt'] = wasmExports['numeric_gt'])(a0);
var _numeric_le = Module['_numeric_le'] = (a0) => (_numeric_le = Module['_numeric_le'] = wasmExports['numeric_le'])(a0);
var _numeric_div = Module['_numeric_div'] = (a0) => (_numeric_div = Module['_numeric_div'] = wasmExports['numeric_div'])(a0);
var _numeric_float8_no_overflow = Module['_numeric_float8_no_overflow'] = (a0) => (_numeric_float8_no_overflow = Module['_numeric_float8_no_overflow'] = wasmExports['numeric_float8_no_overflow'])(a0);
var _current_query = Module['_current_query'] = (a0) => (_current_query = Module['_current_query'] = wasmExports['current_query'])(a0);
var _unpack_sql_state = Module['_unpack_sql_state'] = (a0) => (_unpack_sql_state = Module['_unpack_sql_state'] = wasmExports['unpack_sql_state'])(a0);
var _TransferExpandedObject = Module['_TransferExpandedObject'] = (a0, a1) => (_TransferExpandedObject = Module['_TransferExpandedObject'] = wasmExports['TransferExpandedObject'])(a0, a1);
var _enum_lt = Module['_enum_lt'] = (a0) => (_enum_lt = Module['_enum_lt'] = wasmExports['enum_lt'])(a0);
var _enum_le = Module['_enum_le'] = (a0) => (_enum_le = Module['_enum_le'] = wasmExports['enum_le'])(a0);
var _enum_ge = Module['_enum_ge'] = (a0) => (_enum_ge = Module['_enum_ge'] = wasmExports['enum_ge'])(a0);
var _enum_gt = Module['_enum_gt'] = (a0) => (_enum_gt = Module['_enum_gt'] = wasmExports['enum_gt'])(a0);
var _enum_cmp = Module['_enum_cmp'] = (a0) => (_enum_cmp = Module['_enum_cmp'] = wasmExports['enum_cmp'])(a0);
var _tidin = Module['_tidin'] = (a0) => (_tidin = Module['_tidin'] = wasmExports['tidin'])(a0);
var _tidout = Module['_tidout'] = (a0) => (_tidout = Module['_tidout'] = wasmExports['tidout'])(a0);
var _quote_ident = Module['_quote_ident'] = (a0) => (_quote_ident = Module['_quote_ident'] = wasmExports['quote_ident'])(a0);
var _cash_cmp = Module['_cash_cmp'] = (a0) => (_cash_cmp = Module['_cash_cmp'] = wasmExports['cash_cmp'])(a0);
var _float8out_internal = Module['_float8out_internal'] = (a0) => (_float8out_internal = Module['_float8out_internal'] = wasmExports['float8out_internal'])(a0);
var _float8in_internal = Module['_float8in_internal'] = (a0, a1, a2, a3, a4) => (_float8in_internal = Module['_float8in_internal'] = wasmExports['float8in_internal'])(a0, a1, a2, a3, a4);
var _cos = Module['_cos'] = (a0) => (_cos = Module['_cos'] = wasmExports['cos'])(a0);
var _sin = Module['_sin'] = (a0) => (_sin = Module['_sin'] = wasmExports['sin'])(a0);
var _bpchareq = Module['_bpchareq'] = (a0) => (_bpchareq = Module['_bpchareq'] = wasmExports['bpchareq'])(a0);
var _bpcharlt = Module['_bpcharlt'] = (a0) => (_bpcharlt = Module['_bpcharlt'] = wasmExports['bpcharlt'])(a0);
var _bpcharle = Module['_bpcharle'] = (a0) => (_bpcharle = Module['_bpcharle'] = wasmExports['bpcharle'])(a0);
var _bpchargt = Module['_bpchargt'] = (a0) => (_bpchargt = Module['_bpchargt'] = wasmExports['bpchargt'])(a0);
var _bpcharge = Module['_bpcharge'] = (a0) => (_bpcharge = Module['_bpcharge'] = wasmExports['bpcharge'])(a0);
var _bpcharcmp = Module['_bpcharcmp'] = (a0) => (_bpcharcmp = Module['_bpcharcmp'] = wasmExports['bpcharcmp'])(a0);
var _get_fn_expr_rettype = Module['_get_fn_expr_rettype'] = (a0) => (_get_fn_expr_rettype = Module['_get_fn_expr_rettype'] = wasmExports['get_fn_expr_rettype'])(a0);
var _uuid_in = Module['_uuid_in'] = (a0) => (_uuid_in = Module['_uuid_in'] = wasmExports['uuid_in'])(a0);
var _uuid_out = Module['_uuid_out'] = (a0) => (_uuid_out = Module['_uuid_out'] = wasmExports['uuid_out'])(a0);
var _uuid_cmp = Module['_uuid_cmp'] = (a0) => (_uuid_cmp = Module['_uuid_cmp'] = wasmExports['uuid_cmp'])(a0);
var _gen_random_uuid = Module['_gen_random_uuid'] = (a0) => (_gen_random_uuid = Module['_gen_random_uuid'] = wasmExports['gen_random_uuid'])(a0);
var _inet_in = Module['_inet_in'] = (a0) => (_inet_in = Module['_inet_in'] = wasmExports['inet_in'])(a0);
var _pg_inet_net_ntop = Module['_pg_inet_net_ntop'] = (a0, a1, a2, a3, a4) => (_pg_inet_net_ntop = Module['_pg_inet_net_ntop'] = wasmExports['pg_inet_net_ntop'])(a0, a1, a2, a3, a4);
var _network_cmp = Module['_network_cmp'] = (a0) => (_network_cmp = Module['_network_cmp'] = wasmExports['network_cmp'])(a0);
var _convert_network_to_scalar = Module['_convert_network_to_scalar'] = (a0, a1, a2) => (_convert_network_to_scalar = Module['_convert_network_to_scalar'] = wasmExports['convert_network_to_scalar'])(a0, a1, a2);
var _pg_wchar2mb_with_len = Module['_pg_wchar2mb_with_len'] = (a0, a1, a2) => (_pg_wchar2mb_with_len = Module['_pg_wchar2mb_with_len'] = wasmExports['pg_wchar2mb_with_len'])(a0, a1, a2);
var _IsValidJsonNumber = Module['_IsValidJsonNumber'] = (a0, a1) => (_IsValidJsonNumber = Module['_IsValidJsonNumber'] = wasmExports['IsValidJsonNumber'])(a0, a1);
var _float4in_internal = Module['_float4in_internal'] = (a0, a1, a2, a3, a4) => (_float4in_internal = Module['_float4in_internal'] = wasmExports['float4in_internal'])(a0, a1, a2, a3, a4);
var _strtof = Module['_strtof'] = (a0, a1) => (_strtof = Module['_strtof'] = wasmExports['strtof'])(a0, a1);
var _float_to_shortest_decimal_buf = Module['_float_to_shortest_decimal_buf'] = (a0, a1) => (_float_to_shortest_decimal_buf = Module['_float_to_shortest_decimal_buf'] = wasmExports['float_to_shortest_decimal_buf'])(a0, a1);
var _btfloat4cmp = Module['_btfloat4cmp'] = (a0) => (_btfloat4cmp = Module['_btfloat4cmp'] = wasmExports['btfloat4cmp'])(a0);
var _btfloat8cmp = Module['_btfloat8cmp'] = (a0) => (_btfloat8cmp = Module['_btfloat8cmp'] = wasmExports['btfloat8cmp'])(a0);
var _acos = Module['_acos'] = (a0) => (_acos = Module['_acos'] = wasmExports['acos'])(a0);
var _asin = Module['_asin'] = (a0) => (_asin = Module['_asin'] = wasmExports['asin'])(a0);
var _fmod = Module['_fmod'] = (a0, a1) => (_fmod = Module['_fmod'] = wasmExports['fmod'])(a0, a1);
var _pg_prng_seed_check = Module['_pg_prng_seed_check'] = (a0) => (_pg_prng_seed_check = Module['_pg_prng_seed_check'] = wasmExports['pg_prng_seed_check'])(a0);
var _pg_prng_seed = Module['_pg_prng_seed'] = (a0, a1) => (_pg_prng_seed = Module['_pg_prng_seed'] = wasmExports['pg_prng_seed'])(a0, a1);
var _date_eq = Module['_date_eq'] = (a0) => (_date_eq = Module['_date_eq'] = wasmExports['date_eq'])(a0);
var _date_lt = Module['_date_lt'] = (a0) => (_date_lt = Module['_date_lt'] = wasmExports['date_lt'])(a0);
var _date_le = Module['_date_le'] = (a0) => (_date_le = Module['_date_le'] = wasmExports['date_le'])(a0);
var _date_gt = Module['_date_gt'] = (a0) => (_date_gt = Module['_date_gt'] = wasmExports['date_gt'])(a0);
var _date_ge = Module['_date_ge'] = (a0) => (_date_ge = Module['_date_ge'] = wasmExports['date_ge'])(a0);
var _date_cmp = Module['_date_cmp'] = (a0) => (_date_cmp = Module['_date_cmp'] = wasmExports['date_cmp'])(a0);
var _date_mi = Module['_date_mi'] = (a0) => (_date_mi = Module['_date_mi'] = wasmExports['date_mi'])(a0);
var _time_eq = Module['_time_eq'] = (a0) => (_time_eq = Module['_time_eq'] = wasmExports['time_eq'])(a0);
var _time_lt = Module['_time_lt'] = (a0) => (_time_lt = Module['_time_lt'] = wasmExports['time_lt'])(a0);
var _time_le = Module['_time_le'] = (a0) => (_time_le = Module['_time_le'] = wasmExports['time_le'])(a0);
var _time_gt = Module['_time_gt'] = (a0) => (_time_gt = Module['_time_gt'] = wasmExports['time_gt'])(a0);
var _time_ge = Module['_time_ge'] = (a0) => (_time_ge = Module['_time_ge'] = wasmExports['time_ge'])(a0);
var _time_cmp = Module['_time_cmp'] = (a0) => (_time_cmp = Module['_time_cmp'] = wasmExports['time_cmp'])(a0);
var _time_mi_time = Module['_time_mi_time'] = (a0) => (_time_mi_time = Module['_time_mi_time'] = wasmExports['time_mi_time'])(a0);
var _timetz_cmp = Module['_timetz_cmp'] = (a0) => (_timetz_cmp = Module['_timetz_cmp'] = wasmExports['timetz_cmp'])(a0);
var _macaddr_cmp = Module['_macaddr_cmp'] = (a0) => (_macaddr_cmp = Module['_macaddr_cmp'] = wasmExports['macaddr_cmp'])(a0);
var _macaddr_lt = Module['_macaddr_lt'] = (a0) => (_macaddr_lt = Module['_macaddr_lt'] = wasmExports['macaddr_lt'])(a0);
var _macaddr_le = Module['_macaddr_le'] = (a0) => (_macaddr_le = Module['_macaddr_le'] = wasmExports['macaddr_le'])(a0);
var _macaddr_eq = Module['_macaddr_eq'] = (a0) => (_macaddr_eq = Module['_macaddr_eq'] = wasmExports['macaddr_eq'])(a0);
var _macaddr_ge = Module['_macaddr_ge'] = (a0) => (_macaddr_ge = Module['_macaddr_ge'] = wasmExports['macaddr_ge'])(a0);
var _macaddr_gt = Module['_macaddr_gt'] = (a0) => (_macaddr_gt = Module['_macaddr_gt'] = wasmExports['macaddr_gt'])(a0);
var _localtime = Module['_localtime'] = (a0) => (_localtime = Module['_localtime'] = wasmExports['localtime'])(a0);
var _strftime = Module['_strftime'] = (a0, a1, a2, a3) => (_strftime = Module['_strftime'] = wasmExports['strftime'])(a0, a1, a2, a3);
var _newlocale = Module['_newlocale'] = (a0, a1, a2) => (_newlocale = Module['_newlocale'] = wasmExports['newlocale'])(a0, a1, a2);
var _make_expanded_record_from_typeid = Module['_make_expanded_record_from_typeid'] = (a0, a1, a2) => (_make_expanded_record_from_typeid = Module['_make_expanded_record_from_typeid'] = wasmExports['make_expanded_record_from_typeid'])(a0, a1, a2);
var _make_expanded_record_from_tupdesc = Module['_make_expanded_record_from_tupdesc'] = (a0, a1) => (_make_expanded_record_from_tupdesc = Module['_make_expanded_record_from_tupdesc'] = wasmExports['make_expanded_record_from_tupdesc'])(a0, a1);
var _make_expanded_record_from_exprecord = Module['_make_expanded_record_from_exprecord'] = (a0, a1) => (_make_expanded_record_from_exprecord = Module['_make_expanded_record_from_exprecord'] = wasmExports['make_expanded_record_from_exprecord'])(a0, a1);
var _expanded_record_set_tuple = Module['_expanded_record_set_tuple'] = (a0, a1, a2, a3) => (_expanded_record_set_tuple = Module['_expanded_record_set_tuple'] = wasmExports['expanded_record_set_tuple'])(a0, a1, a2, a3);
var _expanded_record_get_tuple = Module['_expanded_record_get_tuple'] = (a0) => (_expanded_record_get_tuple = Module['_expanded_record_get_tuple'] = wasmExports['expanded_record_get_tuple'])(a0);
var _deconstruct_expanded_record = Module['_deconstruct_expanded_record'] = (a0) => (_deconstruct_expanded_record = Module['_deconstruct_expanded_record'] = wasmExports['deconstruct_expanded_record'])(a0);
var _expanded_record_lookup_field = Module['_expanded_record_lookup_field'] = (a0, a1, a2) => (_expanded_record_lookup_field = Module['_expanded_record_lookup_field'] = wasmExports['expanded_record_lookup_field'])(a0, a1, a2);
var _expanded_record_set_field_internal = Module['_expanded_record_set_field_internal'] = (a0, a1, a2, a3, a4, a5) => (_expanded_record_set_field_internal = Module['_expanded_record_set_field_internal'] = wasmExports['expanded_record_set_field_internal'])(a0, a1, a2, a3, a4, a5);
var _expanded_record_set_fields = Module['_expanded_record_set_fields'] = (a0, a1, a2, a3) => (_expanded_record_set_fields = Module['_expanded_record_set_fields'] = wasmExports['expanded_record_set_fields'])(a0, a1, a2, a3);
var _btnamecmp = Module['_btnamecmp'] = (a0) => (_btnamecmp = Module['_btnamecmp'] = wasmExports['btnamecmp'])(a0);
var _has_fn_opclass_options = Module['_has_fn_opclass_options'] = (a0) => (_has_fn_opclass_options = Module['_has_fn_opclass_options'] = wasmExports['has_fn_opclass_options'])(a0);
var _pg_get_indexdef_columns_extended = Module['_pg_get_indexdef_columns_extended'] = (a0, a1) => (_pg_get_indexdef_columns_extended = Module['_pg_get_indexdef_columns_extended'] = wasmExports['pg_get_indexdef_columns_extended'])(a0, a1);
var _strcspn = Module['_strcspn'] = (a0, a1) => (_strcspn = Module['_strcspn'] = wasmExports['strcspn'])(a0, a1);
var _path_is_relative_and_below_cwd = Module['_path_is_relative_and_below_cwd'] = (a0) => (_path_is_relative_and_below_cwd = Module['_path_is_relative_and_below_cwd'] = wasmExports['path_is_relative_and_below_cwd'])(a0);
var _macaddr8_cmp = Module['_macaddr8_cmp'] = (a0) => (_macaddr8_cmp = Module['_macaddr8_cmp'] = wasmExports['macaddr8_cmp'])(a0);
var _macaddr8_lt = Module['_macaddr8_lt'] = (a0) => (_macaddr8_lt = Module['_macaddr8_lt'] = wasmExports['macaddr8_lt'])(a0);
var _macaddr8_le = Module['_macaddr8_le'] = (a0) => (_macaddr8_le = Module['_macaddr8_le'] = wasmExports['macaddr8_le'])(a0);
var _macaddr8_eq = Module['_macaddr8_eq'] = (a0) => (_macaddr8_eq = Module['_macaddr8_eq'] = wasmExports['macaddr8_eq'])(a0);
var _macaddr8_ge = Module['_macaddr8_ge'] = (a0) => (_macaddr8_ge = Module['_macaddr8_ge'] = wasmExports['macaddr8_ge'])(a0);
var _macaddr8_gt = Module['_macaddr8_gt'] = (a0) => (_macaddr8_gt = Module['_macaddr8_gt'] = wasmExports['macaddr8_gt'])(a0);
var _generic_restriction_selectivity = Module['_generic_restriction_selectivity'] = (a0, a1, a2, a3, a4, a5) => (_generic_restriction_selectivity = Module['_generic_restriction_selectivity'] = wasmExports['generic_restriction_selectivity'])(a0, a1, a2, a3, a4, a5);
var _genericcostestimate = Module['_genericcostestimate'] = (a0, a1, a2, a3) => (_genericcostestimate = Module['_genericcostestimate'] = wasmExports['genericcostestimate'])(a0, a1, a2, a3);
var _local2local = Module['_local2local'] = (a0, a1, a2, a3, a4, a5, a6) => (_local2local = Module['_local2local'] = wasmExports['local2local'])(a0, a1, a2, a3, a4, a5, a6);
var _report_untranslatable_char = Module['_report_untranslatable_char'] = (a0, a1, a2, a3) => (_report_untranslatable_char = Module['_report_untranslatable_char'] = wasmExports['report_untranslatable_char'])(a0, a1, a2, a3);
var _latin2mic = Module['_latin2mic'] = (a0, a1, a2, a3, a4, a5) => (_latin2mic = Module['_latin2mic'] = wasmExports['latin2mic'])(a0, a1, a2, a3, a4, a5);
var _mic2latin = Module['_mic2latin'] = (a0, a1, a2, a3, a4, a5) => (_mic2latin = Module['_mic2latin'] = wasmExports['mic2latin'])(a0, a1, a2, a3, a4, a5);
var _latin2mic_with_table = Module['_latin2mic_with_table'] = (a0, a1, a2, a3, a4, a5, a6) => (_latin2mic_with_table = Module['_latin2mic_with_table'] = wasmExports['latin2mic_with_table'])(a0, a1, a2, a3, a4, a5, a6);
var _mic2latin_with_table = Module['_mic2latin_with_table'] = (a0, a1, a2, a3, a4, a5, a6) => (_mic2latin_with_table = Module['_mic2latin_with_table'] = wasmExports['mic2latin_with_table'])(a0, a1, a2, a3, a4, a5, a6);
var _pg_encoding_verifymbchar = Module['_pg_encoding_verifymbchar'] = (a0, a1, a2) => (_pg_encoding_verifymbchar = Module['_pg_encoding_verifymbchar'] = wasmExports['pg_encoding_verifymbchar'])(a0, a1, a2);
var _MemoryContextAllocHuge = Module['_MemoryContextAllocHuge'] = (a0, a1) => (_MemoryContextAllocHuge = Module['_MemoryContextAllocHuge'] = wasmExports['MemoryContextAllocHuge'])(a0, a1);
var _check_encoding_conversion_args = Module['_check_encoding_conversion_args'] = (a0, a1, a2, a3, a4) => (_check_encoding_conversion_args = Module['_check_encoding_conversion_args'] = wasmExports['check_encoding_conversion_args'])(a0, a1, a2, a3, a4);
var _ResourceOwnerReleaseAllPlanCacheRefs = Module['_ResourceOwnerReleaseAllPlanCacheRefs'] = (a0) => (_ResourceOwnerReleaseAllPlanCacheRefs = Module['_ResourceOwnerReleaseAllPlanCacheRefs'] = wasmExports['ResourceOwnerReleaseAllPlanCacheRefs'])(a0);
var _RegisterResourceReleaseCallback = Module['_RegisterResourceReleaseCallback'] = (a0, a1) => (_RegisterResourceReleaseCallback = Module['_RegisterResourceReleaseCallback'] = wasmExports['RegisterResourceReleaseCallback'])(a0, a1);
var _PinPortal = Module['_PinPortal'] = (a0) => (_PinPortal = Module['_PinPortal'] = wasmExports['PinPortal'])(a0);
var _UnpinPortal = Module['_UnpinPortal'] = (a0) => (_UnpinPortal = Module['_UnpinPortal'] = wasmExports['UnpinPortal'])(a0);
var _in_error_recursion_trouble = Module['_in_error_recursion_trouble'] = () => (_in_error_recursion_trouble = Module['_in_error_recursion_trouble'] = wasmExports['in_error_recursion_trouble'])();
var _GetErrorContextStack = Module['_GetErrorContextStack'] = () => (_GetErrorContextStack = Module['_GetErrorContextStack'] = wasmExports['GetErrorContextStack'])();
var _strlcat = Module['_strlcat'] = (a0, a1, a2) => (_strlcat = Module['_strlcat'] = wasmExports['strlcat'])(a0, a1, a2);
var _pg_bindtextdomain = Module['_pg_bindtextdomain'] = (a0) => (_pg_bindtextdomain = Module['_pg_bindtextdomain'] = wasmExports['pg_bindtextdomain'])(a0);
var _fputc = Module['_fputc'] = (a0, a1) => (_fputc = Module['_fputc'] = wasmExports['fputc'])(a0, a1);
var _GetConfigOption = Module['_GetConfigOption'] = (a0, a1, a2) => (_GetConfigOption = Module['_GetConfigOption'] = wasmExports['GetConfigOption'])(a0, a1, a2);
var _DefineCustomBoolVariable = Module['_DefineCustomBoolVariable'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_DefineCustomBoolVariable = Module['_DefineCustomBoolVariable'] = wasmExports['DefineCustomBoolVariable'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
var _DefineCustomIntVariable = Module['_DefineCustomIntVariable'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) => (_DefineCustomIntVariable = Module['_DefineCustomIntVariable'] = wasmExports['DefineCustomIntVariable'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
var _DefineCustomRealVariable = Module['_DefineCustomRealVariable'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) => (_DefineCustomRealVariable = Module['_DefineCustomRealVariable'] = wasmExports['DefineCustomRealVariable'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
var _DefineCustomStringVariable = Module['_DefineCustomStringVariable'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_DefineCustomStringVariable = Module['_DefineCustomStringVariable'] = wasmExports['DefineCustomStringVariable'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
var _DefineCustomEnumVariable = Module['_DefineCustomEnumVariable'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) => (_DefineCustomEnumVariable = Module['_DefineCustomEnumVariable'] = wasmExports['DefineCustomEnumVariable'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
var _MarkGUCPrefixReserved = Module['_MarkGUCPrefixReserved'] = (a0) => (_MarkGUCPrefixReserved = Module['_MarkGUCPrefixReserved'] = wasmExports['MarkGUCPrefixReserved'])(a0);
var _sampler_random_init_state = Module['_sampler_random_init_state'] = (a0, a1) => (_sampler_random_init_state = Module['_sampler_random_init_state'] = wasmExports['sampler_random_init_state'])(a0, a1);
var _CachedPlanAllowsSimpleValidityCheck = Module['_CachedPlanAllowsSimpleValidityCheck'] = (a0, a1, a2) => (_CachedPlanAllowsSimpleValidityCheck = Module['_CachedPlanAllowsSimpleValidityCheck'] = wasmExports['CachedPlanAllowsSimpleValidityCheck'])(a0, a1, a2);
var _CachedPlanIsSimplyValid = Module['_CachedPlanIsSimplyValid'] = (a0, a1, a2) => (_CachedPlanIsSimplyValid = Module['_CachedPlanIsSimplyValid'] = wasmExports['CachedPlanIsSimplyValid'])(a0, a1, a2);
var _GetCachedExpression = Module['_GetCachedExpression'] = (a0) => (_GetCachedExpression = Module['_GetCachedExpression'] = wasmExports['GetCachedExpression'])(a0);
var _FreeCachedExpression = Module['_FreeCachedExpression'] = (a0) => (_FreeCachedExpression = Module['_FreeCachedExpression'] = wasmExports['FreeCachedExpression'])(a0);
var _get_typsubscript = Module['_get_typsubscript'] = (a0, a1) => (_get_typsubscript = Module['_get_typsubscript'] = wasmExports['get_typsubscript'])(a0, a1);
var _resolve_polymorphic_argtypes = Module['_resolve_polymorphic_argtypes'] = (a0, a1, a2, a3) => (_resolve_polymorphic_argtypes = Module['_resolve_polymorphic_argtypes'] = wasmExports['resolve_polymorphic_argtypes'])(a0, a1, a2, a3);
var _CallerFInfoFunctionCall2 = Module['_CallerFInfoFunctionCall2'] = (a0, a1, a2, a3, a4) => (_CallerFInfoFunctionCall2 = Module['_CallerFInfoFunctionCall2'] = wasmExports['CallerFInfoFunctionCall2'])(a0, a1, a2, a3, a4);
var _FunctionCall0Coll = Module['_FunctionCall0Coll'] = (a0, a1) => (_FunctionCall0Coll = Module['_FunctionCall0Coll'] = wasmExports['FunctionCall0Coll'])(a0, a1);
var _dlsym = Module['_dlsym'] = (a0, a1) => (_dlsym = Module['_dlsym'] = wasmExports['dlsym'])(a0, a1);
var _dlopen = Module['_dlopen'] = (a0, a1) => (_dlopen = Module['_dlopen'] = wasmExports['dlopen'])(a0, a1);
var _dlerror = Module['_dlerror'] = () => (_dlerror = Module['_dlerror'] = wasmExports['dlerror'])();
var _dlclose = Module['_dlclose'] = (a0) => (_dlclose = Module['_dlclose'] = wasmExports['dlclose'])(a0);
var _find_rendezvous_variable = Module['_find_rendezvous_variable'] = (a0) => (_find_rendezvous_variable = Module['_find_rendezvous_variable'] = wasmExports['find_rendezvous_variable'])(a0);
var _WaitForBackgroundWorkerStartup = Module['_WaitForBackgroundWorkerStartup'] = (a0, a1) => (_WaitForBackgroundWorkerStartup = Module['_WaitForBackgroundWorkerStartup'] = wasmExports['WaitForBackgroundWorkerStartup'])(a0, a1);
var _fputs = Module['_fputs'] = (a0, a1) => (_fputs = Module['_fputs'] = wasmExports['fputs'])(a0, a1);
var _popen = Module['_popen'] = (a0, a1) => (_popen = Module['_popen'] = wasmExports['popen'])(a0, a1);
var _float_to_shortest_decimal_bufn = Module['_float_to_shortest_decimal_bufn'] = (a0, a1) => (_float_to_shortest_decimal_bufn = Module['_float_to_shortest_decimal_bufn'] = wasmExports['float_to_shortest_decimal_bufn'])(a0, a1);
var _pg_prng_uint64 = Module['_pg_prng_uint64'] = (a0) => (_pg_prng_uint64 = Module['_pg_prng_uint64'] = wasmExports['pg_prng_uint64'])(a0);
var _scram_ClientKey = Module['_scram_ClientKey'] = (a0, a1, a2, a3, a4) => (_scram_ClientKey = Module['_scram_ClientKey'] = wasmExports['scram_ClientKey'])(a0, a1, a2, a3, a4);
var _pg_encoding_dsplen = Module['_pg_encoding_dsplen'] = (a0, a1) => (_pg_encoding_dsplen = Module['_pg_encoding_dsplen'] = wasmExports['pg_encoding_dsplen'])(a0, a1);
var _getcwd = Module['_getcwd'] = (a0, a1) => (_getcwd = Module['_getcwd'] = wasmExports['getcwd'])(a0, a1);
var _pg_get_user_home_dir = Module['_pg_get_user_home_dir'] = (a0, a1, a2) => (_pg_get_user_home_dir = Module['_pg_get_user_home_dir'] = wasmExports['pg_get_user_home_dir'])(a0, a1, a2);
var _nanosleep = Module['_nanosleep'] = (a0, a1) => (_nanosleep = Module['_nanosleep'] = wasmExports['nanosleep'])(a0, a1);
var _snprintf = Module['_snprintf'] = (a0, a1, a2, a3) => (_snprintf = Module['_snprintf'] = wasmExports['snprintf'])(a0, a1, a2, a3);
var _pg_strerror_r = Module['_pg_strerror_r'] = (a0, a1, a2) => (_pg_strerror_r = Module['_pg_strerror_r'] = wasmExports['pg_strerror_r'])(a0, a1, a2);
var _pthread_mutex_lock = Module['_pthread_mutex_lock'] = (a0) => (_pthread_mutex_lock = Module['_pthread_mutex_lock'] = wasmExports['pthread_mutex_lock'])(a0);
var _pthread_mutex_unlock = Module['_pthread_mutex_unlock'] = (a0) => (_pthread_mutex_unlock = Module['_pthread_mutex_unlock'] = wasmExports['pthread_mutex_unlock'])(a0);
var _strncat = Module['_strncat'] = (a0, a1, a2) => (_strncat = Module['_strncat'] = wasmExports['strncat'])(a0, a1, a2);
var _PQexec = Module['_PQexec'] = (a0, a1) => (_PQexec = Module['_PQexec'] = wasmExports['PQexec'])(a0, a1);
var _PQsetSingleRowMode = Module['_PQsetSingleRowMode'] = (a0) => (_PQsetSingleRowMode = Module['_PQsetSingleRowMode'] = wasmExports['PQsetSingleRowMode'])(a0);
var _PQcmdStatus = Module['_PQcmdStatus'] = (a0) => (_PQcmdStatus = Module['_PQcmdStatus'] = wasmExports['PQcmdStatus'])(a0);
var _pthread_sigmask = Module['_pthread_sigmask'] = (a0, a1, a2) => (_pthread_sigmask = Module['_pthread_sigmask'] = wasmExports['pthread_sigmask'])(a0, a1, a2);
var _sigismember = Module['_sigismember'] = (a0, a1) => (_sigismember = Module['_sigismember'] = wasmExports['sigismember'])(a0, a1);
var _sigpending = Module['_sigpending'] = (a0) => (_sigpending = Module['_sigpending'] = wasmExports['sigpending'])(a0);
var _sigwait = Module['_sigwait'] = (a0, a1) => (_sigwait = Module['_sigwait'] = wasmExports['sigwait'])(a0, a1);
var _isolat1ToUTF8 = Module['_isolat1ToUTF8'] = (a0, a1, a2, a3) => (_isolat1ToUTF8 = Module['_isolat1ToUTF8'] = wasmExports['isolat1ToUTF8'])(a0, a1, a2, a3);
var _UTF8Toisolat1 = Module['_UTF8Toisolat1'] = (a0, a1, a2, a3) => (_UTF8Toisolat1 = Module['_UTF8Toisolat1'] = wasmExports['UTF8Toisolat1'])(a0, a1, a2, a3);
var _vfprintf = Module['_vfprintf'] = (a0, a1, a2) => (_vfprintf = Module['_vfprintf'] = wasmExports['vfprintf'])(a0, a1, a2);
var _vsnprintf = Module['_vsnprintf'] = (a0, a1, a2, a3) => (_vsnprintf = Module['_vsnprintf'] = wasmExports['vsnprintf'])(a0, a1, a2, a3);
var _xmlParserValidityWarning = Module['_xmlParserValidityWarning'] = (a0, a1, a2) => (_xmlParserValidityWarning = Module['_xmlParserValidityWarning'] = wasmExports['xmlParserValidityWarning'])(a0, a1, a2);
var _xmlParserValidityError = Module['_xmlParserValidityError'] = (a0, a1, a2) => (_xmlParserValidityError = Module['_xmlParserValidityError'] = wasmExports['xmlParserValidityError'])(a0, a1, a2);
var _xmlParserError = Module['_xmlParserError'] = (a0, a1, a2) => (_xmlParserError = Module['_xmlParserError'] = wasmExports['xmlParserError'])(a0, a1, a2);
var _xmlParserWarning = Module['_xmlParserWarning'] = (a0, a1, a2) => (_xmlParserWarning = Module['_xmlParserWarning'] = wasmExports['xmlParserWarning'])(a0, a1, a2);
var _fprintf = Module['_fprintf'] = (a0, a1, a2) => (_fprintf = Module['_fprintf'] = wasmExports['fprintf'])(a0, a1, a2);
var ___xmlParserInputBufferCreateFilename = Module['___xmlParserInputBufferCreateFilename'] = (a0, a1) => (___xmlParserInputBufferCreateFilename = Module['___xmlParserInputBufferCreateFilename'] = wasmExports['__xmlParserInputBufferCreateFilename'])(a0, a1);
var ___xmlOutputBufferCreateFilename = Module['___xmlOutputBufferCreateFilename'] = (a0, a1, a2) => (___xmlOutputBufferCreateFilename = Module['___xmlOutputBufferCreateFilename'] = wasmExports['__xmlOutputBufferCreateFilename'])(a0, a1, a2);
var _xmlSAX2InternalSubset = Module['_xmlSAX2InternalSubset'] = (a0, a1, a2, a3) => (_xmlSAX2InternalSubset = Module['_xmlSAX2InternalSubset'] = wasmExports['xmlSAX2InternalSubset'])(a0, a1, a2, a3);
var _xmlSAX2IsStandalone = Module['_xmlSAX2IsStandalone'] = (a0) => (_xmlSAX2IsStandalone = Module['_xmlSAX2IsStandalone'] = wasmExports['xmlSAX2IsStandalone'])(a0);
var _xmlSAX2HasInternalSubset = Module['_xmlSAX2HasInternalSubset'] = (a0) => (_xmlSAX2HasInternalSubset = Module['_xmlSAX2HasInternalSubset'] = wasmExports['xmlSAX2HasInternalSubset'])(a0);
var _xmlSAX2HasExternalSubset = Module['_xmlSAX2HasExternalSubset'] = (a0) => (_xmlSAX2HasExternalSubset = Module['_xmlSAX2HasExternalSubset'] = wasmExports['xmlSAX2HasExternalSubset'])(a0);
var _xmlSAX2ResolveEntity = Module['_xmlSAX2ResolveEntity'] = (a0, a1, a2) => (_xmlSAX2ResolveEntity = Module['_xmlSAX2ResolveEntity'] = wasmExports['xmlSAX2ResolveEntity'])(a0, a1, a2);
var _xmlSAX2GetEntity = Module['_xmlSAX2GetEntity'] = (a0, a1) => (_xmlSAX2GetEntity = Module['_xmlSAX2GetEntity'] = wasmExports['xmlSAX2GetEntity'])(a0, a1);
var _xmlSAX2EntityDecl = Module['_xmlSAX2EntityDecl'] = (a0, a1, a2, a3, a4, a5) => (_xmlSAX2EntityDecl = Module['_xmlSAX2EntityDecl'] = wasmExports['xmlSAX2EntityDecl'])(a0, a1, a2, a3, a4, a5);
var _xmlSAX2NotationDecl = Module['_xmlSAX2NotationDecl'] = (a0, a1, a2, a3) => (_xmlSAX2NotationDecl = Module['_xmlSAX2NotationDecl'] = wasmExports['xmlSAX2NotationDecl'])(a0, a1, a2, a3);
var _xmlSAX2AttributeDecl = Module['_xmlSAX2AttributeDecl'] = (a0, a1, a2, a3, a4, a5, a6) => (_xmlSAX2AttributeDecl = Module['_xmlSAX2AttributeDecl'] = wasmExports['xmlSAX2AttributeDecl'])(a0, a1, a2, a3, a4, a5, a6);
var _xmlSAX2ElementDecl = Module['_xmlSAX2ElementDecl'] = (a0, a1, a2, a3) => (_xmlSAX2ElementDecl = Module['_xmlSAX2ElementDecl'] = wasmExports['xmlSAX2ElementDecl'])(a0, a1, a2, a3);
var _xmlSAX2UnparsedEntityDecl = Module['_xmlSAX2UnparsedEntityDecl'] = (a0, a1, a2, a3, a4) => (_xmlSAX2UnparsedEntityDecl = Module['_xmlSAX2UnparsedEntityDecl'] = wasmExports['xmlSAX2UnparsedEntityDecl'])(a0, a1, a2, a3, a4);
var _xmlSAX2SetDocumentLocator = Module['_xmlSAX2SetDocumentLocator'] = (a0, a1) => (_xmlSAX2SetDocumentLocator = Module['_xmlSAX2SetDocumentLocator'] = wasmExports['xmlSAX2SetDocumentLocator'])(a0, a1);
var _xmlSAX2StartDocument = Module['_xmlSAX2StartDocument'] = (a0) => (_xmlSAX2StartDocument = Module['_xmlSAX2StartDocument'] = wasmExports['xmlSAX2StartDocument'])(a0);
var _xmlSAX2EndDocument = Module['_xmlSAX2EndDocument'] = (a0) => (_xmlSAX2EndDocument = Module['_xmlSAX2EndDocument'] = wasmExports['xmlSAX2EndDocument'])(a0);
var _xmlSAX2StartElement = Module['_xmlSAX2StartElement'] = (a0, a1, a2) => (_xmlSAX2StartElement = Module['_xmlSAX2StartElement'] = wasmExports['xmlSAX2StartElement'])(a0, a1, a2);
var _xmlSAX2EndElement = Module['_xmlSAX2EndElement'] = (a0, a1) => (_xmlSAX2EndElement = Module['_xmlSAX2EndElement'] = wasmExports['xmlSAX2EndElement'])(a0, a1);
var _xmlSAX2Reference = Module['_xmlSAX2Reference'] = (a0, a1) => (_xmlSAX2Reference = Module['_xmlSAX2Reference'] = wasmExports['xmlSAX2Reference'])(a0, a1);
var _xmlSAX2Characters = Module['_xmlSAX2Characters'] = (a0, a1, a2) => (_xmlSAX2Characters = Module['_xmlSAX2Characters'] = wasmExports['xmlSAX2Characters'])(a0, a1, a2);
var _xmlSAX2ProcessingInstruction = Module['_xmlSAX2ProcessingInstruction'] = (a0, a1, a2) => (_xmlSAX2ProcessingInstruction = Module['_xmlSAX2ProcessingInstruction'] = wasmExports['xmlSAX2ProcessingInstruction'])(a0, a1, a2);
var _xmlSAX2Comment = Module['_xmlSAX2Comment'] = (a0, a1) => (_xmlSAX2Comment = Module['_xmlSAX2Comment'] = wasmExports['xmlSAX2Comment'])(a0, a1);
var _xmlSAX2GetParameterEntity = Module['_xmlSAX2GetParameterEntity'] = (a0, a1) => (_xmlSAX2GetParameterEntity = Module['_xmlSAX2GetParameterEntity'] = wasmExports['xmlSAX2GetParameterEntity'])(a0, a1);
var _xmlSAX2CDataBlock = Module['_xmlSAX2CDataBlock'] = (a0, a1, a2) => (_xmlSAX2CDataBlock = Module['_xmlSAX2CDataBlock'] = wasmExports['xmlSAX2CDataBlock'])(a0, a1, a2);
var _xmlSAX2ExternalSubset = Module['_xmlSAX2ExternalSubset'] = (a0, a1, a2, a3) => (_xmlSAX2ExternalSubset = Module['_xmlSAX2ExternalSubset'] = wasmExports['xmlSAX2ExternalSubset'])(a0, a1, a2, a3);
var _xmlSAX2GetPublicId = Module['_xmlSAX2GetPublicId'] = (a0) => (_xmlSAX2GetPublicId = Module['_xmlSAX2GetPublicId'] = wasmExports['xmlSAX2GetPublicId'])(a0);
var _xmlSAX2GetSystemId = Module['_xmlSAX2GetSystemId'] = (a0) => (_xmlSAX2GetSystemId = Module['_xmlSAX2GetSystemId'] = wasmExports['xmlSAX2GetSystemId'])(a0);
var _xmlSAX2GetLineNumber = Module['_xmlSAX2GetLineNumber'] = (a0) => (_xmlSAX2GetLineNumber = Module['_xmlSAX2GetLineNumber'] = wasmExports['xmlSAX2GetLineNumber'])(a0);
var _xmlSAX2GetColumnNumber = Module['_xmlSAX2GetColumnNumber'] = (a0) => (_xmlSAX2GetColumnNumber = Module['_xmlSAX2GetColumnNumber'] = wasmExports['xmlSAX2GetColumnNumber'])(a0);
var _xmlSAX2IgnorableWhitespace = Module['_xmlSAX2IgnorableWhitespace'] = (a0, a1, a2) => (_xmlSAX2IgnorableWhitespace = Module['_xmlSAX2IgnorableWhitespace'] = wasmExports['xmlSAX2IgnorableWhitespace'])(a0, a1, a2);
var _xmlHashDefaultDeallocator = Module['_xmlHashDefaultDeallocator'] = (a0, a1) => (_xmlHashDefaultDeallocator = Module['_xmlHashDefaultDeallocator'] = wasmExports['xmlHashDefaultDeallocator'])(a0, a1);
var _iconv_open = Module['_iconv_open'] = (a0, a1) => (_iconv_open = Module['_iconv_open'] = wasmExports['iconv_open'])(a0, a1);
var _iconv_close = Module['_iconv_close'] = (a0) => (_iconv_close = Module['_iconv_close'] = wasmExports['iconv_close'])(a0);
var _iconv = Module['_iconv'] = (a0, a1, a2, a3, a4) => (_iconv = Module['_iconv'] = wasmExports['iconv'])(a0, a1, a2, a3, a4);
var _UTF8ToHtml = Module['_UTF8ToHtml'] = (a0, a1, a2, a3) => (_UTF8ToHtml = Module['_UTF8ToHtml'] = wasmExports['UTF8ToHtml'])(a0, a1, a2, a3);
var _xmlReadMemory = Module['_xmlReadMemory'] = (a0, a1, a2, a3, a4) => (_xmlReadMemory = Module['_xmlReadMemory'] = wasmExports['xmlReadMemory'])(a0, a1, a2, a3, a4);
var _xmlSAX2StartElementNs = Module['_xmlSAX2StartElementNs'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_xmlSAX2StartElementNs = Module['_xmlSAX2StartElementNs'] = wasmExports['xmlSAX2StartElementNs'])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
var _xmlSAX2EndElementNs = Module['_xmlSAX2EndElementNs'] = (a0, a1, a2, a3) => (_xmlSAX2EndElementNs = Module['_xmlSAX2EndElementNs'] = wasmExports['xmlSAX2EndElementNs'])(a0, a1, a2, a3);
var ___cxa_atexit = Module['___cxa_atexit'] = (a0, a1, a2) => (___cxa_atexit = Module['___cxa_atexit'] = wasmExports['__cxa_atexit'])(a0, a1, a2);
var _xmlDocGetRootElement = Module['_xmlDocGetRootElement'] = (a0) => (_xmlDocGetRootElement = Module['_xmlDocGetRootElement'] = wasmExports['xmlDocGetRootElement'])(a0);
var _xmlFileMatch = Module['_xmlFileMatch'] = (a0) => (_xmlFileMatch = Module['_xmlFileMatch'] = wasmExports['xmlFileMatch'])(a0);
var _xmlFileOpen = Module['_xmlFileOpen'] = (a0) => (_xmlFileOpen = Module['_xmlFileOpen'] = wasmExports['xmlFileOpen'])(a0);
var _xmlFileRead = Module['_xmlFileRead'] = (a0, a1, a2) => (_xmlFileRead = Module['_xmlFileRead'] = wasmExports['xmlFileRead'])(a0, a1, a2);
var _xmlFileClose = Module['_xmlFileClose'] = (a0) => (_xmlFileClose = Module['_xmlFileClose'] = wasmExports['xmlFileClose'])(a0);
var _gzread = Module['_gzread'] = (a0, a1, a2) => (_gzread = Module['_gzread'] = wasmExports['gzread'])(a0, a1, a2);
var _gzclose = Module['_gzclose'] = (a0) => (_gzclose = Module['_gzclose'] = wasmExports['gzclose'])(a0);
var _gzdirect = Module['_gzdirect'] = (a0) => (_gzdirect = Module['_gzdirect'] = wasmExports['gzdirect'])(a0);
var _gzdopen = Module['_gzdopen'] = (a0, a1) => (_gzdopen = Module['_gzdopen'] = wasmExports['gzdopen'])(a0, a1);
var _gzopen = Module['_gzopen'] = (a0, a1) => (_gzopen = Module['_gzopen'] = wasmExports['gzopen'])(a0, a1);
var _gzwrite = Module['_gzwrite'] = (a0, a1, a2) => (_gzwrite = Module['_gzwrite'] = wasmExports['gzwrite'])(a0, a1, a2);
var _xmlUCSIsCatNd = Module['_xmlUCSIsCatNd'] = (a0) => (_xmlUCSIsCatNd = Module['_xmlUCSIsCatNd'] = wasmExports['xmlUCSIsCatNd'])(a0);
var _xmlUCSIsCatP = Module['_xmlUCSIsCatP'] = (a0) => (_xmlUCSIsCatP = Module['_xmlUCSIsCatP'] = wasmExports['xmlUCSIsCatP'])(a0);
var _xmlUCSIsCatZ = Module['_xmlUCSIsCatZ'] = (a0) => (_xmlUCSIsCatZ = Module['_xmlUCSIsCatZ'] = wasmExports['xmlUCSIsCatZ'])(a0);
var _xmlUCSIsCatC = Module['_xmlUCSIsCatC'] = (a0) => (_xmlUCSIsCatC = Module['_xmlUCSIsCatC'] = wasmExports['xmlUCSIsCatC'])(a0);
var _xmlUCSIsCatL = Module['_xmlUCSIsCatL'] = (a0) => (_xmlUCSIsCatL = Module['_xmlUCSIsCatL'] = wasmExports['xmlUCSIsCatL'])(a0);
var _xmlUCSIsCatLu = Module['_xmlUCSIsCatLu'] = (a0) => (_xmlUCSIsCatLu = Module['_xmlUCSIsCatLu'] = wasmExports['xmlUCSIsCatLu'])(a0);
var _xmlUCSIsCatLl = Module['_xmlUCSIsCatLl'] = (a0) => (_xmlUCSIsCatLl = Module['_xmlUCSIsCatLl'] = wasmExports['xmlUCSIsCatLl'])(a0);
var _xmlUCSIsCatLt = Module['_xmlUCSIsCatLt'] = (a0) => (_xmlUCSIsCatLt = Module['_xmlUCSIsCatLt'] = wasmExports['xmlUCSIsCatLt'])(a0);
var _xmlUCSIsCatLm = Module['_xmlUCSIsCatLm'] = (a0) => (_xmlUCSIsCatLm = Module['_xmlUCSIsCatLm'] = wasmExports['xmlUCSIsCatLm'])(a0);
var _xmlUCSIsCatLo = Module['_xmlUCSIsCatLo'] = (a0) => (_xmlUCSIsCatLo = Module['_xmlUCSIsCatLo'] = wasmExports['xmlUCSIsCatLo'])(a0);
var _xmlUCSIsCatM = Module['_xmlUCSIsCatM'] = (a0) => (_xmlUCSIsCatM = Module['_xmlUCSIsCatM'] = wasmExports['xmlUCSIsCatM'])(a0);
var _xmlUCSIsCatMn = Module['_xmlUCSIsCatMn'] = (a0) => (_xmlUCSIsCatMn = Module['_xmlUCSIsCatMn'] = wasmExports['xmlUCSIsCatMn'])(a0);
var _xmlUCSIsCatMc = Module['_xmlUCSIsCatMc'] = (a0) => (_xmlUCSIsCatMc = Module['_xmlUCSIsCatMc'] = wasmExports['xmlUCSIsCatMc'])(a0);
var _xmlUCSIsCatMe = Module['_xmlUCSIsCatMe'] = (a0) => (_xmlUCSIsCatMe = Module['_xmlUCSIsCatMe'] = wasmExports['xmlUCSIsCatMe'])(a0);
var _xmlUCSIsCatN = Module['_xmlUCSIsCatN'] = (a0) => (_xmlUCSIsCatN = Module['_xmlUCSIsCatN'] = wasmExports['xmlUCSIsCatN'])(a0);
var _xmlUCSIsCatNl = Module['_xmlUCSIsCatNl'] = (a0) => (_xmlUCSIsCatNl = Module['_xmlUCSIsCatNl'] = wasmExports['xmlUCSIsCatNl'])(a0);
var _xmlUCSIsCatNo = Module['_xmlUCSIsCatNo'] = (a0) => (_xmlUCSIsCatNo = Module['_xmlUCSIsCatNo'] = wasmExports['xmlUCSIsCatNo'])(a0);
var _xmlUCSIsCatPc = Module['_xmlUCSIsCatPc'] = (a0) => (_xmlUCSIsCatPc = Module['_xmlUCSIsCatPc'] = wasmExports['xmlUCSIsCatPc'])(a0);
var _xmlUCSIsCatPd = Module['_xmlUCSIsCatPd'] = (a0) => (_xmlUCSIsCatPd = Module['_xmlUCSIsCatPd'] = wasmExports['xmlUCSIsCatPd'])(a0);
var _xmlUCSIsCatPs = Module['_xmlUCSIsCatPs'] = (a0) => (_xmlUCSIsCatPs = Module['_xmlUCSIsCatPs'] = wasmExports['xmlUCSIsCatPs'])(a0);
var _xmlUCSIsCatPe = Module['_xmlUCSIsCatPe'] = (a0) => (_xmlUCSIsCatPe = Module['_xmlUCSIsCatPe'] = wasmExports['xmlUCSIsCatPe'])(a0);
var _xmlUCSIsCatPi = Module['_xmlUCSIsCatPi'] = (a0) => (_xmlUCSIsCatPi = Module['_xmlUCSIsCatPi'] = wasmExports['xmlUCSIsCatPi'])(a0);
var _xmlUCSIsCatPf = Module['_xmlUCSIsCatPf'] = (a0) => (_xmlUCSIsCatPf = Module['_xmlUCSIsCatPf'] = wasmExports['xmlUCSIsCatPf'])(a0);
var _xmlUCSIsCatPo = Module['_xmlUCSIsCatPo'] = (a0) => (_xmlUCSIsCatPo = Module['_xmlUCSIsCatPo'] = wasmExports['xmlUCSIsCatPo'])(a0);
var _xmlUCSIsCatZs = Module['_xmlUCSIsCatZs'] = (a0) => (_xmlUCSIsCatZs = Module['_xmlUCSIsCatZs'] = wasmExports['xmlUCSIsCatZs'])(a0);
var _xmlUCSIsCatZl = Module['_xmlUCSIsCatZl'] = (a0) => (_xmlUCSIsCatZl = Module['_xmlUCSIsCatZl'] = wasmExports['xmlUCSIsCatZl'])(a0);
var _xmlUCSIsCatZp = Module['_xmlUCSIsCatZp'] = (a0) => (_xmlUCSIsCatZp = Module['_xmlUCSIsCatZp'] = wasmExports['xmlUCSIsCatZp'])(a0);
var _xmlUCSIsCatS = Module['_xmlUCSIsCatS'] = (a0) => (_xmlUCSIsCatS = Module['_xmlUCSIsCatS'] = wasmExports['xmlUCSIsCatS'])(a0);
var _xmlUCSIsCatSm = Module['_xmlUCSIsCatSm'] = (a0) => (_xmlUCSIsCatSm = Module['_xmlUCSIsCatSm'] = wasmExports['xmlUCSIsCatSm'])(a0);
var _xmlUCSIsCatSc = Module['_xmlUCSIsCatSc'] = (a0) => (_xmlUCSIsCatSc = Module['_xmlUCSIsCatSc'] = wasmExports['xmlUCSIsCatSc'])(a0);
var _xmlUCSIsCatSk = Module['_xmlUCSIsCatSk'] = (a0) => (_xmlUCSIsCatSk = Module['_xmlUCSIsCatSk'] = wasmExports['xmlUCSIsCatSk'])(a0);
var _xmlUCSIsCatSo = Module['_xmlUCSIsCatSo'] = (a0) => (_xmlUCSIsCatSo = Module['_xmlUCSIsCatSo'] = wasmExports['xmlUCSIsCatSo'])(a0);
var _xmlUCSIsCatCc = Module['_xmlUCSIsCatCc'] = (a0) => (_xmlUCSIsCatCc = Module['_xmlUCSIsCatCc'] = wasmExports['xmlUCSIsCatCc'])(a0);
var _xmlUCSIsCatCf = Module['_xmlUCSIsCatCf'] = (a0) => (_xmlUCSIsCatCf = Module['_xmlUCSIsCatCf'] = wasmExports['xmlUCSIsCatCf'])(a0);
var _xmlUCSIsCatCo = Module['_xmlUCSIsCatCo'] = (a0) => (_xmlUCSIsCatCo = Module['_xmlUCSIsCatCo'] = wasmExports['xmlUCSIsCatCo'])(a0);
var _xmlUCSIsAegeanNumbers = Module['_xmlUCSIsAegeanNumbers'] = (a0) => (_xmlUCSIsAegeanNumbers = Module['_xmlUCSIsAegeanNumbers'] = wasmExports['xmlUCSIsAegeanNumbers'])(a0);
var _xmlUCSIsAlphabeticPresentationForms = Module['_xmlUCSIsAlphabeticPresentationForms'] = (a0) => (_xmlUCSIsAlphabeticPresentationForms = Module['_xmlUCSIsAlphabeticPresentationForms'] = wasmExports['xmlUCSIsAlphabeticPresentationForms'])(a0);
var _xmlUCSIsArabic = Module['_xmlUCSIsArabic'] = (a0) => (_xmlUCSIsArabic = Module['_xmlUCSIsArabic'] = wasmExports['xmlUCSIsArabic'])(a0);
var _xmlUCSIsArabicPresentationFormsA = Module['_xmlUCSIsArabicPresentationFormsA'] = (a0) => (_xmlUCSIsArabicPresentationFormsA = Module['_xmlUCSIsArabicPresentationFormsA'] = wasmExports['xmlUCSIsArabicPresentationFormsA'])(a0);
var _xmlUCSIsArabicPresentationFormsB = Module['_xmlUCSIsArabicPresentationFormsB'] = (a0) => (_xmlUCSIsArabicPresentationFormsB = Module['_xmlUCSIsArabicPresentationFormsB'] = wasmExports['xmlUCSIsArabicPresentationFormsB'])(a0);
var _xmlUCSIsArmenian = Module['_xmlUCSIsArmenian'] = (a0) => (_xmlUCSIsArmenian = Module['_xmlUCSIsArmenian'] = wasmExports['xmlUCSIsArmenian'])(a0);
var _xmlUCSIsArrows = Module['_xmlUCSIsArrows'] = (a0) => (_xmlUCSIsArrows = Module['_xmlUCSIsArrows'] = wasmExports['xmlUCSIsArrows'])(a0);
var _xmlUCSIsBasicLatin = Module['_xmlUCSIsBasicLatin'] = (a0) => (_xmlUCSIsBasicLatin = Module['_xmlUCSIsBasicLatin'] = wasmExports['xmlUCSIsBasicLatin'])(a0);
var _xmlUCSIsBengali = Module['_xmlUCSIsBengali'] = (a0) => (_xmlUCSIsBengali = Module['_xmlUCSIsBengali'] = wasmExports['xmlUCSIsBengali'])(a0);
var _xmlUCSIsBlockElements = Module['_xmlUCSIsBlockElements'] = (a0) => (_xmlUCSIsBlockElements = Module['_xmlUCSIsBlockElements'] = wasmExports['xmlUCSIsBlockElements'])(a0);
var _xmlUCSIsBopomofo = Module['_xmlUCSIsBopomofo'] = (a0) => (_xmlUCSIsBopomofo = Module['_xmlUCSIsBopomofo'] = wasmExports['xmlUCSIsBopomofo'])(a0);
var _xmlUCSIsBopomofoExtended = Module['_xmlUCSIsBopomofoExtended'] = (a0) => (_xmlUCSIsBopomofoExtended = Module['_xmlUCSIsBopomofoExtended'] = wasmExports['xmlUCSIsBopomofoExtended'])(a0);
var _xmlUCSIsBoxDrawing = Module['_xmlUCSIsBoxDrawing'] = (a0) => (_xmlUCSIsBoxDrawing = Module['_xmlUCSIsBoxDrawing'] = wasmExports['xmlUCSIsBoxDrawing'])(a0);
var _xmlUCSIsBraillePatterns = Module['_xmlUCSIsBraillePatterns'] = (a0) => (_xmlUCSIsBraillePatterns = Module['_xmlUCSIsBraillePatterns'] = wasmExports['xmlUCSIsBraillePatterns'])(a0);
var _xmlUCSIsBuhid = Module['_xmlUCSIsBuhid'] = (a0) => (_xmlUCSIsBuhid = Module['_xmlUCSIsBuhid'] = wasmExports['xmlUCSIsBuhid'])(a0);
var _xmlUCSIsByzantineMusicalSymbols = Module['_xmlUCSIsByzantineMusicalSymbols'] = (a0) => (_xmlUCSIsByzantineMusicalSymbols = Module['_xmlUCSIsByzantineMusicalSymbols'] = wasmExports['xmlUCSIsByzantineMusicalSymbols'])(a0);
var _xmlUCSIsCJKCompatibility = Module['_xmlUCSIsCJKCompatibility'] = (a0) => (_xmlUCSIsCJKCompatibility = Module['_xmlUCSIsCJKCompatibility'] = wasmExports['xmlUCSIsCJKCompatibility'])(a0);
var _xmlUCSIsCJKCompatibilityForms = Module['_xmlUCSIsCJKCompatibilityForms'] = (a0) => (_xmlUCSIsCJKCompatibilityForms = Module['_xmlUCSIsCJKCompatibilityForms'] = wasmExports['xmlUCSIsCJKCompatibilityForms'])(a0);
var _xmlUCSIsCJKCompatibilityIdeographs = Module['_xmlUCSIsCJKCompatibilityIdeographs'] = (a0) => (_xmlUCSIsCJKCompatibilityIdeographs = Module['_xmlUCSIsCJKCompatibilityIdeographs'] = wasmExports['xmlUCSIsCJKCompatibilityIdeographs'])(a0);
var _xmlUCSIsCJKCompatibilityIdeographsSupplement = Module['_xmlUCSIsCJKCompatibilityIdeographsSupplement'] = (a0) => (_xmlUCSIsCJKCompatibilityIdeographsSupplement = Module['_xmlUCSIsCJKCompatibilityIdeographsSupplement'] = wasmExports['xmlUCSIsCJKCompatibilityIdeographsSupplement'])(a0);
var _xmlUCSIsCJKRadicalsSupplement = Module['_xmlUCSIsCJKRadicalsSupplement'] = (a0) => (_xmlUCSIsCJKRadicalsSupplement = Module['_xmlUCSIsCJKRadicalsSupplement'] = wasmExports['xmlUCSIsCJKRadicalsSupplement'])(a0);
var _xmlUCSIsCJKSymbolsandPunctuation = Module['_xmlUCSIsCJKSymbolsandPunctuation'] = (a0) => (_xmlUCSIsCJKSymbolsandPunctuation = Module['_xmlUCSIsCJKSymbolsandPunctuation'] = wasmExports['xmlUCSIsCJKSymbolsandPunctuation'])(a0);
var _xmlUCSIsCJKUnifiedIdeographs = Module['_xmlUCSIsCJKUnifiedIdeographs'] = (a0) => (_xmlUCSIsCJKUnifiedIdeographs = Module['_xmlUCSIsCJKUnifiedIdeographs'] = wasmExports['xmlUCSIsCJKUnifiedIdeographs'])(a0);
var _xmlUCSIsCJKUnifiedIdeographsExtensionA = Module['_xmlUCSIsCJKUnifiedIdeographsExtensionA'] = (a0) => (_xmlUCSIsCJKUnifiedIdeographsExtensionA = Module['_xmlUCSIsCJKUnifiedIdeographsExtensionA'] = wasmExports['xmlUCSIsCJKUnifiedIdeographsExtensionA'])(a0);
var _xmlUCSIsCJKUnifiedIdeographsExtensionB = Module['_xmlUCSIsCJKUnifiedIdeographsExtensionB'] = (a0) => (_xmlUCSIsCJKUnifiedIdeographsExtensionB = Module['_xmlUCSIsCJKUnifiedIdeographsExtensionB'] = wasmExports['xmlUCSIsCJKUnifiedIdeographsExtensionB'])(a0);
var _xmlUCSIsCherokee = Module['_xmlUCSIsCherokee'] = (a0) => (_xmlUCSIsCherokee = Module['_xmlUCSIsCherokee'] = wasmExports['xmlUCSIsCherokee'])(a0);
var _xmlUCSIsCombiningDiacriticalMarks = Module['_xmlUCSIsCombiningDiacriticalMarks'] = (a0) => (_xmlUCSIsCombiningDiacriticalMarks = Module['_xmlUCSIsCombiningDiacriticalMarks'] = wasmExports['xmlUCSIsCombiningDiacriticalMarks'])(a0);
var _xmlUCSIsCombiningDiacriticalMarksforSymbols = Module['_xmlUCSIsCombiningDiacriticalMarksforSymbols'] = (a0) => (_xmlUCSIsCombiningDiacriticalMarksforSymbols = Module['_xmlUCSIsCombiningDiacriticalMarksforSymbols'] = wasmExports['xmlUCSIsCombiningDiacriticalMarksforSymbols'])(a0);
var _xmlUCSIsCombiningHalfMarks = Module['_xmlUCSIsCombiningHalfMarks'] = (a0) => (_xmlUCSIsCombiningHalfMarks = Module['_xmlUCSIsCombiningHalfMarks'] = wasmExports['xmlUCSIsCombiningHalfMarks'])(a0);
var _xmlUCSIsCombiningMarksforSymbols = Module['_xmlUCSIsCombiningMarksforSymbols'] = (a0) => (_xmlUCSIsCombiningMarksforSymbols = Module['_xmlUCSIsCombiningMarksforSymbols'] = wasmExports['xmlUCSIsCombiningMarksforSymbols'])(a0);
var _xmlUCSIsControlPictures = Module['_xmlUCSIsControlPictures'] = (a0) => (_xmlUCSIsControlPictures = Module['_xmlUCSIsControlPictures'] = wasmExports['xmlUCSIsControlPictures'])(a0);
var _xmlUCSIsCurrencySymbols = Module['_xmlUCSIsCurrencySymbols'] = (a0) => (_xmlUCSIsCurrencySymbols = Module['_xmlUCSIsCurrencySymbols'] = wasmExports['xmlUCSIsCurrencySymbols'])(a0);
var _xmlUCSIsCypriotSyllabary = Module['_xmlUCSIsCypriotSyllabary'] = (a0) => (_xmlUCSIsCypriotSyllabary = Module['_xmlUCSIsCypriotSyllabary'] = wasmExports['xmlUCSIsCypriotSyllabary'])(a0);
var _xmlUCSIsCyrillic = Module['_xmlUCSIsCyrillic'] = (a0) => (_xmlUCSIsCyrillic = Module['_xmlUCSIsCyrillic'] = wasmExports['xmlUCSIsCyrillic'])(a0);
var _xmlUCSIsCyrillicSupplement = Module['_xmlUCSIsCyrillicSupplement'] = (a0) => (_xmlUCSIsCyrillicSupplement = Module['_xmlUCSIsCyrillicSupplement'] = wasmExports['xmlUCSIsCyrillicSupplement'])(a0);
var _xmlUCSIsDeseret = Module['_xmlUCSIsDeseret'] = (a0) => (_xmlUCSIsDeseret = Module['_xmlUCSIsDeseret'] = wasmExports['xmlUCSIsDeseret'])(a0);
var _xmlUCSIsDevanagari = Module['_xmlUCSIsDevanagari'] = (a0) => (_xmlUCSIsDevanagari = Module['_xmlUCSIsDevanagari'] = wasmExports['xmlUCSIsDevanagari'])(a0);
var _xmlUCSIsDingbats = Module['_xmlUCSIsDingbats'] = (a0) => (_xmlUCSIsDingbats = Module['_xmlUCSIsDingbats'] = wasmExports['xmlUCSIsDingbats'])(a0);
var _xmlUCSIsEnclosedAlphanumerics = Module['_xmlUCSIsEnclosedAlphanumerics'] = (a0) => (_xmlUCSIsEnclosedAlphanumerics = Module['_xmlUCSIsEnclosedAlphanumerics'] = wasmExports['xmlUCSIsEnclosedAlphanumerics'])(a0);
var _xmlUCSIsEnclosedCJKLettersandMonths = Module['_xmlUCSIsEnclosedCJKLettersandMonths'] = (a0) => (_xmlUCSIsEnclosedCJKLettersandMonths = Module['_xmlUCSIsEnclosedCJKLettersandMonths'] = wasmExports['xmlUCSIsEnclosedCJKLettersandMonths'])(a0);
var _xmlUCSIsEthiopic = Module['_xmlUCSIsEthiopic'] = (a0) => (_xmlUCSIsEthiopic = Module['_xmlUCSIsEthiopic'] = wasmExports['xmlUCSIsEthiopic'])(a0);
var _xmlUCSIsGeneralPunctuation = Module['_xmlUCSIsGeneralPunctuation'] = (a0) => (_xmlUCSIsGeneralPunctuation = Module['_xmlUCSIsGeneralPunctuation'] = wasmExports['xmlUCSIsGeneralPunctuation'])(a0);
var _xmlUCSIsGeometricShapes = Module['_xmlUCSIsGeometricShapes'] = (a0) => (_xmlUCSIsGeometricShapes = Module['_xmlUCSIsGeometricShapes'] = wasmExports['xmlUCSIsGeometricShapes'])(a0);
var _xmlUCSIsGeorgian = Module['_xmlUCSIsGeorgian'] = (a0) => (_xmlUCSIsGeorgian = Module['_xmlUCSIsGeorgian'] = wasmExports['xmlUCSIsGeorgian'])(a0);
var _xmlUCSIsGothic = Module['_xmlUCSIsGothic'] = (a0) => (_xmlUCSIsGothic = Module['_xmlUCSIsGothic'] = wasmExports['xmlUCSIsGothic'])(a0);
var _xmlUCSIsGreek = Module['_xmlUCSIsGreek'] = (a0) => (_xmlUCSIsGreek = Module['_xmlUCSIsGreek'] = wasmExports['xmlUCSIsGreek'])(a0);
var _xmlUCSIsGreekExtended = Module['_xmlUCSIsGreekExtended'] = (a0) => (_xmlUCSIsGreekExtended = Module['_xmlUCSIsGreekExtended'] = wasmExports['xmlUCSIsGreekExtended'])(a0);
var _xmlUCSIsGreekandCoptic = Module['_xmlUCSIsGreekandCoptic'] = (a0) => (_xmlUCSIsGreekandCoptic = Module['_xmlUCSIsGreekandCoptic'] = wasmExports['xmlUCSIsGreekandCoptic'])(a0);
var _xmlUCSIsGujarati = Module['_xmlUCSIsGujarati'] = (a0) => (_xmlUCSIsGujarati = Module['_xmlUCSIsGujarati'] = wasmExports['xmlUCSIsGujarati'])(a0);
var _xmlUCSIsGurmukhi = Module['_xmlUCSIsGurmukhi'] = (a0) => (_xmlUCSIsGurmukhi = Module['_xmlUCSIsGurmukhi'] = wasmExports['xmlUCSIsGurmukhi'])(a0);
var _xmlUCSIsHalfwidthandFullwidthForms = Module['_xmlUCSIsHalfwidthandFullwidthForms'] = (a0) => (_xmlUCSIsHalfwidthandFullwidthForms = Module['_xmlUCSIsHalfwidthandFullwidthForms'] = wasmExports['xmlUCSIsHalfwidthandFullwidthForms'])(a0);
var _xmlUCSIsHangulCompatibilityJamo = Module['_xmlUCSIsHangulCompatibilityJamo'] = (a0) => (_xmlUCSIsHangulCompatibilityJamo = Module['_xmlUCSIsHangulCompatibilityJamo'] = wasmExports['xmlUCSIsHangulCompatibilityJamo'])(a0);
var _xmlUCSIsHangulJamo = Module['_xmlUCSIsHangulJamo'] = (a0) => (_xmlUCSIsHangulJamo = Module['_xmlUCSIsHangulJamo'] = wasmExports['xmlUCSIsHangulJamo'])(a0);
var _xmlUCSIsHangulSyllables = Module['_xmlUCSIsHangulSyllables'] = (a0) => (_xmlUCSIsHangulSyllables = Module['_xmlUCSIsHangulSyllables'] = wasmExports['xmlUCSIsHangulSyllables'])(a0);
var _xmlUCSIsHanunoo = Module['_xmlUCSIsHanunoo'] = (a0) => (_xmlUCSIsHanunoo = Module['_xmlUCSIsHanunoo'] = wasmExports['xmlUCSIsHanunoo'])(a0);
var _xmlUCSIsHebrew = Module['_xmlUCSIsHebrew'] = (a0) => (_xmlUCSIsHebrew = Module['_xmlUCSIsHebrew'] = wasmExports['xmlUCSIsHebrew'])(a0);
var _xmlUCSIsHighPrivateUseSurrogates = Module['_xmlUCSIsHighPrivateUseSurrogates'] = (a0) => (_xmlUCSIsHighPrivateUseSurrogates = Module['_xmlUCSIsHighPrivateUseSurrogates'] = wasmExports['xmlUCSIsHighPrivateUseSurrogates'])(a0);
var _xmlUCSIsHighSurrogates = Module['_xmlUCSIsHighSurrogates'] = (a0) => (_xmlUCSIsHighSurrogates = Module['_xmlUCSIsHighSurrogates'] = wasmExports['xmlUCSIsHighSurrogates'])(a0);
var _xmlUCSIsHiragana = Module['_xmlUCSIsHiragana'] = (a0) => (_xmlUCSIsHiragana = Module['_xmlUCSIsHiragana'] = wasmExports['xmlUCSIsHiragana'])(a0);
var _xmlUCSIsIPAExtensions = Module['_xmlUCSIsIPAExtensions'] = (a0) => (_xmlUCSIsIPAExtensions = Module['_xmlUCSIsIPAExtensions'] = wasmExports['xmlUCSIsIPAExtensions'])(a0);
var _xmlUCSIsIdeographicDescriptionCharacters = Module['_xmlUCSIsIdeographicDescriptionCharacters'] = (a0) => (_xmlUCSIsIdeographicDescriptionCharacters = Module['_xmlUCSIsIdeographicDescriptionCharacters'] = wasmExports['xmlUCSIsIdeographicDescriptionCharacters'])(a0);
var _xmlUCSIsKanbun = Module['_xmlUCSIsKanbun'] = (a0) => (_xmlUCSIsKanbun = Module['_xmlUCSIsKanbun'] = wasmExports['xmlUCSIsKanbun'])(a0);
var _xmlUCSIsKangxiRadicals = Module['_xmlUCSIsKangxiRadicals'] = (a0) => (_xmlUCSIsKangxiRadicals = Module['_xmlUCSIsKangxiRadicals'] = wasmExports['xmlUCSIsKangxiRadicals'])(a0);
var _xmlUCSIsKannada = Module['_xmlUCSIsKannada'] = (a0) => (_xmlUCSIsKannada = Module['_xmlUCSIsKannada'] = wasmExports['xmlUCSIsKannada'])(a0);
var _xmlUCSIsKatakana = Module['_xmlUCSIsKatakana'] = (a0) => (_xmlUCSIsKatakana = Module['_xmlUCSIsKatakana'] = wasmExports['xmlUCSIsKatakana'])(a0);
var _xmlUCSIsKatakanaPhoneticExtensions = Module['_xmlUCSIsKatakanaPhoneticExtensions'] = (a0) => (_xmlUCSIsKatakanaPhoneticExtensions = Module['_xmlUCSIsKatakanaPhoneticExtensions'] = wasmExports['xmlUCSIsKatakanaPhoneticExtensions'])(a0);
var _xmlUCSIsKhmer = Module['_xmlUCSIsKhmer'] = (a0) => (_xmlUCSIsKhmer = Module['_xmlUCSIsKhmer'] = wasmExports['xmlUCSIsKhmer'])(a0);
var _xmlUCSIsKhmerSymbols = Module['_xmlUCSIsKhmerSymbols'] = (a0) => (_xmlUCSIsKhmerSymbols = Module['_xmlUCSIsKhmerSymbols'] = wasmExports['xmlUCSIsKhmerSymbols'])(a0);
var _xmlUCSIsLao = Module['_xmlUCSIsLao'] = (a0) => (_xmlUCSIsLao = Module['_xmlUCSIsLao'] = wasmExports['xmlUCSIsLao'])(a0);
var _xmlUCSIsLatin1Supplement = Module['_xmlUCSIsLatin1Supplement'] = (a0) => (_xmlUCSIsLatin1Supplement = Module['_xmlUCSIsLatin1Supplement'] = wasmExports['xmlUCSIsLatin1Supplement'])(a0);
var _xmlUCSIsLatinExtendedA = Module['_xmlUCSIsLatinExtendedA'] = (a0) => (_xmlUCSIsLatinExtendedA = Module['_xmlUCSIsLatinExtendedA'] = wasmExports['xmlUCSIsLatinExtendedA'])(a0);
var _xmlUCSIsLatinExtendedB = Module['_xmlUCSIsLatinExtendedB'] = (a0) => (_xmlUCSIsLatinExtendedB = Module['_xmlUCSIsLatinExtendedB'] = wasmExports['xmlUCSIsLatinExtendedB'])(a0);
var _xmlUCSIsLatinExtendedAdditional = Module['_xmlUCSIsLatinExtendedAdditional'] = (a0) => (_xmlUCSIsLatinExtendedAdditional = Module['_xmlUCSIsLatinExtendedAdditional'] = wasmExports['xmlUCSIsLatinExtendedAdditional'])(a0);
var _xmlUCSIsLetterlikeSymbols = Module['_xmlUCSIsLetterlikeSymbols'] = (a0) => (_xmlUCSIsLetterlikeSymbols = Module['_xmlUCSIsLetterlikeSymbols'] = wasmExports['xmlUCSIsLetterlikeSymbols'])(a0);
var _xmlUCSIsLimbu = Module['_xmlUCSIsLimbu'] = (a0) => (_xmlUCSIsLimbu = Module['_xmlUCSIsLimbu'] = wasmExports['xmlUCSIsLimbu'])(a0);
var _xmlUCSIsLinearBIdeograms = Module['_xmlUCSIsLinearBIdeograms'] = (a0) => (_xmlUCSIsLinearBIdeograms = Module['_xmlUCSIsLinearBIdeograms'] = wasmExports['xmlUCSIsLinearBIdeograms'])(a0);
var _xmlUCSIsLinearBSyllabary = Module['_xmlUCSIsLinearBSyllabary'] = (a0) => (_xmlUCSIsLinearBSyllabary = Module['_xmlUCSIsLinearBSyllabary'] = wasmExports['xmlUCSIsLinearBSyllabary'])(a0);
var _xmlUCSIsLowSurrogates = Module['_xmlUCSIsLowSurrogates'] = (a0) => (_xmlUCSIsLowSurrogates = Module['_xmlUCSIsLowSurrogates'] = wasmExports['xmlUCSIsLowSurrogates'])(a0);
var _xmlUCSIsMalayalam = Module['_xmlUCSIsMalayalam'] = (a0) => (_xmlUCSIsMalayalam = Module['_xmlUCSIsMalayalam'] = wasmExports['xmlUCSIsMalayalam'])(a0);
var _xmlUCSIsMathematicalAlphanumericSymbols = Module['_xmlUCSIsMathematicalAlphanumericSymbols'] = (a0) => (_xmlUCSIsMathematicalAlphanumericSymbols = Module['_xmlUCSIsMathematicalAlphanumericSymbols'] = wasmExports['xmlUCSIsMathematicalAlphanumericSymbols'])(a0);
var _xmlUCSIsMathematicalOperators = Module['_xmlUCSIsMathematicalOperators'] = (a0) => (_xmlUCSIsMathematicalOperators = Module['_xmlUCSIsMathematicalOperators'] = wasmExports['xmlUCSIsMathematicalOperators'])(a0);
var _xmlUCSIsMiscellaneousMathematicalSymbolsA = Module['_xmlUCSIsMiscellaneousMathematicalSymbolsA'] = (a0) => (_xmlUCSIsMiscellaneousMathematicalSymbolsA = Module['_xmlUCSIsMiscellaneousMathematicalSymbolsA'] = wasmExports['xmlUCSIsMiscellaneousMathematicalSymbolsA'])(a0);
var _xmlUCSIsMiscellaneousMathematicalSymbolsB = Module['_xmlUCSIsMiscellaneousMathematicalSymbolsB'] = (a0) => (_xmlUCSIsMiscellaneousMathematicalSymbolsB = Module['_xmlUCSIsMiscellaneousMathematicalSymbolsB'] = wasmExports['xmlUCSIsMiscellaneousMathematicalSymbolsB'])(a0);
var _xmlUCSIsMiscellaneousSymbols = Module['_xmlUCSIsMiscellaneousSymbols'] = (a0) => (_xmlUCSIsMiscellaneousSymbols = Module['_xmlUCSIsMiscellaneousSymbols'] = wasmExports['xmlUCSIsMiscellaneousSymbols'])(a0);
var _xmlUCSIsMiscellaneousSymbolsandArrows = Module['_xmlUCSIsMiscellaneousSymbolsandArrows'] = (a0) => (_xmlUCSIsMiscellaneousSymbolsandArrows = Module['_xmlUCSIsMiscellaneousSymbolsandArrows'] = wasmExports['xmlUCSIsMiscellaneousSymbolsandArrows'])(a0);
var _xmlUCSIsMiscellaneousTechnical = Module['_xmlUCSIsMiscellaneousTechnical'] = (a0) => (_xmlUCSIsMiscellaneousTechnical = Module['_xmlUCSIsMiscellaneousTechnical'] = wasmExports['xmlUCSIsMiscellaneousTechnical'])(a0);
var _xmlUCSIsMongolian = Module['_xmlUCSIsMongolian'] = (a0) => (_xmlUCSIsMongolian = Module['_xmlUCSIsMongolian'] = wasmExports['xmlUCSIsMongolian'])(a0);
var _xmlUCSIsMusicalSymbols = Module['_xmlUCSIsMusicalSymbols'] = (a0) => (_xmlUCSIsMusicalSymbols = Module['_xmlUCSIsMusicalSymbols'] = wasmExports['xmlUCSIsMusicalSymbols'])(a0);
var _xmlUCSIsMyanmar = Module['_xmlUCSIsMyanmar'] = (a0) => (_xmlUCSIsMyanmar = Module['_xmlUCSIsMyanmar'] = wasmExports['xmlUCSIsMyanmar'])(a0);
var _xmlUCSIsNumberForms = Module['_xmlUCSIsNumberForms'] = (a0) => (_xmlUCSIsNumberForms = Module['_xmlUCSIsNumberForms'] = wasmExports['xmlUCSIsNumberForms'])(a0);
var _xmlUCSIsOgham = Module['_xmlUCSIsOgham'] = (a0) => (_xmlUCSIsOgham = Module['_xmlUCSIsOgham'] = wasmExports['xmlUCSIsOgham'])(a0);
var _xmlUCSIsOldItalic = Module['_xmlUCSIsOldItalic'] = (a0) => (_xmlUCSIsOldItalic = Module['_xmlUCSIsOldItalic'] = wasmExports['xmlUCSIsOldItalic'])(a0);
var _xmlUCSIsOpticalCharacterRecognition = Module['_xmlUCSIsOpticalCharacterRecognition'] = (a0) => (_xmlUCSIsOpticalCharacterRecognition = Module['_xmlUCSIsOpticalCharacterRecognition'] = wasmExports['xmlUCSIsOpticalCharacterRecognition'])(a0);
var _xmlUCSIsOriya = Module['_xmlUCSIsOriya'] = (a0) => (_xmlUCSIsOriya = Module['_xmlUCSIsOriya'] = wasmExports['xmlUCSIsOriya'])(a0);
var _xmlUCSIsOsmanya = Module['_xmlUCSIsOsmanya'] = (a0) => (_xmlUCSIsOsmanya = Module['_xmlUCSIsOsmanya'] = wasmExports['xmlUCSIsOsmanya'])(a0);
var _xmlUCSIsPhoneticExtensions = Module['_xmlUCSIsPhoneticExtensions'] = (a0) => (_xmlUCSIsPhoneticExtensions = Module['_xmlUCSIsPhoneticExtensions'] = wasmExports['xmlUCSIsPhoneticExtensions'])(a0);
var _xmlUCSIsPrivateUse = Module['_xmlUCSIsPrivateUse'] = (a0) => (_xmlUCSIsPrivateUse = Module['_xmlUCSIsPrivateUse'] = wasmExports['xmlUCSIsPrivateUse'])(a0);
var _xmlUCSIsPrivateUseArea = Module['_xmlUCSIsPrivateUseArea'] = (a0) => (_xmlUCSIsPrivateUseArea = Module['_xmlUCSIsPrivateUseArea'] = wasmExports['xmlUCSIsPrivateUseArea'])(a0);
var _xmlUCSIsRunic = Module['_xmlUCSIsRunic'] = (a0) => (_xmlUCSIsRunic = Module['_xmlUCSIsRunic'] = wasmExports['xmlUCSIsRunic'])(a0);
var _xmlUCSIsShavian = Module['_xmlUCSIsShavian'] = (a0) => (_xmlUCSIsShavian = Module['_xmlUCSIsShavian'] = wasmExports['xmlUCSIsShavian'])(a0);
var _xmlUCSIsSinhala = Module['_xmlUCSIsSinhala'] = (a0) => (_xmlUCSIsSinhala = Module['_xmlUCSIsSinhala'] = wasmExports['xmlUCSIsSinhala'])(a0);
var _xmlUCSIsSmallFormVariants = Module['_xmlUCSIsSmallFormVariants'] = (a0) => (_xmlUCSIsSmallFormVariants = Module['_xmlUCSIsSmallFormVariants'] = wasmExports['xmlUCSIsSmallFormVariants'])(a0);
var _xmlUCSIsSpacingModifierLetters = Module['_xmlUCSIsSpacingModifierLetters'] = (a0) => (_xmlUCSIsSpacingModifierLetters = Module['_xmlUCSIsSpacingModifierLetters'] = wasmExports['xmlUCSIsSpacingModifierLetters'])(a0);
var _xmlUCSIsSpecials = Module['_xmlUCSIsSpecials'] = (a0) => (_xmlUCSIsSpecials = Module['_xmlUCSIsSpecials'] = wasmExports['xmlUCSIsSpecials'])(a0);
var _xmlUCSIsSuperscriptsandSubscripts = Module['_xmlUCSIsSuperscriptsandSubscripts'] = (a0) => (_xmlUCSIsSuperscriptsandSubscripts = Module['_xmlUCSIsSuperscriptsandSubscripts'] = wasmExports['xmlUCSIsSuperscriptsandSubscripts'])(a0);
var _xmlUCSIsSupplementalArrowsA = Module['_xmlUCSIsSupplementalArrowsA'] = (a0) => (_xmlUCSIsSupplementalArrowsA = Module['_xmlUCSIsSupplementalArrowsA'] = wasmExports['xmlUCSIsSupplementalArrowsA'])(a0);
var _xmlUCSIsSupplementalArrowsB = Module['_xmlUCSIsSupplementalArrowsB'] = (a0) => (_xmlUCSIsSupplementalArrowsB = Module['_xmlUCSIsSupplementalArrowsB'] = wasmExports['xmlUCSIsSupplementalArrowsB'])(a0);
var _xmlUCSIsSupplementalMathematicalOperators = Module['_xmlUCSIsSupplementalMathematicalOperators'] = (a0) => (_xmlUCSIsSupplementalMathematicalOperators = Module['_xmlUCSIsSupplementalMathematicalOperators'] = wasmExports['xmlUCSIsSupplementalMathematicalOperators'])(a0);
var _xmlUCSIsSupplementaryPrivateUseAreaA = Module['_xmlUCSIsSupplementaryPrivateUseAreaA'] = (a0) => (_xmlUCSIsSupplementaryPrivateUseAreaA = Module['_xmlUCSIsSupplementaryPrivateUseAreaA'] = wasmExports['xmlUCSIsSupplementaryPrivateUseAreaA'])(a0);
var _xmlUCSIsSupplementaryPrivateUseAreaB = Module['_xmlUCSIsSupplementaryPrivateUseAreaB'] = (a0) => (_xmlUCSIsSupplementaryPrivateUseAreaB = Module['_xmlUCSIsSupplementaryPrivateUseAreaB'] = wasmExports['xmlUCSIsSupplementaryPrivateUseAreaB'])(a0);
var _xmlUCSIsSyriac = Module['_xmlUCSIsSyriac'] = (a0) => (_xmlUCSIsSyriac = Module['_xmlUCSIsSyriac'] = wasmExports['xmlUCSIsSyriac'])(a0);
var _xmlUCSIsTagalog = Module['_xmlUCSIsTagalog'] = (a0) => (_xmlUCSIsTagalog = Module['_xmlUCSIsTagalog'] = wasmExports['xmlUCSIsTagalog'])(a0);
var _xmlUCSIsTagbanwa = Module['_xmlUCSIsTagbanwa'] = (a0) => (_xmlUCSIsTagbanwa = Module['_xmlUCSIsTagbanwa'] = wasmExports['xmlUCSIsTagbanwa'])(a0);
var _xmlUCSIsTags = Module['_xmlUCSIsTags'] = (a0) => (_xmlUCSIsTags = Module['_xmlUCSIsTags'] = wasmExports['xmlUCSIsTags'])(a0);
var _xmlUCSIsTaiLe = Module['_xmlUCSIsTaiLe'] = (a0) => (_xmlUCSIsTaiLe = Module['_xmlUCSIsTaiLe'] = wasmExports['xmlUCSIsTaiLe'])(a0);
var _xmlUCSIsTaiXuanJingSymbols = Module['_xmlUCSIsTaiXuanJingSymbols'] = (a0) => (_xmlUCSIsTaiXuanJingSymbols = Module['_xmlUCSIsTaiXuanJingSymbols'] = wasmExports['xmlUCSIsTaiXuanJingSymbols'])(a0);
var _xmlUCSIsTamil = Module['_xmlUCSIsTamil'] = (a0) => (_xmlUCSIsTamil = Module['_xmlUCSIsTamil'] = wasmExports['xmlUCSIsTamil'])(a0);
var _xmlUCSIsTelugu = Module['_xmlUCSIsTelugu'] = (a0) => (_xmlUCSIsTelugu = Module['_xmlUCSIsTelugu'] = wasmExports['xmlUCSIsTelugu'])(a0);
var _xmlUCSIsThaana = Module['_xmlUCSIsThaana'] = (a0) => (_xmlUCSIsThaana = Module['_xmlUCSIsThaana'] = wasmExports['xmlUCSIsThaana'])(a0);
var _xmlUCSIsThai = Module['_xmlUCSIsThai'] = (a0) => (_xmlUCSIsThai = Module['_xmlUCSIsThai'] = wasmExports['xmlUCSIsThai'])(a0);
var _xmlUCSIsTibetan = Module['_xmlUCSIsTibetan'] = (a0) => (_xmlUCSIsTibetan = Module['_xmlUCSIsTibetan'] = wasmExports['xmlUCSIsTibetan'])(a0);
var _xmlUCSIsUgaritic = Module['_xmlUCSIsUgaritic'] = (a0) => (_xmlUCSIsUgaritic = Module['_xmlUCSIsUgaritic'] = wasmExports['xmlUCSIsUgaritic'])(a0);
var _xmlUCSIsUnifiedCanadianAboriginalSyllabics = Module['_xmlUCSIsUnifiedCanadianAboriginalSyllabics'] = (a0) => (_xmlUCSIsUnifiedCanadianAboriginalSyllabics = Module['_xmlUCSIsUnifiedCanadianAboriginalSyllabics'] = wasmExports['xmlUCSIsUnifiedCanadianAboriginalSyllabics'])(a0);
var _xmlUCSIsVariationSelectors = Module['_xmlUCSIsVariationSelectors'] = (a0) => (_xmlUCSIsVariationSelectors = Module['_xmlUCSIsVariationSelectors'] = wasmExports['xmlUCSIsVariationSelectors'])(a0);
var _xmlUCSIsVariationSelectorsSupplement = Module['_xmlUCSIsVariationSelectorsSupplement'] = (a0) => (_xmlUCSIsVariationSelectorsSupplement = Module['_xmlUCSIsVariationSelectorsSupplement'] = wasmExports['xmlUCSIsVariationSelectorsSupplement'])(a0);
var _xmlUCSIsYiRadicals = Module['_xmlUCSIsYiRadicals'] = (a0) => (_xmlUCSIsYiRadicals = Module['_xmlUCSIsYiRadicals'] = wasmExports['xmlUCSIsYiRadicals'])(a0);
var _xmlUCSIsYiSyllables = Module['_xmlUCSIsYiSyllables'] = (a0) => (_xmlUCSIsYiSyllables = Module['_xmlUCSIsYiSyllables'] = wasmExports['xmlUCSIsYiSyllables'])(a0);
var _xmlUCSIsYijingHexagramSymbols = Module['_xmlUCSIsYijingHexagramSymbols'] = (a0) => (_xmlUCSIsYijingHexagramSymbols = Module['_xmlUCSIsYijingHexagramSymbols'] = wasmExports['xmlUCSIsYijingHexagramSymbols'])(a0);
var _xmlUCSIsCatCs = Module['_xmlUCSIsCatCs'] = (a0) => (_xmlUCSIsCatCs = Module['_xmlUCSIsCatCs'] = wasmExports['xmlUCSIsCatCs'])(a0);
var ___small_fprintf = Module['___small_fprintf'] = (a0, a1, a2) => (___small_fprintf = Module['___small_fprintf'] = wasmExports['__small_fprintf'])(a0, a1, a2);
var _xmlXPathBooleanFunction = Module['_xmlXPathBooleanFunction'] = (a0, a1) => (_xmlXPathBooleanFunction = Module['_xmlXPathBooleanFunction'] = wasmExports['xmlXPathBooleanFunction'])(a0, a1);
var _xmlXPathCeilingFunction = Module['_xmlXPathCeilingFunction'] = (a0, a1) => (_xmlXPathCeilingFunction = Module['_xmlXPathCeilingFunction'] = wasmExports['xmlXPathCeilingFunction'])(a0, a1);
var _xmlXPathCountFunction = Module['_xmlXPathCountFunction'] = (a0, a1) => (_xmlXPathCountFunction = Module['_xmlXPathCountFunction'] = wasmExports['xmlXPathCountFunction'])(a0, a1);
var _xmlXPathConcatFunction = Module['_xmlXPathConcatFunction'] = (a0, a1) => (_xmlXPathConcatFunction = Module['_xmlXPathConcatFunction'] = wasmExports['xmlXPathConcatFunction'])(a0, a1);
var _xmlXPathContainsFunction = Module['_xmlXPathContainsFunction'] = (a0, a1) => (_xmlXPathContainsFunction = Module['_xmlXPathContainsFunction'] = wasmExports['xmlXPathContainsFunction'])(a0, a1);
var _xmlXPathIdFunction = Module['_xmlXPathIdFunction'] = (a0, a1) => (_xmlXPathIdFunction = Module['_xmlXPathIdFunction'] = wasmExports['xmlXPathIdFunction'])(a0, a1);
var _xmlXPathFalseFunction = Module['_xmlXPathFalseFunction'] = (a0, a1) => (_xmlXPathFalseFunction = Module['_xmlXPathFalseFunction'] = wasmExports['xmlXPathFalseFunction'])(a0, a1);
var _xmlXPathFloorFunction = Module['_xmlXPathFloorFunction'] = (a0, a1) => (_xmlXPathFloorFunction = Module['_xmlXPathFloorFunction'] = wasmExports['xmlXPathFloorFunction'])(a0, a1);
var _xmlXPathLastFunction = Module['_xmlXPathLastFunction'] = (a0, a1) => (_xmlXPathLastFunction = Module['_xmlXPathLastFunction'] = wasmExports['xmlXPathLastFunction'])(a0, a1);
var _xmlXPathLangFunction = Module['_xmlXPathLangFunction'] = (a0, a1) => (_xmlXPathLangFunction = Module['_xmlXPathLangFunction'] = wasmExports['xmlXPathLangFunction'])(a0, a1);
var _xmlXPathLocalNameFunction = Module['_xmlXPathLocalNameFunction'] = (a0, a1) => (_xmlXPathLocalNameFunction = Module['_xmlXPathLocalNameFunction'] = wasmExports['xmlXPathLocalNameFunction'])(a0, a1);
var _xmlXPathNotFunction = Module['_xmlXPathNotFunction'] = (a0, a1) => (_xmlXPathNotFunction = Module['_xmlXPathNotFunction'] = wasmExports['xmlXPathNotFunction'])(a0, a1);
var _xmlXPathNamespaceURIFunction = Module['_xmlXPathNamespaceURIFunction'] = (a0, a1) => (_xmlXPathNamespaceURIFunction = Module['_xmlXPathNamespaceURIFunction'] = wasmExports['xmlXPathNamespaceURIFunction'])(a0, a1);
var _xmlXPathNormalizeFunction = Module['_xmlXPathNormalizeFunction'] = (a0, a1) => (_xmlXPathNormalizeFunction = Module['_xmlXPathNormalizeFunction'] = wasmExports['xmlXPathNormalizeFunction'])(a0, a1);
var _xmlXPathNumberFunction = Module['_xmlXPathNumberFunction'] = (a0, a1) => (_xmlXPathNumberFunction = Module['_xmlXPathNumberFunction'] = wasmExports['xmlXPathNumberFunction'])(a0, a1);
var _xmlXPathPositionFunction = Module['_xmlXPathPositionFunction'] = (a0, a1) => (_xmlXPathPositionFunction = Module['_xmlXPathPositionFunction'] = wasmExports['xmlXPathPositionFunction'])(a0, a1);
var _xmlXPathRoundFunction = Module['_xmlXPathRoundFunction'] = (a0, a1) => (_xmlXPathRoundFunction = Module['_xmlXPathRoundFunction'] = wasmExports['xmlXPathRoundFunction'])(a0, a1);
var _xmlXPathStringFunction = Module['_xmlXPathStringFunction'] = (a0, a1) => (_xmlXPathStringFunction = Module['_xmlXPathStringFunction'] = wasmExports['xmlXPathStringFunction'])(a0, a1);
var _xmlXPathStringLengthFunction = Module['_xmlXPathStringLengthFunction'] = (a0, a1) => (_xmlXPathStringLengthFunction = Module['_xmlXPathStringLengthFunction'] = wasmExports['xmlXPathStringLengthFunction'])(a0, a1);
var _xmlXPathStartsWithFunction = Module['_xmlXPathStartsWithFunction'] = (a0, a1) => (_xmlXPathStartsWithFunction = Module['_xmlXPathStartsWithFunction'] = wasmExports['xmlXPathStartsWithFunction'])(a0, a1);
var _xmlXPathSubstringFunction = Module['_xmlXPathSubstringFunction'] = (a0, a1) => (_xmlXPathSubstringFunction = Module['_xmlXPathSubstringFunction'] = wasmExports['xmlXPathSubstringFunction'])(a0, a1);
var _xmlXPathSubstringBeforeFunction = Module['_xmlXPathSubstringBeforeFunction'] = (a0, a1) => (_xmlXPathSubstringBeforeFunction = Module['_xmlXPathSubstringBeforeFunction'] = wasmExports['xmlXPathSubstringBeforeFunction'])(a0, a1);
var _xmlXPathSubstringAfterFunction = Module['_xmlXPathSubstringAfterFunction'] = (a0, a1) => (_xmlXPathSubstringAfterFunction = Module['_xmlXPathSubstringAfterFunction'] = wasmExports['xmlXPathSubstringAfterFunction'])(a0, a1);
var _xmlXPathSumFunction = Module['_xmlXPathSumFunction'] = (a0, a1) => (_xmlXPathSumFunction = Module['_xmlXPathSumFunction'] = wasmExports['xmlXPathSumFunction'])(a0, a1);
var _xmlXPathTrueFunction = Module['_xmlXPathTrueFunction'] = (a0, a1) => (_xmlXPathTrueFunction = Module['_xmlXPathTrueFunction'] = wasmExports['xmlXPathTrueFunction'])(a0, a1);
var _xmlXPathTranslateFunction = Module['_xmlXPathTranslateFunction'] = (a0, a1) => (_xmlXPathTranslateFunction = Module['_xmlXPathTranslateFunction'] = wasmExports['xmlXPathTranslateFunction'])(a0, a1);
var _xmlXPathNextSelf = Module['_xmlXPathNextSelf'] = (a0, a1) => (_xmlXPathNextSelf = Module['_xmlXPathNextSelf'] = wasmExports['xmlXPathNextSelf'])(a0, a1);
var _xmlXPathNextChild = Module['_xmlXPathNextChild'] = (a0, a1) => (_xmlXPathNextChild = Module['_xmlXPathNextChild'] = wasmExports['xmlXPathNextChild'])(a0, a1);
var _xmlXPathNextDescendant = Module['_xmlXPathNextDescendant'] = (a0, a1) => (_xmlXPathNextDescendant = Module['_xmlXPathNextDescendant'] = wasmExports['xmlXPathNextDescendant'])(a0, a1);
var _xmlXPathNextDescendantOrSelf = Module['_xmlXPathNextDescendantOrSelf'] = (a0, a1) => (_xmlXPathNextDescendantOrSelf = Module['_xmlXPathNextDescendantOrSelf'] = wasmExports['xmlXPathNextDescendantOrSelf'])(a0, a1);
var _xmlXPathNextParent = Module['_xmlXPathNextParent'] = (a0, a1) => (_xmlXPathNextParent = Module['_xmlXPathNextParent'] = wasmExports['xmlXPathNextParent'])(a0, a1);
var _xmlXPathNextAncestor = Module['_xmlXPathNextAncestor'] = (a0, a1) => (_xmlXPathNextAncestor = Module['_xmlXPathNextAncestor'] = wasmExports['xmlXPathNextAncestor'])(a0, a1);
var _xmlXPathNextAncestorOrSelf = Module['_xmlXPathNextAncestorOrSelf'] = (a0, a1) => (_xmlXPathNextAncestorOrSelf = Module['_xmlXPathNextAncestorOrSelf'] = wasmExports['xmlXPathNextAncestorOrSelf'])(a0, a1);
var _xmlXPathNextFollowingSibling = Module['_xmlXPathNextFollowingSibling'] = (a0, a1) => (_xmlXPathNextFollowingSibling = Module['_xmlXPathNextFollowingSibling'] = wasmExports['xmlXPathNextFollowingSibling'])(a0, a1);
var _xmlXPathNextPrecedingSibling = Module['_xmlXPathNextPrecedingSibling'] = (a0, a1) => (_xmlXPathNextPrecedingSibling = Module['_xmlXPathNextPrecedingSibling'] = wasmExports['xmlXPathNextPrecedingSibling'])(a0, a1);
var _xmlXPathNextFollowing = Module['_xmlXPathNextFollowing'] = (a0, a1) => (_xmlXPathNextFollowing = Module['_xmlXPathNextFollowing'] = wasmExports['xmlXPathNextFollowing'])(a0, a1);
var _xmlXPathNextNamespace = Module['_xmlXPathNextNamespace'] = (a0, a1) => (_xmlXPathNextNamespace = Module['_xmlXPathNextNamespace'] = wasmExports['xmlXPathNextNamespace'])(a0, a1);
var _xmlXPathNextAttribute = Module['_xmlXPathNextAttribute'] = (a0, a1) => (_xmlXPathNextAttribute = Module['_xmlXPathNextAttribute'] = wasmExports['xmlXPathNextAttribute'])(a0, a1);
var _zcalloc = Module['_zcalloc'] = (a0, a1, a2) => (_zcalloc = Module['_zcalloc'] = wasmExports['zcalloc'])(a0, a1, a2);
var _zcfree = Module['_zcfree'] = (a0, a1) => (_zcfree = Module['_zcfree'] = wasmExports['zcfree'])(a0, a1);
var _strerror = Module['_strerror'] = (a0) => (_strerror = Module['_strerror'] = wasmExports['strerror'])(a0);
var ___dl_seterr = (a0, a1) => (___dl_seterr = wasmExports['__dl_seterr'])(a0, a1);
var _freelocale = Module['_freelocale'] = (a0) => (_freelocale = Module['_freelocale'] = wasmExports['freelocale'])(a0);
var _putc = Module['_putc'] = (a0, a1) => (_putc = Module['_putc'] = wasmExports['putc'])(a0, a1);
var _gmtime = Module['_gmtime'] = (a0) => (_gmtime = Module['_gmtime'] = wasmExports['gmtime'])(a0);
var _htonl = (a0) => (_htonl = wasmExports['htonl'])(a0);
var _htons = (a0) => (_htons = wasmExports['htons'])(a0);
var _ioctl = Module['_ioctl'] = (a0, a1, a2) => (_ioctl = Module['_ioctl'] = wasmExports['ioctl'])(a0, a1, a2);
var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports['emscripten_builtin_memalign'])(a0, a1);
var _ntohs = (a0) => (_ntohs = wasmExports['ntohs'])(a0);
var _srand = Module['_srand'] = (a0) => (_srand = Module['_srand'] = wasmExports['srand'])(a0);
var _rand = Module['_rand'] = () => (_rand = Module['_rand'] = wasmExports['rand'])();
var __emscripten_timeout = (a0, a1) => (__emscripten_timeout = wasmExports['_emscripten_timeout'])(a0, a1);
var ___floatsitf = Module['___floatsitf'] = (a0, a1) => (___floatsitf = Module['___floatsitf'] = wasmExports['__floatsitf'])(a0, a1);
var ___multf3 = Module['___multf3'] = (a0, a1, a2, a3, a4) => (___multf3 = Module['___multf3'] = wasmExports['__multf3'])(a0, a1, a2, a3, a4);
var ___extenddftf2 = Module['___extenddftf2'] = (a0, a1) => (___extenddftf2 = Module['___extenddftf2'] = wasmExports['__extenddftf2'])(a0, a1);
var ___getf2 = Module['___getf2'] = (a0, a1, a2, a3) => (___getf2 = Module['___getf2'] = wasmExports['__getf2'])(a0, a1, a2, a3);
var ___subtf3 = Module['___subtf3'] = (a0, a1, a2, a3, a4) => (___subtf3 = Module['___subtf3'] = wasmExports['__subtf3'])(a0, a1, a2, a3, a4);
var ___letf2 = Module['___letf2'] = (a0, a1, a2, a3) => (___letf2 = Module['___letf2'] = wasmExports['__letf2'])(a0, a1, a2, a3);
var _strxfrm_l = Module['_strxfrm_l'] = (a0, a1, a2, a3) => (_strxfrm_l = Module['_strxfrm_l'] = wasmExports['strxfrm_l'])(a0, a1, a2, a3);
var ___lttf2 = Module['___lttf2'] = (a0, a1, a2, a3) => (___lttf2 = Module['___lttf2'] = wasmExports['__lttf2'])(a0, a1, a2, a3);
var _setThrew = (a0, a1) => (_setThrew = wasmExports['setThrew'])(a0, a1);
var __emscripten_tempret_set = (a0) => (__emscripten_tempret_set = wasmExports['_emscripten_tempret_set'])(a0);
var __emscripten_tempret_get = () => (__emscripten_tempret_get = wasmExports['_emscripten_tempret_get'])();
var ___fixtfsi = Module['___fixtfsi'] = (a0, a1) => (___fixtfsi = Module['___fixtfsi'] = wasmExports['__fixtfsi'])(a0, a1);
var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);
var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);
var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();
var _ScanKeywords = Module['_ScanKeywords'] = 69089412;
var _stderr = Module['_stderr'] = 69111840;
var _stdout = Module['_stdout'] = 69112144;
var _TopMemoryContext = Module['_TopMemoryContext'] = 69139460;
var _CurrentMemoryContext = Module['_CurrentMemoryContext'] = 69139456;
var _wal_level = Module['_wal_level'] = 68955728;
var _wal_segment_size = Module['_wal_segment_size'] = 68955748;
var _MyLatch = Module['_MyLatch'] = 69140980;
var _InterruptPending = Module['_InterruptPending'] = 69140808;
var _RmgrTable = Module['_RmgrTable'] = 68947296;
var _process_shared_preload_libraries_in_progress = Module['_process_shared_preload_libraries_in_progress'] = 69140796;
var _LocalBufferBlockPointers = Module['_LocalBufferBlockPointers'] = 69118452;
var _BufferBlocks = Module['_BufferBlocks'] = 69118616;
var _CritSectionCount = Module['_CritSectionCount'] = 69140856;
var _ParallelWorkerNumber = Module['_ParallelWorkerNumber'] = 68955696;
var _CurrentResourceOwner = Module['_CurrentResourceOwner'] = 69139412;
var _MyProc = Module['_MyProc'] = 69125708;
var _pg_global_prng_state = Module['_pg_global_prng_state'] = 69255664;
var _XactIsoLevel = Module['_XactIsoLevel'] = 68955576;
var _TopTransactionContext = Module['_TopTransactionContext'] = 69139480;
var _TopTransactionResourceOwner = Module['_TopTransactionResourceOwner'] = 69139420;
var _InterruptHoldoffCount = Module['_InterruptHoldoffCount'] = 69140848;
var _MyDatabaseId = Module['_MyDatabaseId'] = 69140864;
var _MainLWLockArray = Module['_MainLWLockArray'] = 69123900;
var _IsUnderPostmaster = Module['_IsUnderPostmaster'] = 69140881;
var _error_context_stack = Module['_error_context_stack'] = 69139840;
var _MyProcPid = Module['_MyProcPid'] = 69140948;
var _ShmemVariableCache = Module['_ShmemVariableCache'] = 69113740;
var _pgWalUsage = Module['_pgWalUsage'] = 69117336;
var _DataDir = Module['_DataDir'] = 69140860;
var _NBuffers = Module['_NBuffers'] = 69035688;
var _GUC_check_errdetail_string = Module['_GUC_check_errdetail_string'] = 69161960;
var ___THREW__ = Module['___THREW__'] = 69269412;
var ___threwValue = Module['___threwValue'] = 69269416;
var _PG_exception_stack = Module['_PG_exception_stack'] = 69139844;
var _old_snapshot_threshold = Module['_old_snapshot_threshold'] = 69139596;
var _work_mem = Module['_work_mem'] = 69035668;
var _maintenance_work_mem = Module['_maintenance_work_mem'] = 69035680;
var _SnapshotAnyData = Module['_SnapshotAnyData'] = 69035400;
var _debug_query_string = Module['_debug_query_string'] = 69118204;
var _TTSOpsHeapTuple = Module['_TTSOpsHeapTuple'] = 68959884;
var _pgBufferUsage = Module['_pgBufferUsage'] = 69117224;
var _TTSOpsVirtual = Module['_TTSOpsVirtual'] = 68959836;
var _stdin = Module['_stdin'] = 69111992;
var _progname = Module['_progname'] = 69117964;
var _application_name = Module['_application_name'] = 69161292;
var _ConfigReloadPending = Module['_ConfigReloadPending'] = 69170176;
var _WalReceiverFunctions = Module['_WalReceiverFunctions'] = 69115628;
var _CacheMemoryContext = Module['_CacheMemoryContext'] = 69139472;
var _ShutdownRequestPending = Module['_ShutdownRequestPending'] = 69170180;
var _TTSOpsMinimalTuple = Module['_TTSOpsMinimalTuple'] = 68959932;
var _cluster_name = Module['_cluster_name'] = 69037172;
var _cpu_operator_cost = Module['_cpu_operator_cost'] = 68959552;
var _cpu_tuple_cost = Module['_cpu_tuple_cost'] = 68959536;
var _seq_page_cost = Module['_seq_page_cost'] = 68959520;
var _planner_hook = Module['_planner_hook'] = 69116304;
var _max_parallel_maintenance_workers = Module['_max_parallel_maintenance_workers'] = 69035684;
var _SPI_processed = Module['_SPI_processed'] = 69116328;
var _SPI_tuptable = Module['_SPI_tuptable'] = 69116336;
var _SPI_result = Module['_SPI_result'] = 69116340;
var _ExecutorStart_hook = Module['_ExecutorStart_hook'] = 69117200;
var _ExecutorRun_hook = Module['_ExecutorRun_hook'] = 69117204;
var _ExecutorFinish_hook = Module['_ExecutorFinish_hook'] = 69117208;
var _ExecutorEnd_hook = Module['_ExecutorEnd_hook'] = 69117212;
var _post_parse_analyze_hook = Module['_post_parse_analyze_hook'] = 69117400;
var _ScanKeywordTokens = Module['_ScanKeywordTokens'] = 68332416;
var _check_function_bodies = Module['_check_function_bodies'] = 69037121;
var _check_password_hook = Module['_check_password_hook'] = 69117820;
var _DateStyle = Module['_DateStyle'] = 69035656;
var _MyProcPort = Module['_MyProcPort'] = 69140968;
var _single_mode_feed = Module['_single_mode_feed'] = 69117980;
var _SOCKET_DATA = Module['_SOCKET_DATA'] = 69173672;
var _SOCKET_FILE = Module['_SOCKET_FILE'] = 69173668;
var _cma_rsize = Module['_cma_rsize'] = 69118012;
var _cma_wsize = Module['_cma_wsize'] = 69118020;
var _quote_all_identifiers = Module['_quote_all_identifiers'] = 69117969;
var _ProcessUtility_hook = Module['_ProcessUtility_hook'] = 69118388;
var _BufferDescriptors = Module['_BufferDescriptors'] = 69118612;
var _shmem_startup_hook = Module['_shmem_startup_hook'] = 69127136;
var _ClientAuthentication_hook = Module['_ClientAuthentication_hook'] = 69135896;
var _xmlStructuredError = Module['_xmlStructuredError'] = 69256028;
var _xmlStructuredErrorContext = Module['_xmlStructuredErrorContext'] = 69256036;
var _xmlGenericErrorContext = Module['_xmlGenericErrorContext'] = 69256032;
var _xmlGenericError = Module['_xmlGenericError'] = 69093716;
var _xmlIsBaseCharGroup = Module['_xmlIsBaseCharGroup'] = 69093480;
var _xmlIsDigitGroup = Module['_xmlIsDigitGroup'] = 69093512;
var _xmlIsCombiningGroup = Module['_xmlIsCombiningGroup'] = 69093496;
var _xmlIsExtenderGroup = Module['_xmlIsExtenderGroup'] = 69093528;
var _xmlFree = Module['_xmlFree'] = 69093680;
var _IntervalStyle = Module['_IntervalStyle'] = 69140888;
var _pg_crc32_table = Module['_pg_crc32_table'] = 68543616;
var _extra_float_digits = Module['_extra_float_digits'] = 68986732;
var _pg_number_of_ones = Module['_pg_number_of_ones'] = 68752720;
var _Log_directory = Module['_Log_directory'] = 69169996;
var _oldSnapshotControl = Module['_oldSnapshotControl'] = 69139600;
var _MyStartTime = Module['_MyStartTime'] = 69140952;
var _shmem_request_hook = Module['_shmem_request_hook'] = 69140800;
var _Log_filename = Module['_Log_filename'] = 69170000;
var _IDB_STAGE = Module['_IDB_STAGE'] = 69173680;
var _IDB_PIPE_FP = Module['_IDB_PIPE_FP'] = 69173676;
var _pg_scram_mech = Module['_pg_scram_mech'] = 69093424;
var _pg_g_threadlock = Module['_pg_g_threadlock'] = 69091528;
var _pgresStatus = Module['_pgresStatus'] = 69093216;
var _xmlIsPubidChar_tab = Module['_xmlIsPubidChar_tab'] = 68753008;
var _xmlGetWarningsDefaultValue = Module['_xmlGetWarningsDefaultValue'] = 69093708;
var _xmlMalloc = Module['_xmlMalloc'] = 69093684;
var _xmlRealloc = Module['_xmlRealloc'] = 69093692;
var _xmlLastError = Module['_xmlLastError'] = 69256048;
var _xmlMallocAtomic = Module['_xmlMallocAtomic'] = 69093688;
var _xmlMemStrdup = Module['_xmlMemStrdup'] = 69093696;
var _xmlBufferAllocScheme = Module['_xmlBufferAllocScheme'] = 69093700;
var _xmlDefaultBufferSize = Module['_xmlDefaultBufferSize'] = 69093704;
var _xmlParserDebugEntities = Module['_xmlParserDebugEntities'] = 69255988;
var _xmlDoValidityCheckingDefaultValue = Module['_xmlDoValidityCheckingDefaultValue'] = 69255992;
var _xmlLoadExtDtdDefaultValue = Module['_xmlLoadExtDtdDefaultValue'] = 69255996;
var _xmlPedanticParserDefaultValue = Module['_xmlPedanticParserDefaultValue'] = 69256000;
var _xmlLineNumbersDefaultValue = Module['_xmlLineNumbersDefaultValue'] = 69256004;
var _xmlKeepBlanksDefaultValue = Module['_xmlKeepBlanksDefaultValue'] = 69093712;
var _xmlSubstituteEntitiesDefaultValue = Module['_xmlSubstituteEntitiesDefaultValue'] = 69256008;
var _xmlRegisterNodeDefaultValue = Module['_xmlRegisterNodeDefaultValue'] = 69256012;
var _xmlDeregisterNodeDefaultValue = Module['_xmlDeregisterNodeDefaultValue'] = 69256016;
var _xmlParserInputBufferCreateFilenameValue = Module['_xmlParserInputBufferCreateFilenameValue'] = 69256020;
var _xmlOutputBufferCreateFilenameValue = Module['_xmlOutputBufferCreateFilenameValue'] = 69256024;
var _xmlIndentTreeOutput = Module['_xmlIndentTreeOutput'] = 69093720;
var _xmlTreeIndentString = Module['_xmlTreeIndentString'] = 69093724;
var _xmlSaveNoEmptyTags = Module['_xmlSaveNoEmptyTags'] = 69256040;
var _xmlDefaultSAXHandler = Module['_xmlDefaultSAXHandler'] = 69093728;
var _xmlDefaultSAXLocator = Module['_xmlDefaultSAXLocator'] = 69093840;
var _xmlParserMaxDepth = Module['_xmlParserMaxDepth'] = 69094500;
var _xmlStringText = Module['_xmlStringText'] = 68754816;
var _xmlStringComment = Module['_xmlStringComment'] = 68754831;
var _xmlStringTextNoenc = Module['_xmlStringTextNoenc'] = 68754821;
var _xmlXPathNAN = Module['_xmlXPathNAN'] = 69256712;
var _xmlXPathNINF = Module['_xmlXPathNINF'] = 69256728;
var _xmlXPathPINF = Module['_xmlXPathPINF'] = 69256720;
var _z_errmsg = Module['_z_errmsg'] = 69111056;
var __length_code = Module['__length_code'] = 68774480;
var __dist_code = Module['__dist_code'] = 68773968;
function invoke_iii(index,a1,a2) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_ii(index,a1) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_v(index) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)();
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_jii(index,a1,a2) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
    return 0n;
  }
}

function invoke_vi(index,a1) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_ji(index,a1) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
    return 0n;
  }
}

function invoke_viiiii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_ijiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vij(index,a1,a2) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vj(index,a1) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_i(index) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)();
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viijii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiji(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viijiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viij(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vid(index,a1,a2) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiij(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_ij(index,a1) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiij(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiji(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiji(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiij(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_jiiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
    return 0n;
  }
}

function invoke_viiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_jiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
    return 0n;
  }
}

function invoke_jiiiii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
    return 0n;
  }
}

function invoke_vji(index,a1,a2) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiijii(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vijiji(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viji(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_di(index,a1) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_id(index,a1) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_ijiiiii(index,a1,a2,a3,a4,a5,a6) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}


// include: postamble.js
// === Auto-generated postamble setup entry stuff ===

Module['addRunDependency'] = addRunDependency;
Module['removeRunDependency'] = removeRunDependency;
Module['callMain'] = callMain;
Module['ccall'] = ccall;
Module['cwrap'] = cwrap;
Module['setValue'] = setValue;
Module['getValue'] = getValue;
Module['UTF8ToString'] = UTF8ToString;
Module['stringToNewUTF8'] = stringToNewUTF8;
Module['stringToUTF8OnStack'] = stringToUTF8OnStack;
Module['FS_createPreloadedFile'] = FS_createPreloadedFile;
Module['FS_unlink'] = FS_unlink;
Module['FS_createPath'] = FS_createPath;
Module['FS_createDevice'] = FS_createDevice;
Module['FS'] = FS;
Module['FS_createDataFile'] = FS_createDataFile;
Module['FS_createLazyFile'] = FS_createLazyFile;


var calledRun;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args = []) {

  var entryFunction = resolveGlobalSymbol('main').sym;;

  // Main modules can't tell if they have main() at compile time, since it may
  // arrive from a dynamic library.
  if (!entryFunction) return;

  args.unshift(thisProgram);

  var argc = args.length;
  var argv = stackAlloc((argc + 1) * 4);
  var argv_ptr = argv;
  args.forEach((arg) => {
    HEAPU32[((argv_ptr)>>2)] = stringToUTF8OnStack(arg);
    argv_ptr += 4;
  });
  HEAPU32[((argv_ptr)>>2)] = 0;

  try {

    var ret = entryFunction(argc, argv);

    // if we're not running an evented main loop, it's time to exit
    exitJS(ret, /* implicit = */ true);
    return ret;
  }
  catch (e) {
    return handleException(e);
  }
}

function run(args = arguments_) {

  if (runDependencies > 0) {
    return;
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    readyPromiseResolve(Module);
    Module['onRuntimeInitialized']?.();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(() => {
      setTimeout(() => Module['setStatus'](''), 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;

run();

// end include: postamble.js

// include: postamble_modularize.js
// In MODULARIZE mode we wrap the generated code in a factory function
// and return either the Module itself, or a promise of the module.
//
// We assign to the `moduleRtn` global here and configure closure to see
// this as and extern so it won't get minified.

moduleRtn = readyPromise;

// end include: postamble_modularize.js



  return moduleRtn;
}
);
})();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Module);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".cgi-worker.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = self.location + "";
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = {
/******/ 			"service-worker": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkdemo_source"] = self["webpackChunkdemo_source"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!****************************!*\
  !*** ./src/cgi-worker.mjs ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var php_cgi_wasm_PhpCgiWorker_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! php-cgi-wasm/PhpCgiWorker.mjs */ "../packages/php-cgi-wasm/PhpCgiWorker.mjs");
/* harmony import */ var _electric_sql_pglite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @electric-sql/pglite */ "../../../software/pglite/packages/pglite/dist/index.js");
/* eslint-disable no-restricted-globals */



// Log requests
const cgi_worker_onRequest = (request, response) => {
  const url = new URL(request.url);
  const logLine = `[${new Date().toISOString()}]` + `#${cgi_worker_php.count} 127.0.0.1 - "${request.method}` + ` ${url.pathname}" - HTTP/1.1 ${response.status}`;
  console.log(logLine);
};

// Formatted 404s
const cgi_worker_notFound = request => {
  return new Response(`<body><h1>404</h1>${request.url} not found</body>`, {
    status: 404,
    headers: {
      'Content-Type': 'text/html'
    }
  });
};
const cgi_worker_sharedLibs = [`php\${PHP_VERSION}-zlib.so`, `php\${PHP_VERSION}-zip.so`, `php\${PHP_VERSION}-gd.so`, `php\${PHP_VERSION}-iconv.so`, `php\${PHP_VERSION}-intl.so`, `php\${PHP_VERSION}-openssl.so`, `php\${PHP_VERSION}-dom.so`, `php\${PHP_VERSION}-mbstring.so`, `php\${PHP_VERSION}-sqlite.so`, `php\${PHP_VERSION}-pdo-sqlite.so`, `php\${PHP_VERSION}-xml.so`, `php\${PHP_VERSION}-simplexml.so`, {
  url: `libs/libxml2.so`,
  ini: false
}];
const cgi_worker_files = [{
  parent: '/preload/',
  name: 'icudt72l.dat',
  url: './icudt72l.dat'
}];
const actions = {
  runSql: (php, database, sql) => {
    console.log({
      database
    });
    const pglite = new _electric_sql_pglite__WEBPACK_IMPORTED_MODULE_1__.PGlite(database);
    return pglite.query(sql);
  },
  execSql: (php, database, sql) => {
    console.log(database);
    const pglite = new _electric_sql_pglite__WEBPACK_IMPORTED_MODULE_1__.PGlite(database);
    return pglite.exec(sql);
  }
};

// Spawn the PHP-CGI binary
const cgi_worker_php = new php_cgi_wasm_PhpCgiWorker_mjs__WEBPACK_IMPORTED_MODULE_0__.PhpCgiWorker({
  onRequest: cgi_worker_onRequest,
  notFound: cgi_worker_notFound,
  sharedLibs: cgi_worker_sharedLibs,
  files: cgi_worker_files,
  PGlite: _electric_sql_pglite__WEBPACK_IMPORTED_MODULE_1__.PGlite,
  actions,
  staticFS: false,
  prefix: '/php-wasm/cgi-bin/',
  exclude: ['/php-wasm/cgi-bin/~!@', '/php-wasm/cgi-bin/.'],
  docroot: '/persist/www',
  types: {
    jpeg: 'image/jpeg',
    jpg: 'image/jpeg',
    gif: 'image/gif',
    png: 'image/png',
    svg: 'image/svg+xml'
  }
});

// Set up the event handlers
self.addEventListener('install', event => cgi_worker_php.handleInstallEvent(event));
self.addEventListener('activate', event => cgi_worker_php.handleActivateEvent(event));
self.addEventListener('fetch', event => cgi_worker_php.handleFetchEvent(event));
self.addEventListener('message', event => cgi_worker_php.handleMessageEvent(event));

// Extras
self.addEventListener('install', event => console.log('Install'));
self.addEventListener('activate', event => console.log('Activate'));
})();

/******/ })()
;
//# sourceMappingURL=cgi-worker.js.map