{"version":3,"file":"static/js/305.de336abc.chunk.js","mappings":"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","sources":["../../../../software/pglite/packages/pglite/src/fs/opfs-ahp/index.ts","../../../../software/pglite/packages/pglite/src/fs/opfs-ahp/emscriptenFs.ts","../../../../software/pglite/packages/pglite/src/fs/opfs-ahp/types.ts","../../../../software/pglite/packages/pglite/src/fs/opfs-ahp/opfsAhp.ts"],"sourcesContent":["import { FilesystemBase } from '../types.js'\nimport { PGDATA } from '../index.js'\nimport type { PostgresMod, FS } from '../../postgresMod.js'\nimport { createOPFSAHP } from './emscriptenFs.js'\nimport { OpfsAhp } from './opfsAhp.js'\nimport { dumpTar, type DumpTarCompressionOptions } from '../tarUtils.js'\n\nexport interface OpfsAhpFSOptions {\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n}\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends FilesystemBase {\n  #initialPoolSize: number\n  #maintainedPoolSize: number\n  opfsAhp?: OpfsAhp\n\n  constructor(\n    dataDir: string,\n    { initialPoolSize, maintainedPoolSize }: OpfsAhpFSOptions = {},\n  ) {\n    super(dataDir)\n    this.#initialPoolSize = initialPoolSize ?? 1000\n    this.#maintainedPoolSize = maintainedPoolSize ?? 100\n  }\n\n  async emscriptenOpts(opts: Partial<PostgresMod>) {\n    this.opfsAhp = await OpfsAhp.create({\n      root: this.dataDir!,\n      initialPoolSize: this.#initialPoolSize,\n      maintainedPoolSize: this.#maintainedPoolSize,\n    })\n    const options: Partial<PostgresMod> = {\n      ...opts,\n      preRun: [\n        ...(opts.preRun || []),\n        (mod: PostgresMod) => {\n          const OPFS = createOPFSAHP(mod, this.opfsAhp!)\n          mod.FS.mkdir(PGDATA)\n          mod.FS.mount(OPFS, {}, PGDATA)\n        },\n      ],\n    }\n    return options\n  }\n\n  async syncToFs(_fs: FS, relaxedDurability = false) {\n    await this.opfsAhp?.maybeCheckpointState()\n    await this.opfsAhp?.maintainPool()\n    // console.log(\"syncToFs\", relaxedDurability);\n    if (!relaxedDurability) {\n      this.opfsAhp?.flush()\n    }\n  }\n\n  async dumpTar(\n    mod: FS,\n    dbname: string,\n    compression?: DumpTarCompressionOptions,\n  ) {\n    return dumpTar(mod, dbname, compression)\n  }\n\n  async close(FS: FS): Promise<void> {\n    this.opfsAhp?.exit()\n    FS.quit()\n  }\n}\n","import type { PostgresMod } from '../../postgresMod.js'\nimport type { OpfsAhp } from './opfsAhp.js'\nimport { ERRNO_CODES } from './types.js'\n\nexport type FileSystemType = Emscripten.FileSystemType & {\n  createNode: (\n    parent: FSNode | null,\n    name: string,\n    mode: number,\n    dev?: any,\n  ) => FSNode\n  node_ops: FS.NodeOps\n  stream_ops: FS.StreamOps & {\n    dup: (stream: FSStream) => void\n    mmap: (\n      stream: FSStream,\n      length: number,\n      position: number,\n      prot: any,\n      flags: any,\n    ) => { ptr: number; allocated: boolean }\n    msync: (\n      stream: FSStream,\n      buffer: Uint8Array,\n      offset: number,\n      length: number,\n      mmapFlags: any,\n    ) => number\n  }\n} & { [key: string]: any }\n\ntype FSNode = FS.FSNode & {\n  node_ops: FS.NodeOps\n  stream_ops: FS.StreamOps\n}\n\ntype FSStream = FS.FSStream & {\n  node: FSNode\n  shared: {\n    refcount: number\n  }\n}\n\nexport interface OpfsMount extends FS.Mount {\n  opts: {\n    root: string\n  }\n}\n\ntype OpfsNode = FSNode\n\ntype EmscriptenFS = PostgresMod['FS'] & {\n  createNode: (\n    parent: FSNode | null,\n    name: string,\n    mode: number,\n    dev?: any,\n  ) => FSNode\n}\n\n/**\n * Create an emscripten filesystem that uses the AHP filesystem.\n * @param Module The emscripten module\n * @param opfsAhp The AHP filesystem - see `OpfsAhp.ts`\n * @returns The emscripten filesystem\n */\nexport const createOPFSAHP = (Module: PostgresMod, opfsAhp: OpfsAhp) => {\n  const FS = Module.FS as EmscriptenFS\n  const OPFS = {\n    tryFSOperation<T>(f: () => T): T {\n      try {\n        return f()\n      } catch (e: any) {\n        if (!e.code) throw e\n        if (e.code === 'UNKNOWN') throw new FS.ErrnoError(ERRNO_CODES.EINVAL)\n        throw new FS.ErrnoError(e.code)\n      }\n    },\n    mount(_mount: OpfsMount): FSNode {\n      return OPFS.createNode(null, '/', 16384 | 511, 0)\n    },\n    syncfs(\n      _mount: FS.Mount,\n      _populate: any, // This has the wrong type in @types/emscripten\n      _done: (err?: number | null) => unknown,\n    ): void {\n      // noop\n    },\n    createNode(\n      parent: FSNode | null,\n      name: string,\n      mode: number,\n      _dev?: any,\n    ): OpfsNode {\n      if (!FS.isDir(mode) && !FS.isFile(mode)) {\n        throw new FS.ErrnoError(28)\n      }\n      const node = FS.createNode(parent, name, mode)\n      node.node_ops = OPFS.node_ops\n      node.stream_ops = OPFS.stream_ops\n      return node\n    },\n    getMode: function (path: string): number {\n      log('getMode', path)\n      return OPFS.tryFSOperation(() => {\n        const stats = opfsAhp.lstat(path)\n        return stats.mode\n      })\n    },\n    realPath: function (node: FSNode): string {\n      const parts: string[] = []\n      while (node.parent !== node) {\n        parts.push(node.name)\n        node = node.parent as FSNode\n      }\n      parts.push((node.mount as OpfsMount).opts.root)\n      parts.reverse()\n      return parts.join('/')\n    },\n    node_ops: {\n      getattr(node: OpfsNode): FS.Stats {\n        log('getattr', OPFS.realPath(node))\n        const path = OPFS.realPath(node)\n        return OPFS.tryFSOperation(() => {\n          const stats = opfsAhp.lstat(path)\n          return {\n            ...stats,\n            dev: 0,\n            ino: node.id,\n            nlink: 1,\n            rdev: node.rdev,\n            atime: new Date(stats.atime),\n            mtime: new Date(stats.mtime),\n            ctime: new Date(stats.ctime),\n          }\n        })\n      },\n      setattr(node: OpfsNode, attr: FS.Stats): void {\n        log('setattr', OPFS.realPath(node), attr)\n        const path = OPFS.realPath(node)\n        OPFS.tryFSOperation(() => {\n          if (attr.mode !== undefined) {\n            opfsAhp.chmod(path, attr.mode)\n          }\n          if (attr.size !== undefined) {\n            opfsAhp.truncate(path, attr.size)\n          }\n          if (attr.timestamp !== undefined) {\n            opfsAhp.utimes(path, attr.timestamp, attr.timestamp)\n          }\n          if (attr.size !== undefined) {\n            opfsAhp.truncate(path, attr.size)\n          }\n        })\n      },\n      lookup(parent: FSNode, name: string): OpfsNode {\n        log('lookup', OPFS.realPath(parent), name)\n        const path = [OPFS.realPath(parent), name].join('/')\n        const mode = OPFS.getMode(path)\n        return OPFS.createNode(parent, name, mode)\n      },\n      mknod(\n        parent: FSNode,\n        name: string,\n        mode: number,\n        dev: unknown,\n      ): OpfsNode {\n        log('mknod', OPFS.realPath(parent), name, mode, dev)\n        const node = OPFS.createNode(parent, name, mode, dev)\n        // create the backing node for this in the fs root as well\n        const path = OPFS.realPath(node)\n        return OPFS.tryFSOperation(() => {\n          if (FS.isDir(node.mode)) {\n            opfsAhp.mkdir(path, { mode })\n          } else {\n            opfsAhp.writeFile(path, '', { mode })\n          }\n          return node\n        })\n      },\n      rename(oldNode: OpfsNode, newDir: OpfsNode, newName: string): void {\n        log('rename', OPFS.realPath(oldNode), OPFS.realPath(newDir), newName)\n        const oldPath = OPFS.realPath(oldNode)\n        const newPath = [OPFS.realPath(newDir), newName].join('/')\n        OPFS.tryFSOperation(() => {\n          opfsAhp.rename(oldPath, newPath)\n        })\n        oldNode.name = newName\n      },\n      unlink(parent: OpfsNode, name: string): void {\n        log('unlink', OPFS.realPath(parent), name)\n        const path = [OPFS.realPath(parent), name].join('/')\n        try {\n          opfsAhp.unlink(path)\n        } catch (e: any) {\n          // no-op\n        }\n      },\n      rmdir(parent: OpfsNode, name: string): void {\n        log('rmdir', OPFS.realPath(parent), name)\n        const path = [OPFS.realPath(parent), name].join('/')\n        return OPFS.tryFSOperation(() => {\n          opfsAhp.rmdir(path)\n        })\n      },\n      readdir(node: OpfsNode): string[] {\n        log('readdir', OPFS.realPath(node))\n        const path = OPFS.realPath(node)\n        return OPFS.tryFSOperation(() => {\n          return opfsAhp.readdir(path)\n        })\n      },\n      symlink(parent: FSNode, newName: string, oldPath: string): void {\n        log('symlink', OPFS.realPath(parent), newName, oldPath)\n        // This is not supported by OPFS\n        throw new FS.ErrnoError(63)\n      },\n      readlink(node: FSNode): string {\n        log('readlink', OPFS.realPath(node))\n        // This is not supported by OPFS\n        throw new FS.ErrnoError(63)\n      },\n    },\n    stream_ops: {\n      open(stream: FSStream): void {\n        log('open stream', OPFS.realPath(stream.node))\n        const path = OPFS.realPath(stream.node)\n        return OPFS.tryFSOperation(() => {\n          if (FS.isFile(stream.node.mode)) {\n            stream.shared.refcount = 1\n            stream.nfd = opfsAhp.open(path)\n          }\n        })\n      },\n      close(stream: FSStream): void {\n        log('close stream', OPFS.realPath(stream.node))\n        return OPFS.tryFSOperation(() => {\n          if (\n            FS.isFile(stream.node.mode) &&\n            stream.nfd &&\n            --stream.shared.refcount === 0\n          ) {\n            opfsAhp.close(stream.nfd)\n          }\n        })\n      },\n      dup(stream: FSStream) {\n        log('dup stream', OPFS.realPath(stream.node))\n        stream.shared.refcount++\n      },\n      read(\n        stream: FSStream, // Stream to read from\n        buffer: Uint8Array, // Buffer to read into - Wrong type in @types/emscripten\n        offset: number, // Offset in buffer to start writing to\n        length: number, // Number of bytes to read\n        position: number, // Position in file to read from\n      ): number {\n        log('read stream', OPFS.realPath(stream.node), offset, length, position)\n        if (length === 0) return 0\n        const ret = OPFS.tryFSOperation(() =>\n          opfsAhp.read(\n            stream.nfd!,\n            buffer as unknown as Int8Array,\n            offset,\n            length,\n            position,\n          ),\n        )\n        return ret\n      },\n      write(\n        stream: FSStream, // Stream to write to\n        buffer: Uint8Array, // Buffer to read from - Wrong type in @types/emscripten\n        offset: number, // Offset in buffer to start writing from\n        length: number, // Number of bytes to write\n        position: number, // Position in file to write to\n      ): number {\n        log(\n          'write stream',\n          OPFS.realPath(stream.node),\n          offset,\n          length,\n          position,\n        )\n        return OPFS.tryFSOperation(() =>\n          opfsAhp.write(\n            stream.nfd!,\n            buffer.buffer as unknown as Int8Array,\n            offset,\n            length,\n            position,\n          ),\n        )\n      },\n      llseek(stream: FSStream, offset: number, whence: number): number {\n        log('llseek stream', OPFS.realPath(stream.node), offset, whence)\n        let position = offset\n        if (whence === 1) {\n          position += stream.position\n        } else if (whence === 2) {\n          if (FS.isFile(stream.node.mode)) {\n            OPFS.tryFSOperation(() => {\n              const stat = opfsAhp.fstat(stream.nfd!)\n              position += stat.size\n            })\n          }\n        }\n        if (position < 0) {\n          throw new FS.ErrnoError(28)\n        }\n        return position\n      },\n      mmap(\n        stream: FSStream,\n        length: number,\n        position: number,\n        prot: any,\n        flags: any,\n      ) {\n        log(\n          'mmap stream',\n          OPFS.realPath(stream.node),\n          length,\n          position,\n          prot,\n          flags,\n        )\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV)\n        }\n\n        const ptr = (Module as any).mmapAlloc(length) // TODO: Fix type and check this is exported\n\n        OPFS.stream_ops.read(\n          stream,\n          Module.HEAP8 as unknown as Uint8Array,\n          ptr,\n          length,\n          position,\n        )\n        return { ptr, allocated: true }\n      },\n      msync(\n        stream: FSStream,\n        buffer: Uint8Array,\n        offset: number,\n        length: number,\n        mmapFlags: any,\n      ) {\n        log(\n          'msync stream',\n          OPFS.realPath(stream.node),\n          offset,\n          length,\n          mmapFlags,\n        )\n        OPFS.stream_ops.write(stream, buffer, 0, length, offset)\n        return 0\n      },\n    },\n  } satisfies FileSystemType\n  return OPFS\n}\n\nfunction log(..._args: any[]) {\n  // console.log(...args);\n}\n","export type FsStats = {\n  dev: number\n  ino: number\n  mode: number\n  nlink: number\n  uid: number\n  gid: number\n  rdev: number\n  size: number\n  blksize: number\n  blocks: number\n  atime: number\n  mtime: number\n  ctime: number\n}\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void\n  flush(): void\n  getSize(): number\n  read(buffer: ArrayBuffer, options: { at: number }): number\n  truncate(newSize: number): void\n  write(buffer: ArrayBuffer, options: { at: number }): number\n}\n\nexport const ERRNO_CODES = {\n  EBADF: 8,\n  EBADFD: 127,\n  EEXIST: 20,\n  EINVAL: 28,\n  EISDIR: 31,\n  ENODEV: 43,\n  ENOENT: 44,\n  ENOTDIR: 54,\n  ENOTEMPTY: 55,\n} as const\n\nexport class FsError extends Error {\n  code?: number\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message)\n    if (typeof code === 'number') {\n      this.code = code\n    } else if (typeof code === 'string') {\n      this.code = ERRNO_CODES[code]\n    }\n  }\n}\n\n// State\n\nexport interface State {\n  root: DirectoryNode\n  pool: PoolFilenames\n}\n\nexport type PoolFilenames = Array<string>\n\n// WAL\n\nexport interface WALEntry {\n  opp: string\n  args: any[]\n}\n\n// Node tree\n\nexport type NodeType = 'file' | 'directory'\n\ninterface BaseNode {\n  type: NodeType\n  lastModified: number\n  mode: number\n}\n\nexport interface FileNode extends BaseNode {\n  type: 'file'\n  backingFilename: string\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: 'directory'\n  children: { [filename: string]: Node }\n}\n\nexport type Node = FileNode | DirectoryNode\n","import { FsError } from './types.js'\nimport type {\n  FsStats,\n  State,\n  FileSystemSyncAccessHandle,\n  Node,\n  FileNode,\n  DirectoryNode,\n  WALEntry,\n} from './types.js'\n\nconst STATE_FILE = 'state.txt'\nconst DATA_DIR = 'data'\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n}\n\nexport interface OpfsAhpOptions {\n  root: string\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n}\n\n/**\n * An OPFS Access Handle Pool VFS that exports a Node.js-like FS interface.\n * This FS is then wrapped by an Emscripten FS interface in emscriptenFs.ts.\n */\nexport class OpfsAhp {\n  readyPromise: Promise<void>\n  #ready = false\n\n  readonly root: string\n  readonly initialPoolSize: number\n  readonly maintainedPoolSize: number\n\n  #opfsRootAh!: FileSystemDirectoryHandle\n  #rootAh!: FileSystemDirectoryHandle\n  #dataDirAh!: FileSystemDirectoryHandle\n\n  #stateFH!: FileSystemFileHandle\n  #stateSH!: FileSystemSyncAccessHandle\n\n  #fh: Map<string, FileSystemFileHandle> = new Map()\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map()\n\n  #handleIdCounter = 0\n  #openHandlePaths: Map<number, string> = new Map()\n  #openHandleIds: Map<string, number> = new Map()\n\n  state!: State\n  lastCheckpoint = 0\n  checkpointInterval = 1000 * 60 // 1 minute\n  poolCounter = 0\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>()\n\n  constructor({ root, initialPoolSize, maintainedPoolSize }: OpfsAhpOptions) {\n    this.root = root\n    this.initialPoolSize = initialPoolSize || 1000\n    this.maintainedPoolSize = maintainedPoolSize || 100\n    this.readyPromise = this.#init()\n  }\n\n  static async create(options: OpfsAhpOptions) {\n    const instance = new OpfsAhp(options)\n    await instance.readyPromise\n    return instance\n  }\n\n  async #init() {\n    this.#opfsRootAh = await navigator.storage.getDirectory()\n    this.#rootAh = await this.#resolveOpfsDirectory(this.root, {\n      create: true,\n    })\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    })\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    })\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle()\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize())\n    this.#stateSH.read(stateAB, { at: 0 })\n    let state: State\n    const stateLines = new TextDecoder().decode(stateAB).split('\\n')\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false\n    try {\n      state = JSON.parse(stateLines[0])\n    } catch (e) {\n      state = {\n        root: {\n          type: 'directory',\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      }\n      // write new state to file\n      this.#stateSH.truncate(0)\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      })\n      isNewState = true\n    }\n    this.state = state\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line))\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`\n      if (typeof this[methodName as keyof this] === 'function') {\n        try {\n          const method = this[methodName as keyof this] as any\n          method.bind(this)(...entry.args)\n        } catch (e) {\n          console.warn('Error applying OPFS AHP WAL entry', entry, e)\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = []\n    const walk = async (node: Node) => {\n      if (node.type === 'file') {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(node.backingFilename, fh)\n\n          this.#sh.set(node.backingFilename, sh)\n        } catch (e) {\n          console.error('Error opening file handle for node', node, e)\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child))\n        }\n      }\n    }\n    await walk(this.state.root)\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = []\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn('File handle already exists for pool file', filename)\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          resolve()\n        }),\n      )\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises])\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    )\n\n    this.#ready = true\n  }\n\n  get ready() {\n    return this.#ready\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize\n    const change = size - this.state.pool.length\n    const promises: Promise<void>[] = []\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, '0')}-${this.poolCounter.toString(16).padStart(8, '0')}`\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          })\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          this.#logWAL({\n            opp: 'createPoolFile',\n            args: [filename],\n          })\n          this.state.pool.push(filename)\n          resolve()\n        }),\n      )\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!\n          this.#logWAL({\n            opp: 'deletePoolFile',\n            args: [filename],\n          })\n          const fh = this.#fh.get(filename)!\n          const sh = this.#sh.get(filename)\n          sh?.close()\n          // @ts-ignore outdated type? need to check\n          await fh.remove().then(() => {\n            this.#fh.delete(filename)\n            this.#sh.delete(filename)\n            resolve()\n          })\n        }),\n      )\n    }\n    await Promise.all(promises)\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename)\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState()\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state))\n    this.#stateSH.truncate(0)\n    this.#stateSH.write(stateAB, { at: 0 })\n    this.#stateSH.flush()\n    this.lastCheckpoint = Date.now()\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush()\n      } catch (e) {\n        // The file may have been closed if it was deleted\n      }\n    }\n    this.#unsyncedSH.clear()\n  }\n\n  exit(): void {\n    for (const sh of this.#sh.values()) {\n      sh.close()\n    }\n    this.#stateSH.flush()\n    this.#stateSH.close()\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: 'chmod', args: [path, mode] }, () => {\n      this._chmodState(path, mode)\n    })\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path)\n    node.mode = mode\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd)\n    this.#openHandlePaths.delete(fd)\n    this.#openHandleIds.delete(path)\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd)\n    return this.lstat(path)\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path)\n    const size =\n      node.type === 'file' ? this.#sh.get(node.backingFilename)!.getSize() : 0\n    const blksize = 4096\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    }\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: 'mkdir', args: [path, options] }, () => {\n      this._mkdirState(path, options)\n    })\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path)\n    const newDirName = parts.pop()!\n    const currentPath: string[] = []\n    let node = this.state.root\n    for (const part of parts) {\n      currentPath.push(path)\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join('/'))\n        } else {\n          throw new FsError('ENOENT', 'No such file or directory')\n        }\n      }\n      if (node.children[part].type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      node = node.children[part] as DirectoryNode\n    }\n    if (Object.prototype.hasOwnProperty.call(node.children, newDirName)) {\n      throw new FsError('EEXIST', 'File exists')\n    }\n    const newDir: DirectoryNode = {\n      type: 'directory',\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    }\n    node.children[newDirName] = newDir\n  }\n\n  open(path: string, _flags?: string, _mode?: number): number {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const handleId = this.#nextHandleId()\n    this.#openHandlePaths.set(handleId, path)\n    this.#openHandleIds.set(path, handleId)\n    return handleId\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    return Object.keys(node.children)\n  }\n\n  read(\n    fd: number,\n    buffer: Int8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)!\n    return sh.read(new Int8Array(buffer.buffer, offset, length), {\n      at: position,\n    })\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: 'rename', args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true)\n    })\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath)\n    const oldFilename = oldPathParts.pop()!\n    const oldParent = this.#resolvePath(oldPathParts.join('/')) as DirectoryNode\n    if (\n      !Object.prototype.hasOwnProperty.call(oldParent.children, oldFilename)\n    ) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const newPathParts = this.#pathParts(newPath)\n    const newFilename = newPathParts.pop()!\n    const newParent = this.#resolvePath(newPathParts.join('/')) as DirectoryNode\n    if (\n      doFileOps &&\n      Object.prototype.hasOwnProperty.call(newParent.children, newFilename)\n    ) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode\n      const sh = this.#sh.get(node.backingFilename)!\n      sh.truncate(0)\n      this.state.pool.push(node.backingFilename)\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!\n    delete oldParent.children[oldFilename]\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: 'rmdir', args: [path] }, () => {\n      this._rmdirState(path)\n    })\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path)\n    const dirName = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(parent.children, dirName)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = parent.children[dirName]!\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError('ENOTEMPTY', 'Directory not empty')\n    }\n    delete parent.children[dirName]\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    sh.truncate(len)\n    this.#unsyncedSH.add(sh)\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: 'unlink', args: [path] }, () => {\n      this._unlinkState(path, true)\n    })\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const dir = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(dir.children, filename)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = dir.children[filename]!\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    delete dir.children[filename]\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0)\n      this.#unsyncedSH.add(sh)\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!)\n        this.#openHandleIds.delete(path)\n      }\n    }\n    this.state.pool.push(node.backingFilename)\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: 'utimes', args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime)\n    })\n  }\n\n  _utimesState(path: string, _atime: number, mtime: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = mtime\n  }\n\n  writeFile(\n    path: string,\n    data: string | Int8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n\n    if (!Object.prototype.hasOwnProperty.call(parent.children, filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error('No more file handles available in the pool')\n      }\n      const node: Node = {\n        type: 'file',\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      }\n      parent.children[filename] = node\n      this.#logWAL({\n        opp: 'createFileNode',\n        args: [path, node],\n      })\n    } else {\n      const node = parent.children[filename] as FileNode\n      node.lastModified = Date.now()\n      this.#logWAL({\n        opp: 'setLastModified',\n        args: [path, node.lastModified],\n      })\n    }\n    const node = parent.children[filename] as FileNode\n    const sh = this.#sh.get(node.backingFilename)!\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === 'string'\n          ? new TextEncoder().encode(data)\n          : new Int8Array(data),\n        { at: 0 },\n      )\n      if (path.startsWith('/pg_wal')) {\n        this.#unsyncedSH.add(sh)\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    parent.children[filename] = node\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n    return node\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = lastModified\n  }\n\n  write(\n    fd: number,\n    buffer: Int8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    const ret = sh.write(new Int8Array(buffer, offset, length), {\n      at: position,\n    })\n    if (path.startsWith('/pg_wal')) {\n      this.#unsyncedSH.add(sh)\n    }\n    return ret\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry)\n    try {\n      fn()\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset)\n      throw e\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry)\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`)\n    const offset = this.#stateSH.getSize()\n    this.#stateSH.write(stateAB, { at: offset })\n    this.#unsyncedSH.add(this.#stateSH)\n    return offset\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split('/').filter(Boolean)\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path)\n    let node: Node = from || this.state.root\n    for (const part of parts) {\n      if (node.type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        throw new FsError('ENOENT', 'No such file or directory')\n      }\n      node = node.children[part]!\n    }\n    return node\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd)\n    if (!path) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    return path\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++\n    }\n    return id\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle\n      create?: boolean\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path)\n    let ah = options?.from || this.#opfsRootAh\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create })\n    }\n    return ah\n  }\n}\n"],"names":["O","B","EBADF","EBADFD","EEXIST","EINVAL","EISDIR","ENODEV","ENOENT","ENOTDIR","ENOTEMPTY","m","Error","constructor","t","r","super","this","code","M","x","_","v","H","y","N","S","j","E","k","b","a","K","D","I","w","f","T","Q","$","V","WeakMap","WeakSet","F","navigator","storage","getDirectory","d","call","root","create","from","s","getFileHandle","createSyncAccessHandle","ArrayBuffer","getSize","read","at","i","TextDecoder","decode","split","e","JSON","parse","type","lastModified","Date","now","mode","children","pool","truncate","write","TextEncoder","encode","stringify","state","n","slice","filter","Boolean","map","h","g","opp","bind","args","P","console","warn","o","c","async","backingFilename","set","error","Object","values","push","l","Promise","has","ee","all","maintainPool","initialPoolSize","maintainedPoolSize","add","prototype","hasOwnProperty","get","C","getDirectoryHandle","z","R","L","X","_ref","u","Map","lastCheckpoint","checkpointInterval","poolCounter","Set","readyPromise","ready","length","toString","padStart","pop","close","remove","then","delete","_createPoolFileState","_deletePoolFileState","indexOf","splice","maybeCheckpointState","checkpointState","flush","clear","exit","chmod","_chmodState","fstat","lstat","dev","ino","nlink","uid","gid","rdev","size","blksize","blocks","Math","ceil","atime","mtime","ctime","mkdir","_mkdirState","recursive","join","open","readdir","keys","Int8Array","buffer","rename","_renameState","arguments","undefined","rmdir","_rmdirState","unlink","_unlinkState","utimes","_utimesState","writeFile","startsWith","_createFileNodeState","_setLastModifiedState","Z","Y","emscriptenOpts","opfsAhp","dataDir","preRun","createOPFSAHP","A","FS","tryFSOperation","ErrnoError","mount","createNode","syncfs","isDir","isFile","node_ops","stream_ops","getMode","realPath","parent","name","opts","reverse","getattr","id","setattr","timestamp","lookup","mknod","symlink","readlink","node","shared","refcount","nfd","dup","llseek","position","mmap","mmapAlloc","HEAP8","ptr","allocated","msync","G","W","syncToFs","dumpTar","q","quit"],"sourceRoot":""}